diff --git a/Cargo.lock b/Cargo.lock
index c72c7b84..c6d7777b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1707,9 +1707,7 @@ checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"
 
 [[package]]
 name = "libc"
-version = "0.2.79"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2448f6066e80e3bfc792e9c98bf705b4b0fc6e8ef5b43e5889aff0eaa9c58743"
+version = "0.2.85"
 dependencies = [
  "rustc-std-workspace-core",
 ]
@@ -3532,6 +3530,7 @@ dependencies = [
  "rustc_target",
  "smallvec 1.4.2",
  "snap",
+ "tempfile",
  "tracing",
 ]
 
diff --git a/Cargo.toml b/Cargo.toml
index e1a36d88..4c5ec3b2 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -94,6 +94,7 @@ rustfmt-nightly = { path = "src/tools/rustfmt" }
 # See comments in `src/tools/rustc-workspace-hack/README.md` for what's going on
 # here
 rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }
+libc = { path = 'library/libc' }
 
 # See comments in `library/rustc-std-workspace-core/README.md` for what's going on
 # here
diff --git a/compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/lib.rs b/compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/lib.rs
index ca145e4f..0daf03bc 100644
--- a/compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/lib.rs
+++ b/compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/lib.rs
@@ -36,6 +36,7 @@
 #[allow(dead_code)]
 const MIN_ALIGN: usize = 8;
 #[cfg(all(any(target_arch = "x86_64",
+              target_arch = "llir_x86_64",
               target_arch = "aarch64",
               target_arch = "mips64",
               target_arch = "s390x",
diff --git a/compiler/rustc_codegen_llvm/Cargo.toml b/compiler/rustc_codegen_llvm/Cargo.toml
index f9373640..bf030e0c 100644
--- a/compiler/rustc_codegen_llvm/Cargo.toml
+++ b/compiler/rustc_codegen_llvm/Cargo.toml
@@ -13,6 +13,7 @@ bitflags = "1.0"
 libc = "0.2"
 measureme = "9.0.0"
 snap = "1"
+tempfile = "3.1"
 tracing = "0.1"
 rustc_middle = { path = "../rustc_middle" }
 rustc-demangle = "0.1.18"
diff --git a/compiler/rustc_codegen_llvm/src/back/write.rs b/compiler/rustc_codegen_llvm/src/back/write.rs
index e6acb686..554094dc 100644
--- a/compiler/rustc_codegen_llvm/src/back/write.rs
+++ b/compiler/rustc_codegen_llvm/src/back/write.rs
@@ -921,6 +921,7 @@ unsafe fn embed_bitcode(
     //   passed though then these sections will show up in the final output.
     //   Additionally the flag that we need to set here is `SHF_EXCLUDE`.
     if is_apple
+        || cgcx.opts.target_triple.triple().starts_with("llir")
         || cgcx.opts.target_triple.triple().starts_with("wasm")
         || cgcx.opts.target_triple.triple().starts_with("asmjs")
     {
diff --git a/compiler/rustc_codegen_llvm/src/base.rs b/compiler/rustc_codegen_llvm/src/base.rs
index 1090d4a2..a2ddb475 100644
--- a/compiler/rustc_codegen_llvm/src/base.rs
+++ b/compiler/rustc_codegen_llvm/src/base.rs
@@ -67,8 +67,10 @@ pub fn write_compressed_metadata<'tcx>(
         // Also generate a .section directive to force no
         // flags, at least for ELF outputs, so that the
         // metadata doesn't get loaded into memory.
-        let directive = format!(".section {}", section_name);
-        llvm::LLVMSetModuleInlineAsm2(metadata_llmod, directive.as_ptr().cast(), directive.len())
+        if !tcx.sess.target.is_llir {
+            let directive = format!(".section {}", section_name);
+            llvm::LLVMSetModuleInlineAsm2(metadata_llmod, directive.as_ptr().cast(), directive.len())
+        }
     }
 }
 
diff --git a/compiler/rustc_codegen_llvm/src/metadata.rs b/compiler/rustc_codegen_llvm/src/metadata.rs
index 3912d6a3..fb6a4f51 100644
--- a/compiler/rustc_codegen_llvm/src/metadata.rs
+++ b/compiler/rustc_codegen_llvm/src/metadata.rs
@@ -104,7 +104,9 @@ pub fn metadata_section_name(target: &Target) -> &'static str {
     // As a result, we choose a slightly shorter name! As to why
     // `.note.rustc` works on MinGW, that's another good question...
 
-    if target.is_like_osx { "__DATA,.rustc" } else { ".rustc" }
+    if target.is_like_osx { "__DATA,.rustc" }
+    else if target.is_llir { ".note.rustc"}
+    else { ".rustc" }
 }
 
 fn read_metadata_section_name(_target: &Target) -> &'static str {
diff --git a/compiler/rustc_codegen_ssa/src/back/linker.rs b/compiler/rustc_codegen_ssa/src/back/linker.rs
index 3df956c4..4bead262 100644
--- a/compiler/rustc_codegen_ssa/src/back/linker.rs
+++ b/compiler/rustc_codegen_ssa/src/back/linker.rs
@@ -184,7 +184,7 @@ fn takes_hints(&self) -> bool {
         // * On OSX they have their own linker, not binutils'
         // * For WebAssembly the only functional linker is LLD, which doesn't
         //   support hint flags
-        !self.sess.target.is_like_osx && self.sess.target.arch != "wasm32"
+        !self.sess.target.is_like_osx && self.sess.target.arch != "wasm32" && !self.sess.target.is_llir
     }
 
     // Some platforms take hints about whether a library is static or dynamic.
diff --git a/compiler/rustc_codegen_ssa/src/back/write.rs b/compiler/rustc_codegen_ssa/src/back/write.rs
index b34bee33..bb53c4b4 100644
--- a/compiler/rustc_codegen_ssa/src/back/write.rs
+++ b/compiler/rustc_codegen_ssa/src/back/write.rs
@@ -139,8 +139,9 @@ fn new(
 
         let emit_obj = if !should_emit_obj {
             EmitObj::None
-        } else if sess.target.obj_is_bitcode
-            || (sess.opts.cg.linker_plugin_lto.enabled() && !no_builtins)
+        } else if !sess.target.is_llir &&
+            (sess.target.obj_is_bitcode
+            || (sess.opts.cg.linker_plugin_lto.enabled() && !no_builtins))
         {
             // This case is selected if the target uses objects as bitcode, or
             // if linker plugin LTO is enabled. In the linker plugin LTO case
@@ -157,7 +158,7 @@ fn new(
             // `#![no_builtins]` is assumed to not participate in LTO and
             // instead goes on to generate object code.
             EmitObj::Bitcode
-        } else if need_bitcode_in_object(sess) {
+        } else if !sess.target.is_llir && need_bitcode_in_object(sess) {
             EmitObj::ObjectCode(BitcodeSection::Full)
         } else {
             EmitObj::ObjectCode(BitcodeSection::None)
diff --git a/compiler/rustc_llvm/build.rs b/compiler/rustc_llvm/build.rs
index 54b22ca4..0c767df0 100644
--- a/compiler/rustc_llvm/build.rs
+++ b/compiler/rustc_llvm/build.rs
@@ -86,6 +86,7 @@ fn main() {
         "nvptx",
         "hexagon",
         "riscv",
+        "llir"
     ];
 
     let mut version_cmd = Command::new(&llvm_config);
diff --git a/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp b/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp
index 71ca4f23..a51a8fd7 100644
--- a/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp
+++ b/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp
@@ -22,6 +22,7 @@
 #include "llvm/Support/CBindingWrapping.h"
 #include "llvm/Support/FileSystem.h"
 #include "llvm/Support/Host.h"
+#include "llvm/Support/Program.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Transforms/IPO/PassManagerBuilder.h"
 #include "llvm/Transforms/IPO/AlwaysInliner.h"
@@ -253,6 +254,12 @@ void LLVMRustAddLastExtensionPasses(
 #define SUBTARGET_HEXAGON
 #endif
 
+#ifdef LLVM_COMPONENT_LLIR
+#define SUBTARGET_LLIR SUBTARGET(LLIR)
+#else
+#define SUBTARGET_LLIR
+#endif
+
 #define GEN_SUBTARGETS                                                         \
   SUBTARGET_X86                                                                \
   SUBTARGET_ARM                                                                \
@@ -265,6 +272,7 @@ void LLVMRustAddLastExtensionPasses(
   SUBTARGET_SPARC                                                              \
   SUBTARGET_HEXAGON                                                            \
   SUBTARGET_RISCV                                                              \
+  SUBTARGET_LLIR                                                               \
 
 #define SUBTARGET(x)                                                           \
   namespace llvm {                                                             \
@@ -624,31 +632,88 @@ static TargetMachine::CodeGenFileType fromRust(LLVMRustFileType Type) {
 }
 #endif
 
+static llvm::Error
+RunExecutable(llvm::Twine Exe, llvm::ArrayRef<llvm::StringRef> Args)
+{
+  if (auto P = llvm::sys::findProgramByName(Exe.str())) {
+    if (auto code = llvm::sys::ExecuteAndWait(*P, Args)) {
+      std::string Msg;
+      llvm::raw_string_ostream os(Msg);
+      os << "command failed: " << Exe << " ";
+      for (size_t i = 1, n = Args.size(); i < n; ++i) {
+        os << Args[i] << " ";
+      }
+      os << "\n";
+      return llvm::make_error<llvm::StringError>(Msg, llvm::inconvertibleErrorCode());
+    }
+    return llvm::Error::success();
+  }
+  return llvm::make_error<llvm::StringError>("Missing executable " + Exe,
+                                             llvm::inconvertibleErrorCode());
+}
+
 extern "C" LLVMRustResult
 LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,
                         LLVMModuleRef M, const char *Path,
                         LLVMRustFileType RustFileType) {
   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);
   auto FileType = fromRust(RustFileType);
+  llvm::Triple TT = unwrap(Target)->getTargetTriple();
+  
+  if (TT.isLLIR()) {
+    // Generate to a temporary file.
+    auto TmpOrError = llvm::sys::fs::TempFile::create("/tmp/rustc-%%%%%%%");
+    if (!TmpOrError) {
+      LLVMRustSetLastError(toString(TmpOrError.takeError()).c_str());
+      return LLVMRustResult::Failure;
+    }
 
-  std::string ErrorInfo;
-  std::error_code EC;
-  raw_fd_ostream OS(Path, EC, sys::fs::F_None);
-  if (EC)
-    ErrorInfo = EC.message();
-  if (ErrorInfo != "") {
-    LLVMRustSetLastError(ErrorInfo.c_str());
-    return LLVMRustResult::Failure;
-  }
+    {
+      std::error_code EC;
+      raw_fd_ostream OS(TmpOrError->TmpName, EC, sys::fs::F_None);
+      if (EC) {
+        LLVMRustSetLastError(EC.message().c_str());
+        return LLVMRustResult::Failure;
+      }
+      buffer_ostream BOS(OS);
+      if (unwrap(Target)->addPassesToEmitFile(*PM, BOS, nullptr, CGFT_AssemblyFile, false)) {
+        report_fatal_error("Cannot create emitter");
+      }
+      PM->run(*unwrap(M));
+      LLVMDisposePassManager(PMR);
+    }
+    
+    // Run the LLIR linker.
+    std::string As = TT.str() + "-as";
+    auto AsError = RunExecutable(As, {As, TmpOrError->TmpName, "-o", Path});
+    if (AsError) {
+      consumeError(TmpOrError->keep());
+      LLVMRustSetLastError(toString(std::move(AsError)).c_str());
+      return LLVMRustResult::Failure;
+    }
+    consumeError(TmpOrError->discard());
+  } else {
+    std::string ErrorInfo;
+    std::error_code EC;
+    raw_fd_ostream OS(Path, EC, sys::fs::F_None);
+    if (EC)
+      ErrorInfo = EC.message();
+    if (ErrorInfo != "") {
+      LLVMRustSetLastError(ErrorInfo.c_str());
+      return LLVMRustResult::Failure;
+    }
 
-  buffer_ostream BOS(OS);
-  unwrap(Target)->addPassesToEmitFile(*PM, BOS, nullptr, FileType, false);
-  PM->run(*unwrap(M));
+    buffer_ostream BOS(OS);
+    if (unwrap(Target)->addPassesToEmitFile(*PM, BOS, nullptr, FileType, false)) {
+      report_fatal_error("Cannot create emitter");
+    }
+    PM->run(*unwrap(M));
 
-  // Apparently `addPassesToEmitFile` adds a pointer to our on-the-stack output
-  // stream (OS), so the only real safe place to delete this is here? Don't we
-  // wish this was written in Rust?
-  LLVMDisposePassManager(PMR);
+    // Apparently `addPassesToEmitFile` adds a pointer to our on-the-stack output
+    // stream (OS), so the only real safe place to delete this is here? Don't we
+    // wish this was written in Rust?
+    LLVMDisposePassManager(PMR);
+  }
   return LLVMRustResult::Success;
 }
 
@@ -676,21 +741,20 @@ void LLVMSelfProfileInitializeCallbacks(
     PassInstrumentationCallbacks& PIC, void* LlvmSelfProfiler,
     LLVMRustSelfProfileBeforePassCallback BeforePassCallback,
     LLVMRustSelfProfileAfterPassCallback AfterPassCallback) {
-  PIC.registerBeforePassCallback([LlvmSelfProfiler, BeforePassCallback](
+  PIC.registerBeforeNonSkippedPassCallback([LlvmSelfProfiler, BeforePassCallback](
                                      StringRef Pass, llvm::Any Ir) {
     std::string PassName = Pass.str();
     std::string IrName = LLVMRustwrappedIrGetName(Ir);
     BeforePassCallback(LlvmSelfProfiler, PassName.c_str(), IrName.c_str());
-    return true;
   });
 
   PIC.registerAfterPassCallback(
-      [LlvmSelfProfiler, AfterPassCallback](StringRef Pass, llvm::Any Ir) {
+      [LlvmSelfProfiler, AfterPassCallback](StringRef Pass, llvm::Any Ir, const PreservedAnalyses &) {
         AfterPassCallback(LlvmSelfProfiler);
       });
 
   PIC.registerAfterPassInvalidatedCallback(
-      [LlvmSelfProfiler, AfterPassCallback](StringRef Pass) {
+      [LlvmSelfProfiler, AfterPassCallback](StringRef Pass, const PreservedAnalyses &) {
         AfterPassCallback(LlvmSelfProfiler);
       });
 
@@ -753,8 +817,10 @@ LLVMRustOptimizeWithNewPassManager(
   PTO.LoopVectorization = LoopVectorize;
   PTO.SLPVectorization = SLPVectorize;
 
+  bool DebugLogging = false;
+
   PassInstrumentationCallbacks PIC;
-  StandardInstrumentations SI;
+  StandardInstrumentations SI(DebugLogging);
   SI.registerCallbacks(PIC);
 
   if (LlvmSelfProfiler){
@@ -770,7 +836,7 @@ LLVMRustOptimizeWithNewPassManager(
     PGOOpt = PGOOptions(PGOUsePath, "", "", PGOOptions::IRUse);
   }
 
-  PassBuilder PB(TM, PTO, PGOOpt, &PIC);
+  PassBuilder PB(DebugLogging, TM, PTO, PGOOpt, &PIC);
 
   // FIXME: We may want to expose this as an option.
   bool DebugPassManager = false;
@@ -795,7 +861,12 @@ LLVMRustOptimizeWithNewPassManager(
 
   // We manually collect pipeline callbacks so we can apply them at O0, where the
   // PassBuilder does not create a pipeline.
+#if LLVM_VERSION_GE(12, 0)
+  std::vector<std::function<void(ModulePassManager &, PassBuilder::OptimizationLevel)>>
+      PipelineStartEPCallbacks;
+#else
   std::vector<std::function<void(ModulePassManager &)>> PipelineStartEPCallbacks;
+#endif
 #if LLVM_VERSION_GE(11, 0)
   std::vector<std::function<void(ModulePassManager &, PassBuilder::OptimizationLevel)>>
       OptimizerLastEPCallbacks;
@@ -805,9 +876,17 @@ LLVMRustOptimizeWithNewPassManager(
 #endif
 
   if (VerifyIR) {
+#if LLVM_VERSION_GE(12, 0)
+    PipelineStartEPCallbacks.push_back(
+      [VerifyIR](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {
+        MPM.addPass(VerifierPass());
+      }
+    );
+#else
     PipelineStartEPCallbacks.push_back([VerifyIR](ModulePassManager &MPM) {
         MPM.addPass(VerifierPass());
     });
+#endif
   }
 
   if (SanitizerOptions) {
@@ -896,7 +975,11 @@ LLVMRustOptimizeWithNewPassManager(
   if (!NoPrepopulatePasses) {
     if (OptLevel == PassBuilder::OptimizationLevel::O0) {
       for (const auto &C : PipelineStartEPCallbacks)
+#if LLVM_VERSION_GE(12, 0)
+        C(MPM, OptLevel);
+#else
         C(MPM);
+#endif
 
 #if LLVM_VERSION_GE(11, 0)
       for (const auto &C : OptimizerLastEPCallbacks)
@@ -912,7 +995,13 @@ LLVMRustOptimizeWithNewPassManager(
 
       MPM.addPass(AlwaysInlinerPass(EmitLifetimeMarkers));
 
-#if LLVM_VERSION_GE(10, 0)
+#if LLVM_VERSION_GE(12, 0)
+      if (PGOOpt) {
+        PB.addPGOInstrPassesForO0(
+            MPM, PGOOpt->Action == PGOOptions::IRInstr,
+            /*IsCS=*/false, PGOOpt->ProfileFile, PGOOpt->ProfileRemappingFile);
+      }
+#elif LLVM_VERSION_GE(10, 0)
       if (PGOOpt) {
         PB.addPGOInstrPassesForO0(
             MPM, DebugPassManager, PGOOpt->Action == PGOOptions::IRInstr,
@@ -929,10 +1018,18 @@ LLVMRustOptimizeWithNewPassManager(
 
       switch (OptStage) {
       case LLVMRustOptStage::PreLinkNoLTO:
+#if LLVM_VERSION_GE(12, 0)
+        MPM = PB.buildPerModuleDefaultPipeline(OptLevel);
+#else
         MPM = PB.buildPerModuleDefaultPipeline(OptLevel, DebugPassManager);
+#endif
         break;
       case LLVMRustOptStage::PreLinkThinLTO:
+#if LLVM_VERSION_GE(12, 0)
+        MPM = PB.buildThinLTOPreLinkDefaultPipeline(OptLevel);
+#else
         MPM = PB.buildThinLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);
+#endif
 #if LLVM_VERSION_GE(11, 0)
         for (const auto &C : OptimizerLastEPCallbacks)
           C(MPM, OptLevel);
@@ -946,15 +1043,27 @@ LLVMRustOptimizeWithNewPassManager(
 #endif
         break;
       case LLVMRustOptStage::PreLinkFatLTO:
+#if LLVM_VERSION_GE(12, 0)
+        MPM = PB.buildLTOPreLinkDefaultPipeline(OptLevel);
+#else
         MPM = PB.buildLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);
+#endif
         break;
       case LLVMRustOptStage::ThinLTO:
         // FIXME: Does it make sense to pass the ModuleSummaryIndex?
         // It only seems to be needed for C++ specific optimizations.
+#if LLVM_VERSION_GE(12, 0)
+        MPM = PB.buildThinLTODefaultPipeline(OptLevel, nullptr);
+#else
         MPM = PB.buildThinLTODefaultPipeline(OptLevel, DebugPassManager, nullptr);
+#endif
         break;
       case LLVMRustOptStage::FatLTO:
+#if LLVM_VERSION_GE(12, 0)
+        MPM = PB.buildLTODefaultPipeline(OptLevel, nullptr);
+#else
         MPM = PB.buildLTODefaultPipeline(OptLevel, DebugPassManager, nullptr);
+#endif
         break;
       }
     }
diff --git a/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp b/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp
index 938eb19f..2194727c 100644
--- a/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp
+++ b/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp
@@ -214,7 +214,15 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {
 extern "C" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,
                                              LLVMRustAttribute RustAttr) {
   CallBase *Call = unwrap<CallBase>(Instr);
-  Attribute Attr = Attribute::get(Call->getContext(), fromRust(RustAttr));
+  Attribute Attr;
+  switch (Attribute::AttrKind K = fromRust(RustAttr)) {
+  case Attribute::StructRet:
+    Attr = Attribute::getWithStructRetType(Call->getContext(), nullptr);
+    break;
+  default:
+    Attr = Attribute::get(Call->getContext(), K);
+    break;
+  }
   Call->addAttribute(Index, Attr);
 }
 
@@ -262,7 +270,15 @@ extern "C" void LLVMRustAddByValCallSiteAttr(LLVMValueRef Instr, unsigned Index,
 extern "C" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,
                                              LLVMRustAttribute RustAttr) {
   Function *A = unwrap<Function>(Fn);
-  Attribute Attr = Attribute::get(A->getContext(), fromRust(RustAttr));
+  Attribute Attr;
+  switch (Attribute::AttrKind K = fromRust(RustAttr)) {
+  case Attribute::StructRet:
+    Attr = Attribute::getWithStructRetType(A->getContext(), nullptr);
+    break;
+  default:
+    Attr = Attribute::get(A->getContext(), K);
+    break;
+  }
   AttrBuilder B(Attr);
   A->addAttributes(Index, B);
 }
diff --git a/compiler/rustc_llvm/src/lib.rs b/compiler/rustc_llvm/src/lib.rs
index a381290d..7bad9672 100644
--- a/compiler/rustc_llvm/src/lib.rs
+++ b/compiler/rustc_llvm/src/lib.rs
@@ -169,4 +169,11 @@ fn init() { }
         LLVMInitializeWebAssemblyTargetMC,
         LLVMInitializeWebAssemblyAsmPrinter
     );
+    init_target!(
+        llvm_component = "llir",
+        LLVMInitializeLLIRTargetInfo,
+        LLVMInitializeLLIRTarget,
+        LLVMInitializeLLIRTargetMC,
+        LLVMInitializeLLIRAsmPrinter
+    );
 }
diff --git a/compiler/rustc_session/src/options.rs b/compiler/rustc_session/src/options.rs
index 1cd3d11e..8a8dbba6 100644
--- a/compiler/rustc_session/src/options.rs
+++ b/compiler/rustc_session/src/options.rs
@@ -735,7 +735,7 @@ fn parse_target_feature(slot: &mut String, v: Option<&str>) -> bool {
         2 = full debug info with variable and type information; default: 0)"),
     default_linker_libraries: bool = (false, parse_bool, [UNTRACKED],
         "allow the linker to link its default libraries (default: no)"),
-    embed_bitcode: bool = (true, parse_bool, [TRACKED],
+    embed_bitcode: bool = (false, parse_bool, [TRACKED],
         "emit bitcode in rlibs (default: yes)"),
     extra_filename: String = (String::new(), parse_string, [UNTRACKED],
         "extra data to put in each output filename"),
diff --git a/compiler/rustc_target/src/abi/call/mod.rs b/compiler/rustc_target/src/abi/call/mod.rs
index 429a3375..d2fba941 100644
--- a/compiler/rustc_target/src/abi/call/mod.rs
+++ b/compiler/rustc_target/src/abi/call/mod.rs
@@ -559,7 +559,7 @@ pub fn adjust_for_cabi<C>(&mut self, cx: &C, abi: spec::abi::Abi) -> Result<(),
                 };
                 x86::compute_abi_info(cx, self, flavor);
             }
-            "x86_64" => {
+            "x86_64" | "llir_x86_64" => {
                 if abi == spec::abi::Abi::SysV64 {
                     x86_64::compute_abi_info(cx, self);
                 } else if abi == spec::abi::Abi::Win64 || cx.target_spec().is_like_windows {
diff --git a/compiler/rustc_target/src/spec/llir_x86_64_unknown_linux_musl.rs b/compiler/rustc_target/src/spec/llir_x86_64_unknown_linux_musl.rs
new file mode 100644
index 00000000..74855dad
--- /dev/null
+++ b/compiler/rustc_target/src/spec/llir_x86_64_unknown_linux_musl.rs
@@ -0,0 +1,21 @@
+use crate::spec::{Target};
+
+pub fn target() -> Target {
+    let mut base = super::linux_musl_base::opts();
+    base.cpu = "x86-64".to_string();
+    base.max_atomic_width = Some(64);
+    base.archive_format = "gnu".to_string();
+    base.dynamic_linking = true;
+    base.crt_static_default = false;
+    base.is_llir = true;
+    base.forces_embed_bitcode = false;
+
+    Target {
+        llvm_target: "llir_x86_64-unknown-linux-musl".to_string(),
+        pointer_width: 64,
+        data_layout: "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+            .to_string(),
+        arch: "llir_x86_64".to_string(),
+        options: base,
+    }
+}
diff --git a/compiler/rustc_target/src/spec/mod.rs b/compiler/rustc_target/src/spec/mod.rs
index f949bf95..0805d358 100644
--- a/compiler/rustc_target/src/spec/mod.rs
+++ b/compiler/rustc_target/src/spec/mod.rs
@@ -476,6 +476,8 @@ fn $module() {
 }
 
 supported_targets! {
+    ("llir_x86_64-unknown-linux-musl", llir_x86_64_unknown_linux_musl),
+
     ("x86_64-unknown-linux-gnu", x86_64_unknown_linux_gnu),
     ("x86_64-unknown-linux-gnux32", x86_64_unknown_linux_gnux32),
     ("i686-unknown-linux-gnu", i686_unknown_linux_gnu),
@@ -812,6 +814,8 @@ pub struct TargetOptions {
     pub os_family: Option<String>,
     /// Whether the target toolchain's ABI supports returning small structs as an integer.
     pub abi_return_struct_as_int: bool,
+    /// Whether the particular toolchain is built for LLIR.
+    pub is_llir: bool,
     /// Whether the target toolchain is like macOS's. Only useful for compiling against iOS/macOS,
     /// in particular running dsymutil and some other stuff like `-dead_strip`. Defaults to false.
     pub is_like_osx: bool,
@@ -1028,6 +1032,7 @@ fn default() -> TargetOptions {
             staticlib_suffix: ".a".to_string(),
             os_family: None,
             abi_return_struct_as_int: false,
+            is_llir: false,
             is_like_osx: false,
             is_like_solaris: false,
             is_like_windows: false,
diff --git a/library/libc/.cirrus.yml b/library/libc/.cirrus.yml
new file mode 100644
index 00000000..36690d7f
--- /dev/null
+++ b/library/libc/.cirrus.yml
@@ -0,0 +1,44 @@
+task:
+  name: stable x86_64-unknown-freebsd-11
+  freebsd_instance:
+    image: freebsd-11-4-release-amd64
+  setup_script:
+    - pkg install -y curl
+    - curl https://sh.rustup.rs -sSf --output rustup.sh
+    - sh rustup.sh -y --profile=minimal
+    - . $HOME/.cargo/env
+    - rustup default stable
+  test_script:
+    - . $HOME/.cargo/env
+    - LIBC_CI=1 sh ci/run.sh x86_64-unknown-freebsd
+    - sh ci/run.sh x86_64-unknown-freebsd
+
+task:
+  name: nightly x86_64-unknown-freebsd-12
+  freebsd_instance:
+    image: freebsd-12-2-release-amd64
+  setup_script:
+    - pkg install -y curl
+    - curl https://sh.rustup.rs -sSf --output rustup.sh
+    - sh rustup.sh --default-toolchain nightly -y --profile=minimal
+    - . $HOME/.cargo/env
+    - rustup default nightly
+  test_script:
+    - . $HOME/.cargo/env
+    - LIBC_CI=1 sh ci/run.sh x86_64-unknown-freebsd
+    - sh ci/run.sh x86_64-unknown-freebsd
+
+task:
+  name: nightly x86_64-unknown-freebsd-13
+  freebsd_instance:
+    image: freebsd-13-0-alpha3-amd64
+  setup_script:
+    - pkg install -y curl
+    - curl https://sh.rustup.rs -sSf --output rustup.sh
+    - sh rustup.sh -y --profile=minimal
+    - . $HOME/.cargo/env
+    - rustup default nightly
+  test_script:
+    - . $HOME/.cargo/env
+    - LIBC_CI=1 sh ci/run.sh x86_64-unknown-freebsd
+    - sh ci/run.sh x86_64-unknown-freebsd
diff --git a/library/libc/.github/ISSUE_TEMPLATE/api_request.md b/library/libc/.github/ISSUE_TEMPLATE/api_request.md
new file mode 100644
index 00000000..871e1b1c
--- /dev/null
+++ b/library/libc/.github/ISSUE_TEMPLATE/api_request.md
@@ -0,0 +1,20 @@
+---
+name: API request
+about: Send a API request for the libc crate.
+labels: C-API-request
+---
+
+<!--
+Please provide the below information:
+
+* the target triple
+* link to the documentation of the API showing the type signatures, how to use
+  it, etc.
+
+In general, just please consider that the people who can help you are all very
+busy, they will be helping you in their free time, there are a lot of people in
+need of help so they need to prioritize to which issues they devote their free
+time, etc. So try to give most of the information upfront, be concise, show
+small self-contained examples (nobody has time to create a new cargo project,
+set up dependencies,...), etc. Help us help you.
+-->
diff --git a/library/libc/.github/ISSUE_TEMPLATE/bug_report.md b/library/libc/.github/ISSUE_TEMPLATE/bug_report.md
new file mode 100644
index 00000000..1946200a
--- /dev/null
+++ b/library/libc/.github/ISSUE_TEMPLATE/bug_report.md
@@ -0,0 +1,23 @@
+---
+name: Bug Report
+about: Create a bug report for the libc crate.
+labels: C-bug
+---
+
+<!--
+Please provide the below information:
+
+* a Minimum Working Example without any dependencies (except libc) that shows
+  the issue and ideally reproduces in the Rust playground
+* the target triple - libc supports many targets and many APIs
+* instructions to reproduce, logs (e.g. build logs, links to Travis-CI logs,
+  uploads to github gists, etc.).
+
+In general, just please consider that the people who can help you are all very
+busy, they will be helping you in their free time, there are a lot of people in
+need of help so they need to prioritize to which issues they devote their free
+time, etc. So try to give most of the information upfront, be concise, show
+small self-contained examples (nobody has time to create a new cargo project,
+set up dependencies,...), etc. Help us help you.
+
+-->
diff --git a/library/libc/.github/workflows/bors.yml b/library/libc/.github/workflows/bors.yml
new file mode 100644
index 00000000..2c16f94c
--- /dev/null
+++ b/library/libc/.github/workflows/bors.yml
@@ -0,0 +1,317 @@
+name: CI (bors)
+
+on:
+  push:
+    branches:
+      - auto-libc
+      - try
+
+jobs:
+  docker_linux_tier1:
+    name: Docker Linux Tier1
+    runs-on: ubuntu-20.04
+    strategy:
+      fail-fast: true
+      matrix:
+        target: [
+          i686-unknown-linux-gnu,
+          x86_64-unknown-linux-gnu,
+        ]
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TARGET=${{ matrix.target }} sh ./ci/install-rust.sh
+      - name: Execute run-docker.sh
+        run: LIBC_CI=1 sh ./ci/run-docker.sh ${{ matrix.target }}
+
+  macos:
+    name: macOS
+    runs-on: macos-10.15
+    strategy:
+      fail-fast: true
+      matrix:
+        target: [
+          x86_64-apple-darwin,
+        ]
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TARGET=${{ matrix.target }} sh ./ci/install-rust.sh
+      - name: Execute run.sh
+        run: LIBC_CI=1 sh ./ci/run.sh ${{ matrix.target }}
+
+  windows:
+    name: Windows
+    runs-on: windows-2019
+    env:
+      OS: windows
+    strategy:
+      fail-fast: true
+      matrix:
+        include:
+          - target: x86_64-pc-windows-gnu
+            env:
+              ARCH_BITS: 64
+              ARCH: x86_64
+          - target: x86_64-pc-windows-msvc
+          # Disabled because broken:
+          #  https://github.com/rust-lang/libc/issues/1592
+          #- target: i686-pc-windows-gnu
+          #  env:
+          #    ARCH_BITS: 32
+          #    ARCH: i686
+          - target: i686-pc-windows-msvc
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TARGET=${{ matrix.target }} sh ./ci/install-rust.sh
+        shell: bash
+      - name: Execute run.sh
+        run: LIBC_CI=1 sh ./ci/run.sh ${{ matrix.target }}
+        shell: bash
+
+  style_check:
+    name: Style check
+    runs-on: ubuntu-20.04
+    strategy:
+      fail-fast: true
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: sh ./ci/install-rust.sh
+      - name: Check style
+        run: sh ci/style.sh
+
+  docker_linux_tier2:
+    name: Docker Linux Tier2
+    needs: [docker_linux_tier1, style_check]
+    runs-on: ubuntu-20.04
+    strategy:
+      fail-fast: true
+      max-parallel: 12
+      matrix:
+        target: [
+          aarch64-linux-android,
+          aarch64-unknown-linux-gnu,
+          aarch64-unknown-linux-musl,
+          arm-linux-androideabi,
+          arm-unknown-linux-gnueabihf,
+          arm-unknown-linux-musleabihf,
+          # FIXME: Disabled because currently broken, see:
+          # https://github.com/rust-lang/libc/issues/1591
+          # asmjs-unknown-emscripten,
+          i686-linux-android,
+          i686-unknown-linux-musl,
+          mips-unknown-linux-gnu,
+          mips-unknown-linux-musl,
+          # FIXME: Somehow failed on CI
+          # https://github.com/rust-lang/libc/runs/1659882216
+          # mips64-unknown-linux-gnuabi64,
+          # mips64el-unknown-linux-gnuabi64,
+          mipsel-unknown-linux-musl,
+          powerpc-unknown-linux-gnu,
+          powerpc64-unknown-linux-gnu,
+          powerpc64le-unknown-linux-gnu,
+          s390x-unknown-linux-gnu,
+          riscv64gc-unknown-linux-gnu,
+          # FIXME: Figure out why this is disabled.
+          #wasm32-wasi,
+          sparc64-unknown-linux-gnu,
+          wasm32-unknown-emscripten,
+          x86_64-linux-android,
+          x86_64-unknown-linux-gnux32,
+          x86_64-unknown-linux-musl,
+          # FIXME: It seems some items in `src/unix/mod.rs`
+          # aren't defined on redox actually.
+          # x86_64-unknown-redox,
+        ]
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TARGET=${{ matrix.target }} sh ./ci/install-rust.sh
+      - name: Execute run-docker.sh
+        run: LIBC_CI=1 sh ./ci/run-docker.sh ${{ matrix.target }}
+
+  # devkitpro's pacman needs to be connected from Docker.
+  docker_switch:
+    name: Docker Switch
+    needs: [docker_linux_tier1, style_check]
+    runs-on: ubuntu-20.04
+    strategy:
+      fail-fast: true
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: sh ./ci/install-rust.sh
+      - name: Execute run-docker.sh
+        run: LIBC_CI=1 sh ./ci/run-docker.sh switch
+
+  build_channels_linux:
+    name: Build Channels Linux
+    needs: docker_linux_tier2
+    runs-on: ubuntu-20.04
+    env:
+      OS: linux
+    strategy:
+      fail-fast: true
+      max-parallel: 5
+      matrix:
+        toolchain: [
+          stable,
+          beta,
+          nightly,
+          1.13.0,
+          1.19.0,
+          1.24.0,
+          1.25.0,
+          1.30.0,
+        ]
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TOOLCHAIN=${{ matrix.toolchain }} sh ./ci/install-rust.sh
+      - name: Execute build.sh
+        run: LIBC_CI=1 TOOLCHAIN=${{ matrix.toolchain }} sh ./ci/build.sh
+
+  build_channels_macos:
+    name: Build Channels macOS
+    needs: macos
+    runs-on: macos-10.15
+    env:
+      OS: macos
+    strategy:
+      fail-fast: true
+      max-parallel: 4
+      matrix:
+        toolchain: [
+          stable,
+          beta,
+          nightly,
+          1.13.0,
+          1.19.0,
+          1.24.0,
+          1.25.0,
+          1.30.0,
+        ]
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TOOLCHAIN=${{ matrix.toolchain }} sh ./ci/install-rust.sh
+      - name: Execute build.sh
+        run: LIBC_CI=1 TOOLCHAIN=${{ matrix.toolchain }} sh ./ci/build.sh
+
+  semver_linux:
+    name: Semver Linux
+    needs: build_channels_linux
+    runs-on: ubuntu-20.04
+    continue-on-error: true
+    strategy:
+      fail-fast: true
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        # Should update the semverver revision in semver.sh if we touch nightly ver.
+        run: TOOLCHAIN=nightly-2020-11-19 sh ./ci/install-rust.sh
+      - name: Check breaking changes
+        run: sh ci/semver.sh linux
+
+  semver_macos:
+    name: Semver macOS
+    needs: build_channels_macos
+    runs-on: macos-10.15
+    continue-on-error: true
+    strategy:
+      fail-fast: true
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        # FIXME: Pin nightly version to make semverver compilable.
+        run: TOOLCHAIN=nightly-2020-11-19 sh ./ci/install-rust.sh
+      - name: Check breaking changes
+        run: sh ci/semver.sh macos
+
+  docs:
+    name: Generate documentation
+    runs-on: ubuntu-20.04
+    needs: docker_linux_tier2
+    strategy:
+      fail-fast: true
+    steps:
+      - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master
+        with:
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: sh ./ci/install-rust.sh
+      - name: Generate documentation
+        run: LIBC_CI=1 sh ci/dox.sh
+
+  # These jobs doesn't actually test anything, but they're only used to tell
+  # bors the build completed, as there is no practical way to detect when a
+  # workflow is successful listening to webhooks only.
+  #
+  # ALL THE PREVIOUS JOBS NEED TO BE ADDED TO THE `needs` SECTION OF THIS JOB!
+
+  end_success:
+    name: bors build finished
+    if: github.event.pusher.name == 'bors' && success()
+    runs-on: ubuntu-20.04
+    needs: [
+      docker_linux_tier1,
+      docker_linux_tier2,
+      macos,
+      windows,
+      style_check,
+      docker_switch,
+      build_channels_linux,
+      build_channels_macos,
+      docs,
+    ]
+
+    steps:
+      - name: Mark the job as successful
+        run: exit 0
+
+  end_failure:
+    name: bors build finished
+    if: github.event.pusher.name == 'bors' && (failure() || cancelled())
+    runs-on: ubuntu-20.04
+    needs: [
+      docker_linux_tier1,
+      docker_linux_tier2,
+      macos,
+      windows,
+      style_check,
+      docker_switch,
+      build_channels_linux,
+      build_channels_macos,
+      docs,
+    ]
+
+    steps:
+      - name: Mark the job as a failure
+        run: exit 1
diff --git a/library/libc/.github/workflows/docs.yml b/library/libc/.github/workflows/docs.yml
new file mode 100644
index 00000000..b7544839
--- /dev/null
+++ b/library/libc/.github/workflows/docs.yml
@@ -0,0 +1,25 @@
+name: Upload documentation
+
+on:
+  push:
+    branches:
+      - master
+
+jobs:
+  upload_docs:
+    name: Upload documentation
+    runs-on: ubuntu-20.04
+    if: github.repository == 'rust-lang/libc'
+
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TARGET=x86_64-unknown-linux-gnu sh ./ci/install-rust.sh
+      - name: Generate documentation
+        run: LIBC_CI=1 sh ci/dox.sh
+      - name: Upload documentation to GitHub Pages
+        uses: rust-lang/simpleinfra/github-actions/static-websites@master
+        with:
+          deploy_dir: target/doc
+          github_token: "${{ secrets.GITHUB_TOKEN }}"
+        if: github.ref == 'refs/heads/master'
diff --git a/library/libc/.github/workflows/main.yml b/library/libc/.github/workflows/main.yml
new file mode 100644
index 00000000..6b5f5daf
--- /dev/null
+++ b/library/libc/.github/workflows/main.yml
@@ -0,0 +1,84 @@
+name: CI
+
+on:
+  pull_request:
+    types: [opened, synchronize, reopened]
+  push:
+    branches:
+      - master
+
+jobs:
+  docker_linux_tier1:
+    name: Docker Linux Tier1
+    runs-on: ubuntu-20.04
+    strategy:
+      fail-fast: true
+      matrix:
+        target: [
+          i686-unknown-linux-gnu,
+          x86_64-unknown-linux-gnu,
+        ]
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TARGET=${{ matrix.target }} sh ./ci/install-rust.sh
+      - name: Execute run-docker.sh
+        run: LIBC_CI=1 sh ./ci/run-docker.sh ${{ matrix.target }}
+
+  macos:
+    name: macOS
+    runs-on: macos-10.15
+    strategy:
+      fail-fast: true
+      matrix:
+        target: [
+          x86_64-apple-darwin,
+        ]
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TARGET=${{ matrix.target }} sh ./ci/install-rust.sh
+      - name: Execute run.sh
+        run: LIBC_CI=1 sh ./ci/run.sh ${{ matrix.target }}
+
+  windows:
+    name: Windows
+    runs-on: windows-2019
+    env:
+      OS: windows
+    strategy:
+      fail-fast: true
+      matrix:
+        include:
+          - target: x86_64-pc-windows-gnu
+            env:
+              ARCH_BITS: 64
+              ARCH: x86_64
+          - target: x86_64-pc-windows-msvc
+          # Disabled because broken:
+          #  https://github.com/rust-lang/libc/issues/1592
+          #- target: i686-pc-windows-gnu
+          #  env:
+          #    ARCH_BITS: 32
+          #    ARCH: i686
+          - target: i686-pc-windows-msvc
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: TARGET=${{ matrix.target }} sh ./ci/install-rust.sh
+        shell: bash
+      - name: Execute run.sh
+        run: LIBC_CI=1 sh ./ci/run.sh ${{ matrix.target }}
+        shell: bash
+
+  style_check:
+    name: Style check
+    runs-on: ubuntu-20.04
+    strategy:
+      fail-fast: true
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup Rust toolchain
+        run: sh ./ci/install-rust.sh
+      - name: Check style
+        run: sh ci/style.sh
diff --git a/library/libc/.gitignore b/library/libc/.gitignore
new file mode 100644
index 00000000..bbbad4bc
--- /dev/null
+++ b/library/libc/.gitignore
@@ -0,0 +1,4 @@
+target
+Cargo.lock
+*~
+style
diff --git a/library/libc/CONTRIBUTING.md b/library/libc/CONTRIBUTING.md
new file mode 100644
index 00000000..1acc71d9
--- /dev/null
+++ b/library/libc/CONTRIBUTING.md
@@ -0,0 +1,79 @@
+# Contributing to `libc`
+
+Welcome! If you are reading this document, it means you are interested in contributing
+to the `libc` crate.
+
+## Adding an API
+
+Want to use an API which currently isn't bound in `libc`? It's quite easy to add
+one!
+
+The internal structure of this crate is designed to minimize the number of
+`#[cfg]` attributes in order to easily be able to add new items which apply
+to all platforms in the future. As a result, the crate is organized
+hierarchically based on platform. Each module has a number of `#[cfg]`'d
+children, but only one is ever actually compiled. Each module then reexports all
+the contents of its children.
+
+This means that for each platform that libc supports, the path from a
+leaf module to the root will contain all bindings for the platform in question.
+Consequently, this indicates where an API should be added! Adding an API at a
+particular level in the hierarchy means that it is supported on all the child
+platforms of that level. For example, when adding a Unix API it should be added
+to `src/unix/mod.rs`, but when adding a Linux-only API it should be added to
+`src/unix/linux_like/linux/mod.rs`.
+
+If you're not 100% sure at what level of the hierarchy an API should be added
+at, fear not! This crate has CI support which tests any binding against all
+platforms supported, so you'll see failures if an API is added at the wrong
+level or has different signatures across platforms.
+
+With that in mind, the steps for adding a new API are:
+
+1. Determine where in the module hierarchy your API should be added.
+2. Add the API.
+3. Send a PR to this repo.
+4. Wait for CI to pass, fixing errors.
+5. Wait for a merge!
+
+## Test before you commit
+
+We have two automated tests running on [GitHub Actions](https://github.com/rust-lang/libc/actions):
+
+1. [`libc-test`](https://github.com/gnzlbg/ctest)
+  - `cd libc-test && cargo test`
+  - Use the `skip_*()` functions in `build.rs` if you really need a workaround.
+2. Style checker
+  - `rustc ci/style.rs && ./style src`
+
+## Breaking change policy
+
+Sometimes an upstream adds a breaking change to their API e.g. removing outdated items,
+changing the type signature, etc. And we probably should follow that change to build the
+`libc` crate successfully. It's annoying to do the equivalent of semver-major versioning
+for each such change. Instead, we mark the item as deprecated and do the actual change
+after a certain period. The steps are:
+
+1. Add `#[deprecated(since = "", note="")]` attribute to the item.
+  - The `since` field should have a next version of `libc`
+    (e.g., if the current version is `0.2.1`, it should be `0.2.2`).
+  - The `note` field should have a reason to deprecate and a tracking issue to call for comments
+    (e.g., "We consider removing this as the upstream removed it.
+    If you're using it, please comment on #XXX").
+2. If we don't see any concerns for a while, do the change actually.
+
+## Releasing your change to crates.io
+
+Now that you've done the amazing job of landing your new API or your new
+platform in this crate, the next step is to get that sweet, sweet usage from
+crates.io! The only next step is to bump the version of libc and then publish
+it. If you'd like to get a release out ASAP you can follow these steps:
+
+1. Increment the patch version number in `Cargo.toml`.
+1. Send a PR to this repository. It should [look like this][example], but it'd
+   also be nice to fill out the description with a small rationale for the
+   release (any rationale is ok though!)
+1. Once merged, the release will be tagged and published by one of the libc crate
+   maintainers.
+
+[example]: https://github.com/rust-lang/libc/pull/583
diff --git a/library/libc/Cargo.toml b/library/libc/Cargo.toml
new file mode 100644
index 00000000..247e4db1
--- /dev/null
+++ b/library/libc/Cargo.toml
@@ -0,0 +1,32 @@
+[package]
+name = "libc"
+version = "0.2.85"
+authors = ["The Rust Project Developers"]
+license = "MIT OR Apache-2.0"
+readme = "README.md"
+repository = "https://github.com/rust-lang/libc"
+homepage = "https://github.com/rust-lang/libc"
+documentation = "https://docs.rs/libc/"
+keywords = ["libc", "ffi", "bindings", "operating", "system" ]
+categories = ["external-ffi-bindings", "no-std", "os"]
+build = "build.rs"
+exclude = ["/ci/*", "/.github/*", "/.cirrus.yml", "/triagebot.toml"]
+description = """
+Raw FFI bindings to platform libraries like libc.
+"""
+
+[dependencies]
+rustc-std-workspace-core = { version = "1.0.0", optional = true }
+
+[features]
+default = ["std"]
+std = []
+align = []
+rustc-dep-of-std = ['align', 'rustc-std-workspace-core']
+extra_traits = []
+const-extern-fn = []
+# use_std is deprecated, use `std` instead
+use_std = [ 'std' ]
+
+[workspace]
+members = ["libc-test"]
diff --git a/library/libc/LICENSE-APACHE b/library/libc/LICENSE-APACHE
new file mode 100644
index 00000000..16fe87b0
--- /dev/null
+++ b/library/libc/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/library/libc/LICENSE-MIT b/library/libc/LICENSE-MIT
new file mode 100644
index 00000000..78061811
--- /dev/null
+++ b/library/libc/LICENSE-MIT
@@ -0,0 +1,25 @@
+Copyright (c) 2014-2020 The Rust Project Developers
+
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/library/libc/README.md b/library/libc/README.md
new file mode 100644
index 00000000..a8a3afd9
--- /dev/null
+++ b/library/libc/README.md
@@ -0,0 +1,106 @@
+# libc - Raw FFI bindings to platforms' system libraries
+
+[![GHA Status]][GitHub Actions] [![Cirrus CI Status]][Cirrus CI] [![Latest Version]][crates.io] [![Documentation]][docs.rs] ![License]
+
+`libc` provides all of the definitions necessary to easily interoperate with C
+code (or "C-like" code) on each of the platforms that Rust supports. This
+includes type definitions (e.g. `c_int`), constants (e.g. `EINVAL`) as well as
+function headers (e.g. `malloc`).
+
+This crate exports all underlying platform types, functions, and constants under
+the crate root, so all items are accessible as `libc::foo`. The types and values
+of all the exported APIs match the platform that libc is compiled for.
+
+More detailed information about the design of this library can be found in its
+[associated RFC][rfc].
+
+[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1291-promote-libc.md
+
+## Usage
+
+Add the following to your `Cargo.toml`:
+
+```toml
+[dependencies]
+libc = "0.2"
+```
+
+## Features
+
+* `std`: by default `libc` links to the standard library. Disable this
+  feature to remove this dependency and be able to use `libc` in `#![no_std]`
+  crates.
+
+* `extra_traits`: all `struct`s implemented in `libc` are `Copy` and `Clone`.
+  This feature derives `Debug`, `Eq`, `Hash`, and `PartialEq`.
+
+* `const-extern-fn`: Changes some `extern fn`s into `const extern fn`s.
+   This feature requires a nightly rustc.
+
+* **deprecated**: `use_std` is deprecated, and is equivalent to `std`.
+
+## Rust version support
+
+The minimum supported Rust toolchain version is **Rust 1.13.0** . APIs requiring
+newer Rust features are only available on newer Rust toolchains:
+
+| Feature              | Version |
+|----------------------|---------|
+| `union`              |  1.19.0 |
+| `const mem::size_of` |  1.24.0 |
+| `repr(align)`        |  1.25.0 |
+| `extra_traits`       |  1.25.0 |
+| `core::ffi::c_void`  |  1.30.0 |
+| `repr(packed(N))`    |  1.33.0 |
+| `cfg(target_vendor)` |  1.33.0 |
+
+## Platform support
+
+[Platform-specific documentation (master branch)][docs.master].
+
+See
+[`ci/build.sh`](https://github.com/rust-lang/libc/blob/master/ci/build.sh)
+for the platforms on which `libc` is guaranteed to build for each Rust
+toolchain. The test-matrix at [GitHub Actions] and [Cirrus CI] show the
+platforms in which `libc` tests are run.
+
+<div class="platform_docs"></div>
+
+## License
+
+This project is licensed under either of
+
+* [Apache License, Version 2.0](https://www.apache.org/licenses/LICENSE-2.0)
+  ([LICENSE-APACHE](https://github.com/rust-lang/libc/blob/master/LICENSE-APACHE))
+
+* [MIT License](https://opensource.org/licenses/MIT)
+  ([LICENSE-MIT](https://github.com/rust-lang/libc/blob/master/LICENSE-MIT))
+
+at your option.
+
+## Contributing
+
+We welcome all people who want to contribute. Please see the [contributing
+instructions] for more information.
+
+[contributing instructions]: https://github.com/rust-lang/libc/blob/master/CONTRIBUTING.md
+
+Contributions in any form (issues, pull requests, etc.) to this project
+must adhere to Rust's [Code of Conduct].
+
+[Code of Conduct]: https://www.rust-lang.org/policies/code-of-conduct
+
+Unless you explicitly state otherwise, any contribution intentionally submitted
+for inclusion in `libc` by you, as defined in the Apache-2.0 license, shall be
+dual licensed as above, without any additional terms or conditions.
+
+[GitHub Actions]: https://github.com/rust-lang/libc/actions
+[GHA Status]: https://github.com/rust-lang/libc/workflows/CI/badge.svg
+[Cirrus CI]: https://cirrus-ci.com/github/rust-lang/libc
+[Cirrus CI Status]: https://api.cirrus-ci.com/github/rust-lang/libc.svg
+[crates.io]: https://crates.io/crates/libc
+[Latest Version]: https://img.shields.io/crates/v/libc.svg
+[Documentation]: https://docs.rs/libc/badge.svg
+[docs.rs]: https://docs.rs/libc
+[License]: https://img.shields.io/crates/l/libc.svg
+[docs.master]: https://rust-lang.github.io/libc/#platform-specific-documentation
diff --git a/library/libc/build.rs b/library/libc/build.rs
new file mode 100644
index 00000000..27cfb024
--- /dev/null
+++ b/library/libc/build.rs
@@ -0,0 +1,145 @@
+use std::env;
+use std::process::Command;
+use std::str;
+
+fn main() {
+    let (rustc_minor_ver, is_nightly) =
+        rustc_minor_nightly().expect("Failed to get rustc version");
+    let rustc_dep_of_std = env::var("CARGO_FEATURE_RUSTC_DEP_OF_STD").is_ok();
+    let align_cargo_feature = env::var("CARGO_FEATURE_ALIGN").is_ok();
+    let const_extern_fn_cargo_feature =
+        env::var("CARGO_FEATURE_CONST_EXTERN_FN").is_ok();
+    let libc_ci = env::var("LIBC_CI").is_ok();
+
+    if env::var("CARGO_FEATURE_USE_STD").is_ok() {
+        println!(
+            "cargo:warning=\"libc's use_std cargo feature is deprecated since libc 0.2.55; \
+             please consider using the `std` cargo feature instead\""
+        );
+    }
+
+    // The ABI of libc used by libstd is backward compatible with FreeBSD 10.
+    // The ABI of libc from crates.io is backward compatible with FreeBSD 11.
+    //
+    // On CI, we detect the actual FreeBSD version and match its ABI exactly,
+    // running tests to ensure that the ABI is correct.
+    match which_freebsd() {
+        Some(10) if libc_ci || rustc_dep_of_std => {
+            println!("cargo:rustc-cfg=freebsd10")
+        }
+        Some(11) if libc_ci => println!("cargo:rustc-cfg=freebsd11"),
+        Some(12) if libc_ci => println!("cargo:rustc-cfg=freebsd12"),
+        Some(13) if libc_ci => println!("cargo:rustc-cfg=freebsd13"),
+        Some(_) | None => println!("cargo:rustc-cfg=freebsd11"),
+    }
+
+    // On CI: deny all warnings
+    if libc_ci {
+        println!("cargo:rustc-cfg=libc_deny_warnings");
+    }
+
+    // Rust >= 1.15 supports private module use:
+    if rustc_minor_ver >= 15 || rustc_dep_of_std {
+        println!("cargo:rustc-cfg=libc_priv_mod_use");
+    }
+
+    // Rust >= 1.19 supports unions:
+    if rustc_minor_ver >= 19 || rustc_dep_of_std {
+        println!("cargo:rustc-cfg=libc_union");
+    }
+
+    // Rust >= 1.24 supports const mem::size_of:
+    if rustc_minor_ver >= 24 || rustc_dep_of_std {
+        println!("cargo:rustc-cfg=libc_const_size_of");
+    }
+
+    // Rust >= 1.25 supports repr(align):
+    if rustc_minor_ver >= 25 || rustc_dep_of_std || align_cargo_feature {
+        println!("cargo:rustc-cfg=libc_align");
+    }
+
+    // Rust >= 1.30 supports `core::ffi::c_void`, so libc can just re-export it.
+    // Otherwise, it defines an incompatible type to retaining
+    // backwards-compatibility.
+    if rustc_minor_ver >= 30 || rustc_dep_of_std {
+        println!("cargo:rustc-cfg=libc_core_cvoid");
+    }
+
+    // Rust >= 1.33 supports repr(packed(N)) and cfg(target_vendor).
+    if rustc_minor_ver >= 33 || rustc_dep_of_std {
+        println!("cargo:rustc-cfg=libc_packedN");
+        println!("cargo:rustc-cfg=libc_cfg_target_vendor");
+    }
+
+    // #[thread_local] is currently unstable
+    if rustc_dep_of_std {
+        println!("cargo:rustc-cfg=libc_thread_local");
+    }
+
+    if const_extern_fn_cargo_feature {
+        if !is_nightly || rustc_minor_ver < 40 {
+            panic!("const-extern-fn requires a nightly compiler >= 1.40")
+        }
+        println!("cargo:rustc-cfg=libc_const_extern_fn");
+    }
+}
+
+fn rustc_minor_nightly() -> Option<(u32, bool)> {
+    macro_rules! otry {
+        ($e:expr) => {
+            match $e {
+                Some(e) => e,
+                None => return None,
+            }
+        };
+    }
+
+    let rustc = otry!(env::var_os("RUSTC"));
+    let output = otry!(Command::new(rustc).arg("--version").output().ok());
+    let version = otry!(str::from_utf8(&output.stdout).ok());
+    let mut pieces = version.split('.');
+
+    if pieces.next() != Some("rustc 1") {
+        return None;
+    }
+
+    let minor = pieces.next();
+
+    // If `rustc` was built from a tarball, its version string
+    // will have neither a git hash nor a commit date
+    // (e.g. "rustc 1.39.0"). Treat this case as non-nightly,
+    // since a nightly build should either come from CI
+    // or a git checkout
+    let nightly_raw = otry!(pieces.next()).split('-').nth(1);
+    let nightly = nightly_raw
+        .map(|raw| raw.starts_with("dev") || raw.starts_with("nightly"))
+        .unwrap_or(false);
+    let minor = otry!(otry!(minor).parse().ok());
+
+    Some((minor, nightly))
+}
+
+fn which_freebsd() -> Option<i32> {
+    let output = std::process::Command::new("freebsd-version").output().ok();
+    if output.is_none() {
+        return None;
+    }
+    let output = output.unwrap();
+    if !output.status.success() {
+        return None;
+    }
+
+    let stdout = String::from_utf8(output.stdout).ok();
+    if stdout.is_none() {
+        return None;
+    }
+    let stdout = stdout.unwrap();
+
+    match &stdout {
+        s if s.starts_with("10") => Some(10),
+        s if s.starts_with("11") => Some(11),
+        s if s.starts_with("12") => Some(12),
+        s if s.starts_with("13") => Some(13),
+        _ => None,
+    }
+}
diff --git a/library/libc/ci/README.md b/library/libc/ci/README.md
new file mode 100644
index 00000000..cfe3d53b
--- /dev/null
+++ b/library/libc/ci/README.md
@@ -0,0 +1,217 @@
+The goal of the libc crate is to have CI running everywhere to have the
+strongest guarantees about the definitions that this library contains, and as a
+result the CI is pretty complicated and also pretty large! Hopefully this can
+serve as a guide through the sea of scripts in this directory and elsewhere in
+this project.
+
+Note that this documentation is quite outdated. See CI config and scripts
+in the `ci` directory how we run CI now.
+
+# Files
+
+First up, let's talk about the files in this directory:
+
+* `run-docker.sh` - a shell script run by most builders, it will execute
+  `run.sh` inside a Docker container configured for the target.
+
+* `run.sh` - the actual script which runs tests for a particular architecture.
+
+* `dox.sh` - build the documentation of the crate and publish it to gh-pages.
+
+# CI Systems
+
+Currently this repository leverages a combination of GitHub Actions and Cirrus CI
+for running tests. You can find tested triples in [Actions config] or [Cirrus config].
+
+The Windows triples are all pretty standard, they just set up their environment
+then run tests, no need for downloading any extra target libs (we just download
+the right installer). The Intel Linux/OSX builds are similar in that we just
+download the right target libs and run tests. Note that the Intel Linux/OSX
+builds are run on stable/beta/nightly, but are the only ones that do so.
+
+The remaining architectures look like:
+
+* Android runs in a [docker image][android-docker] with an emulator, the NDK,
+  and the SDK already set up. The entire build happens within the docker image.
+* The MIPS, ARM, and AArch64 builds all use the QEMU userspace emulator to run
+  the generated binary to actually verify the tests pass.
+* The MUSL build just has to download a MUSL compiler and target libraries and
+  then otherwise runs tests normally.
+* iOS builds need an extra linker flag currently, but beyond that they're built
+  as standard as everything else.
+* The rumprun target builds an entire kernel from the test suite and then runs
+  it inside QEMU using the serial console to test whether it succeeded or
+  failed.
+* The BSD builds, currently OpenBSD and FreeBSD, use QEMU to boot up a system
+  and compile/run tests. More information on that below.
+
+[Actions config]: https://github.com/rust-lang/libc/tree/master/.github/workflows
+[Cirrus config]: https://github.com/rust-lang/libc/blob/master/.cirrus.yml
+[android-docker]: https://github.com/rust-lang/libc/blob/master/ci/docker/x86_64-linux-android/Dockerfile
+
+## QEMU
+
+Lots of the architectures tested here use QEMU in the tests, so it's worth going
+over all the crazy capabilities QEMU has and the various flavors in which we use
+it!
+
+First up, QEMU has userspace emulation where it doesn't boot a full kernel, it
+just runs a binary from another architecture (using the `qemu-<arch>` wrappers).
+We provide it the runtime path for the dynamically loaded system libraries,
+however. This strategy is used for all Linux architectures that aren't intel.
+Note that one downside of this QEMU system is that threads are barely
+implemented, so we're careful to not spawn many threads.
+
+For the rumprun target the only output is a kernel image, so we just use that
+plus the `rumpbake` command to create a full kernel image which is then run from
+within QEMU.
+
+Finally, the fun part, the BSDs. Quite a few hoops are jumped through to get CI
+working for these platforms, but the gist of it looks like:
+
+* Cross compiling from Linux to any of the BSDs seems to be quite non-standard.
+  We may be able to get it working but it might be difficult at that point to
+  ensure that the libc definitions align with what you'd get on the BSD itself.
+  As a result, we try to do compiles within the BSD distro.
+* We resort to userspace emulation (QEMU).
+
+With all that in mind, the way BSD is tested looks like:
+
+1. Download a pre-prepared image for the OS being tested.
+2. Generate the tests for the OS being tested. This involves running the `ctest`
+   library over libc to generate a Rust file and a C file which will then be
+   compiled into the final test.
+3. Generate a disk image which will later be mounted by the OS being tested.
+   This image is mostly just the libc directory, but some modifications are made
+   to compile the generated files from step 2.
+4. The kernel is booted in QEMU, and it is configured to detect the libc-test
+   image being available, run the test script, and then shut down afterwards.
+5. Look for whether the tests passed in the serial console output of the kernel.
+
+There's some pretty specific instructions for setting up each image (detailed
+below), but the main gist of this is that we must avoid a vanilla `cargo run`
+inside of the `libc-test` directory (which is what it's intended for) because
+that would compile `syntex_syntax`, a large library, with userspace emulation.
+This invariably times out on CI, so we can't do that.
+
+Once all those hoops are jumped through, however, we can be happy that we're
+testing almost everything!
+
+Below are some details of how to set up the initial OS images which are
+downloaded. Each image must be enabled have input/output over the serial
+console, log in automatically at the serial console, detect if a second drive in
+QEMU is available, and if so mount it, run a script (it'll specifically be
+`run-qemu.sh` in this folder which is copied into the generated image talked
+about above), and then shut down.
+
+### QEMU Setup - FreeBSD
+
+1. [Download the latest stable amd64-bootonly release ISO](https://www.freebsd.org/where.html).
+   E.g. FreeBSD-11.1-RELEASE-amd64-bootonly.iso
+2. Create the disk image: `qemu-img create -f qcow2 FreeBSD-11.1-RELEASE-amd64.qcow2 2G`
+3. Boot the machine: `qemu-system-x86_64 -cdrom FreeBSD-11.1-RELEASE-amd64-bootonly.iso -drive if=virtio,file=FreeBSD-11.1-RELEASE-amd64.qcow2 -net nic,model=virtio -net user`
+4. Run the installer, and install FreeBSD:
+   1. Install
+   1. Continue with default keymap
+   1. Set Hostname: freebsd-ci
+   1. Distribution Select:
+      1. Uncheck lib32
+      1. Uncheck ports
+   1. Network Configuration: vtnet0
+   1. Configure IPv4? Yes
+   1. DHCP? Yes
+   1. Configure IPv6? No
+   1. Resolver Configuration: Ok
+   1. Mirror Selection: Main Site
+   1. Partitioning: Auto (UFS)
+   1. Partition: Entire Disk
+   1. Partition Scheme: MBR
+   1. App Partition: Ok
+   1. Partition Editor: Finish
+   1. Confirmation: Commit
+   1. Wait for sets to install
+   1. Set the root password to nothing (press enter twice)
+   1. Set time zone to UTC
+   1. Set Date: Skip
+   1. Set Time: Skip
+   1. System Configuration:
+      1. Disable sshd
+      1. Disable dumpdev
+   1. System Hardening
+      1. Disable Sendmail service
+   1. Add User Accounts: No
+   1. Final Configuration: Exit
+   1. Manual Configuration: Yes
+   1. `echo 'console="comconsole"' >> /boot/loader.conf`
+   1. `echo 'autoboot_delay="0"' >> /boot/loader.conf`
+   1. `echo 'ext2fs_load="YES"' >> /boot/loader.conf`
+   1. Look at `/etc/ttys`, see what getty argument is for `ttyu0` (E.g. `3wire`)
+   1. Edit `/etc/gettytab` (with `vi` for example), look for `ttyu0` argument,
+      prepend `:al=root` to the line beneath to have the machine auto-login as
+      root. E.g.
+
+          3wire:\
+                   :np:nc:sp#0:
+      becomes:
+
+          3wire:\
+                   :al=root:np:nc:sp#0:
+
+   1. Edit `/root/.login` and put this in it:
+
+          [ -e /dev/vtbd1 ] || exit 0
+          mount -t ext2fs /dev/vtbd1 /mnt
+          sh /mnt/run.sh /mnt
+          poweroff
+
+   1. Exit the post install shell: `exit`
+   1. Back in in the installer choose Reboot
+   1. If all went well the machine should reboot and show a login prompt.
+      If you switch to the serial console by choosing View > serial0 in
+      the qemu menu, you should be logged in as root.
+   1. Shutdown the machine: `shutdown -p now`
+
+Helpful links
+
+* https://en.wikibooks.org/wiki/QEMU/Images
+* https://blog.nekoconeko.nl/blog/2015/06/04/creating-an-openstack-freebsd-image.html
+* https://www.freebsd.org/doc/handbook/serialconsole-setup.html
+
+### QEMU setup - OpenBSD
+
+1. Download CD installer
+2. `qemu-img create -f qcow2 foo.qcow2 2G`
+3. `qemu -cdrom foo.iso -drive if=virtio,file=foo.qcow2 -net nic,model=virtio -net user`
+4. run installer
+5. `echo 'set tty com0' >> /etc/boot.conf`
+6. `echo 'boot' >> /etc/boot.conf`
+7. Modify /etc/ttys, change the `tty00` at the end from 'unknown off' to
+   'vt220 on secure'
+8. Modify same line in /etc/ttys to have `"/root/foo.sh"` as the shell
+9. Add this script to `/root/foo.sh`
+
+```
+#!/bin/sh
+exec 1>/dev/tty00
+exec 2>&1
+
+if mount -t ext2fs /dev/sd1c /mnt; then
+  sh /mnt/run.sh /mnt
+  shutdown -ph now
+fi
+
+# limited shell...
+exec /bin/sh < /dev/tty00
+```
+
+10. `chmod +x /root/foo.sh`
+
+Helpful links:
+
+* https://en.wikibooks.org/wiki/QEMU/Images
+* http://www.openbsd.org/faq/faq7.html#SerCon
+
+# Questions?
+
+Hopefully that's at least somewhat of an introduction to everything going on
+here, and feel free to ping @alexcrichton with questions!
diff --git a/library/libc/ci/android-install-ndk.sh b/library/libc/ci/android-install-ndk.sh
new file mode 100644
index 00000000..46356512
--- /dev/null
+++ b/library/libc/ci/android-install-ndk.sh
@@ -0,0 +1,41 @@
+#!/usr/bin/env sh
+
+set -ex
+
+NDK=android-ndk-r21d
+wget --tries=20 -q https://dl.google.com/android/repository/${NDK}-linux-x86_64.zip
+unzip -q ${NDK}-linux-x86_64.zip
+
+case "$1" in
+  arm)
+    arch=arm
+    api=28
+    ;;
+  armv7)
+    arch=arm
+    api=28
+    ;;
+  aarch64)
+    arch=arm64
+    api=28
+    ;;
+  i686)
+    arch=x86
+    api=28
+    ;;
+  x86_64)
+    arch=x86_64
+    api=28
+    ;;
+  *)
+    echo "invalid arch: $1"
+    exit 1
+    ;;
+esac;
+
+python3 ${NDK}/build/tools/make_standalone_toolchain.py \
+        --install-dir "/android/ndk-${1}" \
+        --arch "${arch}" \
+        --api ${api}
+
+rm -rf ./${NDK}-linux-x86_64.zip ./${NDK}
diff --git a/library/libc/ci/android-install-sdk.sh b/library/libc/ci/android-install-sdk.sh
new file mode 100644
index 00000000..6f6aeb28
--- /dev/null
+++ b/library/libc/ci/android-install-sdk.sh
@@ -0,0 +1,64 @@
+#!/usr/bin/env sh
+
+set -ex
+
+# Prep the SDK and emulator
+#
+# Note that the update process requires that we accept a bunch of licenses, and
+# we can't just pipe `yes` into it for some reason, so we take the same strategy
+# located in https://github.com/appunite/docker by just wrapping it in a script
+# which apparently magically accepts the licenses.
+
+SDK=6609375
+mkdir -p sdk/cmdline-tools
+wget -q --tries=20 https://dl.google.com/android/repository/commandlinetools-linux-${SDK}_latest.zip
+unzip -q -d sdk/cmdline-tools commandlinetools-linux-${SDK}_latest.zip
+
+case "$1" in
+  arm | armv7)
+    api=24
+    image="system-images;android-${api};default;armeabi-v7a"
+    ;;
+  aarch64)
+    api=24
+    image="system-images;android-${api};google_apis;arm64-v8a"
+    ;;
+  i686)
+    api=28
+    image="system-images;android-${api};default;x86"
+    ;;
+  x86_64)
+    api=28
+    image="system-images;android-${api};default;x86_64"
+    ;;
+  *)
+    echo "invalid arch: $1"
+    exit 1
+    ;;
+esac;
+
+# Try to fix warning about missing file.
+# See https://askubuntu.com/a/1078784
+mkdir -p /root/.android/
+echo '### User Sources for Android SDK Manager' >> /root/.android/repositories.cfg
+echo '#Fri Nov 03 10:11:27 CET 2017 count=0' >> /root/.android/repositories.cfg
+
+# Print all available packages
+# yes | ./sdk/tools/bin/sdkmanager --list --verbose
+
+# --no_https avoids
+# javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: No trusted certificate found
+#
+# | grep -v = || true    removes the progress bar output from the sdkmanager
+# which produces an insane amount of output.
+yes | ./sdk/cmdline-tools/tools/bin/sdkmanager --licenses --no_https | grep -v = || true
+yes | ./sdk/cmdline-tools/tools/bin/sdkmanager --no_https \
+        "emulator" \
+        "platform-tools" \
+        "platforms;android-${api}" \
+        "${image}" | grep -v = || true
+
+echo "no" |
+    ./sdk/cmdline-tools/tools/bin/avdmanager create avd \
+        --name "${1}" \
+        --package "${image}" | grep -v = || true
diff --git a/library/libc/ci/android-sysimage.sh b/library/libc/ci/android-sysimage.sh
new file mode 100644
index 00000000..b4971203
--- /dev/null
+++ b/library/libc/ci/android-sysimage.sh
@@ -0,0 +1,46 @@
+#!/usr/bin/env bash
+
+set -ex
+
+URL=https://dl.google.com/android/repository/sys-img/android
+
+main() {
+    local arch="${1}"
+    local name="${2}"
+    local dest=/system
+    local td
+    td="$(mktemp -d)"
+
+    apt-get install --no-install-recommends e2tools
+
+    pushd "${td}"
+    wget -q --tries=5 "${URL}/${name}"
+    unzip -q "${name}"
+
+    local system
+    system="$(find . -name system.img)"
+    mkdir -p ${dest}/{bin,lib,lib64}
+
+    # Extract android linker and libraries to /system
+    # This allows android executables to be run directly (or with qemu)
+    if [ "${arch}" = "x86_64" ] || [ "${arch}" = "arm64" ]; then
+        e2cp -p "${system}:/bin/linker64" "${dest}/bin/"
+        e2cp -p "${system}:/lib64/libdl.so" "${dest}/lib64/"
+        e2cp -p "${system}:/lib64/libc.so" "${dest}/lib64/"
+        e2cp -p "${system}:/lib64/libm.so" "${dest}/lib64/"
+    else
+        e2cp -p "${system}:/bin/linker" "${dest}/bin/"
+        e2cp -p "${system}:/lib/libdl.so" "${dest}/lib/"
+        e2cp -p "${system}:/lib/libc.so" "${dest}/lib/"
+        e2cp -p "${system}:/lib/libm.so" "${dest}/lib/"
+    fi
+
+    # clean up
+    apt-get purge --auto-remove -y e2tools
+
+    popd
+
+    rm -rf "${td}"
+}
+
+main "${@}"
diff --git a/library/libc/ci/build.sh b/library/libc/ci/build.sh
new file mode 100644
index 00000000..cb4177d0
--- /dev/null
+++ b/library/libc/ci/build.sh
@@ -0,0 +1,281 @@
+#!/usr/bin/env sh
+
+# Checks that libc builds properly for all supported targets on a particular
+# Rust version:
+# The FILTER environment variable can be used to select which target(s) to build.
+# For example: set FILTER to vxworks to select the targets that has vxworks in name
+
+set -ex
+
+: "${TOOLCHAIN?The TOOLCHAIN environment variable must be set.}"
+: "${OS?The OS environment variable must be set.}"
+
+RUST=${TOOLCHAIN}
+
+echo "Testing Rust ${RUST} on ${OS}"
+
+if [ "${TOOLCHAIN}" = "nightly" ] ; then
+    rustup component add rust-src
+fi
+
+test_target() {
+    BUILD_CMD="${1}"
+    TARGET="${2}"
+    NO_STD="${3}"
+
+    # If there is a std component, fetch it:
+    if [ "${NO_STD}" != "1" ]; then
+        # FIXME: rustup often fails to download some artifacts due to network
+        # issues, so we retry this N times.
+        N=5
+        n=0
+        until [ $n -ge $N ]
+        do
+            if rustup target add "${TARGET}" --toolchain "${RUST}" ; then
+                break
+            fi
+            n=$((n+1))
+            sleep 1
+        done
+    fi
+
+    # Test that libc builds without any default features (no libstd)
+    if [ "${NO_STD}" != "1" ]; then
+        cargo "+${RUST}" "${BUILD_CMD}" -vv --no-default-features --target "${TARGET}"
+    else
+        # FIXME: With `build-std` feature, `compiler_builtins` emits a lof of lint warnings.
+        RUSTFLAGS="-A improper_ctypes_definitions" cargo "+${RUST}" "${BUILD_CMD}" \
+            -Z build-std=core,alloc -vv --no-default-features --target "${TARGET}"
+    fi
+    # Test that libc builds with default features (e.g. libstd)
+    # if the target supports libstd
+    if [ "$NO_STD" != "1" ]; then
+        cargo "+${RUST}" "${BUILD_CMD}" -vv --target "${TARGET}"
+    else
+        RUSTFLAGS="-A improper_ctypes_definitions" cargo "+${RUST}" "${BUILD_CMD}" \
+            -Z build-std=core,alloc -vv --target "${TARGET}"
+    fi
+
+    # Test that libc builds with the `extra_traits` feature
+    if [ "${NO_STD}" != "1" ]; then
+        cargo "+${RUST}" "${BUILD_CMD}" -vv --no-default-features --target "${TARGET}" \
+            --features extra_traits
+    else
+        RUSTFLAGS="-A improper_ctypes_definitions" cargo "+${RUST}" "${BUILD_CMD}" \
+            -Z build-std=core,alloc -vv --no-default-features \
+            --target "${TARGET}" --features extra_traits
+    fi
+
+    # Test the 'const-extern-fn' feature on nightly
+    if [ "${RUST}" = "nightly" ]; then
+        if [ "${NO_STD}" != "1" ]; then
+            cargo "+${RUST}" "${BUILD_CMD}" -vv --no-default-features --target "${TARGET}" \
+                --features const-extern-fn
+        else
+            RUSTFLAGS="-A improper_ctypes_definitions" cargo "+${RUST}" "${BUILD_CMD}" \
+                -Z build-std=core,alloc -vv --no-default-features \
+                --target "${TARGET}" --features const-extern-fn
+        fi
+    fi
+
+    # Also test that it builds with `extra_traits` and default features:
+    if [ "$NO_STD" != "1" ]; then
+        cargo "+${RUST}" "${BUILD_CMD}" -vv --target "${TARGET}" \
+            --features extra_traits
+    else
+        RUSTFLAGS="-A improper_ctypes_definitions" cargo "+${RUST}" "${BUILD_CMD}" \
+            -Z build-std=core,alloc -vv --target "${TARGET}" \
+            --features extra_traits
+    fi
+}
+
+RUST_LINUX_TARGETS="\
+aarch64-linux-android \
+aarch64-unknown-linux-gnu \
+arm-linux-androideabi \
+arm-unknown-linux-gnueabi \
+arm-unknown-linux-gnueabihf \
+armv7-linux-androideabi \
+armv7-unknown-linux-gnueabihf \
+i586-unknown-linux-gnu \
+i686-linux-android \
+i686-unknown-freebsd \
+i686-unknown-linux-gnu \
+i686-unknown-linux-musl \
+mips-unknown-linux-gnu \
+mips-unknown-linux-musl \
+mips64-unknown-linux-gnuabi64 \
+mips64el-unknown-linux-gnuabi64 \
+mipsel-unknown-linux-gnu \
+mipsel-unknown-linux-musl \
+powerpc-unknown-linux-gnu \
+powerpc64-unknown-linux-gnu \
+powerpc64le-unknown-linux-gnu \
+s390x-unknown-linux-gnu \
+x86_64-unknown-freebsd \
+x86_64-unknown-linux-gnu \
+x86_64-unknown-linux-musl \
+x86_64-unknown-netbsd \
+"
+
+RUST_GT_1_13_LINUX_TARGETS="\
+arm-unknown-linux-musleabi \
+arm-unknown-linux-musleabihf \
+armv7-unknown-linux-musleabihf \
+sparc64-unknown-linux-gnu \
+wasm32-unknown-emscripten \
+x86_64-linux-android \
+x86_64-rumprun-netbsd \
+"
+RUST_GT_1_19_LINUX_TARGETS="\
+aarch64-unknown-linux-musl \
+sparcv9-sun-solaris \
+wasm32-unknown-unknown \
+x86_64-sun-solaris \
+"
+RUST_GT_1_24_LINUX_TARGETS="\
+i586-unknown-linux-musl \
+"
+
+RUST_NIGHTLY_LINUX_TARGETS="\
+aarch64-fuchsia \
+armv5te-unknown-linux-gnueabi \
+armv5te-unknown-linux-musleabi \
+i686-pc-windows-gnu \
+riscv64gc-unknown-linux-gnu \
+wasm32-wasi \
+x86_64-fortanix-unknown-sgx \
+x86_64-fuchsia \
+x86_64-pc-windows-gnu \
+x86_64-unknown-illumos \
+x86_64-unknown-linux-gnux32 \
+x86_64-unknown-redox \
+"
+
+RUST_APPLE_TARGETS="\
+aarch64-apple-ios \
+x86_64-apple-darwin \
+x86_64-apple-ios \
+"
+
+RUST_NIGHTLY_APPLE_TARGETS="\
+aarch64-apple-darwin \
+"
+
+# The targets are listed here alphabetically
+TARGETS=""
+case "${OS}" in
+    linux*)
+        TARGETS="${RUST_LINUX_TARGETS}"
+
+        if [ "${RUST}" != "1.13.0" ]; then
+            TARGETS="${TARGETS} ${RUST_GT_1_13_LINUX_TARGETS}"
+            if [ "${RUST}" != "1.19.0" ]; then
+                TARGETS="${TARGETS} ${RUST_GT_1_19_LINUX_TARGETS}"
+                if [ "${RUST}" != "1.24.0" ]; then
+                    TARGETS="${TARGETS} ${RUST_GT_1_24_LINUX_TARGETS}"
+                fi
+            fi
+        fi
+
+        if [ "${RUST}" = "nightly" ]; then
+            TARGETS="${TARGETS} ${RUST_NIGHTLY_LINUX_TARGETS}"
+        fi
+
+        ;;
+    macos*)
+        TARGETS="${RUST_APPLE_TARGETS}"
+
+        if [ "${RUST}" = "nightly" ]; then
+            TARGETS="${TARGETS} ${RUST_NIGHTLY_APPLE_TARGETS}"
+        fi
+
+        ;;
+    *)
+        ;;
+esac
+
+for TARGET in $TARGETS; do
+    if echo "$TARGET"|grep -q "$FILTER"; then
+        test_target build "$TARGET"
+    fi
+done
+
+RUST_LINUX_NO_CORE_TARGETS="\
+aarch64-pc-windows-msvc \
+aarch64-unknown-freebsd \
+aarch64-unknown-hermit \
+aarch64-unknown-netbsd \
+aarch64-unknown-openbsd \
+aarch64-wrs-vxworks \
+armebv7r-none-eabi \
+armebv7r-none-eabihf \
+armv7-wrs-vxworks-eabihf \
+armv7r-none-eabi \
+armv7r-none-eabihf \
+hexagon-unknown-linux-musl \
+i586-pc-windows-msvc \
+i686-pc-windows-msvc \
+i686-unknown-haiku \
+i686-unknown-netbsd \
+i686-unknown-openbsd \
+i686-wrs-vxworks \
+mips-unknown-linux-uclibc \
+mipsel-sony-psp \
+mipsel-unknown-linux-uclibc \
+mips64-unknown-linux-muslabi64 \
+mips64el-unknown-linux-muslabi64 \
+nvptx64-nvidia-cuda \
+powerpc-unknown-linux-gnuspe \
+powerpc-unknown-netbsd \
+powerpc-wrs-vxworks \
+powerpc-wrs-vxworks-spe \
+powerpc64-unknown-freebsd \
+powerpc64-wrs-vxworks \
+riscv32i-unknown-none-elf \
+riscv32imac-unknown-none-elf \
+riscv32imc-unknown-none-elf \
+riscv32gc-unknown-linux-gnu \
+riscv64gc-unknown-none-elf \
+riscv64imac-unknown-none-elf \
+sparc-unknown-linux-gnu \
+sparc64-unknown-netbsd \
+
+thumbv6m-none-eabi \
+thumbv7em-none-eabi \
+thumbv7em-none-eabihf \
+thumbv7m-none-eabi \
+thumbv7neon-linux-androideabi \
+thumbv7neon-unknown-linux-gnueabihf \
+thumbv8m.main-none-eabi \
+x86_64-pc-windows-msvc \
+x86_64-unknown-dragonfly \
+x86_64-unknown-haiku \
+x86_64-unknown-hermit \
+x86_64-unknown-l4re-uclibc \
+x86_64-unknown-openbsd \
+x86_64-wrs-vxworks \
+"
+
+if [ "${RUST}" = "nightly" ] && [ "${OS}" = "linux" ]; then
+    for TARGET in $RUST_LINUX_NO_CORE_TARGETS; do
+        if echo "$TARGET"|grep -q "$FILTER"; then
+            test_target build "$TARGET" 1
+        fi
+    done
+fi
+
+RUST_OSX_NO_CORE_TARGETS="\
+armv7-apple-ios \
+armv7s-apple-ios \
+i686-apple-darwin \
+i386-apple-ios \
+"
+
+if [ "${RUST}" = "nightly" ] && [ "${OS}" = "macos" ]; then
+    for TARGET in $RUST_OSX_NO_CORE_TARGETS; do
+        if echo "$TARGET" | grep -q "$FILTER"; then
+            test_target build "$TARGET" 1
+        fi
+    done
+fi
diff --git a/library/libc/ci/docker/aarch64-linux-android/Dockerfile b/library/libc/ci/docker/aarch64-linux-android/Dockerfile
new file mode 100644
index 00000000..0aa99eee
--- /dev/null
+++ b/library/libc/ci/docker/aarch64-linux-android/Dockerfile
@@ -0,0 +1,46 @@
+FROM ubuntu:20.04
+
+RUN dpkg --add-architecture i386
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends libc6-dev gcc
+RUN apt-get install -y --no-install-recommends \
+  file \
+  wget \
+  ca-certificates \
+  python3 \
+  python3-distutils \
+  unzip \
+  expect \
+  openjdk-8-jre \
+  libstdc++6:i386 \
+  libpulse0
+
+WORKDIR /android/
+COPY android* /android/
+
+ENV ANDROID_ARCH=aarch64
+ENV PATH=$PATH:/android/ndk-$ANDROID_ARCH/bin:/android/sdk/cmdline-tools/tools:/android/sdk/platform-tools
+
+RUN sh /android/android-install-ndk.sh $ANDROID_ARCH
+RUN sh /android/android-install-sdk.sh $ANDROID_ARCH
+RUN mv /root/.android /tmp
+RUN chmod 777 -R /tmp/.android
+RUN chmod 755 /android/sdk/cmdline-tools/tools/* /android/sdk/emulator/qemu/linux-x86_64/*
+
+ENV PATH=$PATH:/rust/bin \
+    CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER=aarch64-linux-android28-clang \
+    CARGO_TARGET_AARCH64_LINUX_ANDROID_RUNNER=/tmp/runtest \
+    CC_aarch64_linux_android=aarch64-linux-android28-clang \
+    HOME=/tmp
+
+ADD runtest-android.rs /tmp/runtest.rs
+ENTRYPOINT [ \
+  "bash", \
+  "-c", \
+  # set SHELL so android can detect a 64bits system, see
+  # http://stackoverflow.com/a/41789144
+  "SHELL=/bin/dash /android/sdk/emulator/emulator @aarch64 -no-window & \
+   rustc /tmp/runtest.rs -o /tmp/runtest && \
+   exec \"$@\"", \
+  "--" \
+]
diff --git a/library/libc/ci/docker/aarch64-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..0588b464
--- /dev/null
+++ b/library/libc/ci/docker/aarch64-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,7 @@
+FROM ubuntu:20.04
+RUN apt-get update && apt-get install -y --no-install-recommends \
+  gcc libc6-dev ca-certificates \
+  gcc-aarch64-linux-gnu libc6-dev-arm64-cross qemu-user
+ENV CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc \
+    CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_RUNNER="qemu-aarch64 -L /usr/aarch64-linux-gnu" \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/aarch64-unknown-linux-musl/Dockerfile b/library/libc/ci/docker/aarch64-unknown-linux-musl/Dockerfile
new file mode 100644
index 00000000..add8a685
--- /dev/null
+++ b/library/libc/ci/docker/aarch64-unknown-linux-musl/Dockerfile
@@ -0,0 +1,15 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+  gcc make libc6-dev git curl ca-certificates \
+  gcc-aarch64-linux-gnu qemu-user
+
+COPY install-musl.sh /
+RUN sh /install-musl.sh aarch64
+
+# FIXME: shouldn't need the `-lgcc` here, shouldn't that be in libstd?
+ENV PATH=$PATH:/musl-aarch64/bin:/rust/bin \
+    CC_aarch64_unknown_linux_musl=musl-gcc \
+    RUSTFLAGS='-Clink-args=-lgcc' \
+    CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=musl-gcc \
+    CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_RUNNER="qemu-aarch64 -L /musl-aarch64"
diff --git a/library/libc/ci/docker/arm-linux-androideabi/Dockerfile b/library/libc/ci/docker/arm-linux-androideabi/Dockerfile
new file mode 100644
index 00000000..e5cc79d8
--- /dev/null
+++ b/library/libc/ci/docker/arm-linux-androideabi/Dockerfile
@@ -0,0 +1,46 @@
+FROM ubuntu:20.04
+
+RUN dpkg --add-architecture i386
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends libc6-dev gcc
+RUN apt-get install -y --no-install-recommends \
+  file \
+  wget \
+  ca-certificates \
+  python3 \
+  python3-distutils \
+  unzip \
+  expect \
+  openjdk-8-jre \
+  libstdc++6:i386 \
+  libpulse0
+
+WORKDIR /android/
+COPY android* /android/
+
+ENV ANDROID_ARCH=arm
+ENV PATH=$PATH:/android/ndk-$ANDROID_ARCH/bin:/android/sdk/cmdline-tools/tools:/android/sdk/platform-tools
+
+RUN sh /android/android-install-ndk.sh $ANDROID_ARCH
+RUN sh /android/android-install-sdk.sh $ANDROID_ARCH
+RUN mv /root/.android /tmp
+RUN chmod 777 -R /tmp/.android
+RUN chmod 755 /android/sdk/cmdline-tools/tools/* /android/sdk/emulator/qemu/linux-x86_64/*
+
+ENV PATH=$PATH:/rust/bin \
+    CARGO_TARGET_ARM_LINUX_ANDROIDEABI_LINKER=arm-linux-androideabi-gcc \
+    CARGO_TARGET_ARM_LINUX_ANDROIDEABI_RUNNER=/tmp/runtest \
+    CC_arm_linux_androideabi=arm-linux-androideabi-gcc \
+    HOME=/tmp
+
+ADD runtest-android.rs /tmp/runtest.rs
+ENTRYPOINT [ \
+  "bash", \
+  "-c", \
+  # set SHELL so android can detect a 64bits system, see
+  # http://stackoverflow.com/a/41789144
+  "SHELL=/bin/dash /android/sdk/emulator/emulator @arm -no-window & \
+   rustc /tmp/runtest.rs -o /tmp/runtest && \
+   exec \"$@\"", \
+  "--" \
+]
diff --git a/library/libc/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile b/library/libc/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
new file mode 100644
index 00000000..299ff971
--- /dev/null
+++ b/library/libc/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile
@@ -0,0 +1,7 @@
+FROM ubuntu:20.04
+RUN apt-get update && apt-get install -y --no-install-recommends \
+  gcc libc6-dev ca-certificates \
+  gcc-arm-linux-gnueabihf libc6-dev-armhf-cross qemu-user
+ENV CARGO_TARGET_ARM_UNKNOWN_LINUX_GNUEABIHF_LINKER=arm-linux-gnueabihf-gcc \
+    CARGO_TARGET_ARM_UNKNOWN_LINUX_GNUEABIHF_RUNNER="qemu-arm -L /usr/arm-linux-gnueabihf" \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/arm-unknown-linux-musleabihf/Dockerfile b/library/libc/ci/docker/arm-unknown-linux-musleabihf/Dockerfile
new file mode 100644
index 00000000..6b171508
--- /dev/null
+++ b/library/libc/ci/docker/arm-unknown-linux-musleabihf/Dockerfile
@@ -0,0 +1,13 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+  gcc make libc6-dev git curl ca-certificates \
+  gcc-arm-linux-gnueabihf qemu-user
+
+COPY install-musl.sh /
+RUN sh /install-musl.sh arm
+
+ENV PATH=$PATH:/musl-arm/bin:/rust/bin \
+    CC_arm_unknown_linux_musleabihf=musl-gcc \
+    CARGO_TARGET_ARM_UNKNOWN_LINUX_MUSLEABIHF_LINKER=musl-gcc \
+    CARGO_TARGET_ARM_UNKNOWN_LINUX_MUSLEABIHF_RUNNER="qemu-arm -L /musl-arm"
diff --git a/library/libc/ci/docker/asmjs-unknown-emscripten/Dockerfile b/library/libc/ci/docker/asmjs-unknown-emscripten/Dockerfile
new file mode 100644
index 00000000..57419a36
--- /dev/null
+++ b/library/libc/ci/docker/asmjs-unknown-emscripten/Dockerfile
@@ -0,0 +1,22 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && \
+    apt-get install -y --no-install-recommends \
+    ca-certificates \
+    curl \
+    gcc \
+    git \
+    libc6-dev \
+    libxml2 \
+    python3 \
+    python3-distutils \
+    xz-utils
+
+COPY emscripten.sh /
+RUN bash /emscripten.sh
+
+ENV PATH=$PATH:/rust/bin \
+    CARGO_TARGET_ASMJS_UNKNOWN_EMSCRIPTEN_RUNNER=node
+
+COPY emscripten-entry.sh /
+ENTRYPOINT ["/emscripten-entry.sh"]
diff --git a/library/libc/ci/docker/i686-linux-android/Dockerfile b/library/libc/ci/docker/i686-linux-android/Dockerfile
new file mode 100644
index 00000000..62a379b3
--- /dev/null
+++ b/library/libc/ci/docker/i686-linux-android/Dockerfile
@@ -0,0 +1,46 @@
+FROM ubuntu:20.04
+
+RUN dpkg --add-architecture i386
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends libc6-dev gcc
+RUN apt-get install -y --no-install-recommends \
+  file \
+  wget \
+  ca-certificates \
+  python3 \
+  python3-distutils \
+  unzip \
+  expect \
+  openjdk-8-jre \
+  libstdc++6:i386 \
+  libpulse0
+
+WORKDIR /android/
+COPY android* /android/
+
+ENV ANDROID_ARCH=i686
+ENV PATH=$PATH:/android/ndk-$ANDROID_ARCH/bin:/android/sdk/cmdline-tools/tools:/android/sdk/platform-tools
+
+RUN sh /android/android-install-ndk.sh $ANDROID_ARCH
+RUN sh /android/android-install-sdk.sh $ANDROID_ARCH
+RUN mv /root/.android /tmp
+RUN chmod 777 -R /tmp/.android
+RUN chmod 755 /android/sdk/cmdline-tools/tools/* /android/sdk/emulator/qemu/linux-x86_64/*
+
+ENV PATH=$PATH:/rust/bin \
+    CARGO_TARGET_I686_LINUX_ANDROID_LINKER=i686-linux-android-gcc \
+    CARGO_TARGET_I686_LINUX_ANDROID_RUNNER=/tmp/runtest \
+    CC_i686_linux_android=i686-linux-android-gcc \
+    HOME=/tmp
+
+ADD runtest-android.rs /tmp/runtest.rs
+ENTRYPOINT [ \
+  "bash", \
+  "-c", \
+  # set SHELL so android can detect a 64bits system, see
+  # http://stackoverflow.com/a/41789144
+  "SHELL=/bin/dash /android/sdk/emulator/emulator @i686 -no-window -no-accel & \
+   rustc /tmp/runtest.rs -o /tmp/runtest && \
+   exec \"$@\"", \
+  "--" \
+]
diff --git a/library/libc/ci/docker/i686-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/i686-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..6bab1d0c
--- /dev/null
+++ b/library/libc/ci/docker/i686-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,5 @@
+FROM ubuntu:20.04
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends \
+  gcc-multilib libc6-dev ca-certificates
+ENV PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/i686-unknown-linux-musl/Dockerfile b/library/libc/ci/docker/i686-unknown-linux-musl/Dockerfile
new file mode 100644
index 00000000..3cb7a113
--- /dev/null
+++ b/library/libc/ci/docker/i686-unknown-linux-musl/Dockerfile
@@ -0,0 +1,12 @@
+FROM ubuntu:20.04
+
+RUN dpkg --add-architecture i386
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends \
+  gcc-multilib make libc6-dev git curl ca-certificates libc6-i386
+
+COPY install-musl.sh /
+RUN sh /install-musl.sh i686
+
+ENV PATH=$PATH:/musl-i686/bin:/rust/bin \
+    CC_i686_unknown_linux_musl=musl-gcc
diff --git a/library/libc/ci/docker/mips-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/mips-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..574f1846
--- /dev/null
+++ b/library/libc/ci/docker/mips-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,10 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates \
+        gcc-mips-linux-gnu libc6-dev-mips-cross \
+        qemu-system-mips linux-headers-generic
+
+ENV CARGO_TARGET_MIPS_UNKNOWN_LINUX_GNU_LINKER=mips-linux-gnu-gcc \
+    CARGO_TARGET_MIPS_UNKNOWN_LINUX_GNU_RUNNER="qemu-mips -L /usr/mips-linux-gnu" \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/mips-unknown-linux-musl/Dockerfile b/library/libc/ci/docker/mips-unknown-linux-musl/Dockerfile
new file mode 100644
index 00000000..a9b49ce7
--- /dev/null
+++ b/library/libc/ci/docker/mips-unknown-linux-musl/Dockerfile
@@ -0,0 +1,24 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates qemu-system-mips curl \
+        xz-utils patch
+
+RUN mkdir /toolchain
+
+# Linux kernel version: 4.14.151
+# See build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux-4.14.151
+# Musl version: 1.1.24
+# See staging_dir/toolchain-mips_24kc_gcc-7.4.0_musl/info.mk
+RUN curl --retry 5 -L https://downloads.openwrt.org/releases/19.07.0-rc1/targets/ar71xx/generic/openwrt-sdk-19.07.0-rc1-ar71xx-generic_gcc-7.4.0_musl.Linux-x86_64.tar.xz | \
+    tar xJf - -C /toolchain --strip-components=1
+
+# See https://lkml.org/lkml/2014/3/14/269
+COPY sysinfo_guard.patch /toolchain
+RUN patch /toolchain/staging_dir/toolchain-mips_24kc_gcc-7.4.0_musl/include/linux/kernel.h </toolchain/sysinfo_guard.patch
+
+ENV PATH=$PATH:/rust/bin:/toolchain/staging_dir/toolchain-mips_24kc_gcc-7.4.0_musl/bin \
+    STAGING_DIR=/toolchain/staging_dir \
+    CC_mips_unknown_linux_musl=mips-openwrt-linux-musl-gcc \
+    CARGO_TARGET_MIPS_UNKNOWN_LINUX_MUSL_LINKER=mips-openwrt-linux-musl-gcc \
+    CARGO_TARGET_MIPS_UNKNOWN_LINUX_MUSL_RUNNER="qemu-mips -L /toolchain/staging_dir/toolchain-mips_24kc_gcc-7.4.0_musl"
diff --git a/library/libc/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile b/library/libc/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
new file mode 100644
index 00000000..83a52d87
--- /dev/null
+++ b/library/libc/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile
@@ -0,0 +1,11 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates \
+        gcc-mips64-linux-gnuabi64 libc6-dev-mips64-cross \
+        qemu-system-mips64 linux-headers-generic
+
+ENV CARGO_TARGET_MIPS64_UNKNOWN_LINUX_GNUABI64_LINKER=mips64-linux-gnuabi64-gcc \
+    CARGO_TARGET_MIPS64_UNKNOWN_LINUX_GNUABI64_RUNNER="qemu-mips64 -L /usr/mips64-linux-gnuabi64" \
+    CC_mips64_unknown_linux_gnuabi64=mips64-linux-gnuabi64-gcc \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/mips64-unknown-linux-muslabi64/Dockerfile b/library/libc/ci/docker/mips64-unknown-linux-muslabi64/Dockerfile
new file mode 100644
index 00000000..9ad1688c
--- /dev/null
+++ b/library/libc/ci/docker/mips64-unknown-linux-muslabi64/Dockerfile
@@ -0,0 +1,15 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+  gcc make libc6-dev git curl ca-certificates \
+  gcc-mips64-linux-gnuabi64 qemu-user
+
+COPY install-musl.sh /
+RUN sh /install-musl.sh mips64
+
+# FIXME: shouldn't need the `-lgcc` here, shouldn't that be in libstd?
+ENV PATH=$PATH:/musl-mips64/bin:/rust/bin \
+    CC_mips64_unknown_linux_muslabi64=musl-gcc \
+    RUSTFLAGS='-Clink-args=-lgcc' \
+    CARGO_TARGET_MIPS64_UNKNOWN_LINUX_MUSLABI64_LINKER=musl-gcc \
+    CARGO_TARGET_MIPS64_UNKNOWN_LINUX_MUSLABI64_RUNNER="qemu-mips64 -L /musl-mips64"
diff --git a/library/libc/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile b/library/libc/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
new file mode 100644
index 00000000..2ba6b252
--- /dev/null
+++ b/library/libc/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile
@@ -0,0 +1,11 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates \
+        gcc-mips64el-linux-gnuabi64 libc6-dev-mips64el-cross \
+        qemu-system-mips64el linux-headers-generic
+
+ENV CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_GNUABI64_LINKER=mips64el-linux-gnuabi64-gcc \
+    CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_GNUABI64_RUNNER="qemu-mips64el -L /usr/mips64el-linux-gnuabi64" \
+    CC_mips64el_unknown_linux_gnuabi64=mips64el-linux-gnuabi64-gcc \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/mips64el-unknown-linux-muslabi64/Dockerfile b/library/libc/ci/docker/mips64el-unknown-linux-muslabi64/Dockerfile
new file mode 100644
index 00000000..ac4d1400
--- /dev/null
+++ b/library/libc/ci/docker/mips64el-unknown-linux-muslabi64/Dockerfile
@@ -0,0 +1,15 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+  gcc make libc6-dev git curl ca-certificates \
+  gcc-mips64el-linux-gnuabi64 qemu-user
+
+COPY install-musl.sh /
+RUN sh /install-musl.sh mips64el
+
+# FIXME: shouldn't need the `-lgcc` here, shouldn't that be in libstd?
+ENV PATH=$PATH:/musl-mips64el/bin:/rust/bin \
+    CC_mips64el_unknown_linux_muslabi64=musl-gcc \
+    RUSTFLAGS='-Clink-args=-lgcc' \
+    CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_MUSLABI64_LINKER=musl-gcc \
+    CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_MUSLABI64_RUNNER="qemu-mips64el -L /musl-mips64el"
diff --git a/library/libc/ci/docker/mipsel-unknown-linux-musl/Dockerfile b/library/libc/ci/docker/mipsel-unknown-linux-musl/Dockerfile
new file mode 100644
index 00000000..8b581ee4
--- /dev/null
+++ b/library/libc/ci/docker/mipsel-unknown-linux-musl/Dockerfile
@@ -0,0 +1,24 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates qemu-system-mipsel curl \
+        xz-utils patch
+
+RUN mkdir /toolchain
+
+# Linux kernel version: 4.14.151
+# See build_dir/target-mipsel_mips32_musl/linux-brcm47xx_generic/linux-4.14.151
+# Musl version: 1.1.24
+# See staging_dir/toolchain-mipsel_mips32_gcc-7.4.0_musl/info.mk
+RUN curl --retry 5 -L https://downloads.openwrt.org/releases/19.07.0-rc1/targets/brcm47xx/generic/openwrt-sdk-19.07.0-rc1-brcm47xx-generic_gcc-7.4.0_musl.Linux-x86_64.tar.xz | \
+    tar xJf - -C /toolchain --strip-components=1
+
+# See https://lkml.org/lkml/2014/3/14/269
+COPY sysinfo_guard.patch /toolchain
+RUN patch /toolchain/staging_dir/toolchain-mipsel_mips32_gcc-7.4.0_musl/include/linux/kernel.h </toolchain/sysinfo_guard.patch
+
+ENV PATH=$PATH:/rust/bin:/toolchain/staging_dir/toolchain-mipsel_mips32_gcc-7.4.0_musl/bin \
+    STAGING_DIR=/toolchain/staging_dir \
+    CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-musl-gcc \
+    CARGO_TARGET_MIPSEL_UNKNOWN_LINUX_MUSL_LINKER=mipsel-openwrt-linux-musl-gcc \
+    CARGO_TARGET_MIPSEL_UNKNOWN_LINUX_MUSL_RUNNER="qemu-mipsel -L /toolchain/staging_dir/toolchain-mipsel_mips32_gcc-7.4.0_musl"
diff --git a/library/libc/ci/docker/powerpc-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..2298b964
--- /dev/null
+++ b/library/libc/ci/docker/powerpc-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,11 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates \
+        gcc-powerpc-linux-gnu libc6-dev-powerpc-cross \
+        qemu-system-ppc
+
+ENV CARGO_TARGET_POWERPC_UNKNOWN_LINUX_GNU_LINKER=powerpc-linux-gnu-gcc \
+    CARGO_TARGET_POWERPC_UNKNOWN_LINUX_GNU_RUNNER="qemu-ppc -L /usr/powerpc-linux-gnu" \
+    CC=powerpc-linux-gnu-gcc \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..dcafec95
--- /dev/null
+++ b/library/libc/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,11 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates \
+        gcc-powerpc64-linux-gnu libc6-dev-ppc64-cross \
+        qemu-system-ppc
+
+ENV CARGO_TARGET_POWERPC64_UNKNOWN_LINUX_GNU_LINKER=powerpc64-linux-gnu-gcc \
+    CARGO_TARGET_POWERPC64_UNKNOWN_LINUX_GNU_RUNNER="qemu-ppc64 -L /usr/powerpc64-linux-gnu" \
+    CC=powerpc64-linux-gnu-gcc \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..bfcd268a
--- /dev/null
+++ b/library/libc/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,11 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates \
+        gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross \
+        qemu-system-ppc
+
+ENV CARGO_TARGET_POWERPC64LE_UNKNOWN_LINUX_GNU_LINKER=powerpc64le-linux-gnu-gcc \
+    CARGO_TARGET_POWERPC64LE_UNKNOWN_LINUX_GNU_RUNNER="qemu-ppc64le -L /usr/powerpc64le-linux-gnu" \
+    CC=powerpc64le-linux-gnu-gcc \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/riscv64gc-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/riscv64gc-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..2ab35b31
--- /dev/null
+++ b/library/libc/ci/docker/riscv64gc-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,12 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        gcc libc6-dev qemu-user ca-certificates \
+        gcc-riscv64-linux-gnu libc6-dev-riscv64-cross \
+        qemu-system-riscv64 linux-headers-generic
+
+ENV CARGO_TARGET_RISCV64GC_UNKNOWN_LINUX_GNU_LINKER=riscv64-linux-gnu-gcc \
+    CARGO_TARGET_RISCV64GC_UNKNOWN_LINUX_GNU_RUNNER="qemu-riscv64 -L /usr/riscv64-linux-gnu" \
+    CC_riscv64gc_unknown_linux_gnu=riscv64-linux-gnu-gcc \
+    CFLAGS_riscv64gc_unknown_linux_gnu="-mabi=lp64d -fPIC" \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/s390x-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/s390x-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..b26252a0
--- /dev/null
+++ b/library/libc/ci/docker/s390x-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,18 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        curl ca-certificates \
+        gcc libc6-dev \
+        gcc-s390x-linux-gnu libc6-dev-s390x-cross \
+        qemu-system-s390x \
+        cpio
+
+COPY linux-s390x.sh /
+RUN bash /linux-s390x.sh
+
+COPY test-runner-linux /
+
+ENV CARGO_TARGET_S390X_UNKNOWN_LINUX_GNU_LINKER=s390x-linux-gnu-gcc \
+    CARGO_TARGET_S390X_UNKNOWN_LINUX_GNU_RUNNER="/test-runner-linux s390x" \
+    CC_s390x_unknown_linux_gnu=s390x-linux-gnu-gcc \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/sparc64-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/sparc64-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..6dabc8c5
--- /dev/null
+++ b/library/libc/ci/docker/sparc64-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,18 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+        curl ca-certificates \
+        gcc libc6-dev \
+        gcc-sparc64-linux-gnu libc6-dev-sparc64-cross \
+        qemu-system-sparc64 openbios-sparc seabios ipxe-qemu \
+        p7zip-full cpio linux-libc-dev-sparc64-cross
+
+COPY linux-sparc64.sh /
+RUN bash /linux-sparc64.sh
+
+COPY test-runner-linux /
+
+ENV CARGO_TARGET_SPARC64_UNKNOWN_LINUX_GNU_LINKER=sparc64-linux-gnu-gcc \
+    CARGO_TARGET_SPARC64_UNKNOWN_LINUX_GNU_RUNNER="/test-runner-linux sparc64" \
+    CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \
+    PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/switch/Dockerfile b/library/libc/ci/docker/switch/Dockerfile
new file mode 100644
index 00000000..00d3f141
--- /dev/null
+++ b/library/libc/ci/docker/switch/Dockerfile
@@ -0,0 +1,9 @@
+# NOTE: the pacman that we use for this target doesn't support
+# to use it on CI and we should pull it from another Docker image.
+
+FROM huyuumi/libc-switch:latest
+
+RUN apt-get update && apt-get install -y --no-install-recommends \
+    gcc libc6-dev ca-certificates
+
+ENV PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/wasm32-unknown-emscripten/Dockerfile b/library/libc/ci/docker/wasm32-unknown-emscripten/Dockerfile
new file mode 100644
index 00000000..999b28c8
--- /dev/null
+++ b/library/libc/ci/docker/wasm32-unknown-emscripten/Dockerfile
@@ -0,0 +1,36 @@
+FROM ubuntu:20.04
+
+# This is a workaround to avoid the interaction with tzdata.
+ENV DEBIAN_FRONTEND=noninteractive
+ENV TZ=America/New_York
+
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends tzdata
+RUN apt-get install -y --no-install-recommends \
+    ca-certificates \
+    g++ \
+    make \
+    file \
+    curl \
+    gcc \
+    git \
+    libc6-dev \
+    libxml2 \
+    python3 \
+    python3-distutils \
+    cmake \
+    sudo \
+    gdb \
+    xz-utils
+
+RUN ln -s /usr/bin/python3 /usr/bin/python & \
+    ln -s /usr/bin/pip3 /usr/bin/pip
+COPY emscripten.sh /
+RUN bash /emscripten.sh
+
+ENV PATH=$PATH:/rust/bin \
+    CARGO_TARGET_WASM32_UNKNOWN_EMSCRIPTEN_RUNNER=node-wrapper.sh
+
+COPY emscripten-entry.sh /
+COPY docker/wasm32-unknown-emscripten/node-wrapper.sh /usr/local/bin/node-wrapper.sh
+ENTRYPOINT ["/emscripten-entry.sh"]
diff --git a/library/libc/ci/docker/wasm32-unknown-emscripten/node-wrapper.sh b/library/libc/ci/docker/wasm32-unknown-emscripten/node-wrapper.sh
new file mode 100755
index 00000000..3122e2e2
--- /dev/null
+++ b/library/libc/ci/docker/wasm32-unknown-emscripten/node-wrapper.sh
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+set -e
+
+me=$1
+shift
+dir=$(dirname $me)
+file=$(basename $me)
+
+if echo $file | grep -q wasm; then
+  exit 0 # FIXME(rust-lang/cargo#4750)
+fi
+
+cd $dir
+exec node $file "$@"
diff --git a/library/libc/ci/docker/wasm32-wasi/Dockerfile b/library/libc/ci/docker/wasm32-wasi/Dockerfile
new file mode 100644
index 00000000..d5b504a3
--- /dev/null
+++ b/library/libc/ci/docker/wasm32-wasi/Dockerfile
@@ -0,0 +1,39 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && \
+    apt-get install -y --no-install-recommends \
+    ca-certificates \
+    clang \
+    curl \
+    git \
+    libc6-dev \
+    make \
+    xz-utils
+
+# Note that we're using `git reset --hard` to pin to a specific commit for
+# verification for now. The sysroot is currently in somewhat of a state of flux
+# and is expected to have breaking changes, so this is an attempt to mitigate
+# those breaking changes on `libc`'s own CI
+RUN git clone https://github.com/CraneStation/wasi-libc && \
+  cd wasi-libc && \
+  git reset --hard f645f498dfbbbc00a7a97874d33082d3605c3f21
+RUN apt-get install -y --no-install-recommends llvm
+RUN make -C wasi-libc install -j $(nproc) INSTALL_DIR=/wasi-libc
+
+RUN curl -L https://github.com/bytecodealliance/wasmtime/releases/download/dev/wasmtime-dev-x86_64-linux.tar.xz | \
+  tar xJf -
+ENV PATH=$PATH:/wasmtime-dev-x86_64-linux
+COPY docker/wasm32-wasi/clang.sh /wasi-libc/bin/clang
+
+RUN apt-get install -y --no-install-recommends lld
+ENV PATH=$PATH:/usr/lib/llvm-9/bin
+
+# Of note here is our clang wrapper which just executes a normal clang
+# executable with the right sysroot, and then we're sure to turn off the
+# crt-static feature to ensure that the CRT that we're specifying with `clang`
+# is used.
+ENV CARGO_TARGET_WASM32_WASI_RUNNER=wasmtime \
+  CARGO_TARGET_WASM32_WASI_LINKER=/wasi-libc/bin/clang \
+  CC_wasm32_wasi=/wasi-libc/bin/clang \
+  PATH=$PATH:/rust/bin \
+  RUSTFLAGS=-Ctarget-feature=-crt-static
diff --git a/library/libc/ci/docker/wasm32-wasi/clang.sh b/library/libc/ci/docker/wasm32-wasi/clang.sh
new file mode 100755
index 00000000..83f5da5a
--- /dev/null
+++ b/library/libc/ci/docker/wasm32-wasi/clang.sh
@@ -0,0 +1,2 @@
+#!/usr/bin/env sh
+exec /usr/bin/clang --target=wasm32-wasi --sysroot /wasi-libc/sysroot "$@"
diff --git a/library/libc/ci/docker/x86_64-linux-android/Dockerfile b/library/libc/ci/docker/x86_64-linux-android/Dockerfile
new file mode 100644
index 00000000..50849e4c
--- /dev/null
+++ b/library/libc/ci/docker/x86_64-linux-android/Dockerfile
@@ -0,0 +1,27 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && \
+    apt-get install -y --no-install-recommends \
+  ca-certificates \
+  wget \
+  gcc \
+  libc-dev \
+  python3 \
+  python3-distutils \
+  unzip
+
+WORKDIR /android/
+ENV ANDROID_ARCH=x86_64
+COPY android-install-ndk.sh /android/
+RUN sh /android/android-install-ndk.sh $ANDROID_ARCH
+
+# We do not run x86_64-linux-android tests on an android emulator.
+# See ci/android-sysimage.sh for informations about how tests are run.
+COPY android-sysimage.sh /android/
+RUN bash /android/android-sysimage.sh x86_64 x86_64-24_r07.zip
+
+ENV PATH=$PATH:/rust/bin:/android/ndk-$ANDROID_ARCH/bin \
+    CARGO_TARGET_X86_64_LINUX_ANDROID_LINKER=x86_64-linux-android-gcc \
+    CC_x86_64_linux_android=x86_64-linux-android-gcc \
+    CXX_x86_64_linux_android=x86_64-linux-android-g++ \
+    HOME=/tmp
diff --git a/library/libc/ci/docker/x86_64-rumprun-netbsd/Dockerfile b/library/libc/ci/docker/x86_64-rumprun-netbsd/Dockerfile
new file mode 100644
index 00000000..a486d05b
--- /dev/null
+++ b/library/libc/ci/docker/x86_64-rumprun-netbsd/Dockerfile
@@ -0,0 +1,10 @@
+FROM mato/rumprun-toolchain-hw-x86_64
+USER root
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends \
+  qemu
+ENV PATH=$PATH:/rust/bin \
+    CARGO_TARGET_X86_64_RUMPRUN_NETBSD_RUNNER=/tmp/runtest
+
+ADD docker/x86_64-rumprun-netbsd/runtest.rs /tmp/
+ENTRYPOINT ["sh", "-c", "rustc /tmp/runtest.rs -o /tmp/runtest && exec \"$@\"", "--"]
diff --git a/library/libc/ci/docker/x86_64-rumprun-netbsd/runtest.rs b/library/libc/ci/docker/x86_64-rumprun-netbsd/runtest.rs
new file mode 100644
index 00000000..7e96fbfa
--- /dev/null
+++ b/library/libc/ci/docker/x86_64-rumprun-netbsd/runtest.rs
@@ -0,0 +1,55 @@
+use std::env;
+use std::process::{Command, Stdio};
+use std::sync::mpsc;
+use std::thread;
+use std::time::Duration;
+use std::io::{BufRead, BufReader, Read};
+
+fn main() {
+    assert_eq!(env::args().len(), 2);
+
+    let status = Command::new("rumprun-bake")
+        .arg("hw_virtio")
+        .arg("/tmp/libc-test.img")
+        .arg(env::args().nth(1).unwrap())
+        .status()
+        .expect("failed to run rumprun-bake");
+    assert!(status.success());
+
+    let mut child = Command::new("qemu-system-x86_64")
+        .arg("-nographic")
+        .arg("-vga").arg("none")
+        .arg("-m").arg("64")
+        .arg("-kernel").arg("/tmp/libc-test.img")
+        .stdout(Stdio::piped())
+        .stderr(Stdio::piped())
+        .spawn()
+        .expect("failed to spawn qemu");
+
+    let mut stdout = child.stdout.take().unwrap();
+    let mut stderr = child.stderr.take().unwrap();
+    let (tx, rx) = mpsc::channel();
+    let tx2 = tx.clone();
+    let t1 = thread::spawn(move || find_ok(&mut stdout, tx));
+    let t2 = thread::spawn(move || find_ok(&mut stderr, tx2));
+
+    let res = rx.recv_timeout(Duration::new(5, 0));
+    child.kill().unwrap();
+    t1.join().unwrap();
+    t2.join().unwrap();
+
+    if res.is_err() {
+        panic!("didn't find success");
+    }
+}
+
+fn find_ok(input: &mut Read, tx: mpsc::Sender<()>) {
+    for line in BufReader::new(input).lines() {
+        let line = line.unwrap();
+        println!("{}", line);
+        if (line.starts_with("PASSED ") && line.contains(" tests")) ||
+            line.starts_with("test result: ok"){
+            tx.send(()).unwrap();
+        }
+    }
+}
diff --git a/library/libc/ci/docker/x86_64-unknown-linux-gnu/Dockerfile b/library/libc/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
new file mode 100644
index 00000000..5eb1ad08
--- /dev/null
+++ b/library/libc/ci/docker/x86_64-unknown-linux-gnu/Dockerfile
@@ -0,0 +1,9 @@
+FROM ubuntu:20.04
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends \
+  gcc libc6-dev ca-certificates linux-headers-generic
+
+RUN apt search linux-headers
+RUN ls /usr/src
+
+ENV PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/x86_64-unknown-linux-gnux32/Dockerfile b/library/libc/ci/docker/x86_64-unknown-linux-gnux32/Dockerfile
new file mode 100644
index 00000000..6bab1d0c
--- /dev/null
+++ b/library/libc/ci/docker/x86_64-unknown-linux-gnux32/Dockerfile
@@ -0,0 +1,5 @@
+FROM ubuntu:20.04
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends \
+  gcc-multilib libc6-dev ca-certificates
+ENV PATH=$PATH:/rust/bin
diff --git a/library/libc/ci/docker/x86_64-unknown-linux-musl/Dockerfile b/library/libc/ci/docker/x86_64-unknown-linux-musl/Dockerfile
new file mode 100644
index 00000000..4c36e976
--- /dev/null
+++ b/library/libc/ci/docker/x86_64-unknown-linux-musl/Dockerfile
@@ -0,0 +1,10 @@
+FROM ubuntu:20.04
+
+RUN apt-get update
+RUN apt-get install -y --no-install-recommends \
+  gcc make libc6-dev git curl ca-certificates
+
+COPY install-musl.sh /
+RUN sh /install-musl.sh x86_64
+
+ENV PATH=$PATH:/musl-x86_64/bin:/rust/bin
diff --git a/library/libc/ci/docker/x86_64-unknown-redox/Dockerfile b/library/libc/ci/docker/x86_64-unknown-redox/Dockerfile
new file mode 100644
index 00000000..91b0cbab
--- /dev/null
+++ b/library/libc/ci/docker/x86_64-unknown-redox/Dockerfile
@@ -0,0 +1,9 @@
+FROM redoxos/redoxer
+
+RUN mv /root/.redoxer /.redoxer
+
+ENV PATH=$PATH:/.redoxer/toolchain/bin:/rust/bin \
+    AR_x86_64_unknown_redox="x86_64-unknown-redox-ar" \
+    CC_x86_64_unknown_redox="x86_64-unknown-redox-gcc" \
+    CARGO_TARGET_X86_64_UNKNOWN_REDOX_LINKER="x86_64-unknown-redox-gcc" \
+    CARGO_TARGET_X86_64_UNKNOWN_REDOX_RUNNER="redoxer exec --folder ."
diff --git a/library/libc/ci/dox.sh b/library/libc/ci/dox.sh
new file mode 100644
index 00000000..67a0a75e
--- /dev/null
+++ b/library/libc/ci/dox.sh
@@ -0,0 +1,81 @@
+#!/usr/bin/env sh
+
+# Builds documentation for all target triples that we have a registered URL for
+# in liblibc. This scrapes the list of triples to document from `src/lib.rs`
+# which has a bunch of `html_root_url` directives we pick up.
+
+set -ex
+
+TARGET_DOC_DIR=target/doc
+README=README.md
+PLATFORM_SUPPORT=platform-support.md
+
+rm -rf $TARGET_DOC_DIR
+mkdir -p $TARGET_DOC_DIR
+
+if ! rustc --version | grep -E "nightly" ; then
+    echo "Building the documentation requires a nightly Rust toolchain"
+    exit 1
+fi
+
+rustup component add rust-src
+
+# List all targets that do currently build successfully:
+# shellcheck disable=SC1003
+grep '[\d|\w|-]* \\' ci/build.sh > targets
+sed -i.bak 's/ \\//g' targets
+grep '^[_a-zA-Z0-9-]*$' targets | sort > tmp && mv tmp targets
+
+# Create a markdown list of supported platforms in $PLATFORM_SUPPORT
+rm $PLATFORM_SUPPORT || true
+
+printf '### Platform-specific documentation\n' >> $PLATFORM_SUPPORT
+
+while read -r target; do
+    echo "documenting ${target}"
+
+    case "${target}" in
+        *apple*)
+            # FIXME:
+            # We can't build docs of apple targets from Linux yet.
+            continue
+            ;;
+        *)
+            ;;
+    esac
+
+    rustup target add "${target}" || true
+
+    # Enable extra configuration flags:
+    export RUSTDOCFLAGS="--cfg freebsd11"
+
+    # If cargo doc fails, then try with unstable feature:
+    if ! cargo doc --target "${target}" \
+        --no-default-features --features extra_traits ; then
+        cargo doc --target "${target}" \
+        -Z build-std=core,alloc \
+        --no-default-features --features extra_traits
+    fi
+
+    cp -r "target/${target}/doc" "${TARGET_DOC_DIR}/${target}"
+
+    echo "* [${target}](${target}/libc/index.html)" >> $PLATFORM_SUPPORT
+done < targets
+
+# Replace <div class="platform_support"></div> with the contents of $PLATFORM_SUPPORT
+cp $README $TARGET_DOC_DIR
+line=$(grep -n '<div class="platform_docs"></div>' $README | cut -d ":" -f 1)
+
+{ head -n "$((line-1))" $README; cat $PLATFORM_SUPPORT; tail -n "+$((line+1))" $README; } > $TARGET_DOC_DIR/$README
+
+cp $TARGET_DOC_DIR/$README $TARGET_DOC_DIR/index.md
+
+RUSTDOCFLAGS="--enable-index-page --index-page=${TARGET_DOC_DIR}/index.md -Zunstable-options" cargo doc
+
+# Tweak style
+cp ci/rust.css $TARGET_DOC_DIR
+sed -ie "8i <link rel=\"stylesheet\" type=\"text/css\" href=\"normalize.css\">" $TARGET_DOC_DIR/index.html
+sed -ie "9i <link rel=\"stylesheet\" type=\"text/css\" href=\"rust.css\">" $TARGET_DOC_DIR/index.html
+
+# Copy the licenses
+cp LICENSE-* $TARGET_DOC_DIR/
diff --git a/library/libc/ci/emscripten-entry.sh b/library/libc/ci/emscripten-entry.sh
new file mode 100755
index 00000000..ee3261f1
--- /dev/null
+++ b/library/libc/ci/emscripten-entry.sh
@@ -0,0 +1,12 @@
+#!/usr/bin/env bash
+
+set -ex
+
+# shellcheck disable=SC1091
+source /emsdk-portable/emsdk_env.sh &> /dev/null
+
+# emsdk-portable provides a node binary, but we need version 8 to run wasm
+# NOTE: Do not forget to sync Node.js version with `emscripten.sh`!
+export PATH="/node-v12.18.3-linux-x64/bin:$PATH"
+
+exec "$@"
diff --git a/library/libc/ci/emscripten.sh b/library/libc/ci/emscripten.sh
new file mode 100644
index 00000000..ea1083ae
--- /dev/null
+++ b/library/libc/ci/emscripten.sh
@@ -0,0 +1,43 @@
+#!/usr/bin/env bash
+
+set -ex
+
+EMSDK_VERSION=1.39.20
+
+hide_output() {
+  set +x
+  on_err="
+echo ERROR: An error was encountered with the build.
+cat /tmp/build.log
+exit 1
+"
+  trap '$on_err' ERR
+  bash -c "while true; do sleep 30; echo \$(date) - building ...; done" &
+  PING_LOOP_PID=$!
+  "${@}" &> /tmp/build.log
+  trap - ERR
+  kill $PING_LOOP_PID
+  rm -f /tmp/build.log
+  set -x
+}
+
+git clone https://github.com/emscripten-core/emsdk.git /emsdk-portable
+cd /emsdk-portable
+hide_output ./emsdk install "${EMSDK_VERSION}"
+./emsdk activate "${EMSDK_VERSION}"
+
+# Compile and cache libc
+# shellcheck disable=SC1091
+source ./emsdk_env.sh
+echo "main(){}" > a.c
+HOME=/emsdk-portable/ emcc a.c
+rm -f a.*
+
+# Make emsdk usable by any user
+chmod a+rxw -R /emsdk-portable
+
+# node 8 is required to run wasm
+# NOTE: Do not forget to sync Node.js version with `emscripten-entry.sh`!
+cd /
+curl --retry 5 -L https://nodejs.org/dist/v12.18.3/node-v12.18.3-linux-x64.tar.xz | \
+    tar -xJ
diff --git a/library/libc/ci/install-musl.sh b/library/libc/ci/install-musl.sh
new file mode 100644
index 00000000..88cb4f0b
--- /dev/null
+++ b/library/libc/ci/install-musl.sh
@@ -0,0 +1,83 @@
+#!/usr/bin/env sh
+#
+# Install musl and musl-sanitized linux kernel headers
+# to musl-{$1} directory
+
+set -ex
+
+MUSL_VERSION=1.1.24
+MUSL="musl-${MUSL_VERSION}"
+
+# Download, configure, build, and install musl:
+curl --retry 5 https://www.musl-libc.org/releases/${MUSL}.tar.gz | tar xzf -
+
+cd $MUSL
+case ${1} in
+    aarch64)
+        musl_arch=aarch64
+        kernel_arch=arm64
+        CC=aarch64-linux-gnu-gcc \
+          ./configure --prefix="/musl-${musl_arch}" --enable-wrapper=yes
+        make install -j4
+        ;;
+    arm)
+        musl_arch=arm
+        kernel_arch=arm
+        CC=arm-linux-gnueabihf-gcc CFLAGS="-march=armv6 -marm -mfpu=vfp" \
+          ./configure --prefix="/musl-${musl_arch}" --enable-wrapper=yes
+        make install -j4
+        ;;
+    i686)
+        # cross-compile musl for i686 using the system compiler on an x86_64
+        # system.
+        musl_arch=i686
+        kernel_arch=i386
+        # Specifically pass -m32 in CFLAGS and override CC when running
+        # ./configure, since otherwise the script will fail to find a compiler.
+        CC=gcc CFLAGS="-m32" \
+          ./configure --prefix="/musl-${musl_arch}" --disable-shared --target=i686
+        # unset CROSS_COMPILE when running make; otherwise the makefile will
+        # call the non-existent binary 'i686-ar'.
+        make CROSS_COMPILE= install -j4
+        ;;
+    x86_64)
+        musl_arch=x86_64
+        kernel_arch=x86_64
+        ./configure --prefix="/musl-${musl_arch}"
+        make install -j4
+        ;;
+    mips64)
+        musl_arch=mips64
+        kernel_arch=mips
+        CC=mips64-linux-gnuabi64-gcc CFLAGS="-march=mips64r2 -mabi=64" \
+          ./configure --prefix="/musl-${musl_arch}" --enable-wrapper=yes
+        make install -j4
+        ;;
+    mips64el)
+        musl_arch=mips64el
+        kernel_arch=mips
+        CC=mips64el-linux-gnuabi64-gcc CFLAGS="-march=mips64r2 -mabi=64" \
+          ./configure --prefix="/musl-${musl_arch}" --enable-wrapper=yes
+        make install -j4
+        ;;
+    *)
+        echo "Unknown target arch: \"${1}\""
+        exit 1
+        ;;
+esac
+
+
+# shellcheck disable=SC2103
+cd ..
+rm -rf $MUSL
+
+# Download, configure, build, and install musl-sanitized kernel headers:
+KERNEL_HEADER_VER="4.4.2-2"
+curl --retry 5 -L \
+     "https://github.com/sabotage-linux/kernel-headers/archive/v${KERNEL_HEADER_VER}.tar.gz" | \
+    tar xzf -
+(
+    cd kernel-headers-${KERNEL_HEADER_VER}
+    make ARCH="${kernel_arch}" prefix="/musl-${musl_arch}" install -j4
+)
+rm -rf kernel-headers-${KERNEL_HEADER_VER}
diff --git a/library/libc/ci/install-rust.sh b/library/libc/ci/install-rust.sh
new file mode 100644
index 00000000..b06ba8ed
--- /dev/null
+++ b/library/libc/ci/install-rust.sh
@@ -0,0 +1,69 @@
+#!/usr/bin/env sh
+# This is intended to be used in CI only.
+
+set -ex
+
+echo "Setup toolchain"
+toolchain=
+if [ -n "$TOOLCHAIN" ]; then
+  toolchain=$TOOLCHAIN
+else
+  toolchain=nightly
+fi
+if [ "$OS" = "windows" ]; then
+  : "${TARGET?The TARGET environment variable must be set.}"
+  rustup set profile minimal
+  # FIXME: Add `--no-self-update` to avoid CI failure.
+  rustup update --force $toolchain-"$TARGET" --no-self-update
+  rustup default $toolchain-"$TARGET"
+else
+  rustup set profile minimal
+  rustup update --force $toolchain
+  rustup default $toolchain
+fi
+
+if [ -n "$TARGET" ]; then
+  echo "Install target"
+  rustup target add "$TARGET"
+fi
+
+if [ "$OS" = "windows" ]; then
+  if [ "$ARCH_BITS" = "i686" ]; then
+    echo "Install MinGW32"
+    choco install mingw --x86 --force
+  fi
+
+  echo "Find GCC libraries"
+  gcc -print-search-dirs
+  /usr/bin/find "C:\ProgramData\Chocolatey" -name "crt2*"
+  /usr/bin/find "C:\ProgramData\Chocolatey" -name "dllcrt2*"
+  /usr/bin/find "C:\ProgramData\Chocolatey" -name "libmsvcrt*"
+
+  if [ -n "$ARCH_BITS" ]; then
+    echo "Fix MinGW"
+    for i in crt2.o dllcrt2.o libmingwex.a libmsvcrt.a ; do
+      cp -f "/C/ProgramData/Chocolatey/lib/mingw/tools/install/mingw$ARCH_BITS/$ARCH-w64-mingw32/lib/$i" "$(rustc --print sysroot)/lib/rustlib/$TARGET/lib"
+    done
+  fi
+fi
+
+echo "Query rust and cargo versions"
+command -v rustc
+command -v cargo
+command -v rustup
+rustc -Vv
+cargo -V
+rustup -Vv
+rustup show
+
+echo "Generate lockfile"
+N=5
+n=0
+until [ $n -ge $N ]
+do
+  if cargo generate-lockfile; then
+    break
+  fi
+  n=$((n+1))
+  sleep 1
+done
diff --git a/library/libc/ci/ios/deploy_and_run_on_ios_simulator.rs b/library/libc/ci/ios/deploy_and_run_on_ios_simulator.rs
new file mode 100644
index 00000000..aa1034fc
--- /dev/null
+++ b/library/libc/ci/ios/deploy_and_run_on_ios_simulator.rs
@@ -0,0 +1,165 @@
+// This is a script to deploy and execute a binary on an iOS simulator.
+// The primary use of this is to be able to run unit tests on the simulator and
+// retrieve the results.
+//
+// To do this through Cargo instead, use Dinghy
+// (https://github.com/snipsco/dinghy): cargo dinghy install, then cargo dinghy
+// test.
+
+use std::env;
+use std::fs::{self, File};
+use std::io::Write;
+use std::path::Path;
+use std::process;
+use std::process::Command;
+
+macro_rules! t {
+    ($e:expr) => (match $e {
+        Ok(e) => e,
+        Err(e) => panic!("{} failed with: {}", stringify!($e), e),
+    })
+}
+
+// Step one: Wrap as an app
+fn package_as_simulator_app(crate_name: &str, test_binary_path: &Path) {
+    println!("Packaging simulator app");
+    drop(fs::remove_dir_all("ios_simulator_app"));
+    t!(fs::create_dir("ios_simulator_app"));
+    t!(fs::copy(test_binary_path,
+                Path::new("ios_simulator_app").join(crate_name)));
+
+    let mut f = t!(File::create("ios_simulator_app/Info.plist"));
+    t!(f.write_all(format!(r#"
+        <?xml version="1.0" encoding="UTF-8"?>
+        <!DOCTYPE plist PUBLIC
+                "-//Apple//DTD PLIST 1.0//EN"
+                "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+        <plist version="1.0">
+            <dict>
+                <key>CFBundleExecutable</key>
+                <string>{}</string>
+                <key>CFBundleIdentifier</key>
+                <string>com.rust.unittests</string>
+            </dict>
+        </plist>
+    "#, crate_name).as_bytes()));
+}
+
+// Step two: Start the iOS simulator
+fn start_simulator() {
+    println!("Looking for iOS simulator");
+    let output = t!(Command::new("xcrun").arg("simctl").arg("list").output());
+    assert!(output.status.success());
+    let mut simulator_exists = false;
+    let mut simulator_booted = false;
+    let mut found_rust_sim = false;
+    let stdout = t!(String::from_utf8(output.stdout));
+    for line in stdout.lines() {
+        if line.contains("rust_ios") {
+            if found_rust_sim {
+                panic!("Duplicate rust_ios simulators found. Please \
+                        double-check xcrun simctl list.");
+            }
+            simulator_exists = true;
+            simulator_booted = line.contains("(Booted)");
+            found_rust_sim = true;
+        }
+    }
+
+    if simulator_exists == false {
+        println!("Creating iOS simulator");
+        Command::new("xcrun")
+                .arg("simctl")
+                .arg("create")
+                .arg("rust_ios")
+                .arg("com.apple.CoreSimulator.SimDeviceType.iPhone-SE")
+                .arg("com.apple.CoreSimulator.SimRuntime.iOS-10-2")
+                .check_status();
+    } else if simulator_booted == true {
+        println!("Shutting down already-booted simulator");
+        Command::new("xcrun")
+                .arg("simctl")
+                .arg("shutdown")
+                .arg("rust_ios")
+                .check_status();
+    }
+
+    println!("Starting iOS simulator");
+    // We can't uninstall the app (if present) as that will hang if the
+    // simulator isn't completely booted; just erase the simulator instead.
+    Command::new("xcrun").arg("simctl").arg("erase").arg("rust_ios").check_status();
+    Command::new("xcrun").arg("simctl").arg("boot").arg("rust_ios").check_status();
+}
+
+// Step three: Install the app
+fn install_app_to_simulator() {
+    println!("Installing app to simulator");
+    Command::new("xcrun")
+            .arg("simctl")
+            .arg("install")
+            .arg("booted")
+            .arg("ios_simulator_app/")
+            .check_status();
+}
+
+// Step four: Run the app
+fn run_app_on_simulator() {
+    println!("Running app");
+    let output = t!(Command::new("xcrun")
+                    .arg("simctl")
+                    .arg("launch")
+                    .arg("--console")
+                    .arg("booted")
+                    .arg("com.rust.unittests")
+                    .output());
+
+    println!("status: {}", output.status);
+    println!("stdout --\n{}\n", String::from_utf8_lossy(&output.stdout));
+    println!("stderr --\n{}\n", String::from_utf8_lossy(&output.stderr));
+
+    let stdout = String::from_utf8_lossy(&output.stdout);
+    let passed = stdout.lines()
+                       .find(|l|
+                             (l.contains("PASSED") &&
+                              l.contains("tests")) ||
+                             l.contains("test result: ok")
+                        )
+                       .unwrap_or(false);
+
+    println!("Shutting down simulator");
+    Command::new("xcrun")
+        .arg("simctl")
+        .arg("shutdown")
+        .arg("rust_ios")
+        .check_status();
+    if !passed {
+        panic!("tests didn't pass");
+    }
+}
+
+trait CheckStatus {
+    fn check_status(&mut self);
+}
+
+impl CheckStatus for Command {
+    fn check_status(&mut self) {
+        println!("\trunning: {:?}", self);
+        assert!(t!(self.status()).success());
+    }
+}
+
+fn main() {
+    let args: Vec<String> = env::args().collect();
+    if args.len() != 2 {
+        println!("Usage: {} <executable>", args[0]);
+        process::exit(-1);
+    }
+
+    let test_binary_path = Path::new(&args[1]);
+    let crate_name = test_binary_path.file_name().unwrap();
+
+    package_as_simulator_app(crate_name.to_str().unwrap(), test_binary_path);
+    start_simulator();
+    install_app_to_simulator();
+    run_app_on_simulator();
+}
diff --git a/library/libc/ci/linux-s390x.sh b/library/libc/ci/linux-s390x.sh
new file mode 100644
index 00000000..762ee731
--- /dev/null
+++ b/library/libc/ci/linux-s390x.sh
@@ -0,0 +1,20 @@
+#!/usr/bin/env sh
+
+set -ex
+
+mkdir -m 777 /qemu
+cd /qemu
+
+curl --retry 5 -LO https://github.com/qemu/qemu/raw/master/pc-bios/s390-ccw.img
+curl --retry 5 -LO http://ftp.debian.org/debian/dists/testing/main/installer-s390x/20200314/images/generic/kernel.debian
+curl --retry 5 -LO http://ftp.debian.org/debian/dists/testing/main/installer-s390x/20200314/images/generic/initrd.debian
+
+mv kernel.debian kernel
+mv initrd.debian initrd.gz
+
+mkdir init
+cd init
+gunzip -c ../initrd.gz | cpio -id
+rm ../initrd.gz
+cp /usr/s390x-linux-gnu/lib/libgcc_s.so.1 usr/lib/
+chmod a+w .
diff --git a/library/libc/ci/linux-sparc64.sh b/library/libc/ci/linux-sparc64.sh
new file mode 100644
index 00000000..57aa3b5f
--- /dev/null
+++ b/library/libc/ci/linux-sparc64.sh
@@ -0,0 +1,19 @@
+#!/usr/bin/env sh
+
+set -ex
+
+mkdir -m 777 /qemu
+cd /qemu
+
+curl --retry 5 -LO https://cdimage.debian.org/cdimage/ports/snapshots/2020-10-13/debian-10.0.0-sparc64-NETINST-1.iso
+7z e debian-10.0.0-sparc64-NETINST-1.iso install/initrd.gz
+7z e debian-10.0.0-sparc64-NETINST-1.iso install/vmlinux
+mv vmlinux kernel
+rm debian-10.0.0-sparc64-NETINST-1.iso
+
+mkdir init
+cd init
+gunzip -c ../initrd.gz | cpio -id
+rm ../initrd.gz
+cp /usr/sparc64-linux-gnu/lib/libgcc_s.so.1 usr/lib/
+chmod a+w .
diff --git a/library/libc/ci/run-docker.sh b/library/libc/ci/run-docker.sh
new file mode 100755
index 00000000..f1fa6656
--- /dev/null
+++ b/library/libc/ci/run-docker.sh
@@ -0,0 +1,97 @@
+#!/usr/bin/env sh
+
+# Small script to run tests for a target (or all targets) inside all the
+# respective docker images.
+
+set -ex
+
+# Default to assuming the CARGO_HOME is one directory up (to account for a `bin`
+# subdir) from where the `cargo` binary in `$PATH` lives.
+DEFAULT_CARGO_HOME="$(dirname "$(dirname "$(command -v cargo)")")"
+# If the CARGO_HOME env var is already set, use that. If it isn't set use the
+# default.
+CARGO_HOME="${CARGO_HOME:-$DEFAULT_CARGO_HOME}"
+
+echo "${HOME}"
+pwd
+
+# Avoid "no space left on device" failure.
+if [ "${1}" = "aarch64-linux-android" ] ; then
+  docker system prune -af
+  docker system df
+fi
+
+run() {
+    echo "Building docker container for target ${1}"
+
+    # use -f so we can use ci/ as build context
+    docker build -t libc -f "ci/docker/${1}/Dockerfile" ci/
+    mkdir -p target
+    if [ -w /dev/kvm ]; then
+        kvm="--volume /dev/kvm:/dev/kvm"
+    else
+        kvm=""
+    fi
+
+    docker run \
+      --rm \
+      --user "$(id -u)":"$(id -g)" \
+      --env LIBC_CI \
+      --env CARGO_HOME=/cargo \
+      --env CARGO_TARGET_DIR=/checkout/target \
+      --volume "$CARGO_HOME":/cargo \
+      --volume "$(rustc --print sysroot)":/rust:ro \
+      --volume "$(pwd)":/checkout:ro \
+      --volume "$(pwd)"/target:/checkout/target \
+      $kvm \
+      --init \
+      --workdir /checkout \
+      libc \
+      sh -c "HOME=/tmp PATH=\$PATH:/rust/bin exec ci/run.sh ${1}"
+}
+
+build_switch() {
+    echo "Building docker container for target switch"
+
+    # use -f so we can use ci/ as build context
+    docker build -t libc -f "ci/docker/switch/Dockerfile" ci/
+    mkdir -p target
+    if [ -w /dev/kvm ]; then
+        kvm="--volume /dev/kvm:/dev/kvm"
+    else
+        kvm=""
+    fi
+
+    cp "$(command -v rustup)" "$(rustc --print sysroot)/bin"
+
+    docker run \
+      --rm \
+      --user "$(id -u)":"$(id -g)" \
+      --env LIBC_CI \
+      --env CARGO_HOME=/cargo \
+      --env CARGO_TARGET_DIR=/checkout/target \
+      --volume "$CARGO_HOME":/cargo \
+      --volume "$(rustc --print sysroot)":/rust:ro \
+      --volume "$(pwd)":/checkout:ro \
+      --volume "$(pwd)"/target:/checkout/target \
+      --volume ~/.rustup:/.rustup:Z \
+      $kvm \
+      --init \
+      --workdir /checkout \
+      libc \
+      sh -c "HOME=/tmp RUSTUP_HOME=/tmp PATH=\$PATH:/rust/bin rustup default nightly \
+        && rustup component add rust-src --target ci/switch.json \
+        && cargo build -Z build-std=core,alloc --target ci/switch.json"
+}
+
+if [ -z "${1}" ]; then
+  for d in ci/docker/*; do
+    run "${d}"
+  done
+else
+  if [ "${1}" != "switch" ]; then
+    run "${1}"
+  else
+    build_switch
+  fi
+fi
diff --git a/library/libc/ci/run.sh b/library/libc/ci/run.sh
new file mode 100755
index 00000000..6fb059d2
--- /dev/null
+++ b/library/libc/ci/run.sh
@@ -0,0 +1,126 @@
+#!/usr/bin/env sh
+
+# Builds and runs tests for a particular target passed as an argument to this
+# script.
+
+set -ex
+
+MIRRORS_URL="https://ci-mirrors.rust-lang.org/libc"
+
+TARGET="${1}"
+
+# If we're going to run tests inside of a qemu image, then we don't need any of
+# the scripts below. Instead, download the image, prepare a filesystem which has
+# the current state of this repository, and then run the image.
+#
+# It's assume that all images, when run with two disks, will run the `run.sh`
+# script from the second which we place inside.
+if [ "$QEMU" != "" ]; then
+  tmpdir=/tmp/qemu-img-creation
+  mkdir -p "${tmpdir}"
+
+  if [ -z "${QEMU#*.gz}" ]; then
+    # image is .gz : download and uncompress it
+    qemufile="$(echo "${QEMU%.gz}" | sed 's/\//__/g')"
+    if [ ! -f "${tmpdir}/${qemufile}" ]; then
+      curl --retry 5 "${MIRRORS_URL}/${QEMU}" | \
+          gunzip -d > "${tmpdir}/${qemufile}"
+    fi
+  elif [ -z "${QEMU#*.xz}" ]; then
+    # image is .xz : download and uncompress it
+    qemufile="$(echo "${QEMU%.xz}" | sed 's/\//__/g')"
+    if [ ! -f "${tmpdir}/${qemufile}" ]; then
+      curl --retry 5 "${MIRRORS_URL}/${QEMU}" | \
+          unxz > "${tmpdir}/${qemufile}"
+    fi
+  else
+    # plain qcow2 image: just download it
+    qemufile="$(echo "${QEMU}" | sed 's/\//__/g')"
+    if [ ! -f "${tmpdir}/${qemufile}" ]; then
+      curl --retry 5 "${MIRRORS_URL}/${QEMU}" \
+        > "${tmpdir}/${qemufile}"
+    fi
+  fi
+
+  # Create a mount a fresh new filesystem image that we'll later pass to QEMU.
+  # This will have a `run.sh` script will which use the artifacts inside to run
+  # on the host.
+  rm -f "${tmpdir}/libc-test.img"
+  mkdir "${tmpdir}/mount"
+
+  # Do the standard rigamarole of cross-compiling an executable and then the
+  # script to run just executes the binary.
+  cargo build \
+    --manifest-path libc-test/Cargo.toml \
+    --target "${TARGET}" \
+    --test main
+  rm "${CARGO_TARGET_DIR}/${TARGET}"/debug/main-*.d
+  cp "${CARGO_TARGET_DIR}/${TARGET}"/debug/main-* "${tmpdir}"/mount/libc-test
+  # shellcheck disable=SC2016
+  echo 'exec $1/libc-test' > "${tmpdir}/mount/run.sh"
+
+  du -sh "${tmpdir}/mount"
+  genext2fs \
+      --root "${tmpdir}/mount" \
+      --size-in-blocks 100000 \
+      "${tmpdir}/libc-test.img"
+
+  # Pass -snapshot to prevent tampering with the disk images, this helps when
+  # running this script in development. The two drives are then passed next,
+  # first is the OS and second is the one we just made. Next the network is
+  # configured to work (I'm not entirely sure how), and then finally we turn off
+  # graphics and redirect the serial console output to out.log.
+  qemu-system-x86_64 \
+    -m 1024 \
+    -snapshot \
+    -drive if=virtio,file="${tmpdir}/${qemufile}" \
+    -drive if=virtio,file="${tmpdir}/libc-test.img" \
+    -net nic,model=virtio \
+    -net user \
+    -nographic \
+    -vga none 2>&1 | tee "${CARGO_TARGET_DIR}/out.log"
+  exec egrep "^(PASSED)|(test result: ok)" "${CARGO_TARGET_DIR}/out.log"
+fi
+
+# FIXME: x86_64-unknown-linux-gnux32 fails to compile without --release
+# See https://github.com/rust-lang/rust/issues/59220
+opt=
+if [ "$TARGET" = "x86_64-unknown-linux-gnux32" ]; then
+  opt="--release"
+fi
+
+if [ "$TARGET" = "s390x-unknown-linux-gnu" ]; then
+  # FIXME: s390x-unknown-linux-gnu often fails to test due to timeout,
+  # so we retry this N times.
+  N=5
+  n=0
+  passed=0
+  until [ $n -ge $N ]
+  do
+    if [ "$passed" = "0" ]; then
+      if cargo test --no-default-features --manifest-path libc-test/Cargo.toml --target "${TARGET}" ; then
+        passed=$((passed+1))
+        continue
+      fi
+    elif [ "$passed" = "1" ]; then
+      if cargo test $opt --manifest-path libc-test/Cargo.toml --target "${TARGET}" ; then
+        passed=$((passed+1))
+        continue
+      fi
+    elif [ "$passed" = "2" ]; then
+      if cargo test $opt --features extra_traits --manifest-path libc-test/Cargo.toml --target "${TARGET}"; then
+        break
+      fi
+    fi
+    n=$((n+1))
+    sleep 1
+  done
+else
+  cargo test $opt --no-default-features --manifest-path libc-test/Cargo.toml \
+    --target "${TARGET}"
+
+  cargo test $opt --manifest-path libc-test/Cargo.toml --target "${TARGET}"
+
+  cargo test $opt --features extra_traits --manifest-path libc-test/Cargo.toml \
+    --target "${TARGET}"
+fi
diff --git a/library/libc/ci/runtest-android.rs b/library/libc/ci/runtest-android.rs
new file mode 100644
index 00000000..b8030c41
--- /dev/null
+++ b/library/libc/ci/runtest-android.rs
@@ -0,0 +1,47 @@
+use std::env;
+use std::process::Command;
+use std::path::{Path, PathBuf};
+
+fn main() {
+    let args = env::args_os()
+        .skip(1)
+        .filter(|arg| arg != "--quiet")
+        .collect::<Vec<_>>();
+    assert_eq!(args.len(), 1);
+    let test = PathBuf::from(&args[0]);
+    let dst = Path::new("/data/local/tmp").join(test.file_name().unwrap());
+
+    let status = Command::new("adb")
+        .arg("wait-for-device")
+        .status()
+        .expect("failed to run: adb wait-for-device");
+    assert!(status.success());
+
+    let status = Command::new("adb")
+        .arg("push")
+        .arg(&test)
+        .arg(&dst)
+        .status()
+        .expect("failed to run: adb pushr");
+    assert!(status.success());
+
+    let output = Command::new("adb")
+        .arg("shell")
+        .arg(&dst)
+        .output()
+        .expect("failed to run: adb shell");
+    assert!(status.success());
+
+    println!("status: {}\nstdout ---\n{}\nstderr ---\n{}",
+             output.status,
+             String::from_utf8_lossy(&output.stdout),
+             String::from_utf8_lossy(&output.stderr));
+
+    let stdout = String::from_utf8_lossy(&output.stdout);
+    stdout.lines().find(|l|
+        (l.starts_with("PASSED ") && l.contains(" tests")) ||
+        l.starts_with("test result: ok")
+    ).unwrap_or_else(|| {
+        panic!("failed to find successful test run");
+    });
+}
diff --git a/library/libc/ci/rust.css b/library/libc/ci/rust.css
new file mode 100644
index 00000000..d33e36e6
--- /dev/null
+++ b/library/libc/ci/rust.css
@@ -0,0 +1,451 @@
+/* This is taken from https://github.com/rust-lang/rust/blob/master/src/doc/rust.css */
+
+@font-face {
+  font-family: 'Fira Sans';
+  font-style: normal;
+  font-weight: 400;
+  src: local('Fira Sans'), url("FiraSans-Regular.woff") format('woff');
+}
+@font-face {
+  font-family: 'Fira Sans';
+  font-style: normal;
+  font-weight: 500;
+  src: local('Fira Sans Medium'), url("FiraSans-Medium.woff") format('woff');
+}
+@font-face {
+  font-family: 'Source Serif Pro';
+  font-style: normal;
+  font-weight: 400;
+  src: local('Source Serif Pro'), url("SourceSerifPro-Regular.ttf.woff") format('woff');
+}
+@font-face {
+  font-family: 'Source Serif Pro';
+  font-style: italic;
+  font-weight: 400;
+  src: url("SourceSerifPro-It.ttf.woff") format('woff');
+}
+@font-face {
+  font-family: 'Source Serif Pro';
+  font-style: normal;
+  font-weight: 700;
+  src: local('Source Serif Pro Bold'), url("SourceSerifPro-Bold.ttf.woff") format('woff');
+}
+@font-face {
+  font-family: 'Source Code Pro';
+  font-style: normal;
+  font-weight: 400;
+  /* Avoid using locally installed font because bad versions are in circulation:
+   * see https://github.com/rust-lang/rust/issues/24355 */
+  src: url("SourceCodePro-Regular.woff") format('woff');
+}
+
+*:not(body) {
+  -webkit-box-sizing: border-box;
+  -moz-box-sizing: border-box;
+  box-sizing: border-box;
+}
+
+/* General structure */
+
+body {
+  background-color: white;
+  margin: 0 auto;
+  padding: 0 15px;
+  font-family: "Source Serif Pro", Georgia, Times, "Times New Roman", serif;
+  font-size: 18px;
+  color: #333;
+  line-height: 1.428571429;
+
+  -webkit-font-feature-settings: "kern", "liga";
+  -moz-font-feature-settings: "kern", "liga";
+  font-feature-settings: "kern", "liga";
+}
+@media (min-width: 768px) {
+  body {
+    max-width: 750px;
+  }
+}
+
+h1, h2, h3, h4, h5, h6, nav, #versioninfo {
+  font-family: "Fira Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
+}
+h1, h2, h3, h4, h5, h6 {
+  color: black;
+  font-weight: 400;
+  line-height: 1.1;
+}
+h1, h2, h3 {
+  margin-top: 20px;
+  margin-bottom: 15px;
+}
+h1 {
+  margin-bottom: 20px;
+}
+h4, h5, h6 {
+  margin-top: 12px;
+  margin-bottom: 10px;
+  padding: 5px 10px;
+}
+h5, h6 {
+  text-decoration: underline;
+}
+
+h1 {
+  font-size: 28px;
+  font-weight: 500;
+  padding: .1em .4em;
+  border-bottom: 2px solid #ddd;
+}
+h1.title {
+  line-height: 1.5em;
+}
+h2 {
+  font-size: 26px;
+  padding: .2em .5em;
+  border-bottom: 1px solid #ddd;
+}
+h3 {
+  font-size: 24px;
+  padding: .2em .7em;
+  border-bottom: 1px solid #DDE8FC;
+}
+h4 {
+  font-size: 22px;
+}
+h5 {
+  font-size: 20px;
+}
+h6 {
+  font-size: 18px;
+}
+@media (min-width: 992px) {
+  h1 {
+    font-size: 36px;
+  }
+  h2 {
+    font-size: 30px;
+  }
+  h3 {
+    font-size: 26px;
+  }
+}
+
+nav {
+  column-count: 2;
+  -moz-column-count: 2;
+  -webkit-column-count: 2;
+  font-size: 15px;
+  margin: 0 0 1em 0;
+}
+p {
+  margin: 0 0 1em 0;
+}
+
+strong {
+  font-weight: bold;
+}
+
+em {
+  font-style: italic;
+}
+
+footer {
+  border-top: 1px solid #ddd;
+  font-size: 14px;
+  font-style: italic;
+  padding-top: 5px;
+  margin-top: 3em;
+  margin-bottom: 1em;
+}
+
+/* Links layout */
+
+a {
+  text-decoration: none;
+  color: #428BCA;
+  background: transparent;
+}
+a:hover, a:focus {
+  color: #2A6496;
+  text-decoration: underline;
+}
+a:focus {
+  outline: thin dotted #333;
+  outline: 5px auto -webkit-focus-ring-color;
+  outline-offset: -2px;
+}
+a:hover, a:active {
+  outline: 0;
+}
+
+h1 a:link, h1 a:visited, h2 a:link, h2 a:visited,
+h3 a:link, h3 a:visited, h4 a:link, h4 a:visited,
+h5 a:link, h5 a:visited {color: black;}
+h1 a:hover, h2 a:hover, h3 a:hover, h4 a:hover,
+h5 a:hover {text-decoration: none;}
+
+/* Code */
+
+pre, code {
+  font-family: "Source Code Pro", Menlo, Monaco, Consolas, "DejaVu Sans Mono", monospace;
+  word-wrap: break-word;
+}
+pre {
+  border-left: 2px solid #eee;
+  white-space: pre-wrap;
+  padding: 14px;
+  padding-right: 0;
+  margin: 20px 0;
+  font-size: 15px;
+  word-break: break-all;
+}
+code {
+  padding: 0 2px;
+  color: #8D1A38;
+}
+pre code {
+  padding: 0;
+  font-size: inherit;
+  color: inherit;
+}
+
+a > code {
+  color: #428BCA;
+}
+
+.section-header > a > code {
+  color: #8D1A38;
+}
+
+/* Code highlighting */
+pre.rust .kw { color: #8959A8; }
+pre.rust .kw-2, pre.rust .prelude-ty { color: #4271AE; }
+pre.rust .number, pre.rust .string { color: #718C00; }
+pre.rust .self, pre.rust .bool-val, pre.rust .prelude-val,
+pre.rust .attribute, pre.rust .attribute .ident { color: #C82829; }
+pre.rust .comment { color: #8E908C; }
+pre.rust .doccomment { color: #4D4D4C; }
+pre.rust .macro, pre.rust .macro-nonterminal { color: #3E999F; }
+pre.rust .lifetime { color: #B76514; }
+
+/* The rest */
+
+#versioninfo {
+  text-align: center;
+  margin: 0.5em;
+  font-size: 1.1em;
+}
+@media (min-width: 992px) {
+  #versioninfo {
+    font-size: 0.8em;
+    position: fixed;
+    bottom: 0px;
+    right: 0px;
+  }
+  .white-sticker {
+    background-color: #fff;
+    margin: 2px;
+    padding: 0 2px;
+    border-radius: .2em;
+  }
+}
+#versioninfo a.hash {
+  color: gray;
+  font-size: 80%;
+}
+
+blockquote {
+  color: #000;
+  margin: 20px 0;
+  padding: 15px 20px;
+  background-color: #f2f7f9;
+  border-top: .1em solid #e5eef2;
+  border-bottom: .1em solid #e5eef2;
+}
+blockquote p {
+  font-size: 17px;
+  font-weight: 300;
+  line-height: 1.4;
+}
+blockquote p:last-child {
+  margin-bottom: 0;
+}
+
+ul, ol {
+  padding-left: 25px;
+}
+ul ul, ol ul, ul ol, ol ol {
+  margin-bottom: 0;
+}
+dl {
+  margin-bottom: 20px;
+}
+dd {
+  margin-left: 0;
+}
+
+nav ul {
+  list-style-type: none;
+  margin: 0;
+  padding-left: 0px;
+}
+
+/* Only display one level of hierarchy in the TOC */
+nav ul ul {
+  display: none;
+}
+
+sub,
+sup {
+  font-size: 75%;
+  line-height: 0;
+  position: relative;
+}
+
+hr {
+  margin-top: 20px;
+  margin-bottom: 20px;
+  border: 0;
+  border-top: 1px solid #eeeeee;
+}
+
+table {
+  border-collapse: collapse;
+  border-spacing: 0;
+  overflow-x: auto;
+  display: block;
+}
+
+table tr.odd {
+  background: #eee;
+}
+
+table td,
+table th {
+  border: 1px solid #ddd;
+  padding: 5px;
+}
+
+/* Code snippets */
+
+pre.rust { position: relative; }
+a.test-arrow {
+  background-color: rgba(78, 139, 202, 0.2);
+  display: inline-block;
+  position: absolute;
+  color: #f5f5f5;
+  padding: 5px 10px 5px 10px;
+  border-radius: 5px;
+  font-size: 130%;
+  top: 5px;
+  right: 5px;
+}
+a.test-arrow:hover{
+  background-color: #4e8bca;
+  text-decoration: none;
+}
+
+.unstable-feature {
+  border: 2px solid red;
+  padding: 5px;
+}
+
+@media (min-width: 1170px) {
+  pre {
+    font-size: 15px;
+  }
+}
+
+@media print {
+  * {
+    text-shadow: none !important;
+    color: #000 !important;
+    background: transparent !important;
+    box-shadow: none !important;
+  }
+  a, a:visited {
+    text-decoration: underline;
+  }
+  p a[href]:after {
+    content: " (" attr(href) ")";
+  }
+  footer a[href]:after {
+    content: "";
+  }
+  a[href^="javascript:"]:after, a[href^="#"]:after {
+    content: "";
+  }
+  pre, blockquote {
+    border: 1px solid #999;
+    page-break-inside: avoid;
+  }
+  @page {
+    margin: 2cm .5cm;
+  }
+  h1:not(.title), h2, h3 {
+    border-bottom: 0px none;
+  }
+  p, h2, h3 {
+    orphans: 3;
+    widows: 3;
+  }
+  h2, h3 {
+    page-break-after: avoid;
+  }
+  table {
+    border-collapse: collapse !important;
+  }
+  table td, table th {
+    background-color: #fff !important;
+  }
+}
+
+#keyword-table-marker + table thead { display: none; }
+#keyword-table-marker + table td { border: none; }
+#keyword-table-marker + table {
+  margin-left: 2em;
+  margin-bottom: 1em;
+}
+
+.error-described {
+  position: relative;
+}
+
+.information {
+  position: absolute;
+  left: -25px;
+  margin-top: 7px;
+  z-index: 1;
+}
+
+.tooltip {
+  position: relative;
+  display: inline-block;
+  cursor: pointer;
+}
+
+.tooltip .tooltiptext {
+  width: 120px;
+  display: none;
+  text-align: center;
+  padding: 5px 3px;
+  border-radius: 6px;
+  margin-left: 5px;
+  top: -5px;
+  left: 105%;
+  z-index: 1;
+}
+
+.tooltip:hover .tooltiptext {
+  display: inline;
+}
+
+.tooltip .tooltiptext::after {
+  content: " ";
+  position: absolute;
+  top: 50%;
+  left: 13px;
+  margin-top: -5px;
+  border-width: 5px;
+  border-style: solid;
+}
diff --git a/library/libc/ci/semver.sh b/library/libc/ci/semver.sh
new file mode 100644
index 00000000..6d6dfd17
--- /dev/null
+++ b/library/libc/ci/semver.sh
@@ -0,0 +1,75 @@
+#!/usr/bin/env sh
+
+# Checks that libc does not contain breaking changes for the following targets.
+
+set -ex
+
+OS=${1}
+
+echo "Testing Semver on ${OS}"
+
+if ! rustc --version | grep -E "nightly" ; then
+    echo "Building semverver requires a nightly Rust toolchain"
+    exit 1
+fi
+
+rustup component add rustc-dev llvm-tools-preview
+
+# Should update the nightly version in bors CI config if we touch this.
+cargo install --locked --git https://github.com/rust-lang/rust-semverver --rev 71c340ff867d2f79613cfe02c6714f1d2ef00bc4
+
+TARGETS=
+case "${OS}" in
+    *linux*)
+        TARGETS="\
+aarch64-fuchsia \
+aarch64-linux-android \
+aarch64-unknown-linux-gnu \
+aarch64-unknown-linux-musl \
+armv7-linux-androideabi \
+armv7-unknown-linux-gnueabihf \
+i586-unknown-linux-gnu \
+i586-unknown-linux-musl \
+i686-linux-android \
+i686-unknown-freebsd \
+i686-unknown-linux-gnu \
+i686-unknown-linux-musl \
+i686-pc-windows-gnu \
+x86_64-unknown-freebsd \
+x86_64-unknown-linux-gnu \
+x86_64-unknown-linux-musl \
+x86_64-unknown-netbsd \
+x86_64-sun-solaris \
+x86_64-fuchsia \
+x86_64-pc-windows-gnu \
+x86_64-unknown-linux-gnux32 \
+x86_64-unknown-redox \
+x86_64-fortanix-unknown-sgx \
+wasm32-unknown-unknown \
+"
+    ;;
+    *macos*)
+        TARGETS="\
+aarch64-apple-ios \
+x86_64-apple-darwin \
+x86_64-apple-ios \
+"
+    ;;
+esac
+
+for TARGET in $TARGETS; do
+    # FIXME: rustup often fails to download some artifacts due to network
+    # issues, so we retry this N times.
+    N=5
+    n=0
+    until [ $n -ge $N ]
+    do
+        if rustup target add "${TARGET}" ; then
+            break
+        fi
+        n=$((n+1))
+        sleep 1
+    done
+
+    cargo semver --api-guidelines --target="${TARGET}"
+done
diff --git a/library/libc/ci/style.rs b/library/libc/ci/style.rs
new file mode 100644
index 00000000..b0b6d124
--- /dev/null
+++ b/library/libc/ci/style.rs
@@ -0,0 +1,213 @@
+//! Simple script to verify the coding style of this library
+//!
+//! ## How to run
+//!
+//! The first argument to this script is the directory to run on, so running
+//! this script should be as simple as:
+//!
+//! ```notrust
+//! rustc ci/style.rs
+//! ./style src
+//! ```
+//!
+//! ## Guidelines
+//!
+//! The current style is:
+//!
+//! * No trailing whitespace
+//! * No tabs
+//! * 80-character lines
+//! * Specific module layout:
+//!     1. use directives
+//!     2. typedefs
+//!     3. structs
+//!     4. constants
+//!     5. f! { ... } functions
+//!     6. extern functions
+//!     7. modules + pub use
+//!
+//! Things not verified:
+//!
+//! * alignment
+//! * 4-space tabs
+//! * leading colons on paths
+
+use std::env;
+use std::fs;
+use std::io::prelude::*;
+use std::path::Path;
+
+macro_rules! t {
+    ($e:expr) => (match $e {
+        Ok(e) => e,
+        Err(e) => panic!("{} failed with {}", stringify!($e), e),
+    })
+}
+
+fn main() {
+    let arg = env::args().skip(1).next().unwrap_or(".".to_string());
+
+    let mut errors = Errors { errs: false };
+    walk(Path::new(&arg), &mut errors);
+
+    if errors.errs {
+        panic!("found some lint errors");
+    } else {
+        println!("good style!");
+    }
+}
+
+fn walk(path: &Path, err: &mut Errors) {
+    for entry in t!(path.read_dir()).map(|e| t!(e)) {
+        let path = entry.path();
+        if t!(entry.file_type()).is_dir() {
+            walk(&path, err);
+            continue
+        }
+
+        let name = entry.file_name().into_string().unwrap();
+        match &name[..] {
+            n if !n.ends_with(".rs") => continue,
+
+            "dox.rs" |
+            "lib.rs" |
+            "ctypes.rs" |
+            "libc.rs" |
+            "macros.rs" => continue,
+
+            _ => {}
+        }
+
+        let mut contents = String::new();
+        t!(t!(fs::File::open(&path)).read_to_string(&mut contents));
+
+        check_style(&contents, &path, err);
+    }
+}
+
+struct Errors {
+    errs: bool,
+}
+
+#[derive(Clone, Copy, PartialEq)]
+enum State {
+    Start,
+    Imports,
+    Typedefs,
+    Structs,
+    Constants,
+    FunctionDefinitions,
+    Functions,
+    Modules,
+}
+
+fn check_style(file: &str, path: &Path, err: &mut Errors) {
+    let mut state = State::Start;
+    let mut s_macros = 0;
+    let mut f_macros = 0;
+    let mut prev_blank = false;
+
+    for (i, line) in file.lines().enumerate() {
+        if line == "" {
+            if prev_blank {
+                err.error(path, i, "double blank line");
+            }
+            prev_blank = true;
+        } else {
+            prev_blank = false;
+        }
+        if line != line.trim_end() {
+            err.error(path, i, "trailing whitespace");
+        }
+        if line.contains("\t") {
+            err.error(path, i, "tab character");
+        }
+        if line.len() > 80 {
+            err.error(path, i, "line longer than 80 chars");
+        }
+        // This doesn't work any more due to rustfmt changes
+        /*if line.contains("#[cfg(") && !line.contains(" if ")
+            && !(line.contains("target_endian") ||
+                 line.contains("target_arch"))
+        {
+            if state != State::Structs {
+                err.error(path, i, "use cfg_if! and submodules \
+                                    instead of #[cfg]");
+            }
+        }*/
+        if line.contains("#[derive(") && (line.contains("Copy") || line.contains("Clone")) {
+            err.error(path, i, "impl ::Copy and ::Clone manually");
+        }
+
+        let orig_line = line;
+        let line = line.trim_start();
+        let is_pub = line.starts_with("pub ");
+        let line = if is_pub {&line[4..]} else {line};
+
+        let line_state = if line.starts_with("use ") {
+            if line.contains("c_void") {
+                continue;
+            }
+            if is_pub {
+                State::Modules
+            } else {
+                State::Imports
+            }
+        } else if line.starts_with("const ") {
+            State::Constants
+        } else if line.starts_with("type ") {
+            State::Typedefs
+        } else if line.starts_with("s! {") {
+            s_macros += 1;
+            State::Structs
+        } else if line.starts_with("f! {") {
+            f_macros += 1;
+            State::FunctionDefinitions
+        } else if line.starts_with("extern ") && !orig_line.starts_with(" ") {
+            State::Functions
+        } else if line.starts_with("mod ") {
+            State::Modules
+        } else {
+            continue
+        };
+
+        if state as usize > line_state as usize {
+            err.error(path, i, &format!("{} found after {} when \
+                                         it belongs before",
+                                        line_state.desc(), state.desc()));
+        }
+
+        if f_macros == 2 {
+            f_macros += 1;
+            err.error(path, i, "multiple f! macros in one module");
+        }
+        if s_macros == 2 {
+            s_macros += 1;
+            err.error(path, i, "multiple s! macros in one module");
+        }
+
+        state = line_state;
+    }
+}
+
+impl State {
+    fn desc(&self) -> &str {
+        match *self {
+            State::Start => "start",
+            State::Imports => "import",
+            State::Typedefs => "typedef",
+            State::Structs => "struct",
+            State::Constants => "constant",
+            State::FunctionDefinitions => "function definition",
+            State::Functions => "extern function",
+            State::Modules => "module",
+        }
+    }
+}
+
+impl Errors {
+    fn error(&mut self, path: &Path, line: usize, msg: &str) {
+        self.errs = true;
+        println!("{}:{} - {}", path.display(), line + 1, msg);
+    }
+}
diff --git a/library/libc/ci/style.sh b/library/libc/ci/style.sh
new file mode 100644
index 00000000..923e675b
--- /dev/null
+++ b/library/libc/ci/style.sh
@@ -0,0 +1,20 @@
+#!/usr/bin/env sh
+
+set -ex
+
+rustc ci/style.rs && ./style src
+
+rustup toolchain install nightly -c rustfmt --allow-downgrade
+rustup override set nightly
+command -v rustfmt
+rustfmt -V
+cargo fmt --all -- --check
+
+if shellcheck --version ; then
+    # GHA's shellcheck is too old (0.4.6) and cannot handle SC2153 correctly.
+    shellcheck -e SC2103 -e SC2153 ci/*.sh
+else
+    echo "shellcheck not found"
+    exit 1
+fi
+
diff --git a/library/libc/ci/switch.json b/library/libc/ci/switch.json
new file mode 100644
index 00000000..bc189487
--- /dev/null
+++ b/library/libc/ci/switch.json
@@ -0,0 +1,37 @@
+{
+  "family": "unix",
+  "env": "newlib",
+  "target-env": "newlib",
+  "target-family": "unix",
+  "target-c-int-width": "32",
+  "target-endian": "little",
+  "target-pointer-width": "64",
+  "os": "horizon",
+  "arch": "aarch64",
+  "panic-strategy": "unwind",
+  "abi-blacklist": [
+      "stdcall",
+      "fastcall",
+      "vectorcall",
+      "thiscall",
+      "win64",
+      "sysv64"
+  ],
+  "dynamic-linking" : false,
+  "features": "+a53,+strict-align",
+  "data-layout": "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128",
+  "executables": true,
+  "position-independent-executables" : true,
+  "linker-flavor": "gcc",
+  "llvm-target": "aarch64-unknown-none",
+  "has-elf-tls" : false,
+  "linker-is-gnu" : true,
+  "disable-redzone" : true,
+  "relocation-model" : "pic",
+  "max-atomic-width": 128,
+  "exe-suffix": ".elf",
+  "staticlib-suffix" : ".a",
+  "trap-unreachable" : true,
+  "emit-debug-gdb-scripts" : true,
+  "requires-uwtable" : true
+}
\ No newline at end of file
diff --git a/library/libc/ci/sysinfo_guard.patch b/library/libc/ci/sysinfo_guard.patch
new file mode 100644
index 00000000..69fb795c
--- /dev/null
+++ b/library/libc/ci/sysinfo_guard.patch
@@ -0,0 +1,10 @@
+@@ -2,7 +2,9 @@
+ #ifndef _LINUX_KERNEL_H
+ #define _LINUX_KERNEL_H
+ 
++#ifdef __GLIBC__
+ #include <linux/sysinfo.h>
++#endif
+ 
+ /*
+  * 'kernel.h' contains some often-used function prototypes etc
diff --git a/library/libc/ci/test-runner-linux b/library/libc/ci/test-runner-linux
new file mode 100755
index 00000000..cad31ec4
--- /dev/null
+++ b/library/libc/ci/test-runner-linux
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+set -e
+
+arch=$1
+prog=$2
+
+cd /qemu/init
+echo "#!/bin/sh\n/prog --color=never" > run_prog.sh
+chmod +x run_prog.sh
+cp -f $2 prog
+find . | cpio --create --format='newc' --quiet | gzip > ../initrd.gz
+cd ..
+
+timeout 30s qemu-system-$arch \
+  -m 1024 \
+  -nographic \
+  -kernel kernel \
+  -initrd initrd.gz \
+  -append init=/run_prog.sh > output || true
+
+# remove kernel messages
+tr -d '\r' < output | egrep -v '^\['
+
+egrep "(PASSED)|(test result: ok)" output > /dev/null
diff --git a/library/libc/libc-test/Cargo.toml b/library/libc/libc-test/Cargo.toml
new file mode 100644
index 00000000..75ae6046
--- /dev/null
+++ b/library/libc/libc-test/Cargo.toml
@@ -0,0 +1,60 @@
+[package]
+name = "libc-test"
+version = "0.1.0"
+authors = ["Alex Crichton <alex@alexcrichton.com>"]
+build = "build.rs"
+
+[dependencies.libc]
+path = ".."
+default-features = false
+
+[build-dependencies]
+cc = "1.0.61"
+# FIXME: Use fork ctest until the maintainer gets back.
+ctest2 = "0.3"
+
+[features]
+default = [ "std" ]
+std = [ "libc/std" ]
+align = [ "libc/align" ]
+extra_traits = [ "libc/extra_traits" ]
+
+[[test]]
+name = "main"
+path = "test/main.rs"
+harness = false
+
+[[test]]
+name = "linux-fcntl"
+path = "test/linux_fcntl.rs"
+harness = false
+
+[[test]]
+name = "linux-ipv6"
+path = "test/linux_ipv6.rs"
+harness = false
+
+[[test]]
+name = "linux-elf"
+path = "test/linux_elf.rs"
+harness = false
+
+[[test]]
+name = "linux-strerror_r"
+path = "test/linux_strerror_r.rs"
+harness = false
+
+[[test]]
+name = "linux-termios"
+path = "test/linux_termios.rs"
+harness = false
+
+[[test]]
+name = "cmsg"
+path = "test/cmsg.rs"
+harness = true
+
+[[test]]
+name = "errqueue"
+path = "test/errqueue.rs"
+harness = true
diff --git a/library/libc/libc-test/build.rs b/library/libc/libc-test/build.rs
new file mode 100755
index 00000000..098dde21
--- /dev/null
+++ b/library/libc/libc-test/build.rs
@@ -0,0 +1,2948 @@
+#![deny(warnings)]
+
+extern crate cc;
+extern crate ctest2 as ctest;
+
+use std::env;
+
+fn do_cc() {
+    let target = env::var("TARGET").unwrap();
+    if cfg!(unix) {
+        let exclude = ["redox", "wasi"];
+        if !exclude.iter().any(|x| target.contains(x)) {
+            let mut cmsg = cc::Build::new();
+
+            cmsg.file("src/cmsg.c");
+
+            if target.contains("solaris") || target.contains("illumos") {
+                cmsg.define("_XOPEN_SOURCE", "700");
+            }
+            cmsg.compile("cmsg");
+        }
+    }
+    if target.contains("android") || target.contains("linux") {
+        cc::Build::new().file("src/errqueue.c").compile("errqueue");
+    }
+}
+
+fn do_ctest() {
+    match &env::var("TARGET").unwrap() {
+        t if t.contains("android") => return test_android(t),
+        t if t.contains("apple") => return test_apple(t),
+        t if t.contains("dragonfly") => return test_dragonflybsd(t),
+        t if t.contains("emscripten") => return test_emscripten(t),
+        t if t.contains("freebsd") => return test_freebsd(t),
+        t if t.contains("linux") => return test_linux(t),
+        t if t.contains("netbsd") => return test_netbsd(t),
+        t if t.contains("openbsd") => return test_openbsd(t),
+        t if t.contains("redox") => return test_redox(t),
+        t if t.contains("solaris") => return test_solarish(t),
+        t if t.contains("illumos") => return test_solarish(t),
+        t if t.contains("wasi") => return test_wasi(t),
+        t if t.contains("windows") => return test_windows(t),
+        t if t.contains("vxworks") => return test_vxworks(t),
+        t => panic!("unknown target {}", t),
+    }
+}
+
+fn ctest_cfg() -> ctest::TestGenerator {
+    let mut cfg = ctest::TestGenerator::new();
+    let libc_cfgs = [
+        "libc_priv_mod_use",
+        "libc_union",
+        "libc_const_size_of",
+        "libc_align",
+        "libc_core_cvoid",
+        "libc_packedN",
+        "libc_thread_local",
+    ];
+    for f in &libc_cfgs {
+        cfg.cfg(f, None);
+    }
+    cfg
+}
+
+fn main() {
+    do_cc();
+    do_ctest();
+}
+
+macro_rules! headers {
+    ($cfg:ident: [$m:expr]: $header:literal) => {
+        if $m {
+            $cfg.header($header);
+        }
+    };
+    ($cfg:ident: $header:literal) => {
+        $cfg.header($header);
+    };
+    ($($cfg:ident: $([$c:expr]:)* $header:literal,)*) => {
+        $(headers!($cfg: $([$c]:)* $header);)*
+    };
+    ($cfg:ident: $( $([$c:expr]:)* $header:literal,)*) => {
+        headers!($($cfg: $([$c]:)* $header,)*);
+    };
+    ($cfg:ident: $( $([$c:expr]:)* $header:literal),*) => {
+        headers!($($cfg: $([$c]:)* $header,)*);
+    };
+}
+
+fn test_apple(target: &str) {
+    assert!(target.contains("apple"));
+    let x86_64 = target.contains("x86_64");
+    let i686 = target.contains("i686");
+
+    let mut cfg = ctest_cfg();
+    cfg.flag("-Wno-deprecated-declarations");
+    cfg.define("__APPLE_USE_RFC_3542", None);
+
+    headers! { cfg:
+        "aio.h",
+        "ctype.h",
+        "dirent.h",
+        "dlfcn.h",
+        "errno.h",
+        "execinfo.h",
+        "fcntl.h",
+        "glob.h",
+        "grp.h",
+        "ifaddrs.h",
+        "langinfo.h",
+        "limits.h",
+        "locale.h",
+        "mach-o/dyld.h",
+        "mach/mach_time.h",
+        "malloc/malloc.h",
+        "net/bpf.h",
+        "net/if.h",
+        "net/if_arp.h",
+        "net/if_dl.h",
+        "net/if_utun.h",
+        "net/route.h",
+        "net/route.h",
+        "netdb.h",
+        "netinet/if_ether.h",
+        "netinet/in.h",
+        "netinet/in.h",
+        "netinet/ip.h",
+        "netinet/tcp.h",
+        "netinet/udp.h",
+        "poll.h",
+        "pthread.h",
+        "pwd.h",
+        "regex.h",
+        "resolv.h",
+        "sched.h",
+        "semaphore.h",
+        "signal.h",
+        "spawn.h",
+        "stddef.h",
+        "stdint.h",
+        "stdio.h",
+        "stdlib.h",
+        "string.h",
+        "sys/event.h",
+        "sys/file.h",
+        "sys/ioctl.h",
+        "sys/ipc.h",
+        "sys/kern_control.h",
+        "sys/mman.h",
+        "sys/mount.h",
+        "sys/proc_info.h",
+        "sys/ptrace.h",
+        "sys/quota.h",
+        "sys/resource.h",
+        "sys/sem.h",
+        "sys/shm.h",
+        "sys/socket.h",
+        "sys/stat.h",
+        "sys/statvfs.h",
+        "sys/sys_domain.h",
+        "sys/sysctl.h",
+        "sys/time.h",
+        "sys/times.h",
+        "sys/timex.h",
+        "sys/types.h",
+        "sys/uio.h",
+        "sys/un.h",
+        "sys/utsname.h",
+        "sys/wait.h",
+        "sys/xattr.h",
+        "syslog.h",
+        "termios.h",
+        "time.h",
+        "unistd.h",
+        "util.h",
+        "utime.h",
+        "utmpx.h",
+        "wchar.h",
+        "xlocale.h",
+        [x86_64]: "crt_externs.h",
+    }
+
+    cfg.skip_struct(move |ty| {
+        match ty {
+            // FIXME: actually a union
+            "sigval" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            // These OSX constants are removed in Sierra.
+            // https://developer.apple.com/library/content/releasenotes/General/APIDiffsMacOS10_12/Swift/Darwin.html
+            "KERN_KDENABLE_BG_TRACE" | "KERN_KDDISABLE_BG_TRACE" => true,
+            // FIXME: the value has been changed since Catalina (0xffff0000 -> 0x3fff0000).
+            "SF_SETTABLE" => true,
+            // FIXME: the value has been changed since Catalina (VM_FLAGS_RESILIENT_MEDIA is also contained now).
+            "VM_FLAGS_USER_REMAP" => true,
+            // FIXME: the values have been changed since Big Sur
+            "HW_TARGET" | "HW_PRODUCT" | "HW_MAXID" => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        // skip those that are manually verified
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" => true,
+
+            // close calls the close_nocancel system call
+            "close" => true,
+
+            // these calls require macOS 11.0 or higher
+            "preadv" | "pwritev" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_field(move |struct_, field| {
+        match (struct_, field) {
+            // FIXME: the array size has been changed since macOS 10.15 ([8] -> [7]).
+            ("statfs", "f_reserved") => true,
+            ("__darwin_arm_neon_state64", "__v") => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_field_type(move |struct_, field| {
+        match (struct_, field) {
+            // FIXME: actually a union
+            ("sigevent", "sigev_value") => true,
+            _ => false,
+        }
+    });
+
+    cfg.volatile_item(|i| {
+        use ctest::VolatileItemKind::*;
+        match i {
+            StructField(ref n, ref f) if n == "aiocb" && f == "aio_buf" => {
+                true
+            }
+            _ => false,
+        }
+    });
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "DIR" | "Dl_info" => ty.to_string(),
+
+            // OSX calls this something else
+            "sighandler_t" => "sig_t".to_string(),
+
+            t if is_union => format!("union {}", t),
+            t if t.ends_with("_t") => t.to_string(),
+            t if is_struct => format!("struct {}", t),
+            t => t.to_string(),
+        }
+    });
+
+    cfg.field_name(move |struct_, field| {
+        match field {
+            s if s.ends_with("_nsec") && struct_.starts_with("stat") => {
+                s.replace("e_nsec", "espec.tv_nsec")
+            }
+            // FIXME: sigaction actually contains a union with two variants:
+            // a sa_sigaction with type: (*)(int, struct __siginfo *, void *)
+            // a sa_handler with type sig_t
+            "sa_sigaction" if struct_ == "sigaction" => {
+                "sa_handler".to_string()
+            }
+            s => s.to_string(),
+        }
+    });
+
+    cfg.skip_roundtrip(move |s| match s {
+        // FIXME: this type has the wrong ABI
+        "max_align_t" if i686 => true,
+        _ => false,
+    });
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_openbsd(target: &str) {
+    assert!(target.contains("openbsd"));
+
+    let mut cfg = ctest_cfg();
+    cfg.flag("-Wno-deprecated-declarations");
+
+    headers! { cfg:
+        "elf.h",
+        "errno.h",
+        "fcntl.h",
+        "limits.h",
+        "link.h",
+        "locale.h",
+        "stddef.h",
+        "stdint.h",
+        "stdio.h",
+        "stdlib.h",
+        "sys/stat.h",
+        "sys/types.h",
+        "time.h",
+        "wchar.h",
+        "ctype.h",
+        "dirent.h",
+        "sys/socket.h",
+        "net/if.h",
+        "net/route.h",
+        "net/if_arp.h",
+        "netdb.h",
+        "netinet/in.h",
+        "netinet/ip.h",
+        "netinet/tcp.h",
+        "netinet/udp.h",
+        "net/bpf.h",
+        "regex.h",
+        "resolv.h",
+        "pthread.h",
+        "dlfcn.h",
+        "signal.h",
+        "string.h",
+        "sys/file.h",
+        "sys/ioctl.h",
+        "sys/mman.h",
+        "sys/resource.h",
+        "sys/socket.h",
+        "sys/time.h",
+        "sys/un.h",
+        "sys/wait.h",
+        "unistd.h",
+        "utime.h",
+        "pwd.h",
+        "grp.h",
+        "sys/utsname.h",
+        "sys/ptrace.h",
+        "sys/mount.h",
+        "sys/uio.h",
+        "sched.h",
+        "termios.h",
+        "poll.h",
+        "syslog.h",
+        "semaphore.h",
+        "sys/statvfs.h",
+        "sys/times.h",
+        "glob.h",
+        "ifaddrs.h",
+        "langinfo.h",
+        "sys/sysctl.h",
+        "utmp.h",
+        "sys/event.h",
+        "net/if_dl.h",
+        "util.h",
+        "ufs/ufs/quota.h",
+        "pthread_np.h",
+        "sys/syscall.h",
+        "sys/shm.h",
+    }
+
+    cfg.skip_struct(move |ty| {
+        match ty {
+            // FIXME: actually a union
+            "sigval" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            // Removed in OpenBSD 6.0
+            "KERN_USERMOUNT" | "KERN_ARND" => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" | "execvpe" => true,
+
+            // Removed in OpenBSD 6.5
+            // https://marc.info/?l=openbsd-cvs&m=154723400730318
+            "mincore" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "DIR" | "Dl_info" | "Elf32_Phdr" | "Elf64_Phdr" => {
+                ty.to_string()
+            }
+
+            // OSX calls this something else
+            "sighandler_t" => "sig_t".to_string(),
+
+            t if is_union => format!("union {}", t),
+            t if t.ends_with("_t") => t.to_string(),
+            t if is_struct => format!("struct {}", t),
+            t => t.to_string(),
+        }
+    });
+
+    cfg.field_name(move |struct_, field| match field {
+        "st_birthtime" if struct_.starts_with("stat") => {
+            "__st_birthtime".to_string()
+        }
+        "st_birthtime_nsec" if struct_.starts_with("stat") => {
+            "__st_birthtimensec".to_string()
+        }
+        s if s.ends_with("_nsec") && struct_.starts_with("stat") => {
+            s.replace("e_nsec", ".tv_nsec")
+        }
+        "sa_sigaction" if struct_ == "sigaction" => "sa_handler".to_string(),
+        s => s.to_string(),
+    });
+
+    cfg.skip_field_type(move |struct_, field| {
+        // type siginfo_t.si_addr changed from OpenBSD 6.0 to 6.1
+        struct_ == "siginfo_t" && field == "si_addr"
+    });
+
+    cfg.skip_field(|struct_, field| {
+        match (struct_, field) {
+            // conflicting with `p_type` macro from <resolve.h>.
+            ("Elf32_Phdr", "p_type") => true,
+            ("Elf64_Phdr", "p_type") => true,
+            _ => false,
+        }
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_windows(target: &str) {
+    assert!(target.contains("windows"));
+    let gnu = target.contains("gnu");
+
+    let mut cfg = ctest_cfg();
+    cfg.define("_WIN32_WINNT", Some("0x8000"));
+
+    headers! { cfg:
+        "direct.h",
+        "errno.h",
+        "fcntl.h",
+        "io.h",
+        "limits.h",
+        "locale.h",
+        "process.h",
+        "signal.h",
+        "stddef.h",
+        "stdint.h",
+        "stdio.h",
+        "stdlib.h",
+        "sys/stat.h",
+        "sys/types.h",
+        "sys/utime.h",
+        "time.h",
+        "wchar.h",
+        [gnu]: "ws2tcpip.h",
+        [!gnu]: "Winsock2.h",
+    }
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "DIR" | "Dl_info" => ty.to_string(),
+
+            // FIXME: these don't exist:
+            "time64_t" => "__time64_t".to_string(),
+            "ssize_t" => "SSIZE_T".to_string(),
+
+            "sighandler_t" if !gnu => "_crt_signal_t".to_string(),
+            "sighandler_t" if gnu => "__p_sig_fn_t".to_string(),
+
+            t if is_union => format!("union {}", t),
+            t if t.ends_with("_t") => t.to_string(),
+
+            // Windows uppercase structs don't have `struct` in front:
+            t if is_struct => {
+                if ty.clone().chars().next().unwrap().is_uppercase() {
+                    t.to_string()
+                } else if t == "stat" {
+                    "struct __stat64".to_string()
+                } else if t == "utimbuf" {
+                    "struct __utimbuf64".to_string()
+                } else {
+                    // put `struct` in front of all structs:
+                    format!("struct {}", t)
+                }
+            }
+            t => t.to_string(),
+        }
+    });
+
+    cfg.fn_cname(move |name, cname| cname.unwrap_or(name).to_string());
+
+    cfg.skip_type(move |name| match name {
+        "SSIZE_T" if !gnu => true,
+        "ssize_t" if !gnu => true,
+        _ => false,
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            // FIXME: API error:
+            // SIG_ERR type is "void (*)(int)", not "int"
+            "SIG_ERR" => true,
+            _ => false,
+        }
+    });
+
+    // FIXME: All functions point to the wrong addresses?
+    cfg.skip_fn_ptrcheck(|_| true);
+
+    cfg.skip_signededness(move |c| {
+        match c {
+            // windows-isms
+            n if n.starts_with("P") => true,
+            n if n.starts_with("H") => true,
+            n if n.starts_with("LP") => true,
+            "sighandler_t" if gnu => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" | "execvpe" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_redox(target: &str) {
+    assert!(target.contains("redox"));
+
+    let mut cfg = ctest_cfg();
+    cfg.flag("-Wno-deprecated-declarations");
+
+    headers! {
+        cfg:
+        "ctype.h",
+        "dirent.h",
+        "dlfcn.h",
+        "errno.h",
+        "fcntl.h",
+        "grp.h",
+        "limits.h",
+        "locale.h",
+        "netdb.h",
+        "netinet/in.h",
+        "netinet/ip.h",
+        "netinet/tcp.h",
+        "poll.h",
+        "pwd.h",
+        "semaphore.h",
+        "string.h",
+        "strings.h",
+        "sys/file.h",
+        "sys/ioctl.h",
+        "sys/mman.h",
+        "sys/ptrace.h",
+        "sys/resource.h",
+        "sys/socket.h",
+        "sys/stat.h",
+        "sys/statvfs.h",
+        "sys/time.h",
+        "sys/types.h",
+        "sys/uio.h",
+        "sys/un.h",
+        "sys/utsname.h",
+        "sys/wait.h",
+        "termios.h",
+        "time.h",
+        "unistd.h",
+        "utime.h",
+        "wchar.h",
+    }
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_solarish(target: &str) {
+    let is_solaris = target.contains("solaris");
+    let is_illumos = target.contains("illumos");
+    assert!(is_solaris || is_illumos);
+
+    // ctest generates arguments supported only by clang, so make sure to run with CC=clang.
+    // While debugging, "CFLAGS=-ferror-limit=<large num>" is useful to get more error output.
+    let mut cfg = ctest_cfg();
+    cfg.flag("-Wno-deprecated-declarations");
+
+    cfg.define("_XOPEN_SOURCE", Some("700"));
+    cfg.define("__EXTENSIONS__", None);
+    cfg.define("_LCONV_C99", None);
+
+    headers! {
+        cfg:
+        "ctype.h",
+        "dirent.h",
+        "dlfcn.h",
+        "door.h",
+        "errno.h",
+        "execinfo.h",
+        "fcntl.h",
+        "glob.h",
+        "grp.h",
+        "ifaddrs.h",
+        "langinfo.h",
+        "limits.h",
+        "locale.h",
+        "mqueue.h",
+        "net/if.h",
+        "net/if_arp.h",
+        "net/route.h",
+        "netdb.h",
+        "netinet/in.h",
+        "netinet/ip.h",
+        "netinet/tcp.h",
+        "netinet/udp.h",
+        "poll.h",
+        "port.h",
+        "pthread.h",
+        "pwd.h",
+        "resolv.h",
+        "sched.h",
+        "semaphore.h",
+        "signal.h",
+        "stddef.h",
+        "stdint.h",
+        "stdio.h",
+        "stdlib.h",
+        "string.h",
+        "sys/epoll.h",
+        "sys/eventfd.h",
+        "sys/file.h",
+        "sys/filio.h",
+        "sys/ioctl.h",
+        "sys/loadavg.h",
+        "sys/mman.h",
+        "sys/mount.h",
+        "sys/resource.h",
+        "sys/socket.h",
+        "sys/stat.h",
+        "sys/statvfs.h",
+        "sys/stropts.h",
+        "sys/shm.h",
+        "sys/time.h",
+        "sys/times.h",
+        "sys/timex.h",
+        "sys/types.h",
+        "sys/uio.h",
+        "sys/un.h",
+        "sys/utsname.h",
+        "sys/wait.h",
+        "syslog.h",
+        "termios.h",
+        "time.h",
+        "ucontext.h",
+        "unistd.h",
+        "utime.h",
+        "utmpx.h",
+        "wchar.h",
+    }
+
+    cfg.skip_type(move |ty| {
+        match ty {
+            // sighandler_t is not present here
+            "sighandler_t" => true,
+            _ => false,
+        }
+    });
+
+    cfg.type_name(move |ty, is_struct, is_union| match ty {
+        "FILE" => "__FILE".to_string(),
+        "DIR" | "Dl_info" => ty.to_string(),
+        t if t.ends_with("_t") => t.to_string(),
+        t if is_struct => format!("struct {}", t),
+        t if is_union => format!("union {}", t),
+        t => t.to_string(),
+    });
+
+    cfg.field_name(move |struct_, field| {
+        match struct_ {
+            // rust struct uses raw u64, rather than union
+            "epoll_event" if field == "u64" => "data.u64".to_string(),
+            // rust struct was committed with typo for Solaris
+            "door_arg_t" if field == "dec_num" => "desc_num".to_string(),
+            "stat" if field.ends_with("_nsec") => {
+                // expose stat.Xtim.tv_nsec fields
+                field.trim_end_matches("e_nsec").to_string() + ".tv_nsec"
+            }
+            _ => field.to_string(),
+        }
+    });
+
+    cfg.skip_const(move |name| match name {
+        "DT_FIFO" | "DT_CHR" | "DT_DIR" | "DT_BLK" | "DT_REG" | "DT_LNK"
+        | "DT_SOCK" | "USRQUOTA" | "GRPQUOTA" | "PRIO_MIN" | "PRIO_MAX" => {
+            true
+        }
+
+        // skip sighandler_t assignments
+        "SIG_DFL" | "SIG_ERR" | "SIG_IGN" => true,
+
+        "DT_UNKNOWN" => true,
+
+        "_UTX_LINESIZE" | "_UTX_USERSIZE" | "_UTX_PADSIZE" | "_UTX_IDSIZE"
+        | "_UTX_HOSTSIZE" => true,
+
+        "EADI" | "EXTPROC" | "IPC_SEAT" => true,
+
+        // This evaluates to a sysconf() call rather than a constant
+        "PTHREAD_STACK_MIN" => true,
+
+        // EPOLLEXCLUSIVE is a relatively recent addition to the epoll interface and may not be
+        // defined on older systems.  It is, however, safe to use on systems which do not
+        // explicitly support it. (A no-op is an acceptable implementation of EPOLLEXCLUSIVE.)
+        "EPOLLEXCLUSIVE" => true,
+
+        _ => false,
+    });
+
+    cfg.skip_struct(move |ty| {
+        // the union handling is a mess
+        if ty.contains("door_desc_t_") {
+            return true;
+        }
+        match ty {
+            // union, not a struct
+            "sigval" => true,
+            // a bunch of solaris-only fields
+            "utmpx" if is_illumos => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_field(move |s, field| {
+        match s {
+            // C99 sizing on this is tough
+            "dirent" if field == "d_name" => true,
+            // the union/macro makes this rough
+            "sigaction" if field == "sa_sigaction" => true,
+            // Missing in illumos
+            "sigevent" if field == "ss_sp" => true,
+            // Avoid sigval union issues
+            "sigevent" if field == "sigev_value" => true,
+            // const issues
+            "sigevent" if field == "sigev_notify_attributes" => true,
+
+            // Avoid const and union issues
+            "door_arg" if field == "desc_ptr" => true,
+            "door_desc_t" if field == "d_data" => true,
+            "door_arg_t" if field.ends_with("_ptr") => true,
+            "door_arg_t" if field.ends_with("rbuf") => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        // skip those that are manually verified
+        match name {
+            // const-ness only added recently
+            "dladdr" => true,
+
+            // Definition of those functions as changed since unified headers
+            // from NDK r14b These changes imply some API breaking changes but
+            // are still ABI compatible. We can wait for the next major release
+            // to be compliant with the new API.
+            //
+            // FIXME: unskip these for next major release
+            "setpriority" | "personality" => true,
+
+            // signal is defined in terms of sighandler_t, so ignore
+            "signal" => true,
+
+            // Currently missing
+            "cfmakeraw" | "cfsetspeed" => true,
+
+            // const-ness issues
+            "execv" | "execve" | "execvp" | "settimeofday" | "sethostname" => {
+                true
+            }
+
+            // Solaris-different
+            "getpwent_r" | "getgrent_r" | "updwtmpx" if is_illumos => true,
+            "madvise" | "mprotect" if is_illumos => true,
+            "door_call" | "door_return" | "door_create" if is_illumos => true,
+
+            // These functions may return int or void depending on the exact
+            // configuration of the compilation environment, but the return
+            // value is not useful (always 0) so we can ignore it:
+            "setservent" | "endservent" if is_illumos => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_netbsd(target: &str) {
+    assert!(target.contains("netbsd"));
+    let rumprun = target.contains("rumprun");
+    let mut cfg = ctest_cfg();
+
+    cfg.flag("-Wno-deprecated-declarations");
+    cfg.define("_NETBSD_SOURCE", Some("1"));
+
+    headers! {
+        cfg:
+        "elf.h",
+        "errno.h",
+        "fcntl.h",
+        "limits.h",
+        "link.h",
+        "locale.h",
+        "stddef.h",
+        "stdint.h",
+        "stdio.h",
+        "stdlib.h",
+        "sys/stat.h",
+        "sys/types.h",
+        "time.h",
+        "wchar.h",
+        "aio.h",
+        "ctype.h",
+        "dirent.h",
+        "dlfcn.h",
+        "glob.h",
+        "grp.h",
+        "ifaddrs.h",
+        "langinfo.h",
+        "net/if.h",
+        "net/if_arp.h",
+        "net/if_dl.h",
+        "net/route.h",
+        "netdb.h",
+        "netinet/in.h",
+        "netinet/ip.h",
+        "netinet/tcp.h",
+        "netinet/udp.h",
+        "poll.h",
+        "pthread.h",
+        "pwd.h",
+        "regex.h",
+        "resolv.h",
+        "sched.h",
+        "semaphore.h",
+        "signal.h",
+        "string.h",
+        "sys/extattr.h",
+        "sys/file.h",
+        "sys/ioctl.h",
+        "sys/ioctl_compat.h",
+        "sys/mman.h",
+        "sys/mount.h",
+        "sys/ptrace.h",
+        "sys/resource.h",
+        "sys/socket.h",
+        "sys/statvfs.h",
+        "sys/sysctl.h",
+        "sys/time.h",
+        "sys/times.h",
+        "sys/timex.h",
+        "sys/uio.h",
+        "sys/un.h",
+        "sys/utsname.h",
+        "sys/wait.h",
+        "syslog.h",
+        "termios.h",
+        "ufs/ufs/quota.h",
+        "ufs/ufs/quota1.h",
+        "unistd.h",
+        "util.h",
+        "utime.h",
+        "mqueue.h",
+        "netinet/dccp.h",
+        "sys/event.h",
+        "sys/quota.h",
+        "sys/shm.h",
+    }
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "fd_set" | "Dl_info" | "DIR" | "Elf32_Phdr"
+            | "Elf64_Phdr" | "Elf32_Shdr" | "Elf64_Shdr" | "Elf32_Sym"
+            | "Elf64_Sym" | "Elf32_Ehdr" | "Elf64_Ehdr" | "Elf32_Chdr"
+            | "Elf64_Chdr" => ty.to_string(),
+
+            // OSX calls this something else
+            "sighandler_t" => "sig_t".to_string(),
+
+            t if is_union => format!("union {}", t),
+
+            t if t.ends_with("_t") => t.to_string(),
+
+            // put `struct` in front of all structs:.
+            t if is_struct => format!("struct {}", t),
+
+            t => t.to_string(),
+        }
+    });
+
+    cfg.field_name(move |struct_, field| {
+        match field {
+            // Our stat *_nsec fields normally don't actually exist but are part
+            // of a timeval struct
+            s if s.ends_with("_nsec") && struct_.starts_with("stat") => {
+                s.replace("e_nsec", ".tv_nsec")
+            }
+            "u64" if struct_ == "epoll_event" => "data.u64".to_string(),
+            s => s.to_string(),
+        }
+    });
+
+    cfg.skip_type(move |ty| {
+        match ty {
+            // FIXME: sighandler_t is crazy across platforms
+            "sighandler_t" => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_struct(move |ty| {
+        match ty {
+            // This is actually a union, not a struct
+            "sigval" => true,
+            // These are tested as part of the linux_fcntl tests since there are
+            // header conflicts when including them with all the other structs.
+            "termios2" => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_signededness(move |c| {
+        match c {
+            "LARGE_INTEGER" | "float" | "double" => true,
+            n if n.starts_with("pthread") => true,
+            // sem_t is a struct or pointer
+            "sem_t" => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            "SIG_DFL" | "SIG_ERR" | "SIG_IGN" => true, // sighandler_t weirdness
+            "SIGUNUSED" => true,                       // removed in glibc 2.26
+
+            // weird signed extension or something like that?
+            "MS_NOUSER" => true,
+            "MS_RMT_MASK" => true, // updated in glibc 2.22 and musl 1.1.13
+            "BOTHER" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" => true,
+
+            "getrlimit" | "getrlimit64" |    // non-int in 1st arg
+            "setrlimit" | "setrlimit64" |    // non-int in 1st arg
+            "prlimit" | "prlimit64" |        // non-int in 2nd arg
+
+            // These functions presumably exist on netbsd but don't look like
+            // they're implemented on rumprun yet, just let them slide for now.
+            // Some of them look like they have headers but then don't have
+            // corresponding actual definitions either...
+            "shm_open" |
+            "shm_unlink" |
+            "syscall" |
+            "mq_open" |
+            "mq_close" |
+            "mq_getattr" |
+            "mq_notify" |
+            "mq_receive" |
+            "mq_send" |
+            "mq_setattr" |
+            "mq_timedreceive" |
+            "mq_timedsend" |
+            "mq_unlink" |
+            "ptrace" |
+            "sigaltstack" if rumprun => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_field_type(move |struct_, field| {
+        // This is a weird union, don't check the type.
+        (struct_ == "ifaddrs" && field == "ifa_ifu") ||
+        // sighandler_t type is super weird
+        (struct_ == "sigaction" && field == "sa_sigaction") ||
+        // sigval is actually a union, but we pretend it's a struct
+        (struct_ == "sigevent" && field == "sigev_value") ||
+        // aio_buf is "volatile void*" and Rust doesn't understand volatile
+        (struct_ == "aiocb" && field == "aio_buf")
+    });
+
+    cfg.skip_field(|struct_, field| {
+        match (struct_, field) {
+            // conflicting with `p_type` macro from <resolve.h>.
+            ("Elf32_Phdr", "p_type") => true,
+            ("Elf64_Phdr", "p_type") => true,
+            _ => false,
+        }
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_dragonflybsd(target: &str) {
+    assert!(target.contains("dragonfly"));
+    let mut cfg = ctest_cfg();
+    cfg.flag("-Wno-deprecated-declarations");
+
+    headers! {
+        cfg:
+        "aio.h",
+        "ctype.h",
+        "dirent.h",
+        "dlfcn.h",
+        "errno.h",
+        "execinfo.h",
+        "fcntl.h",
+        "glob.h",
+        "grp.h",
+        "ifaddrs.h",
+        "langinfo.h",
+        "limits.h",
+        "locale.h",
+        "mqueue.h",
+        "net/if.h",
+        "net/if_arp.h",
+        "net/if_dl.h",
+        "net/route.h",
+        "netdb.h",
+        "netinet/in.h",
+        "netinet/ip.h",
+        "netinet/tcp.h",
+        "netinet/udp.h",
+        "poll.h",
+        "pthread.h",
+        "pthread_np.h",
+        "pwd.h",
+        "regex.h",
+        "resolv.h",
+        "sched.h",
+        "semaphore.h",
+        "signal.h",
+        "stddef.h",
+        "stdint.h",
+        "stdio.h",
+        "stdlib.h",
+        "string.h",
+        "sys/event.h",
+        "sys/file.h",
+        "sys/ioctl.h",
+        "sys/mman.h",
+        "sys/mount.h",
+        "sys/ptrace.h",
+        "sys/resource.h",
+        "sys/rtprio.h",
+        "sys/socket.h",
+        "sys/stat.h",
+        "sys/statvfs.h",
+        "sys/sysctl.h",
+        "sys/time.h",
+        "sys/times.h",
+        "sys/types.h",
+        "sys/uio.h",
+        "sys/un.h",
+        "sys/utsname.h",
+        "sys/wait.h",
+        "syslog.h",
+        "termios.h",
+        "time.h",
+        "ufs/ufs/quota.h",
+        "unistd.h",
+        "util.h",
+        "utime.h",
+        "utmpx.h",
+        "wchar.h",
+    }
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "fd_set" | "Dl_info" | "DIR" | "Elf32_Phdr"
+            | "Elf64_Phdr" | "Elf32_Shdr" | "Elf64_Shdr" | "Elf32_Sym"
+            | "Elf64_Sym" | "Elf32_Ehdr" | "Elf64_Ehdr" | "Elf32_Chdr"
+            | "Elf64_Chdr" => ty.to_string(),
+
+            // FIXME: OSX calls this something else
+            "sighandler_t" => "sig_t".to_string(),
+
+            t if is_union => format!("union {}", t),
+
+            t if t.ends_with("_t") => t.to_string(),
+
+            // put `struct` in front of all structs:.
+            t if is_struct => format!("struct {}", t),
+
+            t => t.to_string(),
+        }
+    });
+
+    cfg.field_name(move |struct_, field| {
+        match field {
+            // Our stat *_nsec fields normally don't actually exist but are part
+            // of a timeval struct
+            s if s.ends_with("_nsec") && struct_.starts_with("stat") => {
+                s.replace("e_nsec", ".tv_nsec")
+            }
+            "u64" if struct_ == "epoll_event" => "data.u64".to_string(),
+            // Field is named `type` in C but that is a Rust keyword,
+            // so these fields are translated to `type_` in the bindings.
+            "type_" if struct_ == "rtprio" => "type".to_string(),
+            s => s.to_string(),
+        }
+    });
+
+    cfg.skip_type(move |ty| {
+        match ty {
+            // sighandler_t is crazy across platforms
+            "sighandler_t" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_struct(move |ty| {
+        match ty {
+            // This is actually a union, not a struct
+            "sigval" => true,
+
+            // FIXME: These are tested as part of the linux_fcntl tests since
+            // there are header conflicts when including them with all the other
+            // structs.
+            "termios2" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_signededness(move |c| {
+        match c {
+            "LARGE_INTEGER" | "float" | "double" => true,
+            // uuid_t is a struct, not an integer.
+            "uuid_t" => true,
+            n if n.starts_with("pthread") => true,
+            // sem_t is a struct or pointer
+            "sem_t" => true,
+            // mqd_t is a pointer on DragonFly
+            "mqd_t" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            "SIG_DFL" | "SIG_ERR" | "SIG_IGN" => true, // sighandler_t weirdness
+
+            // weird signed extension or something like that?
+            "MS_NOUSER" => true,
+            "MS_RMT_MASK" => true, // updated in glibc 2.22 and musl 1.1.13
+
+            // These are defined for Solaris 11, but the crate is tested on
+            // illumos, where they are currently not defined
+            "EADI"
+            | "PORT_SOURCE_POSTWAIT"
+            | "PORT_SOURCE_SIGNAL"
+            | "PTHREAD_STACK_MIN" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        // skip those that are manually verified
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" => true,
+
+            "getrlimit" | "getrlimit64" |    // non-int in 1st arg
+            "setrlimit" | "setrlimit64" |    // non-int in 1st arg
+            "prlimit" | "prlimit64"        // non-int in 2nd arg
+             => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_field_type(move |struct_, field| {
+        // This is a weird union, don't check the type.
+        (struct_ == "ifaddrs" && field == "ifa_ifu") ||
+        // sighandler_t type is super weird
+        (struct_ == "sigaction" && field == "sa_sigaction") ||
+        // sigval is actually a union, but we pretend it's a struct
+        (struct_ == "sigevent" && field == "sigev_value") ||
+        // aio_buf is "volatile void*" and Rust doesn't understand volatile
+        (struct_ == "aiocb" && field == "aio_buf")
+    });
+
+    cfg.skip_field(move |struct_, field| {
+        // this is actually a union on linux, so we can't represent it well and
+        // just insert some padding.
+        (struct_ == "siginfo_t" && field == "_pad") ||
+        // sigev_notify_thread_id is actually part of a sigev_un union
+        (struct_ == "sigevent" && field == "sigev_notify_thread_id")
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_wasi(target: &str) {
+    assert!(target.contains("wasi"));
+
+    let mut cfg = ctest_cfg();
+    cfg.define("_GNU_SOURCE", None);
+
+    headers! { cfg:
+        "ctype.h",
+        "dirent.h",
+        "errno.h",
+        "fcntl.h",
+        "limits.h",
+        "locale.h",
+        "malloc.h",
+        "poll.h",
+        "sched.h",
+        "stdbool.h",
+        "stddef.h",
+        "stdint.h",
+        "stdio.h",
+        "stdlib.h",
+        "string.h",
+        "sys/resource.h",
+        "sys/select.h",
+        "sys/socket.h",
+        "sys/stat.h",
+        "sys/times.h",
+        "sys/types.h",
+        "sys/uio.h",
+        "sys/utsname.h",
+        "sys/ioctl.h",
+        "time.h",
+        "unistd.h",
+        "wasi/api.h",
+        "wasi/libc.h",
+        "wasi/libc-find-relpath.h",
+        "wchar.h",
+    }
+
+    cfg.type_name(move |ty, is_struct, is_union| match ty {
+        "FILE" | "fd_set" | "DIR" => ty.to_string(),
+        t if is_union => format!("union {}", t),
+        t if t.starts_with("__wasi") && t.ends_with("_u") => {
+            format!("union {}", t)
+        }
+        t if t.starts_with("__wasi") && is_struct => format!("struct {}", t),
+        t if t.ends_with("_t") => t.to_string(),
+        t if is_struct => format!("struct {}", t),
+        t => t.to_string(),
+    });
+
+    cfg.field_name(move |_struct, field| {
+        match field {
+            // deal with fields as rust keywords
+            "type_" => "type".to_string(),
+            s => s.to_string(),
+        }
+    });
+
+    // Looks like LLD doesn't merge duplicate imports, so if the Rust
+    // code imports from a module and the C code also imports from a
+    // module we end up with two imports of function pointers which
+    // import the same thing but have different function pointers
+    cfg.skip_fn_ptrcheck(|f| f.starts_with("__wasi"));
+
+    // d_name is declared as a flexible array in WASI libc, so it
+    // doesn't support sizeof.
+    cfg.skip_field(|s, field| s == "dirent" && field == "d_name");
+
+    // Currently Rust/clang disagree on function argument ABI, so skip these
+    // tests. For more info see WebAssembly/tool-conventions#88
+    cfg.skip_roundtrip(|_| true);
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_android(target: &str) {
+    assert!(target.contains("android"));
+    let target_pointer_width = match target {
+        t if t.contains("aarch64") || t.contains("x86_64") => 64,
+        t if t.contains("i686") || t.contains("arm") => 32,
+        t => panic!("unsupported target: {}", t),
+    };
+    let x86 = target.contains("i686") || target.contains("x86_64");
+
+    let mut cfg = ctest_cfg();
+    cfg.define("_GNU_SOURCE", None);
+
+    headers! { cfg:
+               "arpa/inet.h",
+               "ctype.h",
+               "dirent.h",
+               "dlfcn.h",
+               "errno.h",
+               "fcntl.h",
+               "grp.h",
+               "ifaddrs.h",
+               "limits.h",
+               "locale.h",
+               "malloc.h",
+               "net/ethernet.h",
+               "net/if.h",
+               "net/if_arp.h",
+               "net/route.h",
+               "netdb.h",
+               "netinet/in.h",
+               "netinet/ip.h",
+               "netinet/tcp.h",
+               "netinet/udp.h",
+               "netpacket/packet.h",
+               "poll.h",
+               "pthread.h",
+               "pty.h",
+               "pwd.h",
+               "regex.h",
+               "resolv.h",
+               "sched.h",
+               "semaphore.h",
+               "signal.h",
+               "stddef.h",
+               "stdint.h",
+               "stdio.h",
+               "stdlib.h",
+               "string.h",
+               "sys/auxv.h",
+               "sys/epoll.h",
+               "sys/eventfd.h",
+               "sys/file.h",
+               "sys/fsuid.h",
+               "sys/inotify.h",
+               "sys/ioctl.h",
+               "sys/mman.h",
+               "sys/mount.h",
+               "sys/personality.h",
+               "sys/prctl.h",
+               "sys/ptrace.h",
+               "sys/random.h",
+               "sys/reboot.h",
+               "sys/resource.h",
+               "sys/sendfile.h",
+               "sys/signalfd.h",
+               "sys/socket.h",
+               "sys/stat.h",
+               "sys/statvfs.h",
+               "sys/swap.h",
+               "sys/syscall.h",
+               "sys/sysinfo.h",
+               "sys/time.h",
+               "sys/times.h",
+               "sys/timerfd.h",
+               "sys/types.h",
+               "sys/ucontext.h",
+               "sys/uio.h",
+               "sys/un.h",
+               "sys/utsname.h",
+               "sys/vfs.h",
+               "sys/xattr.h",
+               "sys/wait.h",
+               "syslog.h",
+               "termios.h",
+               "time.h",
+               "unistd.h",
+               "utime.h",
+               "utmp.h",
+               "wchar.h",
+               "xlocale.h",
+               // time64_t is not defined for 64-bit targets If included it will
+               // generate the error 'Your time_t is already 64-bit'
+               [target_pointer_width == 32]: "time64.h",
+               [x86]: "sys/reg.h",
+    }
+
+    // Include linux headers at the end:
+    headers! { cfg:
+                "asm/mman.h",
+                "linux/auxvec.h",
+                "linux/dccp.h",
+                "linux/errqueue.h",
+                "linux/falloc.h",
+                "linux/futex.h",
+                "linux/fs.h",
+                "linux/genetlink.h",
+                "linux/if_alg.h",
+                "linux/if_ether.h",
+                "linux/if_tun.h",
+                "linux/magic.h",
+                "linux/memfd.h",
+                "linux/module.h",
+                "linux/net_tstamp.h",
+                "linux/netfilter/nfnetlink.h",
+                "linux/netfilter/nfnetlink_log.h",
+                "linux/netfilter/nfnetlink_queue.h",
+                "linux/netfilter/nf_tables.h",
+                "linux/netfilter_ipv4.h",
+                "linux/netfilter_ipv6.h",
+                "linux/netfilter_ipv6/ip6_tables.h",
+                "linux/netlink.h",
+                "linux/quota.h",
+                "linux/reboot.h",
+                "linux/seccomp.h",
+                "linux/sched.h",
+                "linux/sockios.h",
+                "linux/vm_sockets.h",
+                "linux/wait.h",
+
+    }
+
+    // Include Android-specific headers:
+    headers! { cfg:
+                "android/set_abort_message.h"
+    }
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "fd_set" | "Dl_info" => ty.to_string(),
+
+            t if is_union => format!("union {}", t),
+
+            t if t.ends_with("_t") => t.to_string(),
+
+            // sigval is a struct in Rust, but a union in C:
+            "sigval" => format!("union sigval"),
+
+            // put `struct` in front of all structs:.
+            t if is_struct => format!("struct {}", t),
+
+            t => t.to_string(),
+        }
+    });
+
+    cfg.field_name(move |struct_, field| {
+        match field {
+            // Our stat *_nsec fields normally don't actually exist but are part
+            // of a timeval struct
+            s if s.ends_with("_nsec") && struct_.starts_with("stat") => {
+                s.to_string()
+            }
+            // FIXME: appears that `epoll_event.data` is an union
+            "u64" if struct_ == "epoll_event" => "data.u64".to_string(),
+            s => s.to_string(),
+        }
+    });
+
+    cfg.skip_type(move |ty| {
+        match ty {
+            // FIXME: `sighandler_t` type is incorrect, see:
+            // https://github.com/rust-lang/libc/issues/1359
+            "sighandler_t" => true,
+            _ => false,
+        }
+    });
+
+    cfg.skip_struct(move |ty| {
+        if ty.starts_with("__c_anonymous_") {
+            return true;
+        }
+        match ty {
+            // These are tested as part of the linux_fcntl tests since there are
+            // header conflicts when including them with all the other structs.
+            "termios2" => true,
+            // uc_sigmask and uc_sigmask64 of ucontext_t are an anonymous union
+            "ucontext_t" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            // FIXME: deprecated: not available in any header
+            // See: https://github.com/rust-lang/libc/issues/1356
+            "ENOATTR" => true,
+
+            // FIXME: still necessary?
+            "SIG_DFL" | "SIG_ERR" | "SIG_IGN" => true, // sighandler_t weirdness
+            // FIXME: deprecated - removed in glibc 2.26
+            "SIGUNUSED" => true,
+
+            // Needs a newer Android SDK for the definition
+            "P_PIDFD" => true,
+
+            // Requires Linux kernel 5.6
+            "VMADDR_CID_LOCAL" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        // skip those that are manually verified
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" | "execvpe" | "fexecve" => true,
+
+            // There are two versions of the sterror_r function, see
+            //
+            // https://linux.die.net/man/3/strerror_r
+            //
+            // An XSI-compliant version provided if:
+            //
+            // (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE
+            //
+            // and a GNU specific version provided if _GNU_SOURCE is defined.
+            //
+            // libc provides bindings for the XSI-compliant version, which is
+            // preferred for portable applications.
+            //
+            // We skip the test here since here _GNU_SOURCE is defined, and
+            // test the XSI version below.
+            "strerror_r" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_field_type(move |struct_, field| {
+        // This is a weird union, don't check the type.
+        (struct_ == "ifaddrs" && field == "ifa_ifu") ||
+        // sigval is actually a union, but we pretend it's a struct
+        (struct_ == "sigevent" && field == "sigev_value")
+    });
+
+    cfg.skip_field(move |struct_, field| {
+        // this is actually a union on linux, so we can't represent it well and
+        // just insert some padding.
+        (struct_ == "siginfo_t" && field == "_pad") ||
+        // FIXME: `sa_sigaction` has type `sighandler_t` but that type is
+        // incorrect, see: https://github.com/rust-lang/libc/issues/1359
+        (struct_ == "sigaction" && field == "sa_sigaction") ||
+        // sigev_notify_thread_id is actually part of a sigev_un union
+        (struct_ == "sigevent" && field == "sigev_notify_thread_id") ||
+        // signalfd had SIGSYS fields added in Android 4.19, but CI does not have that version yet.
+        (struct_ == "signalfd_siginfo" && (field == "ssi_syscall" ||
+                                           field == "ssi_call_addr" ||
+                                           field == "ssi_arch"))
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+
+    test_linux_like_apis(target);
+}
+
+fn test_freebsd(target: &str) {
+    assert!(target.contains("freebsd"));
+    let mut cfg = ctest_cfg();
+
+    let freebsd_ver = which_freebsd();
+
+    match freebsd_ver {
+        Some(10) => cfg.cfg("freebsd10", None),
+        Some(11) => cfg.cfg("freebsd11", None),
+        Some(12) => cfg.cfg("freebsd12", None),
+        Some(13) => cfg.cfg("freebsd13", None),
+        _ => &mut cfg,
+    };
+
+    // Required for `getline`:
+    cfg.define("_WITH_GETLINE", None);
+    // Required for making freebsd11_stat available in the headers
+    match freebsd_ver {
+        Some(10) => &mut cfg,
+        _ => cfg.define("_WANT_FREEBSD11_STAT", None),
+    };
+
+    headers! { cfg:
+                "aio.h",
+                "arpa/inet.h",
+                "ctype.h",
+                "dirent.h",
+                "dlfcn.h",
+                "elf.h",
+                "errno.h",
+                "fcntl.h",
+                "glob.h",
+                "grp.h",
+                "ifaddrs.h",
+                "langinfo.h",
+                "libutil.h",
+                "limits.h",
+                "link.h",
+                "locale.h",
+                "machine/reg.h",
+                "mqueue.h",
+                "net/bpf.h",
+                "net/if.h",
+                "net/if_arp.h",
+                "net/if_dl.h",
+                "net/route.h",
+                "netdb.h",
+                "netinet/ip.h",
+                "netinet/in.h",
+                "netinet/tcp.h",
+                "netinet/udp.h",
+                "poll.h",
+                "pthread.h",
+                "pthread_np.h",
+                "pwd.h",
+                "regex.h",
+                "resolv.h",
+                "sched.h",
+                "semaphore.h",
+                "signal.h",
+                "spawn.h",
+                "stddef.h",
+                "stdint.h",
+                "stdio.h",
+                "stdlib.h",
+                "string.h",
+                "sys/event.h",
+                "sys/extattr.h",
+                "sys/file.h",
+                "sys/ioctl.h",
+                "sys/ipc.h",
+                "sys/jail.h",
+                "sys/mman.h",
+                "sys/mount.h",
+                "sys/msg.h",
+                "sys/procdesc.h",
+                "sys/ptrace.h",
+                "sys/random.h",
+                "sys/resource.h",
+                "sys/rtprio.h",
+                "sys/shm.h",
+                "sys/socket.h",
+                "sys/stat.h",
+                "sys/statvfs.h",
+                "sys/sysctl.h",
+                "sys/time.h",
+                "sys/times.h",
+                "sys/timex.h",
+                "sys/types.h",
+                "sys/ucontext.h",
+                "sys/uio.h",
+                "sys/un.h",
+                "sys/utsname.h",
+                "sys/wait.h",
+                "syslog.h",
+                "termios.h",
+                "time.h",
+                "ufs/ufs/quota.h",
+                "unistd.h",
+                "utime.h",
+                "utmpx.h",
+                "wchar.h",
+    }
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "fd_set" | "Dl_info" | "DIR" | "Elf32_Phdr"
+            | "Elf64_Phdr" => ty.to_string(),
+
+            // FIXME: https://github.com/rust-lang/libc/issues/1273
+            "sighandler_t" => "sig_t".to_string(),
+
+            t if is_union => format!("union {}", t),
+
+            t if t.ends_with("_t") => t.to_string(),
+
+            // sigval is a struct in Rust, but a union in C:
+            "sigval" => format!("union sigval"),
+
+            // put `struct` in front of all structs:.
+            t if is_struct => format!("struct {}", t),
+
+            t => t.to_string(),
+        }
+    });
+
+    cfg.field_name(move |struct_, field| {
+        match field {
+            // Our stat *_nsec fields normally don't actually exist but are part
+            // of a timeval struct
+            s if s.ends_with("_nsec") && struct_.starts_with("stat") => {
+                s.replace("e_nsec", ".tv_nsec")
+            }
+            // Field is named `type` in C but that is a Rust keyword,
+            // so these fields are translated to `type_` in the bindings.
+            "type_" if struct_ == "rtprio" => "type".to_string(),
+            s => s.to_string(),
+        }
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            // These constants are to be introduced in yet-unreleased FreeBSD 12.2.
+            "F_ADD_SEALS" | "F_GET_SEALS" | "F_SEAL_SEAL"
+            | "F_SEAL_SHRINK" | "F_SEAL_GROW" | "F_SEAL_WRITE"
+                if Some(12) <= freebsd_ver =>
+            {
+                true
+            }
+
+            // These constants were introduced in FreeBSD 12:
+            "SF_USER_READAHEAD"
+            | "EVFILT_EMPTY"
+            | "SO_REUSEPORT_LB"
+            | "IP_ORIGDSTADDR"
+            | "IP_RECVORIGDSTADDR"
+            | "IPV6_ORIGDSTADDR"
+            | "IPV6_RECVORIGDSTADDR"
+            | "NI_NUMERICSCOPE"
+                if Some(11) == freebsd_ver =>
+            {
+                true
+            }
+
+            // These constants were introduced in FreeBSD 11:
+            "SF_USER_READAHEAD"
+            | "SF_NOCACHE"
+            | "RLIMIT_KQUEUES"
+            | "RLIMIT_UMTXP"
+            | "EVFILT_PROCDESC"
+            | "EVFILT_SENDFILE"
+            | "EVFILT_EMPTY"
+            | "SO_REUSEPORT_LB"
+            | "TCP_CCALGOOPT"
+            | "TCP_PCAP_OUT"
+            | "TCP_PCAP_IN"
+            | "IP_BINDMULTI"
+            | "IP_ORIGDSTADDR"
+            | "IP_RECVORIGDSTADDR"
+            | "IPV6_ORIGDSTADDR"
+            | "IPV6_RECVORIGDSTADDR"
+            | "PD_CLOEXEC"
+            | "PD_ALLOWED_AT_FORK"
+            | "IP_RSS_LISTEN_BUCKET"
+            | "NI_NUMERICSCOPE"
+                if Some(10) == freebsd_ver =>
+            {
+                true
+            }
+
+            // FIXME: This constant has a different value in FreeBSD 10:
+            "RLIM_NLIMITS" if Some(10) == freebsd_ver => true,
+
+            // FIXME: There are deprecated - remove in a couple of releases.
+            // These constants were removed in FreeBSD 11 (svn r273250) but will
+            // still be accepted and ignored at runtime.
+            "MAP_RENAME" | "MAP_NORESERVE" if Some(10) != freebsd_ver => true,
+
+            // FIXME: There are deprecated - remove in a couple of releases.
+            // These constants were removed in FreeBSD 11 (svn r262489),
+            // and they've never had any legitimate use outside of the
+            // base system anyway.
+            "CTL_MAXID" | "KERN_MAXID" | "HW_MAXID" | "USER_MAXID" => true,
+
+            // This constant was removed in FreeBSD 13 (svn r363622), and never
+            // had any legitimate use outside of the base system anyway.
+            "CTL_P1003_1B_MAXID" => true,
+
+            // This was renamed in FreeBSD 12.2 and 13 (r352486).
+            "CTL_UNSPEC" | "CTL_SYSCTL" => true,
+
+            // These were added in FreeBSD 12.2 and 13 (r352486),
+            // but they are just names for magic numbers that existed for ages.
+            "CTL_SYSCTL_DEBUG"
+            | "CTL_SYSCTL_NAME"
+            | "CTL_SYSCTL_NEXT"
+            | "CTL_SYSCTL_NAME2OID"
+            | "CTL_SYSCTL_OIDFMT"
+            | "CTL_SYSCTL_OIDDESCR"
+            | "CTL_SYSCTL_OIDLABEL" => true,
+
+            // This was renamed in FreeBSD 12.2 and 13 (r350749).
+            "IPPROTO_SEP" | "IPPROTO_DCCP" => true,
+
+            // This was changed to 96(0x60) in FreeBSD 13:
+            // https://github.com/freebsd/freebsd/
+            // commit/06b00ceaa914a3907e4e27bad924f44612bae1d7
+            "MINCORE_SUPER" if Some(13) == freebsd_ver => true,
+
+            // This was increased to 97 in FreeBSD 12.2 and 13.
+            // https://github.com/freebsd/freebsd/
+            // commit/72a21ba0f62da5e86a1c0b462aeb3f5ff849a1b7
+            "ELAST" if Some(12) == freebsd_ver => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_struct(move |ty| {
+        match ty {
+            // `mmsghdr` is not available in FreeBSD 10
+            "mmsghdr" if Some(10) == freebsd_ver => true,
+
+            // `max_align_t` is not available in FreeBSD 10
+            "max_align_t" if Some(10) == freebsd_ver => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        // skip those that are manually verified
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" | "execvpe" | "fexecve" => true,
+
+            // These functions were added in FreeBSD 11:
+            "fdatasync" | "mq_getfd_np" | "sendmmsg" | "recvmmsg"
+                if Some(10) == freebsd_ver =>
+            {
+                true
+            }
+
+            // This function changed its return type from `int` in FreeBSD10 to
+            // `ssize_t` in FreeBSD11:
+            "aio_waitcomplete" if Some(10) == freebsd_ver => true,
+
+            // The `uname` function in the `utsname.h` FreeBSD header is a C
+            // inline function (has no symbol) that calls the `__xuname` symbol.
+            // Therefore the function pointer comparison does not make sense for it.
+            "uname" => true,
+
+            // FIXME: Our API is unsound. The Rust API allows aliasing
+            // pointers, but the C API requires pointers not to alias.
+            // We should probably be at least using `&`/`&mut` here, see:
+            // https://github.com/gnzlbg/ctest/issues/68
+            "lio_listio" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_signededness(move |c| {
+        match c {
+            // FIXME: has a different sign in FreeBSD10
+            "blksize_t" if Some(10) == freebsd_ver => true,
+            _ => false,
+        }
+    });
+
+    cfg.volatile_item(|i| {
+        use ctest::VolatileItemKind::*;
+        match i {
+            // aio_buf is a volatile void** but since we cannot express that in
+            // Rust types, we have to explicitly tell the checker about it here:
+            StructField(ref n, ref f) if n == "aiocb" && f == "aio_buf" => {
+                true
+            }
+            _ => false,
+        }
+    });
+
+    cfg.skip_field(move |struct_, field| {
+        match (struct_, field) {
+            // FIXME: `sa_sigaction` has type `sighandler_t` but that type is
+            // incorrect, see: https://github.com/rust-lang/libc/issues/1359
+            ("sigaction", "sa_sigaction") => true,
+
+            // FIXME: in FreeBSD10 this field has type `char*` instead of
+            // `void*`:
+            ("stack_t", "ss_sp") if Some(10) == freebsd_ver => true,
+
+            // conflicting with `p_type` macro from <resolve.h>.
+            ("Elf32_Phdr", "p_type") => true,
+            ("Elf64_Phdr", "p_type") => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_emscripten(target: &str) {
+    assert!(target.contains("emscripten"));
+
+    let mut cfg = ctest_cfg();
+    cfg.define("_GNU_SOURCE", None); // FIXME: ??
+
+    headers! { cfg:
+               "aio.h",
+               "ctype.h",
+               "dirent.h",
+               "dlfcn.h",
+               "errno.h",
+               "fcntl.h",
+               "glob.h",
+               "grp.h",
+               "ifaddrs.h",
+               "langinfo.h",
+               "limits.h",
+               "locale.h",
+               "malloc.h",
+               "mntent.h",
+               "mqueue.h",
+               "net/ethernet.h",
+               "net/if.h",
+               "net/if_arp.h",
+               "net/route.h",
+               "netdb.h",
+               "netinet/in.h",
+               "netinet/ip.h",
+               "netinet/tcp.h",
+               "netinet/udp.h",
+               "netpacket/packet.h",
+               "poll.h",
+               "pthread.h",
+               "pty.h",
+               "pwd.h",
+               "resolv.h",
+               "sched.h",
+               "sched.h",
+               "semaphore.h",
+               "shadow.h",
+               "signal.h",
+               "stddef.h",
+               "stdint.h",
+               "stdio.h",
+               "stdlib.h",
+               "string.h",
+               "sys/epoll.h",
+               "sys/eventfd.h",
+               "sys/file.h",
+               "sys/ioctl.h",
+               "sys/ipc.h",
+               "sys/mman.h",
+               "sys/mount.h",
+               "sys/msg.h",
+               "sys/personality.h",
+               "sys/prctl.h",
+               "sys/ptrace.h",
+               "sys/quota.h",
+               "sys/reboot.h",
+               "sys/resource.h",
+               "sys/sem.h",
+               "sys/sendfile.h",
+               "sys/shm.h",
+               "sys/signalfd.h",
+               "sys/socket.h",
+               "sys/stat.h",
+               "sys/statvfs.h",
+               "sys/swap.h",
+               "sys/syscall.h",
+               "sys/sysctl.h",
+               "sys/sysinfo.h",
+               "sys/time.h",
+               "sys/timerfd.h",
+               "sys/times.h",
+               "sys/types.h",
+               "sys/uio.h",
+               "sys/un.h",
+               "sys/user.h",
+               "sys/utsname.h",
+               "sys/vfs.h",
+               "sys/wait.h",
+               "sys/xattr.h",
+               "syslog.h",
+               "termios.h",
+               "time.h",
+               "ucontext.h",
+               "unistd.h",
+               "utime.h",
+               "utmp.h",
+               "utmpx.h",
+               "wchar.h",
+    }
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "fd_set" | "Dl_info" | "DIR" => ty.to_string(),
+
+            t if is_union => format!("union {}", t),
+
+            t if t.ends_with("_t") => t.to_string(),
+
+            // put `struct` in front of all structs:.
+            t if is_struct => format!("struct {}", t),
+
+            t => t.to_string(),
+        }
+    });
+
+    cfg.field_name(move |struct_, field| {
+        match field {
+            // Our stat *_nsec fields normally don't actually exist but are part
+            // of a timeval struct
+            s if s.ends_with("_nsec") && struct_.starts_with("stat") => {
+                s.replace("e_nsec", ".tv_nsec")
+            }
+            // FIXME: appears that `epoll_event.data` is an union
+            "u64" if struct_ == "epoll_event" => "data.u64".to_string(),
+            s => s.to_string(),
+        }
+    });
+
+    cfg.skip_type(move |ty| {
+        match ty {
+            // sighandler_t is crazy across platforms
+            // FIXME: is this necessary?
+            "sighandler_t" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_struct(move |ty| {
+        match ty {
+            // This is actually a union, not a struct
+            // FIXME: is this necessary?
+            "sigval" => true,
+
+            // FIXME: It was removed in
+            // emscripten-core/emscripten@953e414
+            "pthread_mutexattr_t" => true,
+
+            // FIXME: Investigate why the test fails.
+            // Skip for now to unblock CI.
+            "pthread_condattr_t" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" | "execvpe" | "fexecve" => true,
+
+            // FIXME: Investigate why CI is missing it.
+            "clearenv" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            // FIXME: deprecated - SIGNUNUSED was removed in glibc 2.26
+            // users should use SIGSYS instead
+            "SIGUNUSED" => true,
+
+            // FIXME: emscripten uses different constants to constructs these
+            n if n.contains("__SIZEOF_PTHREAD") => true,
+
+            // FIXME: `SYS_gettid` was removed in
+            // emscripten-core/emscripten@6d6474e
+            "SYS_gettid" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_field_type(move |struct_, field| {
+        // This is a weird union, don't check the type.
+        // FIXME: is this necessary?
+        (struct_ == "ifaddrs" && field == "ifa_ifu") ||
+        // sighandler_t type is super weird
+        // FIXME: is this necessary?
+        (struct_ == "sigaction" && field == "sa_sigaction") ||
+        // sigval is actually a union, but we pretend it's a struct
+        // FIXME: is this necessary?
+        (struct_ == "sigevent" && field == "sigev_value") ||
+        // aio_buf is "volatile void*" and Rust doesn't understand volatile
+        // FIXME: is this necessary?
+        (struct_ == "aiocb" && field == "aio_buf")
+    });
+
+    cfg.skip_field(move |struct_, field| {
+        // this is actually a union on linux, so we can't represent it well and
+        // just insert some padding.
+        // FIXME: is this necessary?
+        (struct_ == "siginfo_t" && field == "_pad") ||
+        // musl names this __dummy1 but it's still there
+        // FIXME: is this necessary?
+        (struct_ == "glob_t" && field == "gl_flags") ||
+        // musl seems to define this as an *anonymous* bitfield
+        // FIXME: is this necessary?
+        (struct_ == "statvfs" && field == "__f_unused") ||
+        // sigev_notify_thread_id is actually part of a sigev_un union
+        (struct_ == "sigevent" && field == "sigev_notify_thread_id") ||
+        // signalfd had SIGSYS fields added in Linux 4.18, but no libc release has them yet.
+        (struct_ == "signalfd_siginfo" && (field == "ssi_addr_lsb" ||
+                                           field == "_pad2" ||
+                                           field == "ssi_syscall" ||
+                                           field == "ssi_call_addr" ||
+                                           field == "ssi_arch"))
+    });
+
+    // FIXME: test linux like
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_vxworks(target: &str) {
+    assert!(target.contains("vxworks"));
+
+    let mut cfg = ctest::TestGenerator::new();
+    headers! { cfg:
+               "vxWorks.h",
+               "yvals.h",
+               "nfs/nfsCommon.h",
+               "rtpLibCommon.h",
+               "randomNumGen.h",
+               "taskLib.h",
+               "sysLib.h",
+               "ioLib.h",
+               "inetLib.h",
+               "socket.h",
+               "errnoLib.h",
+               "ctype.h",
+               "dirent.h",
+               "dlfcn.h",
+               "elf.h",
+               "fcntl.h",
+               "grp.h",
+               "sys/poll.h",
+               "ifaddrs.h",
+               "langinfo.h",
+               "limits.h",
+               "link.h",
+               "locale.h",
+               "sys/stat.h",
+               "netdb.h",
+               "pthread.h",
+               "pwd.h",
+               "sched.h",
+               "semaphore.h",
+               "signal.h",
+               "stddef.h",
+               "stdint.h",
+               "stdio.h",
+               "stdlib.h",
+               "string.h",
+               "sys/file.h",
+               "sys/ioctl.h",
+               "sys/socket.h",
+               "sys/time.h",
+               "sys/times.h",
+               "sys/types.h",
+               "sys/uio.h",
+               "sys/un.h",
+               "sys/utsname.h",
+               "sys/wait.h",
+               "netinet/tcp.h",
+               "syslog.h",
+               "termios.h",
+               "time.h",
+               "ucontext.h",
+               "unistd.h",
+               "utime.h",
+               "wchar.h",
+               "errno.h",
+               "sys/mman.h",
+               "pathLib.h",
+               "mqueue.h",
+    }
+    // FIXME
+    cfg.skip_const(move |name| match name {
+        // sighandler_t weirdness
+        "SIG_DFL" | "SIG_ERR" | "SIG_IGN"
+        // This is not defined in vxWorks
+        | "RTLD_DEFAULT"   => true,
+        _ => false,
+    });
+    // FIXME
+    cfg.skip_type(move |ty| match ty {
+        "stat64" | "sighandler_t" | "off64_t" => true,
+        _ => false,
+    });
+
+    cfg.skip_field_type(move |struct_, field| match (struct_, field) {
+        ("siginfo_t", "si_value")
+        | ("stat", "st_size")
+        | ("sigaction", "sa_u") => true,
+        _ => false,
+    });
+
+    cfg.skip_roundtrip(move |s| match s {
+        _ => false,
+    });
+
+    cfg.type_name(move |ty, is_struct, is_union| match ty {
+        "DIR" | "FILE" | "Dl_info" | "RTP_DESC" => ty.to_string(),
+        t if is_union => format!("union {}", t),
+        t if t.ends_with("_t") => t.to_string(),
+        t if is_struct => format!("struct {}", t),
+        t => t.to_string(),
+    });
+
+    // FIXME
+    cfg.skip_fn(move |name| match name {
+        // sigval
+        "sigqueue" | "_sigqueue"
+        // sighandler_t
+        | "signal"
+        // not used in static linking by default
+        | "dlerror" => true,
+        _ => false,
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+}
+
+fn test_linux(target: &str) {
+    assert!(target.contains("linux"));
+
+    // target_env
+    let gnu = target.contains("gnu");
+    let musl = target.contains("musl");
+    let uclibc = target.contains("uclibc");
+
+    match (gnu, musl, uclibc) {
+        (true, false, false) => (),
+        (false, true, false) => (),
+        (false, false, true) => (),
+        (_, _, _) => panic!(
+            "linux target lib is gnu: {}, musl: {}, uclibc: {}",
+            gnu, musl, uclibc
+        ),
+    }
+
+    let arm = target.contains("arm");
+    let i686 = target.contains("i686");
+    let mips = target.contains("mips");
+    let mips32 = mips && !target.contains("64");
+    let mips64 = mips && target.contains("64");
+    let ppc64 = target.contains("powerpc64");
+    let s390x = target.contains("s390x");
+    let sparc64 = target.contains("sparc64");
+    let x32 = target.contains("x32");
+    let x86_32 = target.contains("i686");
+    let x86_64 = target.contains("x86_64");
+    let aarch64_musl = target.contains("aarch64") && musl;
+    let gnuabihf = target.contains("gnueabihf");
+    let x86_64_gnux32 = target.contains("gnux32") && x86_64;
+    let riscv64 = target.contains("riscv64");
+
+    let mut cfg = ctest_cfg();
+    cfg.define("_GNU_SOURCE", None);
+    // This macro re-deifnes fscanf,scanf,sscanf to link to the symbols that are
+    // deprecated since glibc >= 2.29. This allows Rust binaries to link against
+    // glibc versions older than 2.29.
+    cfg.define("__GLIBC_USE_DEPRECATED_SCANF", None);
+
+    headers! { cfg:
+               "ctype.h",
+               "dirent.h",
+               "dlfcn.h",
+               "elf.h",
+               "fcntl.h",
+               "glob.h",
+               "grp.h",
+               "ifaddrs.h",
+               "langinfo.h",
+               "limits.h",
+               "link.h",
+               "locale.h",
+               "malloc.h",
+               "mntent.h",
+               "mqueue.h",
+               "net/ethernet.h",
+               "net/if.h",
+               "net/if_arp.h",
+               "net/route.h",
+               "netdb.h",
+               "netinet/in.h",
+               "netinet/ip.h",
+               "netinet/tcp.h",
+               "netinet/udp.h",
+               "netpacket/packet.h",
+               "poll.h",
+               "pthread.h",
+               "pty.h",
+               "pwd.h",
+               "regex.h",
+               "resolv.h",
+               "sched.h",
+               "semaphore.h",
+               "shadow.h",
+               "signal.h",
+               "spawn.h",
+               "stddef.h",
+               "stdint.h",
+               "stdio.h",
+               "stdlib.h",
+               "string.h",
+               "sys/epoll.h",
+               "sys/eventfd.h",
+               "sys/file.h",
+               "sys/fsuid.h",
+               "sys/inotify.h",
+               "sys/ioctl.h",
+               "sys/ipc.h",
+               "sys/mman.h",
+               "sys/mount.h",
+               "sys/msg.h",
+               "sys/personality.h",
+               "sys/prctl.h",
+               "sys/ptrace.h",
+               "sys/quota.h",
+               "sys/random.h",
+               "sys/reboot.h",
+               "sys/resource.h",
+               "sys/sem.h",
+               "sys/sendfile.h",
+               "sys/shm.h",
+               "sys/signalfd.h",
+               "sys/socket.h",
+               "sys/stat.h",
+               "sys/statvfs.h",
+               "sys/swap.h",
+               "sys/syscall.h",
+               "sys/time.h",
+               "sys/timerfd.h",
+               "sys/times.h",
+               "sys/timex.h",
+               "sys/types.h",
+               "sys/uio.h",
+               "sys/un.h",
+               "sys/user.h",
+               "sys/utsname.h",
+               "sys/vfs.h",
+               "sys/wait.h",
+               "syslog.h",
+               "termios.h",
+               "time.h",
+               "ucontext.h",
+               "unistd.h",
+               "utime.h",
+               "utmp.h",
+               "utmpx.h",
+               "wchar.h",
+               "errno.h",
+               // `sys/io.h` is only available on x86*, Alpha, IA64, and 32-bit
+               // ARM: https://bugzilla.redhat.com/show_bug.cgi?id=1116162
+               // Also unavailable on gnuabihf with glibc 2.30.
+               // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=6b33f373c7b9199e00ba5fbafd94ac9bfb4337b1
+               [(x86_64 || x86_32 || arm) && !gnuabihf]: "sys/io.h",
+               // `sys/reg.h` is only available on x86 and x86_64
+               [x86_64 || x86_32]: "sys/reg.h",
+               // sysctl system call is deprecated and not available on musl
+               // It is also unsupported in x32, deprecated since glibc 2.30:
+               [!(x32 || musl || gnu)]: "sys/sysctl.h",
+               // <execinfo.h> is not supported by musl:
+               // https://www.openwall.com/lists/musl/2015/04/09/3
+               [!musl]: "execinfo.h",
+    }
+
+    // Include linux headers at the end:
+    headers! {
+        cfg:
+        "asm/mman.h",
+        "linux/can.h",
+        "linux/dccp.h",
+        "linux/errqueue.h",
+        "linux/falloc.h",
+        "linux/fs.h",
+        "linux/futex.h",
+        "linux/genetlink.h",
+        "linux/if.h",
+        "linux/if_addr.h",
+        "linux/if_alg.h",
+        "linux/if_ether.h",
+        "linux/if_tun.h",
+        "linux/input.h",
+        "linux/keyctl.h",
+        "linux/magic.h",
+        "linux/memfd.h",
+        "linux/mman.h",
+        "linux/module.h",
+        "linux/net_tstamp.h",
+        "linux/netfilter/nfnetlink.h",
+        "linux/netfilter/nfnetlink_log.h",
+        "linux/netfilter/nfnetlink_queue.h",
+        "linux/netfilter/nf_tables.h",
+        "linux/netfilter_ipv4.h",
+        "linux/netfilter_ipv6.h",
+        "linux/netfilter_ipv6/ip6_tables.h",
+        "linux/netlink.h",
+        "linux/quota.h",
+        "linux/random.h",
+        "linux/reboot.h",
+        "linux/rtnetlink.h",
+        "linux/seccomp.h",
+        "linux/sockios.h",
+        "linux/vm_sockets.h",
+        "linux/wait.h",
+        "sys/auxv.h",
+        "sys/fanotify.h",
+    }
+
+    // note: aio.h must be included before sys/mount.h
+    headers! {
+        cfg:
+        "sys/xattr.h",
+        "sys/sysinfo.h",
+        "aio.h",
+    }
+
+    cfg.type_name(move |ty, is_struct, is_union| {
+        match ty {
+            // Just pass all these through, no need for a "struct" prefix
+            "FILE" | "fd_set" | "Dl_info" | "DIR" | "Elf32_Phdr"
+            | "Elf64_Phdr" | "Elf32_Shdr" | "Elf64_Shdr" | "Elf32_Sym"
+            | "Elf64_Sym" | "Elf32_Ehdr" | "Elf64_Ehdr" | "Elf32_Chdr"
+            | "Elf64_Chdr" => ty.to_string(),
+
+            t if is_union => format!("union {}", t),
+
+            t if t.ends_with("_t") => t.to_string(),
+
+            // In MUSL `flock64` is a typedef to `flock`.
+            "flock64" if musl => format!("struct {}", ty),
+
+            // put `struct` in front of all structs:.
+            t if is_struct => format!("struct {}", t),
+
+            t => t.to_string(),
+        }
+    });
+
+    cfg.field_name(move |struct_, field| {
+        match field {
+            // Our stat *_nsec fields normally don't actually exist but are part
+            // of a timeval struct
+            s if s.ends_with("_nsec") && struct_.starts_with("stat") => {
+                s.replace("e_nsec", ".tv_nsec")
+            }
+            // FIXME: epoll_event.data is actuall a union in C, but in Rust
+            // it is only a u64 because we only expose one field
+            // http://man7.org/linux/man-pages/man2/epoll_wait.2.html
+            "u64" if struct_ == "epoll_event" => "data.u64".to_string(),
+            // The following structs have a field called `type` in C,
+            // but `type` is a Rust keyword, so these fields are translated
+            // to `type_` in Rust.
+            "type_"
+                if struct_ == "input_event"
+                    || struct_ == "input_mask"
+                    || struct_ == "ff_effect" =>
+            {
+                "type".to_string()
+            }
+
+            s => s.to_string(),
+        }
+    });
+
+    cfg.skip_type(move |ty| {
+        match ty {
+            // FIXME: `sighandler_t` type is incorrect, see:
+            // https://github.com/rust-lang/libc/issues/1359
+            "sighandler_t" => true,
+
+            // These cannot be tested when "resolv.h" is included and are tested
+            // in the `linux_elf.rs` file.
+            "Elf64_Phdr" | "Elf32_Phdr" => true,
+
+            // This type is private on Linux. It is implemented as a C `enum`
+            // (`c_uint`) and this clashes with the type of the `rlimit` APIs
+            // which expect a `c_int` even though both are ABI compatible.
+            "__rlimit_resource_t" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_struct(move |ty| {
+        if ty.starts_with("__c_anonymous_") {
+            return true;
+        }
+        match ty {
+            // These cannot be tested when "resolv.h" is included and are tested
+            // in the `linux_elf.rs` file.
+            "Elf64_Phdr" | "Elf32_Phdr" => true,
+
+            // On Linux, the type of `ut_tv` field of `struct utmpx`
+            // can be an anonymous struct, so an extra struct,
+            // which is absent in glibc, has to be defined.
+            "__timeval" => true,
+
+            // FIXME: This is actually a union, not a struct
+            "sigval" => true,
+
+            // This type is tested in the `linux_termios.rs` file since there
+            // are header conflicts when including them with all the other
+            // structs.
+            "termios2" => true,
+
+            // FIXME: remove once we set minimum supported glibc version.
+            // ucontext_t added a new field as of glibc 2.28; our struct definition is
+            // conservative and omits the field, but that means the size doesn't match for newer
+            // glibcs (see https://github.com/rust-lang/libc/issues/1410)
+            "ucontext_t" if gnu => true,
+
+            // FIXME: Somehow we cannot include headers correctly in glibc 2.30.
+            // So let's ignore for now and re-visit later.
+            // Probably related: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91085
+            "statx" => true,
+            "statx_timestamp" => true,
+
+            // On Linux, the type of `ut_exit` field of struct `utmpx`
+            // can be an anonymous struct, so an extra struct,
+            // which is absent in musl, has to be defined.
+            "__exit_status" if musl => true,
+
+            // FIXME: CI's kernel header version is old.
+            "sockaddr_can" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_const(move |name| {
+        match name {
+            // These constants are not available if gnu headers have been included
+            // and can therefore not be tested here
+            //
+            // The IPV6 constants are tested in the `linux_ipv6.rs` tests:
+            | "IPV6_FLOWINFO"
+            | "IPV6_FLOWLABEL_MGR"
+            | "IPV6_FLOWINFO_SEND"
+            | "IPV6_FLOWINFO_FLOWLABEL"
+            | "IPV6_FLOWINFO_PRIORITY"
+            // The F_ fnctl constants are tested in the `linux_fnctl.rs` tests:
+            | "F_CANCELLK"
+            | "F_ADD_SEALS"
+            | "F_GET_SEALS"
+            | "F_SEAL_SEAL"
+            | "F_SEAL_SHRINK"
+            | "F_SEAL_GROW"
+            | "F_SEAL_WRITE" => true,
+
+            // The musl-sanitized kernel headers used in CI
+            // target the Linux kernel 4.4 and do not contain the
+            // following constants:
+            //
+            // Requires Linux kernel 4.9
+            | "FALLOC_FL_UNSHARE_RANGE"
+            //
+            // Require Linux kernel 5.x:
+            | "MSG_COPY"
+               if musl  => true,
+            // Require Linux kernel 5.1:
+            "F_SEAL_FUTURE_WRITE" => true,
+
+            // The musl version 1.1.24 used in CI does not
+            // contain these glibc constants yet:
+            | "RLIMIT_RTTIME" // should be in `resource.h`
+            | "TCP_COOKIE_TRANSACTIONS"  // should be in the `netinet/tcp.h` header
+                if musl => true,
+
+            // FIXME: deprecated: not available in any header
+            // See: https://github.com/rust-lang/libc/issues/1356
+            "ENOATTR" => true,
+
+            // FIXME: SIGUNUSED was removed in glibc 2.26
+            // Users should use SIGSYS instead.
+            "SIGUNUSED" => true,
+
+            // FIXME: conflicts with glibc headers and is tested in
+            // `linux_termios.rs` below:
+            "BOTHER" => true,
+
+            // FIXME: on musl the pthread types are defined a little differently
+            // - these constants are used by the glibc implementation.
+            n if musl && n.contains("__SIZEOF_PTHREAD") => true,
+
+            // FIXME: It was extended to 4096 since glibc 2.31 (Linux 5.4).
+            // We should do so after a while.
+            "SOMAXCONN" if gnu => true,
+
+            // deprecated: not available from Linux kernel 5.6:
+            "VMADDR_CID_RESERVED" => true,
+
+            // Require Linux kernel 5.6:
+            "VMADDR_CID_LOCAL" => true,
+
+            // IPPROTO_MAX was increased in 5.6 for IPPROTO_MPTCP:
+            | "IPPROTO_MAX"
+            | "IPPROTO_MPTCP" => true,
+
+            // Defined in kernel headers but musl removes it; need musl 1.2 for definition in musl
+            // headers.
+            "P_PIDFD" => true,
+
+            // FIXME: Not currently available in headers
+            "SYS_pidfd_open" if mips => true,
+
+            // FIXME: Not currently available in headers on MIPS
+            // Not yet implemented on sparc64
+            "SYS_clone3" if mips | sparc64 => true,
+
+            // Missing from musl's kernel headers
+            | "IFLA_GSO_MAX_SEGS"
+            | "IFLA_GSO_MAX_SIZE"
+            | "IFLA_PAD"
+            | "IFLA_XDP"
+            | "IFLA_EVENT"
+            | "IFLA_NEW_NETNSID"
+            | "IFLA_IF_NETNSID"
+            | "IFLA_TARGET_NETNSID"
+            | "IFLA_CARRIER_UP_COUNT"
+            | "IFLA_CARRIER_DOWN_COUNT"
+            | "IFLA_NEW_IFINDEX"
+            | "IFLA_MIN_MTU"
+            | "IFLA_MAX_MTU"
+                if musl => true,
+
+            // Requires more recent kernel headers:
+            | "IFLA_PROP_LIST"
+            | "IFLA_ALT_IFNAME"
+            | "IFLA_PERM_ADDRESS"
+            | "IFLA_PROTO_DOWN_REASON" => true,
+
+            // FIXME: They require recent kernel header:
+            | "CAN_J1939"
+            | "CAN_RAW_FILTER_MAX"
+            | "CAN_NPROTO" => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_fn(move |name| {
+        // skip those that are manually verified
+        match name {
+            // FIXME: https://github.com/rust-lang/libc/issues/1272
+            "execv" | "execve" | "execvp" | "execvpe" | "fexecve" => true,
+
+            // There are two versions of the sterror_r function, see
+            //
+            // https://linux.die.net/man/3/strerror_r
+            //
+            // An XSI-compliant version provided if:
+            //
+            // (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600)
+            //  && ! _GNU_SOURCE
+            //
+            // and a GNU specific version provided if _GNU_SOURCE is defined.
+            //
+            // libc provides bindings for the XSI-compliant version, which is
+            // preferred for portable applications.
+            //
+            // We skip the test here since here _GNU_SOURCE is defined, and
+            // test the XSI version below.
+            "strerror_r" => true,
+
+            // FIXME: Our API is unsound. The Rust API allows aliasing
+            // pointers, but the C API requires pointers not to alias.
+            // We should probably be at least using `&`/`&mut` here, see:
+            // https://github.com/gnzlbg/ctest/issues/68
+            "lio_listio" if musl => true,
+
+            // FIXME: the glibc version used by the Sparc64 build jobs
+            // which use Debian 10.0 is too old.
+            "statx" if sparc64 => true,
+
+            // FIXME: Deprecated since glibc 2.30. Remove fn once upstream does.
+            "sysctl" if gnu => true,
+
+            // FIXME: It now takes c_void instead of timezone since glibc 2.31.
+            "gettimeofday" if gnu => true,
+
+            _ => false,
+        }
+    });
+
+    cfg.skip_field_type(move |struct_, field| {
+        // This is a weird union, don't check the type.
+        (struct_ == "ifaddrs" && field == "ifa_ifu") ||
+        // sighandler_t type is super weird
+        (struct_ == "sigaction" && field == "sa_sigaction") ||
+        // __timeval type is a patch which doesn't exist in glibc
+        (struct_ == "utmpx" && field == "ut_tv") ||
+        // sigval is actually a union, but we pretend it's a struct
+        (struct_ == "sigevent" && field == "sigev_value") ||
+        // this one is an anonymous union
+        (struct_ == "ff_effect" && field == "u") ||
+        // `__exit_status` type is a patch which is absent in musl
+        (struct_ == "utmpx" && field == "ut_exit" && musl) ||
+        // `can_addr` is an anonymous union
+        (struct_ == "sockaddr_can" && field == "can_addr")
+    });
+
+    cfg.volatile_item(|i| {
+        use ctest::VolatileItemKind::*;
+        match i {
+            // aio_buf is a volatile void** but since we cannot express that in
+            // Rust types, we have to explicitly tell the checker about it here:
+            StructField(ref n, ref f) if n == "aiocb" && f == "aio_buf" => {
+                true
+            }
+            _ => false,
+        }
+    });
+
+    cfg.skip_field(move |struct_, field| {
+        // this is actually a union on linux, so we can't represent it well and
+        // just insert some padding.
+        (struct_ == "siginfo_t" && field == "_pad") ||
+        // musl names this __dummy1 but it's still there
+        (musl && struct_ == "glob_t" && field == "gl_flags") ||
+        // musl seems to define this as an *anonymous* bitfield
+        (musl && struct_ == "statvfs" && field == "__f_unused") ||
+        // sigev_notify_thread_id is actually part of a sigev_un union
+        (struct_ == "sigevent" && field == "sigev_notify_thread_id") ||
+        // signalfd had SIGSYS fields added in Linux 4.18, but no libc release
+        // has them yet.
+        (struct_ == "signalfd_siginfo" && (field == "ssi_addr_lsb" ||
+                                           field == "_pad2" ||
+                                           field == "ssi_syscall" ||
+                                           field == "ssi_call_addr" ||
+                                           field == "ssi_arch")) ||
+        // FIXME: After musl 1.1.24, it have only one field `sched_priority`,
+        // while other fields become reserved.
+        (struct_ == "sched_param" && [
+            "sched_ss_low_priority",
+            "sched_ss_repl_period",
+            "sched_ss_init_budget",
+            "sched_ss_max_repl",
+        ].contains(&field) && musl) ||
+        // FIXME: After musl 1.1.24, the type becomes `int` instead of `unsigned short`.
+        (struct_ == "ipc_perm" && field == "__seq" && aarch64_musl) ||
+        // glibc uses unnamed fields here and Rust doesn't support that yet
+        (struct_ == "timex" && field.starts_with("__unused")) ||
+        // FIXME: It now takes mode_t since glibc 2.31 on some targets.
+        (struct_ == "ipc_perm" && field == "mode"
+            && ((x86_64 || i686 || arm || riscv64) && gnu || x86_64_gnux32)
+        )
+    });
+
+    cfg.skip_roundtrip(move |s| match s {
+        // FIXME:
+        "utsname" if mips32 || mips64 => true,
+        // FIXME:
+        "mcontext_t" if s390x => true,
+        // FIXME: This is actually a union.
+        "fpreg_t" if s390x => true,
+
+        "sockaddr_un" | "sembuf" | "ff_constant_effect"
+            if mips32 && (gnu || musl) =>
+        {
+            true
+        }
+        "ipv6_mreq"
+        | "ip_mreq_source"
+        | "sockaddr_in6"
+        | "sockaddr_ll"
+        | "in_pktinfo"
+        | "arpreq"
+        | "arpreq_old"
+        | "sockaddr_un"
+        | "ff_constant_effect"
+        | "ff_ramp_effect"
+        | "ff_condition_effect"
+        | "Elf32_Ehdr"
+        | "Elf32_Chdr"
+        | "ucred"
+        | "in6_pktinfo"
+        | "sockaddr_nl"
+        | "termios"
+        | "nlmsgerr"
+            if (mips64 || sparc64) && gnu =>
+        {
+            true
+        }
+
+        // FIXME: the call ABI of max_align_t is incorrect on these platforms:
+        "max_align_t" if i686 || mips64 || ppc64 => true,
+
+        _ => false,
+    });
+
+    cfg.generate("../src/lib.rs", "main.rs");
+
+    test_linux_like_apis(target);
+}
+
+// This function tests APIs that are incompatible to test when other APIs
+// are included (e.g. because including both sets of headers clashes)
+fn test_linux_like_apis(target: &str) {
+    let musl = target.contains("musl");
+    let linux = target.contains("linux");
+    let emscripten = target.contains("emscripten");
+    let android = target.contains("android");
+    assert!(linux || android || emscripten);
+
+    if linux || android || emscripten {
+        // test strerror_r from the `string.h` header
+        let mut cfg = ctest_cfg();
+        cfg.skip_type(|_| true).skip_static(|_| true);
+
+        headers! { cfg: "string.h" }
+        cfg.skip_fn(|f| match f {
+            "strerror_r" => false,
+            _ => true,
+        })
+        .skip_const(|_| true)
+        .skip_struct(|_| true);
+        cfg.generate("../src/lib.rs", "linux_strerror_r.rs");
+    }
+
+    if linux || android || emscripten {
+        // test fcntl - see:
+        // http://man7.org/linux/man-pages/man2/fcntl.2.html
+        let mut cfg = ctest_cfg();
+
+        if musl {
+            cfg.header("fcntl.h");
+        } else {
+            cfg.header("linux/fcntl.h");
+        }
+
+        cfg.skip_type(|_| true)
+            .skip_static(|_| true)
+            .skip_struct(|_| true)
+            .skip_fn(|_| true)
+            .skip_const(move |name| match name {
+                // test fcntl constants:
+                "F_CANCELLK" | "F_ADD_SEALS" | "F_GET_SEALS"
+                | "F_SEAL_SEAL" | "F_SEAL_SHRINK" | "F_SEAL_GROW"
+                | "F_SEAL_WRITE" => false,
+                _ => true,
+            })
+            .type_name(move |ty, is_struct, is_union| match ty {
+                t if is_struct => format!("struct {}", t),
+                t if is_union => format!("union {}", t),
+                t => t.to_string(),
+            });
+
+        cfg.generate("../src/lib.rs", "linux_fcntl.rs");
+    }
+
+    if linux || android {
+        // test termios
+        let mut cfg = ctest_cfg();
+        cfg.header("asm/termbits.h");
+        cfg.skip_type(|_| true)
+            .skip_static(|_| true)
+            .skip_fn(|_| true)
+            .skip_const(|c| c != "BOTHER")
+            .skip_struct(|s| s != "termios2")
+            .type_name(move |ty, is_struct, is_union| match ty {
+                t if is_struct => format!("struct {}", t),
+                t if is_union => format!("union {}", t),
+                t => t.to_string(),
+            });
+        cfg.generate("../src/lib.rs", "linux_termios.rs");
+    }
+
+    if linux || android {
+        // test IPV6_ constants:
+        let mut cfg = ctest_cfg();
+        headers! {
+            cfg:
+            "linux/in6.h"
+        }
+        cfg.skip_type(|_| true)
+            .skip_static(|_| true)
+            .skip_fn(|_| true)
+            .skip_const(|_| true)
+            .skip_struct(|_| true)
+            .skip_const(move |name| match name {
+                "IPV6_FLOWINFO"
+                | "IPV6_FLOWLABEL_MGR"
+                | "IPV6_FLOWINFO_SEND"
+                | "IPV6_FLOWINFO_FLOWLABEL"
+                | "IPV6_FLOWINFO_PRIORITY" => false,
+                _ => true,
+            })
+            .type_name(move |ty, is_struct, is_union| match ty {
+                t if is_struct => format!("struct {}", t),
+                t if is_union => format!("union {}", t),
+                t => t.to_string(),
+            });
+        cfg.generate("../src/lib.rs", "linux_ipv6.rs");
+    }
+
+    if linux || android {
+        // Test Elf64_Phdr and Elf32_Phdr
+        // These types have a field called `p_type`, but including
+        // "resolve.h" defines a `p_type` macro that expands to `__p_type`
+        // making the tests for these fails when both are included.
+        let mut cfg = ctest_cfg();
+        cfg.header("elf.h");
+        cfg.skip_fn(|_| true)
+            .skip_static(|_| true)
+            .skip_fn(|_| true)
+            .skip_const(|_| true)
+            .type_name(move |ty, _is_struct, _is_union| ty.to_string())
+            .skip_struct(move |ty| match ty {
+                "Elf64_Phdr" | "Elf32_Phdr" => false,
+                _ => true,
+            })
+            .skip_type(move |ty| match ty {
+                "Elf64_Phdr" | "Elf32_Phdr" => false,
+                _ => true,
+            });
+        cfg.generate("../src/lib.rs", "linux_elf.rs");
+    }
+}
+
+fn which_freebsd() -> Option<i32> {
+    let output = std::process::Command::new("freebsd-version")
+        .output()
+        .ok()?;
+    if !output.status.success() {
+        return None;
+    }
+
+    let stdout = String::from_utf8(output.stdout).ok()?;
+
+    match &stdout {
+        s if s.starts_with("10") => Some(10),
+        s if s.starts_with("11") => Some(11),
+        s if s.starts_with("12") => Some(12),
+        s if s.starts_with("13") => Some(13),
+        _ => None,
+    }
+}
diff --git a/library/libc/libc-test/src/cmsg.c b/library/libc/libc-test/src/cmsg.c
new file mode 100644
index 00000000..a8b1c371
--- /dev/null
+++ b/library/libc/libc-test/src/cmsg.c
@@ -0,0 +1,28 @@
+#include <sys/param.h>
+#include <sys/socket.h>
+
+// Since the cmsg(3) macros are macros instead of functions, they aren't
+// available to FFI.  libc must reimplement them, which is error-prone.  This
+// file provides FFI access to the actual macros so they can be tested against
+// the Rust reimplementations.
+
+struct cmsghdr *cmsg_firsthdr(struct msghdr *msgh) {
+	return CMSG_FIRSTHDR(msgh);
+}
+
+struct cmsghdr *cmsg_nxthdr(struct msghdr *msgh, struct cmsghdr *cmsg) {
+	return CMSG_NXTHDR(msgh, cmsg);
+}
+
+size_t cmsg_space(size_t length) {
+	return CMSG_SPACE(length);
+}
+
+size_t cmsg_len(size_t length) {
+	return CMSG_LEN(length);
+}
+
+unsigned char *cmsg_data(struct cmsghdr *cmsg) {
+	return CMSG_DATA(cmsg);
+}
+
diff --git a/library/libc/libc-test/src/errqueue.c b/library/libc/libc-test/src/errqueue.c
new file mode 100644
index 00000000..931ca91b
--- /dev/null
+++ b/library/libc/libc-test/src/errqueue.c
@@ -0,0 +1,10 @@
+#include <time.h>
+#include <linux/errqueue.h>
+
+// SO_EE_OFFENDER is defined as a macro in linux/errqueue.h.  This file wraps
+// that macro in a function so we can test the reimplementation in this package
+// is equivalent.
+
+struct sockaddr *so_ee_offender(struct sock_extended_err *ee) {
+  return SO_EE_OFFENDER(ee);
+}
diff --git a/library/libc/libc-test/test/cmsg.rs b/library/libc/libc-test/test/cmsg.rs
new file mode 100644
index 00000000..38a8ce15
--- /dev/null
+++ b/library/libc/libc-test/test/cmsg.rs
@@ -0,0 +1,100 @@
+//! Compare libc's CMSG(3) family of functions against the actual C macros, for
+//! various inputs.
+
+extern crate libc;
+
+#[cfg(unix)]
+mod t {
+
+    use libc::{self, c_uchar, c_uint, c_void, cmsghdr, msghdr};
+    use std::mem;
+
+    extern "C" {
+        pub fn cmsg_firsthdr(msgh: *const msghdr) -> *mut cmsghdr;
+        pub fn cmsg_nxthdr(
+            mhdr: *const msghdr,
+            cmsg: *const cmsghdr,
+        ) -> *mut cmsghdr;
+        pub fn cmsg_space(length: c_uint) -> usize;
+        pub fn cmsg_len(length: c_uint) -> usize;
+        pub fn cmsg_data(cmsg: *const cmsghdr) -> *mut c_uchar;
+    }
+
+    #[test]
+    fn test_cmsg_data() {
+        for l in 0..128 {
+            let pcmsghdr = l as *const cmsghdr;
+            unsafe {
+                assert_eq!(libc::CMSG_DATA(pcmsghdr), cmsg_data(pcmsghdr));
+            }
+        }
+    }
+
+    #[test]
+    fn test_cmsg_firsthdr() {
+        let mut mhdr: msghdr = unsafe { mem::zeroed() };
+        mhdr.msg_control = 0xdeadbeef as *mut c_void;
+        let pmhdr = &mhdr as *const msghdr;
+        for l in 0..128 {
+            mhdr.msg_controllen = l;
+            unsafe {
+                assert_eq!(libc::CMSG_FIRSTHDR(pmhdr), cmsg_firsthdr(pmhdr));
+            }
+        }
+    }
+
+    #[test]
+    fn test_cmsg_len() {
+        for l in 0..128 {
+            unsafe {
+                assert_eq!(libc::CMSG_LEN(l) as usize, cmsg_len(l));
+            }
+        }
+    }
+
+    // Skip on sparc64
+    // https://github.com/rust-lang/libc/issues/1239
+    #[cfg(not(target_arch = "sparc64"))]
+    #[test]
+    fn test_cmsg_nxthdr() {
+        use std::ptr;
+
+        let mut buffer = [0u8; 256];
+        let mut mhdr: msghdr = unsafe { mem::zeroed() };
+        let pmhdr = &mhdr as *const msghdr;
+        for start_ofs in 0..64 {
+            let pcmsghdr = &mut buffer[start_ofs] as *mut u8 as *mut cmsghdr;
+            mhdr.msg_control = pcmsghdr as *mut c_void;
+            mhdr.msg_controllen = (160 - start_ofs) as _;
+            for cmsg_len in 0..64 {
+                for next_cmsg_len in 0..32 {
+                    for i in buffer[start_ofs..].iter_mut() {
+                        *i = 0;
+                    }
+                    unsafe {
+                        (*pcmsghdr).cmsg_len = cmsg_len;
+                        let libc_next = libc::CMSG_NXTHDR(pmhdr, pcmsghdr);
+                        let next = cmsg_nxthdr(pmhdr, pcmsghdr);
+                        assert_eq!(libc_next, next);
+
+                        if libc_next != ptr::null_mut() {
+                            (*libc_next).cmsg_len = next_cmsg_len;
+                            let libc_next = libc::CMSG_NXTHDR(pmhdr, pcmsghdr);
+                            let next = cmsg_nxthdr(pmhdr, pcmsghdr);
+                            assert_eq!(libc_next, next);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    #[test]
+    fn test_cmsg_space() {
+        unsafe {
+            for l in 0..128 {
+                assert_eq!(libc::CMSG_SPACE(l) as usize, cmsg_space(l));
+            }
+        }
+    }
+}
diff --git a/library/libc/libc-test/test/errqueue.rs b/library/libc/libc-test/test/errqueue.rs
new file mode 100644
index 00000000..8d0c7bb7
--- /dev/null
+++ b/library/libc/libc-test/test/errqueue.rs
@@ -0,0 +1,22 @@
+//! Compare libc's SO_EE_OFFENDER function against the actual C macro
+
+extern crate libc;
+
+#[cfg(any(target_os = "linux", target_os = "android"))]
+mod t {
+    use libc::{self, sock_extended_err, sockaddr};
+
+    extern "C" {
+        pub fn so_ee_offender(ee: *const sock_extended_err) -> *mut sockaddr;
+    }
+
+    #[test]
+    fn test_cmsg_data() {
+        for l in 0..128 {
+            let ee = l as *const sock_extended_err;
+            unsafe {
+                assert_eq!(libc::SO_EE_OFFENDER(ee), so_ee_offender(ee));
+            }
+        }
+    }
+}
diff --git a/library/libc/libc-test/test/linux_elf.rs b/library/libc/libc-test/test/linux_elf.rs
new file mode 100644
index 00000000..d149c9aa
--- /dev/null
+++ b/library/libc/libc-test/test/linux_elf.rs
@@ -0,0 +1,12 @@
+#![allow(bad_style, improper_ctypes, unused, deprecated)]
+
+extern crate libc;
+use libc::*;
+
+#[cfg(target_os = "linux")]
+include!(concat!(env!("OUT_DIR"), "/linux_elf.rs"));
+
+#[cfg(not(target_os = "linux"))]
+fn main() {
+    println!("PASSED 0 tests");
+}
diff --git a/library/libc/libc-test/test/linux_fcntl.rs b/library/libc/libc-test/test/linux_fcntl.rs
new file mode 100644
index 00000000..49c06cc4
--- /dev/null
+++ b/library/libc/libc-test/test/linux_fcntl.rs
@@ -0,0 +1,12 @@
+#![allow(bad_style, improper_ctypes, unused, deprecated)]
+
+extern crate libc;
+use libc::*;
+
+#[cfg(any(target_os = "linux", target_os = "android"))]
+include!(concat!(env!("OUT_DIR"), "/linux_fcntl.rs"));
+
+#[cfg(not(any(target_os = "linux", target_os = "android")))]
+fn main() {
+    println!("PASSED 0 tests");
+}
diff --git a/library/libc/libc-test/test/linux_ipv6.rs b/library/libc/libc-test/test/linux_ipv6.rs
new file mode 100644
index 00000000..83c389ce
--- /dev/null
+++ b/library/libc/libc-test/test/linux_ipv6.rs
@@ -0,0 +1,12 @@
+#![allow(bad_style, improper_ctypes, unused, deprecated)]
+
+extern crate libc;
+use libc::*;
+
+#[cfg(target_os = "linux")]
+include!(concat!(env!("OUT_DIR"), "/linux_ipv6.rs"));
+
+#[cfg(not(target_os = "linux"))]
+fn main() {
+    println!("PASSED 0 tests");
+}
diff --git a/library/libc/libc-test/test/linux_strerror_r.rs b/library/libc/libc-test/test/linux_strerror_r.rs
new file mode 100644
index 00000000..17db959d
--- /dev/null
+++ b/library/libc/libc-test/test/linux_strerror_r.rs
@@ -0,0 +1,12 @@
+#![allow(bad_style, improper_ctypes, unused, deprecated)]
+
+extern crate libc;
+use libc::*;
+
+#[cfg(any(target_os = "linux", target_os = "android"))]
+include!(concat!(env!("OUT_DIR"), "/linux_strerror_r.rs"));
+
+#[cfg(not(any(target_os = "linux", target_os = "android")))]
+fn main() {
+    println!("PASSED 0 tests");
+}
diff --git a/library/libc/libc-test/test/linux_termios.rs b/library/libc/libc-test/test/linux_termios.rs
new file mode 100644
index 00000000..703a9b9b
--- /dev/null
+++ b/library/libc/libc-test/test/linux_termios.rs
@@ -0,0 +1,12 @@
+#![allow(bad_style, improper_ctypes, unused, deprecated)]
+
+extern crate libc;
+use libc::*;
+
+#[cfg(any(target_os = "linux", target_os = "android"))]
+include!(concat!(env!("OUT_DIR"), "/linux_termios.rs"));
+
+#[cfg(not(any(target_os = "linux", target_os = "android")))]
+fn main() {
+    println!("PASSED 0 tests");
+}
diff --git a/library/libc/libc-test/test/main.rs b/library/libc/libc-test/test/main.rs
new file mode 100644
index 00000000..62a587cf
--- /dev/null
+++ b/library/libc/libc-test/test/main.rs
@@ -0,0 +1,6 @@
+#![allow(bad_style, improper_ctypes, deprecated)]
+extern crate libc;
+
+use libc::*;
+
+include!(concat!(env!("OUT_DIR"), "/main.rs"));
diff --git a/library/libc/rustfmt.toml b/library/libc/rustfmt.toml
new file mode 100644
index 00000000..7ecc610f
--- /dev/null
+++ b/library/libc/rustfmt.toml
@@ -0,0 +1,3 @@
+max_width = 79
+comment_width = 79
+error_on_line_overflow = true
\ No newline at end of file
diff --git a/library/libc/src/fixed_width_ints.rs b/library/libc/src/fixed_width_ints.rs
new file mode 100644
index 00000000..01464085
--- /dev/null
+++ b/library/libc/src/fixed_width_ints.rs
@@ -0,0 +1,20 @@
+//! This module contains type aliases for C's fixed-width integer types .
+//!
+//! These aliases are deprecated: use the Rust types instead.
+
+#[deprecated(since = "0.2.55", note = "Use i8 instead.")]
+pub type int8_t = i8;
+#[deprecated(since = "0.2.55", note = "Use i16 instead.")]
+pub type int16_t = i16;
+#[deprecated(since = "0.2.55", note = "Use i32 instead.")]
+pub type int32_t = i32;
+#[deprecated(since = "0.2.55", note = "Use i64 instead.")]
+pub type int64_t = i64;
+#[deprecated(since = "0.2.55", note = "Use u8 instead.")]
+pub type uint8_t = u8;
+#[deprecated(since = "0.2.55", note = "Use u16 instead.")]
+pub type uint16_t = u16;
+#[deprecated(since = "0.2.55", note = "Use u32 instead.")]
+pub type uint32_t = u32;
+#[deprecated(since = "0.2.55", note = "Use u64 instead.")]
+pub type uint64_t = u64;
diff --git a/library/libc/src/fuchsia/aarch64.rs b/library/libc/src/fuchsia/aarch64.rs
new file mode 100644
index 00000000..259893c0
--- /dev/null
+++ b/library/libc/src/fuchsia/aarch64.rs
@@ -0,0 +1,66 @@
+pub type c_char = u8;
+pub type __u64 = ::c_ulonglong;
+pub type wchar_t = u32;
+pub type nlink_t = ::c_ulong;
+pub type blksize_t = ::c_long;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad0: ::c_ulong,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        __pad1: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_uint; 2],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad0: ::c_ulong,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        __pad1: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_uint; 2],
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong,
+    }
+}
+
+pub const MINSIGSTKSZ: ::size_t = 6144;
+pub const SIGSTKSZ: ::size_t = 12288;
diff --git a/library/libc/src/fuchsia/align.rs b/library/libc/src/fuchsia/align.rs
new file mode 100644
index 00000000..3409bf0c
--- /dev/null
+++ b/library/libc/src/fuchsia/align.rs
@@ -0,0 +1,142 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            #[cfg_attr(
+                any(
+                    target_pointer_width = "32",
+                    target_arch = "x86_64"
+                ),
+                repr(align(4)))]
+            #[cfg_attr(
+                not(any(
+                    target_pointer_width = "32",
+                    target_arch = "x86_64"
+                )),
+                repr(align(8)))]
+            pub struct pthread_mutexattr_t {
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            #[cfg_attr(target_pointer_width = "32",
+                       repr(align(4)))]
+            #[cfg_attr(target_pointer_width = "64",
+                       repr(align(8)))]
+            pub struct pthread_rwlockattr_t {
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_condattr_t {
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+
+        s_no_extra_traits! {
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "arm",
+                               target_arch = "x86_64")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "arm",
+                                   target_arch = "x86_64"))),
+                       repr(align(8)))]
+            pub struct pthread_mutex_t {
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "arm",
+                               target_arch = "x86_64")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "arm",
+                                   target_arch = "x86_64"))),
+                       repr(align(8)))]
+            pub struct pthread_rwlock_t {
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+
+            #[cfg_attr(target_pointer_width = "32",
+                       repr(align(4)))]
+            #[cfg_attr(target_pointer_width = "64",
+                       repr(align(8)))]
+            #[cfg_attr(target_arch = "x86",
+                       repr(align(4)))]
+            #[cfg_attr(not(target_arch = "x86"),
+                       repr(align(8)))]
+            pub struct pthread_cond_t {
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for pthread_cond_t {
+                    fn eq(&self, other: &pthread_cond_t) -> bool {
+                        self.size
+                            .iter()
+                            .zip(other.size.iter())
+                            .all(|(a,b)| a == b)
+                    }
+                }
+                impl Eq for pthread_cond_t {}
+                impl ::fmt::Debug for pthread_cond_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("pthread_cond_t")
+                            // FIXME: .field("size", &self.size)
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for pthread_cond_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.size.hash(state);
+                    }
+                }
+
+                impl PartialEq for pthread_mutex_t {
+                    fn eq(&self, other: &pthread_mutex_t) -> bool {
+                        self.size
+                            .iter()
+                            .zip(other.size.iter())
+                            .all(|(a,b)| a == b)
+                    }
+                }
+                impl Eq for pthread_mutex_t {}
+                impl ::fmt::Debug for pthread_mutex_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("pthread_mutex_t")
+                            // FIXME: .field("size", &self.size)
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for pthread_mutex_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.size.hash(state);
+                    }
+                }
+
+                impl PartialEq for pthread_rwlock_t {
+                    fn eq(&self, other: &pthread_rwlock_t) -> bool {
+                        self.size
+                            .iter()
+                            .zip(other.size.iter())
+                            .all(|(a,b)| a == b)
+                    }
+                }
+                impl Eq for pthread_rwlock_t {}
+                impl ::fmt::Debug for pthread_rwlock_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("pthread_rwlock_t")
+                            // FIXME: .field("size", &self.size)
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for pthread_rwlock_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.size.hash(state);
+                    }
+                }
+            }
+        }
+    };
+}
diff --git a/library/libc/src/fuchsia/mod.rs b/library/libc/src/fuchsia/mod.rs
new file mode 100644
index 00000000..f179923a
--- /dev/null
+++ b/library/libc/src/fuchsia/mod.rs
@@ -0,0 +1,4638 @@
+//! Definitions found commonly among almost all Unix derivatives
+//!
+//! More functions and definitions can be found in the more specific modules
+//! according to the platform in question.
+
+// PUB_TYPE
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_float = f32;
+pub type c_double = f64;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+
+pub type locale_t = *mut ::c_void;
+
+pub type size_t = usize;
+pub type ptrdiff_t = isize;
+pub type intptr_t = isize;
+pub type uintptr_t = usize;
+pub type ssize_t = isize;
+
+pub type pid_t = i32;
+pub type uid_t = u32;
+pub type gid_t = u32;
+pub type in_addr_t = u32;
+pub type in_port_t = u16;
+pub type sighandler_t = ::size_t;
+pub type cc_t = ::c_uchar;
+pub type sa_family_t = u16;
+pub type pthread_key_t = ::c_uint;
+pub type speed_t = ::c_uint;
+pub type tcflag_t = ::c_uint;
+pub type clockid_t = ::c_int;
+pub type key_t = ::c_int;
+pub type id_t = ::c_uint;
+pub type useconds_t = u32;
+pub type dev_t = u64;
+pub type socklen_t = u32;
+pub type pthread_t = c_ulong;
+pub type mode_t = u32;
+pub type ino64_t = u64;
+pub type off64_t = i64;
+pub type blkcnt64_t = i64;
+pub type rlim64_t = u64;
+pub type mqd_t = ::c_int;
+pub type nfds_t = ::c_ulong;
+pub type nl_item = ::c_int;
+pub type idtype_t = ::c_uint;
+pub type loff_t = ::c_longlong;
+
+pub type __u8 = ::c_uchar;
+pub type __u16 = ::c_ushort;
+pub type __s16 = ::c_short;
+pub type __u32 = ::c_uint;
+pub type __s32 = ::c_int;
+
+pub type Elf32_Half = u16;
+pub type Elf32_Word = u32;
+pub type Elf32_Off = u32;
+pub type Elf32_Addr = u32;
+
+pub type Elf64_Half = u16;
+pub type Elf64_Word = u32;
+pub type Elf64_Off = u64;
+pub type Elf64_Addr = u64;
+pub type Elf64_Xword = u64;
+
+pub type clock_t = c_long;
+pub type time_t = c_long;
+pub type suseconds_t = c_long;
+pub type ino_t = u64;
+pub type off_t = i64;
+pub type blkcnt_t = i64;
+
+pub type shmatt_t = ::c_ulong;
+pub type msgqnum_t = ::c_ulong;
+pub type msglen_t = ::c_ulong;
+pub type fsblkcnt_t = ::c_ulonglong;
+pub type fsfilcnt_t = ::c_ulonglong;
+pub type rlim_t = ::c_ulonglong;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+// FIXME: why are these uninhabited types? that seems... wrong?
+// Presumably these should be `()` or an `extern type` (when that stabilizes).
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum DIR {}
+impl ::Copy for DIR {}
+impl ::Clone for DIR {
+    fn clone(&self) -> DIR {
+        *self
+    }
+}
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum fpos64_t {} // FIXME: fill this out with a struct
+impl ::Copy for fpos64_t {}
+impl ::Clone for fpos64_t {
+    fn clone(&self) -> fpos64_t {
+        *self
+    }
+}
+
+// PUB_STRUCT
+
+s! {
+    pub struct group {
+        pub gr_name: *mut ::c_char,
+        pub gr_passwd: *mut ::c_char,
+        pub gr_gid: ::gid_t,
+        pub gr_mem: *mut *mut ::c_char,
+    }
+
+    pub struct utimbuf {
+        pub actime: time_t,
+        pub modtime: time_t,
+    }
+
+    pub struct timeval {
+        pub tv_sec: time_t,
+        pub tv_usec: suseconds_t,
+    }
+
+    pub struct timespec {
+        pub tv_sec: time_t,
+        pub tv_nsec: ::c_long,
+    }
+
+    // FIXME: the rlimit and rusage related functions and types don't exist
+    // within zircon. Are there reasons for keeping them around?
+    pub struct rlimit {
+        pub rlim_cur: rlim_t,
+        pub rlim_max: rlim_t,
+    }
+
+    pub struct rusage {
+        pub ru_utime: timeval,
+        pub ru_stime: timeval,
+        pub ru_maxrss: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad1: u32,
+        pub ru_ixrss: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad2: u32,
+        pub ru_idrss: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad3: u32,
+        pub ru_isrss: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad4: u32,
+        pub ru_minflt: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad5: u32,
+        pub ru_majflt: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad6: u32,
+        pub ru_nswap: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad7: u32,
+        pub ru_inblock: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad8: u32,
+        pub ru_oublock: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad9: u32,
+        pub ru_msgsnd: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad10: u32,
+        pub ru_msgrcv: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad11: u32,
+        pub ru_nsignals: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad12: u32,
+        pub ru_nvcsw: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad13: u32,
+        pub ru_nivcsw: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad14: u32,
+    }
+
+    pub struct in_addr {
+        pub s_addr: in_addr_t,
+    }
+
+    pub struct in6_addr {
+        pub s6_addr: [u8; 16],
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct ip_mreqn {
+        pub imr_multiaddr: in_addr,
+        pub imr_address: in_addr,
+        pub imr_ifindex: ::c_int,
+    }
+
+    pub struct ipv6_mreq {
+        pub ipv6mr_multiaddr: in6_addr,
+        pub ipv6mr_interface: ::c_uint,
+    }
+
+    pub struct hostent {
+        pub h_name: *mut ::c_char,
+        pub h_aliases: *mut *mut ::c_char,
+        pub h_addrtype: ::c_int,
+        pub h_length: ::c_int,
+        pub h_addr_list: *mut *mut ::c_char,
+    }
+
+    pub struct iovec {
+        pub iov_base: *mut ::c_void,
+        pub iov_len: ::size_t,
+    }
+
+    pub struct pollfd {
+        pub fd: ::c_int,
+        pub events: ::c_short,
+        pub revents: ::c_short,
+    }
+
+    pub struct winsize {
+        pub ws_row: ::c_ushort,
+        pub ws_col: ::c_ushort,
+        pub ws_xpixel: ::c_ushort,
+        pub ws_ypixel: ::c_ushort,
+    }
+
+    pub struct linger {
+        pub l_onoff: ::c_int,
+        pub l_linger: ::c_int,
+    }
+
+    pub struct sigval {
+        // Actually a union of an int and a void*
+        pub sival_ptr: *mut ::c_void
+    }
+
+    // <sys/time.h>
+    pub struct itimerval {
+        pub it_interval: ::timeval,
+        pub it_value: ::timeval,
+    }
+
+    // <sys/times.h>
+    pub struct tms {
+        pub tms_utime: ::clock_t,
+        pub tms_stime: ::clock_t,
+        pub tms_cutime: ::clock_t,
+        pub tms_cstime: ::clock_t,
+    }
+
+    pub struct servent {
+        pub s_name: *mut ::c_char,
+        pub s_aliases: *mut *mut ::c_char,
+        pub s_port: ::c_int,
+        pub s_proto: *mut ::c_char,
+    }
+
+    pub struct protoent {
+        pub p_name: *mut ::c_char,
+        pub p_aliases: *mut *mut ::c_char,
+        pub p_proto: ::c_int,
+    }
+
+    pub struct aiocb {
+        pub aio_fildes: ::c_int,
+        pub aio_lio_opcode: ::c_int,
+        pub aio_reqprio: ::c_int,
+        pub aio_buf: *mut ::c_void,
+        pub aio_nbytes: ::size_t,
+        pub aio_sigevent: ::sigevent,
+        __td: *mut ::c_void,
+        __lock: [::c_int; 2],
+        __err: ::c_int,
+        __ret: ::ssize_t,
+        pub aio_offset: off_t,
+        __next: *mut ::c_void,
+        __prev: *mut ::c_void,
+        #[cfg(target_pointer_width = "32")]
+        __dummy4: [::c_char; 24],
+        #[cfg(target_pointer_width = "64")]
+        __dummy4: [::c_char; 16],
+    }
+
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        pub __c_ispeed: ::speed_t,
+        pub __c_ospeed: ::speed_t,
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct ucred {
+        pub pid: ::pid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+    }
+
+    pub struct sockaddr {
+        pub sa_family: sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in {
+        pub sin_family: sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [u8; 8],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_family: sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: socklen_t,
+
+        pub ai_addr: *mut ::sockaddr,
+
+        pub ai_canonname: *mut c_char,
+
+        pub ai_next: *mut addrinfo,
+    }
+
+    pub struct sockaddr_ll {
+        pub sll_family: ::c_ushort,
+        pub sll_protocol: ::c_ushort,
+        pub sll_ifindex: ::c_int,
+        pub sll_hatype: ::c_ushort,
+        pub sll_pkttype: ::c_uchar,
+        pub sll_halen: ::c_uchar,
+        pub sll_addr: [::c_uchar; 8]
+    }
+
+    pub struct fd_set {
+        fds_bits: [::c_ulong; FD_SETSIZE / ULONG_SIZE],
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+        pub tm_gmtoff: ::c_long,
+        pub tm_zone: *const ::c_char,
+    }
+
+    pub struct sched_param {
+        pub sched_priority: ::c_int,
+        pub sched_ss_low_priority: ::c_int,
+        pub sched_ss_repl_period: ::timespec,
+        pub sched_ss_init_budget: ::timespec,
+        pub sched_ss_max_repl: ::c_int,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct epoll_event {
+        pub events: u32,
+        pub u64: u64,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct rlimit64 {
+        pub rlim_cur: rlim64_t,
+        pub rlim_max: rlim64_t,
+    }
+
+    pub struct glob_t {
+        pub gl_pathc: ::size_t,
+        pub gl_pathv: *mut *mut c_char,
+        pub gl_offs: ::size_t,
+        pub gl_flags: ::c_int,
+
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+    }
+
+    pub struct ifaddrs {
+        pub ifa_next: *mut ifaddrs,
+        pub ifa_name: *mut c_char,
+        pub ifa_flags: ::c_uint,
+        pub ifa_addr: *mut ::sockaddr,
+        pub ifa_netmask: *mut ::sockaddr,
+        pub ifa_ifu: *mut ::sockaddr, // FIXME This should be a union
+        pub ifa_data: *mut ::c_void
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct spwd {
+        pub sp_namp: *mut ::c_char,
+        pub sp_pwdp: *mut ::c_char,
+        pub sp_lstchg: ::c_long,
+        pub sp_min: ::c_long,
+        pub sp_max: ::c_long,
+        pub sp_warn: ::c_long,
+        pub sp_inact: ::c_long,
+        pub sp_expire: ::c_long,
+        pub sp_flag: ::c_ulong,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        #[cfg(target_endian = "little")]
+        pub f_fsid: ::c_ulong,
+        #[cfg(all(target_pointer_width = "32", not(target_arch = "x86_64")))]
+        __f_unused: ::c_int,
+        #[cfg(target_endian = "big")]
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct dqblk {
+        pub dqb_bhardlimit: u64,
+        pub dqb_bsoftlimit: u64,
+        pub dqb_curspace: u64,
+        pub dqb_ihardlimit: u64,
+        pub dqb_isoftlimit: u64,
+        pub dqb_curinodes: u64,
+        pub dqb_btime: u64,
+        pub dqb_itime: u64,
+        pub dqb_valid: u32,
+    }
+
+    pub struct signalfd_siginfo {
+        pub ssi_signo: u32,
+        pub ssi_errno: i32,
+        pub ssi_code: i32,
+        pub ssi_pid: u32,
+        pub ssi_uid: u32,
+        pub ssi_fd: i32,
+        pub ssi_tid: u32,
+        pub ssi_band: u32,
+        pub ssi_overrun: u32,
+        pub ssi_trapno: u32,
+        pub ssi_status: i32,
+        pub ssi_int: i32,
+        pub ssi_ptr: u64,
+        pub ssi_utime: u64,
+        pub ssi_stime: u64,
+        pub ssi_addr: u64,
+        pub ssi_addr_lsb: u16,
+        _pad2: u16,
+        pub ssi_syscall: i32,
+        pub ssi_call_addr: u64,
+        pub ssi_arch: u32,
+        _pad: [u8; 28],
+    }
+
+    pub struct itimerspec {
+        pub it_interval: ::timespec,
+        pub it_value: ::timespec,
+    }
+
+    pub struct fsid_t {
+        __val: [::c_int; 2],
+    }
+
+    pub struct cpu_set_t {
+        #[cfg(all(target_pointer_width = "32",
+                  not(target_arch = "x86_64")))]
+        bits: [u32; 32],
+        #[cfg(not(all(target_pointer_width = "32",
+                      not(target_arch = "x86_64"))))]
+        bits: [u64; 16],
+    }
+
+    pub struct if_nameindex {
+        pub if_index: ::c_uint,
+        pub if_name: *mut ::c_char,
+    }
+
+    // System V IPC
+    pub struct msginfo {
+        pub msgpool: ::c_int,
+        pub msgmap: ::c_int,
+        pub msgmax: ::c_int,
+        pub msgmnb: ::c_int,
+        pub msgmni: ::c_int,
+        pub msgssz: ::c_int,
+        pub msgtql: ::c_int,
+        pub msgseg: ::c_ushort,
+    }
+
+    pub struct mmsghdr {
+        pub msg_hdr: ::msghdr,
+        pub msg_len: ::c_uint,
+    }
+
+    pub struct sembuf {
+        pub sem_num: ::c_ushort,
+        pub sem_op: ::c_short,
+        pub sem_flg: ::c_short,
+    }
+
+    pub struct input_event {
+        pub time: ::timeval,
+        pub type_: ::__u16,
+        pub code: ::__u16,
+        pub value: ::__s32,
+    }
+
+    pub struct input_id {
+        pub bustype: ::__u16,
+        pub vendor: ::__u16,
+        pub product: ::__u16,
+        pub version: ::__u16,
+    }
+
+    pub struct input_absinfo {
+        pub value: ::__s32,
+        pub minimum: ::__s32,
+        pub maximum: ::__s32,
+        pub fuzz: ::__s32,
+        pub flat: ::__s32,
+        pub resolution: ::__s32,
+    }
+
+    pub struct input_keymap_entry {
+        pub flags: ::__u8,
+        pub len: ::__u8,
+        pub index: ::__u16,
+        pub keycode: ::__u32,
+        pub scancode: [::__u8; 32],
+    }
+
+    pub struct input_mask {
+        pub type_: ::__u32,
+        pub codes_size: ::__u32,
+        pub codes_ptr: ::__u64,
+    }
+
+    pub struct ff_replay {
+        pub length: ::__u16,
+        pub delay: ::__u16,
+    }
+
+    pub struct ff_trigger {
+        pub button: ::__u16,
+        pub interval: ::__u16,
+    }
+
+    pub struct ff_envelope {
+        pub attack_length: ::__u16,
+        pub attack_level: ::__u16,
+        pub fade_length: ::__u16,
+        pub fade_level: ::__u16,
+    }
+
+    pub struct ff_constant_effect {
+        pub level: ::__s16,
+        pub envelope: ff_envelope,
+    }
+
+    pub struct ff_ramp_effect {
+        pub start_level: ::__s16,
+        pub end_level: ::__s16,
+        pub envelope: ff_envelope,
+    }
+
+    pub struct ff_condition_effect {
+        pub right_saturation: ::__u16,
+        pub left_saturation: ::__u16,
+
+        pub right_coeff: ::__s16,
+        pub left_coeff: ::__s16,
+
+        pub deadband: ::__u16,
+        pub center: ::__s16,
+    }
+
+    pub struct ff_periodic_effect {
+        pub waveform: ::__u16,
+        pub period: ::__u16,
+        pub magnitude: ::__s16,
+        pub offset: ::__s16,
+        pub phase: ::__u16,
+
+        pub envelope: ff_envelope,
+
+        pub custom_len: ::__u32,
+        pub custom_data: *mut ::__s16,
+    }
+
+    pub struct ff_rumble_effect {
+        pub strong_magnitude: ::__u16,
+        pub weak_magnitude: ::__u16,
+    }
+
+    pub struct ff_effect {
+        pub type_: ::__u16,
+        pub id: ::__s16,
+        pub direction: ::__u16,
+        pub trigger: ff_trigger,
+        pub replay: ff_replay,
+        // FIXME this is actually a union
+        #[cfg(target_pointer_width = "64")]
+        pub u: [u64; 4],
+        #[cfg(target_pointer_width = "32")]
+        pub u: [u32; 7],
+    }
+
+    pub struct dl_phdr_info {
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_addr: Elf64_Addr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_addr: Elf32_Addr,
+
+        pub dlpi_name: *const ::c_char,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phdr: *const Elf64_Phdr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phdr: *const Elf32_Phdr,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phnum: Elf64_Half,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phnum: Elf32_Half,
+
+        pub dlpi_adds: ::c_ulonglong,
+        pub dlpi_subs: ::c_ulonglong,
+        pub dlpi_tls_modid: ::size_t,
+        pub dlpi_tls_data: *mut ::c_void,
+    }
+
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct pthread_attr_t {
+        __size: [u64; 7]
+    }
+
+    pub struct sigset_t {
+        __val: [::c_ulong; 16],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        pub msg_rtime: ::time_t,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        __pad1: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::socklen_t,
+        __pad2: ::socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::socklen_t,
+        pub __pad1: ::c_int,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct sem_t {
+        __val: [::c_int; 8],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct sysinfo {
+        pub uptime: ::c_ulong,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub __reserved: [::c_char; 256],
+    }
+
+    pub struct sockaddr_un {
+        pub sun_family: sa_family_t,
+        pub sun_path: [::c_char; 108]
+    }
+
+    pub struct sockaddr_storage {
+        pub ss_family: sa_family_t,
+        __ss_align: ::size_t,
+        __ss_pad2: [u8; 128 - 2 * 8],
+    }
+
+    pub struct utsname {
+        pub sysname: [::c_char; 65],
+        pub nodename: [::c_char; 65],
+        pub release: [::c_char; 65],
+        pub version: [::c_char; 65],
+        pub machine: [::c_char; 65],
+        pub domainname: [::c_char; 65]
+    }
+
+    pub struct dirent {
+        pub d_ino: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct dirent64 {
+        pub d_ino: ::ino64_t,
+        pub d_off: ::off64_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    // x32 compatibility
+    // See https://sourceware.org/bugzilla/show_bug.cgi?id=21279
+    pub struct mq_attr {
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub mq_flags: i64,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub mq_maxmsg: i64,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub mq_msgsize: i64,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub mq_curmsgs: i64,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pad: [i64; 4],
+
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub mq_flags: ::c_long,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub mq_maxmsg: ::c_long,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub mq_msgsize: ::c_long,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub mq_curmsgs: ::c_long,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pad: [::c_long; 4],
+    }
+
+    pub struct sockaddr_nl {
+        pub nl_family: ::sa_family_t,
+        nl_pad: ::c_ushort,
+        pub nl_pid: u32,
+        pub nl_groups: u32
+    }
+
+    pub struct sigevent {
+        pub sigev_value: ::sigval,
+        pub sigev_signo: ::c_int,
+        pub sigev_notify: ::c_int,
+        pub sigev_notify_function: fn(::sigval),
+        pub sigev_notify_attributes: *mut pthread_attr_t,
+        pub __pad: [::c_char; 56 - 3 * 8 /* 8 == sizeof(long) */],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for sysinfo {
+            fn eq(&self, other: &sysinfo) -> bool {
+                self.uptime == other.uptime
+                    && self.loads == other.loads
+                    && self.totalram == other.totalram
+                    && self.freeram == other.freeram
+                    && self.sharedram == other.sharedram
+                    && self.bufferram == other.bufferram
+                    && self.totalswap == other.totalswap
+                    && self.freeswap == other.freeswap
+                    && self.procs == other.procs
+                    && self.pad == other.pad
+                    && self.totalhigh == other.totalhigh
+                    && self.freehigh == other.freehigh
+                    && self.mem_unit == other.mem_unit
+                    && self
+                        .__reserved
+                        .iter()
+                        .zip(other.__reserved.iter())
+                        .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sysinfo {}
+        impl ::fmt::Debug for sysinfo {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sysinfo")
+                    .field("uptime", &self.uptime)
+                    .field("loads", &self.loads)
+                    .field("totalram", &self.totalram)
+                    .field("freeram", &self.freeram)
+                    .field("sharedram", &self.sharedram)
+                    .field("bufferram", &self.bufferram)
+                    .field("totalswap", &self.totalswap)
+                    .field("freeswap", &self.freeswap)
+                    .field("procs", &self.procs)
+                    .field("pad", &self.pad)
+                    .field("totalhigh", &self.totalhigh)
+                    .field("freehigh", &self.freehigh)
+                    .field("mem_unit", &self.mem_unit)
+                    // FIXME: .field("__reserved", &self.__reserved)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sysinfo {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uptime.hash(state);
+                self.loads.hash(state);
+                self.totalram.hash(state);
+                self.freeram.hash(state);
+                self.sharedram.hash(state);
+                self.bufferram.hash(state);
+                self.totalswap.hash(state);
+                self.freeswap.hash(state);
+                self.procs.hash(state);
+                self.pad.hash(state);
+                self.totalhigh.hash(state);
+                self.freehigh.hash(state);
+                self.mem_unit.hash(state);
+                self.__reserved.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_un {
+            fn eq(&self, other: &sockaddr_un) -> bool {
+                self.sun_family == other.sun_family
+                    && self
+                    .sun_path
+                    .iter()
+                    .zip(other.sun_path.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_un {}
+        impl ::fmt::Debug for sockaddr_un {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_un")
+                    .field("sun_family", &self.sun_family)
+                    // FIXME: .field("sun_path", &self.sun_path)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_un {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sun_family.hash(state);
+                self.sun_path.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_family == other.ss_family
+                    && self.__ss_align == other.__ss_align
+                    && self
+                    .__ss_pad2
+                    .iter()
+                    .zip(other.__ss_pad2.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_storage {}
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_align", &self.__ss_align)
+                    // FIXME: .field("__ss_pad2", &self.__ss_pad2)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_family.hash(state);
+                self.__ss_align.hash(state);
+                self.__ss_pad2.hash(state);
+            }
+        }
+
+        impl PartialEq for utsname {
+            fn eq(&self, other: &utsname) -> bool {
+                self.sysname
+                    .iter()
+                    .zip(other.sysname.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .nodename
+                    .iter()
+                    .zip(other.nodename.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .release
+                    .iter()
+                    .zip(other.release.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .version
+                    .iter()
+                    .zip(other.version.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .machine
+                    .iter()
+                    .zip(other.machine.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for utsname {}
+        impl ::fmt::Debug for utsname {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utsname")
+                    // FIXME: .field("sysname", &self.sysname)
+                    // FIXME: .field("nodename", &self.nodename)
+                    // FIXME: .field("release", &self.release)
+                    // FIXME: .field("version", &self.version)
+                    // FIXME: .field("machine", &self.machine)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for utsname {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sysname.hash(state);
+                self.nodename.hash(state);
+                self.release.hash(state);
+                self.version.hash(state);
+                self.machine.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent64 {
+            fn eq(&self, other: &dirent64) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent64 {}
+        impl ::fmt::Debug for dirent64 {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent64")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent64 {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for mq_attr {
+            fn eq(&self, other: &mq_attr) -> bool {
+                self.mq_flags == other.mq_flags &&
+                self.mq_maxmsg == other.mq_maxmsg &&
+                self.mq_msgsize == other.mq_msgsize &&
+                self.mq_curmsgs == other.mq_curmsgs
+            }
+        }
+        impl Eq for mq_attr {}
+        impl ::fmt::Debug for mq_attr {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("mq_attr")
+                    .field("mq_flags", &self.mq_flags)
+                    .field("mq_maxmsg", &self.mq_maxmsg)
+                    .field("mq_msgsize", &self.mq_msgsize)
+                    .field("mq_curmsgs", &self.mq_curmsgs)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for mq_attr {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.mq_flags.hash(state);
+                self.mq_maxmsg.hash(state);
+                self.mq_msgsize.hash(state);
+                self.mq_curmsgs.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_nl {
+            fn eq(&self, other: &sockaddr_nl) -> bool {
+                self.nl_family == other.nl_family &&
+                self.nl_pid == other.nl_pid &&
+                self.nl_groups == other.nl_groups
+            }
+        }
+        impl Eq for sockaddr_nl {}
+        impl ::fmt::Debug for sockaddr_nl {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_nl")
+                    .field("nl_family", &self.nl_family)
+                    .field("nl_pid", &self.nl_pid)
+                    .field("nl_groups", &self.nl_groups)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_nl {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.nl_family.hash(state);
+                self.nl_pid.hash(state);
+                self.nl_groups.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_value == other.sigev_value
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_notify == other.sigev_notify
+                    && self.sigev_notify_function
+                        == other.sigev_notify_function
+                    && self.sigev_notify_attributes
+                        == other.sigev_notify_attributes
+            }
+        }
+        impl Eq for sigevent {}
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_value", &self.sigev_value)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_notify_function", &self.sigev_notify_function)
+                    .field("sigev_notify_attributes",
+                           &self.sigev_notify_attributes)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_value.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_notify.hash(state);
+                self.sigev_notify_function.hash(state);
+                self.sigev_notify_attributes.hash(state);
+            }
+        }
+    }
+}
+
+// PUB_CONST
+
+pub const INT_MIN: c_int = -2147483648;
+pub const INT_MAX: c_int = 2147483647;
+
+pub const SIG_DFL: sighandler_t = 0 as sighandler_t;
+pub const SIG_IGN: sighandler_t = 1 as sighandler_t;
+pub const SIG_ERR: sighandler_t = !0 as sighandler_t;
+
+pub const DT_FIFO: u8 = 1;
+pub const DT_CHR: u8 = 2;
+pub const DT_DIR: u8 = 4;
+pub const DT_BLK: u8 = 6;
+pub const DT_REG: u8 = 8;
+pub const DT_LNK: u8 = 10;
+pub const DT_SOCK: u8 = 12;
+
+pub const FD_CLOEXEC: ::c_int = 0x1;
+
+pub const USRQUOTA: ::c_int = 0;
+pub const GRPQUOTA: ::c_int = 1;
+
+pub const SIGIOT: ::c_int = 6;
+
+pub const S_ISUID: ::c_int = 0x800;
+pub const S_ISGID: ::c_int = 0x400;
+pub const S_ISVTX: ::c_int = 0x200;
+
+pub const IF_NAMESIZE: ::size_t = 16;
+pub const IFNAMSIZ: ::size_t = IF_NAMESIZE;
+
+pub const LOG_EMERG: ::c_int = 0;
+pub const LOG_ALERT: ::c_int = 1;
+pub const LOG_CRIT: ::c_int = 2;
+pub const LOG_ERR: ::c_int = 3;
+pub const LOG_WARNING: ::c_int = 4;
+pub const LOG_NOTICE: ::c_int = 5;
+pub const LOG_INFO: ::c_int = 6;
+pub const LOG_DEBUG: ::c_int = 7;
+
+pub const LOG_KERN: ::c_int = 0;
+pub const LOG_USER: ::c_int = 1 << 3;
+pub const LOG_MAIL: ::c_int = 2 << 3;
+pub const LOG_DAEMON: ::c_int = 3 << 3;
+pub const LOG_AUTH: ::c_int = 4 << 3;
+pub const LOG_SYSLOG: ::c_int = 5 << 3;
+pub const LOG_LPR: ::c_int = 6 << 3;
+pub const LOG_NEWS: ::c_int = 7 << 3;
+pub const LOG_UUCP: ::c_int = 8 << 3;
+pub const LOG_LOCAL0: ::c_int = 16 << 3;
+pub const LOG_LOCAL1: ::c_int = 17 << 3;
+pub const LOG_LOCAL2: ::c_int = 18 << 3;
+pub const LOG_LOCAL3: ::c_int = 19 << 3;
+pub const LOG_LOCAL4: ::c_int = 20 << 3;
+pub const LOG_LOCAL5: ::c_int = 21 << 3;
+pub const LOG_LOCAL6: ::c_int = 22 << 3;
+pub const LOG_LOCAL7: ::c_int = 23 << 3;
+
+pub const LOG_PID: ::c_int = 0x01;
+pub const LOG_CONS: ::c_int = 0x02;
+pub const LOG_ODELAY: ::c_int = 0x04;
+pub const LOG_NDELAY: ::c_int = 0x08;
+pub const LOG_NOWAIT: ::c_int = 0x10;
+
+pub const LOG_PRIMASK: ::c_int = 7;
+pub const LOG_FACMASK: ::c_int = 0x3f8;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+pub const PRIO_MIN: ::c_int = -20;
+pub const PRIO_MAX: ::c_int = 20;
+
+pub const IPPROTO_ICMP: ::c_int = 1;
+pub const IPPROTO_ICMPV6: ::c_int = 58;
+pub const IPPROTO_TCP: ::c_int = 6;
+pub const IPPROTO_UDP: ::c_int = 17;
+pub const IPPROTO_IP: ::c_int = 0;
+pub const IPPROTO_IPV6: ::c_int = 41;
+
+pub const INADDR_LOOPBACK: in_addr_t = 2130706433;
+pub const INADDR_ANY: in_addr_t = 0;
+pub const INADDR_BROADCAST: in_addr_t = 4294967295;
+pub const INADDR_NONE: in_addr_t = 4294967295;
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const RAND_MAX: ::c_int = 2147483647;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 2;
+pub const _IOLBF: ::c_int = 1;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+
+// Linux-specific fcntls
+pub const F_SETLEASE: ::c_int = 1024;
+pub const F_GETLEASE: ::c_int = 1025;
+pub const F_NOTIFY: ::c_int = 1026;
+pub const F_CANCELLK: ::c_int = 1029;
+pub const F_DUPFD_CLOEXEC: ::c_int = 1030;
+pub const F_SETPIPE_SZ: ::c_int = 1031;
+pub const F_GETPIPE_SZ: ::c_int = 1032;
+pub const F_ADD_SEALS: ::c_int = 1033;
+pub const F_GET_SEALS: ::c_int = 1034;
+
+pub const F_SEAL_SEAL: ::c_int = 0x0001;
+pub const F_SEAL_SHRINK: ::c_int = 0x0002;
+pub const F_SEAL_GROW: ::c_int = 0x0004;
+pub const F_SEAL_WRITE: ::c_int = 0x0008;
+
+// FIXME(#235): Include file sealing fcntls once we have a way to verify them.
+
+pub const SIGTRAP: ::c_int = 5;
+
+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;
+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;
+
+pub const CLOCK_REALTIME: ::clockid_t = 0;
+pub const CLOCK_MONOTONIC: ::clockid_t = 1;
+pub const CLOCK_PROCESS_CPUTIME_ID: ::clockid_t = 2;
+pub const CLOCK_THREAD_CPUTIME_ID: ::clockid_t = 3;
+pub const CLOCK_MONOTONIC_RAW: ::clockid_t = 4;
+pub const CLOCK_REALTIME_COARSE: ::clockid_t = 5;
+pub const CLOCK_MONOTONIC_COARSE: ::clockid_t = 6;
+pub const CLOCK_BOOTTIME: ::clockid_t = 7;
+pub const CLOCK_REALTIME_ALARM: ::clockid_t = 8;
+pub const CLOCK_BOOTTIME_ALARM: ::clockid_t = 9;
+pub const CLOCK_SGI_CYCLE: ::clockid_t = 10;
+pub const CLOCK_TAI: ::clockid_t = 11;
+pub const TIMER_ABSTIME: ::c_int = 1;
+
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_LOCKS: ::c_int = 10;
+pub const RLIMIT_SIGPENDING: ::c_int = 11;
+pub const RLIMIT_MSGQUEUE: ::c_int = 12;
+pub const RLIMIT_NICE: ::c_int = 13;
+pub const RLIMIT_RTPRIO: ::c_int = 14;
+
+pub const RUSAGE_SELF: ::c_int = 0;
+
+pub const O_RDONLY: ::c_int = 0;
+pub const O_WRONLY: ::c_int = 1;
+pub const O_RDWR: ::c_int = 2;
+
+pub const S_IFIFO: ::mode_t = 4096;
+pub const S_IFCHR: ::mode_t = 8192;
+pub const S_IFBLK: ::mode_t = 24576;
+pub const S_IFDIR: ::mode_t = 16384;
+pub const S_IFREG: ::mode_t = 32768;
+pub const S_IFLNK: ::mode_t = 40960;
+pub const S_IFSOCK: ::mode_t = 49152;
+pub const S_IFMT: ::mode_t = 61440;
+pub const S_IRWXU: ::mode_t = 448;
+pub const S_IXUSR: ::mode_t = 64;
+pub const S_IWUSR: ::mode_t = 128;
+pub const S_IRUSR: ::mode_t = 256;
+pub const S_IRWXG: ::mode_t = 56;
+pub const S_IXGRP: ::mode_t = 8;
+pub const S_IWGRP: ::mode_t = 16;
+pub const S_IRGRP: ::mode_t = 32;
+pub const S_IRWXO: ::mode_t = 7;
+pub const S_IXOTH: ::mode_t = 1;
+pub const S_IWOTH: ::mode_t = 2;
+pub const S_IROTH: ::mode_t = 4;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+
+pub const PROT_NONE: ::c_int = 0;
+pub const PROT_READ: ::c_int = 1;
+pub const PROT_WRITE: ::c_int = 2;
+pub const PROT_EXEC: ::c_int = 4;
+
+pub const LC_CTYPE: ::c_int = 0;
+pub const LC_NUMERIC: ::c_int = 1;
+pub const LC_TIME: ::c_int = 2;
+pub const LC_COLLATE: ::c_int = 3;
+pub const LC_MONETARY: ::c_int = 4;
+pub const LC_MESSAGES: ::c_int = 5;
+pub const LC_ALL: ::c_int = 6;
+pub const LC_CTYPE_MASK: ::c_int = 1 << LC_CTYPE;
+pub const LC_NUMERIC_MASK: ::c_int = 1 << LC_NUMERIC;
+pub const LC_TIME_MASK: ::c_int = 1 << LC_TIME;
+pub const LC_COLLATE_MASK: ::c_int = 1 << LC_COLLATE;
+pub const LC_MONETARY_MASK: ::c_int = 1 << LC_MONETARY;
+pub const LC_MESSAGES_MASK: ::c_int = 1 << LC_MESSAGES;
+// LC_ALL_MASK defined per platform
+
+pub const MAP_FILE: ::c_int = 0x0000;
+pub const MAP_SHARED: ::c_int = 0x0001;
+pub const MAP_PRIVATE: ::c_int = 0x0002;
+pub const MAP_FIXED: ::c_int = 0x0010;
+
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+// MS_ flags for msync(2)
+pub const MS_ASYNC: ::c_int = 0x0001;
+pub const MS_INVALIDATE: ::c_int = 0x0002;
+pub const MS_SYNC: ::c_int = 0x0004;
+
+// MS_ flags for mount(2)
+pub const MS_RDONLY: ::c_ulong = 0x01;
+pub const MS_NOSUID: ::c_ulong = 0x02;
+pub const MS_NODEV: ::c_ulong = 0x04;
+pub const MS_NOEXEC: ::c_ulong = 0x08;
+pub const MS_SYNCHRONOUS: ::c_ulong = 0x10;
+pub const MS_REMOUNT: ::c_ulong = 0x20;
+pub const MS_MANDLOCK: ::c_ulong = 0x40;
+pub const MS_DIRSYNC: ::c_ulong = 0x80;
+pub const MS_NOATIME: ::c_ulong = 0x0400;
+pub const MS_NODIRATIME: ::c_ulong = 0x0800;
+pub const MS_BIND: ::c_ulong = 0x1000;
+pub const MS_MOVE: ::c_ulong = 0x2000;
+pub const MS_REC: ::c_ulong = 0x4000;
+pub const MS_SILENT: ::c_ulong = 0x8000;
+pub const MS_POSIXACL: ::c_ulong = 0x010000;
+pub const MS_UNBINDABLE: ::c_ulong = 0x020000;
+pub const MS_PRIVATE: ::c_ulong = 0x040000;
+pub const MS_SLAVE: ::c_ulong = 0x080000;
+pub const MS_SHARED: ::c_ulong = 0x100000;
+pub const MS_RELATIME: ::c_ulong = 0x200000;
+pub const MS_KERNMOUNT: ::c_ulong = 0x400000;
+pub const MS_I_VERSION: ::c_ulong = 0x800000;
+pub const MS_STRICTATIME: ::c_ulong = 0x1000000;
+pub const MS_ACTIVE: ::c_ulong = 0x40000000;
+pub const MS_NOUSER: ::c_ulong = 0x80000000;
+pub const MS_MGC_VAL: ::c_ulong = 0xc0ed0000;
+pub const MS_MGC_MSK: ::c_ulong = 0xffff0000;
+pub const MS_RMT_MASK: ::c_ulong = 0x800051;
+
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+
+pub const SCM_RIGHTS: ::c_int = 0x01;
+pub const SCM_CREDENTIALS: ::c_int = 0x02;
+
+pub const PROT_GROWSDOWN: ::c_int = 0x1000000;
+pub const PROT_GROWSUP: ::c_int = 0x2000000;
+
+pub const MAP_TYPE: ::c_int = 0x000f;
+
+pub const MADV_NORMAL: ::c_int = 0;
+pub const MADV_RANDOM: ::c_int = 1;
+pub const MADV_SEQUENTIAL: ::c_int = 2;
+pub const MADV_WILLNEED: ::c_int = 3;
+pub const MADV_DONTNEED: ::c_int = 4;
+pub const MADV_FREE: ::c_int = 8;
+pub const MADV_REMOVE: ::c_int = 9;
+pub const MADV_DONTFORK: ::c_int = 10;
+pub const MADV_DOFORK: ::c_int = 11;
+pub const MADV_MERGEABLE: ::c_int = 12;
+pub const MADV_UNMERGEABLE: ::c_int = 13;
+pub const MADV_HUGEPAGE: ::c_int = 14;
+pub const MADV_NOHUGEPAGE: ::c_int = 15;
+pub const MADV_DONTDUMP: ::c_int = 16;
+pub const MADV_DODUMP: ::c_int = 17;
+pub const MADV_HWPOISON: ::c_int = 100;
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+
+pub const IFF_UP: ::c_int = 0x1;
+pub const IFF_BROADCAST: ::c_int = 0x2;
+pub const IFF_DEBUG: ::c_int = 0x4;
+pub const IFF_LOOPBACK: ::c_int = 0x8;
+pub const IFF_POINTOPOINT: ::c_int = 0x10;
+pub const IFF_NOTRAILERS: ::c_int = 0x20;
+pub const IFF_RUNNING: ::c_int = 0x40;
+pub const IFF_NOARP: ::c_int = 0x80;
+pub const IFF_PROMISC: ::c_int = 0x100;
+pub const IFF_ALLMULTI: ::c_int = 0x200;
+pub const IFF_MASTER: ::c_int = 0x400;
+pub const IFF_SLAVE: ::c_int = 0x800;
+pub const IFF_MULTICAST: ::c_int = 0x1000;
+pub const IFF_PORTSEL: ::c_int = 0x2000;
+pub const IFF_AUTOMEDIA: ::c_int = 0x4000;
+pub const IFF_DYNAMIC: ::c_int = 0x8000;
+pub const IFF_TUN: ::c_int = 0x0001;
+pub const IFF_TAP: ::c_int = 0x0002;
+pub const IFF_NO_PI: ::c_int = 0x1000;
+
+pub const SOL_IP: ::c_int = 0;
+pub const SOL_TCP: ::c_int = 6;
+pub const SOL_UDP: ::c_int = 17;
+pub const SOL_IPV6: ::c_int = 41;
+pub const SOL_ICMPV6: ::c_int = 58;
+pub const SOL_RAW: ::c_int = 255;
+pub const SOL_DECNET: ::c_int = 261;
+pub const SOL_X25: ::c_int = 262;
+pub const SOL_PACKET: ::c_int = 263;
+pub const SOL_ATM: ::c_int = 264;
+pub const SOL_AAL: ::c_int = 265;
+pub const SOL_IRDA: ::c_int = 266;
+pub const SOL_NETBEUI: ::c_int = 267;
+pub const SOL_LLC: ::c_int = 268;
+pub const SOL_DCCP: ::c_int = 269;
+pub const SOL_NETLINK: ::c_int = 270;
+pub const SOL_TIPC: ::c_int = 271;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_UNIX: ::c_int = 1;
+pub const AF_LOCAL: ::c_int = 1;
+pub const AF_INET: ::c_int = 2;
+pub const AF_AX25: ::c_int = 3;
+pub const AF_IPX: ::c_int = 4;
+pub const AF_APPLETALK: ::c_int = 5;
+pub const AF_NETROM: ::c_int = 6;
+pub const AF_BRIDGE: ::c_int = 7;
+pub const AF_ATMPVC: ::c_int = 8;
+pub const AF_X25: ::c_int = 9;
+pub const AF_INET6: ::c_int = 10;
+pub const AF_ROSE: ::c_int = 11;
+pub const AF_DECnet: ::c_int = 12;
+pub const AF_NETBEUI: ::c_int = 13;
+pub const AF_SECURITY: ::c_int = 14;
+pub const AF_KEY: ::c_int = 15;
+pub const AF_NETLINK: ::c_int = 16;
+pub const AF_ROUTE: ::c_int = AF_NETLINK;
+pub const AF_PACKET: ::c_int = 17;
+pub const AF_ASH: ::c_int = 18;
+pub const AF_ECONET: ::c_int = 19;
+pub const AF_ATMSVC: ::c_int = 20;
+pub const AF_RDS: ::c_int = 21;
+pub const AF_SNA: ::c_int = 22;
+pub const AF_IRDA: ::c_int = 23;
+pub const AF_PPPOX: ::c_int = 24;
+pub const AF_WANPIPE: ::c_int = 25;
+pub const AF_LLC: ::c_int = 26;
+pub const AF_CAN: ::c_int = 29;
+pub const AF_TIPC: ::c_int = 30;
+pub const AF_BLUETOOTH: ::c_int = 31;
+pub const AF_IUCV: ::c_int = 32;
+pub const AF_RXRPC: ::c_int = 33;
+pub const AF_ISDN: ::c_int = 34;
+pub const AF_PHONET: ::c_int = 35;
+pub const AF_IEEE802154: ::c_int = 36;
+pub const AF_CAIF: ::c_int = 37;
+pub const AF_ALG: ::c_int = 38;
+
+pub const PF_UNSPEC: ::c_int = AF_UNSPEC;
+pub const PF_UNIX: ::c_int = AF_UNIX;
+pub const PF_LOCAL: ::c_int = AF_LOCAL;
+pub const PF_INET: ::c_int = AF_INET;
+pub const PF_AX25: ::c_int = AF_AX25;
+pub const PF_IPX: ::c_int = AF_IPX;
+pub const PF_APPLETALK: ::c_int = AF_APPLETALK;
+pub const PF_NETROM: ::c_int = AF_NETROM;
+pub const PF_BRIDGE: ::c_int = AF_BRIDGE;
+pub const PF_ATMPVC: ::c_int = AF_ATMPVC;
+pub const PF_X25: ::c_int = AF_X25;
+pub const PF_INET6: ::c_int = AF_INET6;
+pub const PF_ROSE: ::c_int = AF_ROSE;
+pub const PF_DECnet: ::c_int = AF_DECnet;
+pub const PF_NETBEUI: ::c_int = AF_NETBEUI;
+pub const PF_SECURITY: ::c_int = AF_SECURITY;
+pub const PF_KEY: ::c_int = AF_KEY;
+pub const PF_NETLINK: ::c_int = AF_NETLINK;
+pub const PF_ROUTE: ::c_int = AF_ROUTE;
+pub const PF_PACKET: ::c_int = AF_PACKET;
+pub const PF_ASH: ::c_int = AF_ASH;
+pub const PF_ECONET: ::c_int = AF_ECONET;
+pub const PF_ATMSVC: ::c_int = AF_ATMSVC;
+pub const PF_RDS: ::c_int = AF_RDS;
+pub const PF_SNA: ::c_int = AF_SNA;
+pub const PF_IRDA: ::c_int = AF_IRDA;
+pub const PF_PPPOX: ::c_int = AF_PPPOX;
+pub const PF_WANPIPE: ::c_int = AF_WANPIPE;
+pub const PF_LLC: ::c_int = AF_LLC;
+pub const PF_CAN: ::c_int = AF_CAN;
+pub const PF_TIPC: ::c_int = AF_TIPC;
+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;
+pub const PF_IUCV: ::c_int = AF_IUCV;
+pub const PF_RXRPC: ::c_int = AF_RXRPC;
+pub const PF_ISDN: ::c_int = AF_ISDN;
+pub const PF_PHONET: ::c_int = AF_PHONET;
+pub const PF_IEEE802154: ::c_int = AF_IEEE802154;
+pub const PF_CAIF: ::c_int = AF_CAIF;
+pub const PF_ALG: ::c_int = AF_ALG;
+
+pub const SOMAXCONN: ::c_int = 128;
+
+pub const MSG_OOB: ::c_int = 1;
+pub const MSG_PEEK: ::c_int = 2;
+pub const MSG_DONTROUTE: ::c_int = 4;
+pub const MSG_CTRUNC: ::c_int = 8;
+pub const MSG_TRUNC: ::c_int = 0x20;
+pub const MSG_DONTWAIT: ::c_int = 0x40;
+pub const MSG_EOR: ::c_int = 0x80;
+pub const MSG_WAITALL: ::c_int = 0x100;
+pub const MSG_FIN: ::c_int = 0x200;
+pub const MSG_SYN: ::c_int = 0x400;
+pub const MSG_CONFIRM: ::c_int = 0x800;
+pub const MSG_RST: ::c_int = 0x1000;
+pub const MSG_ERRQUEUE: ::c_int = 0x2000;
+pub const MSG_NOSIGNAL: ::c_int = 0x4000;
+pub const MSG_MORE: ::c_int = 0x8000;
+pub const MSG_WAITFORONE: ::c_int = 0x10000;
+pub const MSG_FASTOPEN: ::c_int = 0x20000000;
+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x40000000;
+
+pub const SCM_TIMESTAMP: ::c_int = SO_TIMESTAMP;
+
+pub const SOCK_RAW: ::c_int = 3;
+pub const SOCK_RDM: ::c_int = 4;
+
+pub const IP_TTL: ::c_int = 2;
+pub const IP_HDRINCL: ::c_int = 3;
+pub const IP_FREEBIND: ::c_int = 15;
+pub const IP_TRANSPARENT: ::c_int = 19;
+pub const IP_MULTICAST_IF: ::c_int = 32;
+pub const IP_MULTICAST_TTL: ::c_int = 33;
+pub const IP_MULTICAST_LOOP: ::c_int = 34;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 35;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 36;
+
+pub const IPV6_UNICAST_HOPS: ::c_int = 16;
+pub const IPV6_MULTICAST_IF: ::c_int = 17;
+pub const IPV6_MULTICAST_HOPS: ::c_int = 18;
+pub const IPV6_MULTICAST_LOOP: ::c_int = 19;
+pub const IPV6_ADD_MEMBERSHIP: ::c_int = 20;
+pub const IPV6_DROP_MEMBERSHIP: ::c_int = 21;
+pub const IPV6_V6ONLY: ::c_int = 26;
+
+pub const TCP_NODELAY: ::c_int = 1;
+pub const TCP_MAXSEG: ::c_int = 2;
+pub const TCP_CORK: ::c_int = 3;
+pub const TCP_KEEPIDLE: ::c_int = 4;
+pub const TCP_KEEPINTVL: ::c_int = 5;
+pub const TCP_KEEPCNT: ::c_int = 6;
+pub const TCP_SYNCNT: ::c_int = 7;
+pub const TCP_LINGER2: ::c_int = 8;
+pub const TCP_DEFER_ACCEPT: ::c_int = 9;
+pub const TCP_WINDOW_CLAMP: ::c_int = 10;
+pub const TCP_INFO: ::c_int = 11;
+pub const TCP_QUICKACK: ::c_int = 12;
+pub const TCP_CONGESTION: ::c_int = 13;
+
+pub const SO_DEBUG: ::c_int = 1;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const LOCK_SH: ::c_int = 1;
+pub const LOCK_EX: ::c_int = 2;
+pub const LOCK_NB: ::c_int = 4;
+pub const LOCK_UN: ::c_int = 8;
+
+pub const SS_ONSTACK: ::c_int = 1;
+pub const SS_DISABLE: ::c_int = 2;
+
+pub const PATH_MAX: ::c_int = 4096;
+
+pub const FD_SETSIZE: usize = 1024;
+
+pub const EPOLLIN: ::c_int = 0x1;
+pub const EPOLLPRI: ::c_int = 0x2;
+pub const EPOLLOUT: ::c_int = 0x4;
+pub const EPOLLRDNORM: ::c_int = 0x40;
+pub const EPOLLRDBAND: ::c_int = 0x80;
+pub const EPOLLWRNORM: ::c_int = 0x100;
+pub const EPOLLWRBAND: ::c_int = 0x200;
+pub const EPOLLMSG: ::c_int = 0x400;
+pub const EPOLLERR: ::c_int = 0x8;
+pub const EPOLLHUP: ::c_int = 0x10;
+pub const EPOLLET: ::c_int = 0x80000000;
+
+pub const EPOLL_CTL_ADD: ::c_int = 1;
+pub const EPOLL_CTL_MOD: ::c_int = 3;
+pub const EPOLL_CTL_DEL: ::c_int = 2;
+
+pub const MNT_DETACH: ::c_int = 0x2;
+pub const MNT_EXPIRE: ::c_int = 0x4;
+
+pub const Q_GETFMT: ::c_int = 0x800004;
+pub const Q_GETINFO: ::c_int = 0x800005;
+pub const Q_SETINFO: ::c_int = 0x800006;
+pub const QIF_BLIMITS: u32 = 1;
+pub const QIF_SPACE: u32 = 2;
+pub const QIF_ILIMITS: u32 = 4;
+pub const QIF_INODES: u32 = 8;
+pub const QIF_BTIME: u32 = 16;
+pub const QIF_ITIME: u32 = 32;
+pub const QIF_LIMITS: u32 = 5;
+pub const QIF_USAGE: u32 = 10;
+pub const QIF_TIMES: u32 = 48;
+pub const QIF_ALL: u32 = 63;
+
+pub const MNT_FORCE: ::c_int = 0x1;
+
+pub const Q_SYNC: ::c_int = 0x800001;
+pub const Q_QUOTAON: ::c_int = 0x800002;
+pub const Q_QUOTAOFF: ::c_int = 0x800003;
+pub const Q_GETQUOTA: ::c_int = 0x800007;
+pub const Q_SETQUOTA: ::c_int = 0x800008;
+
+pub const TCIOFF: ::c_int = 2;
+pub const TCION: ::c_int = 3;
+pub const TCOOFF: ::c_int = 0;
+pub const TCOON: ::c_int = 1;
+pub const TCIFLUSH: ::c_int = 0;
+pub const TCOFLUSH: ::c_int = 1;
+pub const TCIOFLUSH: ::c_int = 2;
+pub const NL0: ::c_int = 0x00000000;
+pub const NL1: ::c_int = 0x00000100;
+pub const TAB0: ::c_int = 0x00000000;
+pub const CR0: ::c_int = 0x00000000;
+pub const FF0: ::c_int = 0x00000000;
+pub const BS0: ::c_int = 0x00000000;
+pub const VT0: ::c_int = 0x00000000;
+pub const VERASE: usize = 2;
+pub const VKILL: usize = 3;
+pub const VINTR: usize = 0;
+pub const VQUIT: usize = 1;
+pub const VLNEXT: usize = 15;
+pub const IGNBRK: ::tcflag_t = 0x00000001;
+pub const BRKINT: ::tcflag_t = 0x00000002;
+pub const IGNPAR: ::tcflag_t = 0x00000004;
+pub const PARMRK: ::tcflag_t = 0x00000008;
+pub const INPCK: ::tcflag_t = 0x00000010;
+pub const ISTRIP: ::tcflag_t = 0x00000020;
+pub const INLCR: ::tcflag_t = 0x00000040;
+pub const IGNCR: ::tcflag_t = 0x00000080;
+pub const ICRNL: ::tcflag_t = 0x00000100;
+pub const IXANY: ::tcflag_t = 0x00000800;
+pub const IMAXBEL: ::tcflag_t = 0x00002000;
+pub const OPOST: ::tcflag_t = 0x1;
+pub const CS5: ::tcflag_t = 0x00000000;
+pub const CRTSCTS: ::tcflag_t = 0x80000000;
+pub const ECHO: ::tcflag_t = 0x00000008;
+pub const OCRNL: ::tcflag_t = 0o000010;
+pub const ONOCR: ::tcflag_t = 0o000020;
+pub const ONLRET: ::tcflag_t = 0o000040;
+pub const OFILL: ::tcflag_t = 0o000100;
+pub const OFDEL: ::tcflag_t = 0o000200;
+
+pub const CLONE_VM: ::c_int = 0x100;
+pub const CLONE_FS: ::c_int = 0x200;
+pub const CLONE_FILES: ::c_int = 0x400;
+pub const CLONE_SIGHAND: ::c_int = 0x800;
+pub const CLONE_PTRACE: ::c_int = 0x2000;
+pub const CLONE_VFORK: ::c_int = 0x4000;
+pub const CLONE_PARENT: ::c_int = 0x8000;
+pub const CLONE_THREAD: ::c_int = 0x10000;
+pub const CLONE_NEWNS: ::c_int = 0x20000;
+pub const CLONE_SYSVSEM: ::c_int = 0x40000;
+pub const CLONE_SETTLS: ::c_int = 0x80000;
+pub const CLONE_PARENT_SETTID: ::c_int = 0x100000;
+pub const CLONE_CHILD_CLEARTID: ::c_int = 0x200000;
+pub const CLONE_DETACHED: ::c_int = 0x400000;
+pub const CLONE_UNTRACED: ::c_int = 0x800000;
+pub const CLONE_CHILD_SETTID: ::c_int = 0x01000000;
+pub const CLONE_NEWUTS: ::c_int = 0x04000000;
+pub const CLONE_NEWIPC: ::c_int = 0x08000000;
+pub const CLONE_NEWUSER: ::c_int = 0x10000000;
+pub const CLONE_NEWPID: ::c_int = 0x20000000;
+pub const CLONE_NEWNET: ::c_int = 0x40000000;
+pub const CLONE_IO: ::c_int = 0x80000000;
+pub const CLONE_NEWCGROUP: ::c_int = 0x02000000;
+
+pub const WNOHANG: ::c_int = 0x00000001;
+pub const WUNTRACED: ::c_int = 0x00000002;
+pub const WSTOPPED: ::c_int = WUNTRACED;
+pub const WEXITED: ::c_int = 0x00000004;
+pub const WCONTINUED: ::c_int = 0x00000008;
+pub const WNOWAIT: ::c_int = 0x01000000;
+
+// ::Options set using PTRACE_SETOPTIONS.
+pub const PTRACE_O_TRACESYSGOOD: ::c_int = 0x00000001;
+pub const PTRACE_O_TRACEFORK: ::c_int = 0x00000002;
+pub const PTRACE_O_TRACEVFORK: ::c_int = 0x00000004;
+pub const PTRACE_O_TRACECLONE: ::c_int = 0x00000008;
+pub const PTRACE_O_TRACEEXEC: ::c_int = 0x00000010;
+pub const PTRACE_O_TRACEVFORKDONE: ::c_int = 0x00000020;
+pub const PTRACE_O_TRACEEXIT: ::c_int = 0x00000040;
+pub const PTRACE_O_TRACESECCOMP: ::c_int = 0x00000080;
+pub const PTRACE_O_EXITKILL: ::c_int = 0x00100000;
+pub const PTRACE_O_SUSPEND_SECCOMP: ::c_int = 0x00200000;
+pub const PTRACE_O_MASK: ::c_int = 0x003000ff;
+
+// Wait extended result codes for the above trace options.
+pub const PTRACE_EVENT_FORK: ::c_int = 1;
+pub const PTRACE_EVENT_VFORK: ::c_int = 2;
+pub const PTRACE_EVENT_CLONE: ::c_int = 3;
+pub const PTRACE_EVENT_EXEC: ::c_int = 4;
+pub const PTRACE_EVENT_VFORK_DONE: ::c_int = 5;
+pub const PTRACE_EVENT_EXIT: ::c_int = 6;
+pub const PTRACE_EVENT_SECCOMP: ::c_int = 7;
+// PTRACE_EVENT_STOP was added to glibc in 2.26
+// pub const PTRACE_EVENT_STOP: ::c_int = 128;
+
+pub const __WNOTHREAD: ::c_int = 0x20000000;
+pub const __WALL: ::c_int = 0x40000000;
+pub const __WCLONE: ::c_int = 0x80000000;
+
+pub const SPLICE_F_MOVE: ::c_uint = 0x01;
+pub const SPLICE_F_NONBLOCK: ::c_uint = 0x02;
+pub const SPLICE_F_MORE: ::c_uint = 0x04;
+pub const SPLICE_F_GIFT: ::c_uint = 0x08;
+
+pub const RTLD_LOCAL: ::c_int = 0;
+pub const RTLD_LAZY: ::c_int = 1;
+
+pub const POSIX_FADV_NORMAL: ::c_int = 0;
+pub const POSIX_FADV_RANDOM: ::c_int = 1;
+pub const POSIX_FADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_FADV_WILLNEED: ::c_int = 3;
+
+pub const AT_FDCWD: ::c_int = -100;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x100;
+pub const AT_REMOVEDIR: ::c_int = 0x200;
+pub const AT_EACCESS: ::c_int = 0x200;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x400;
+pub const AT_NO_AUTOMOUNT: ::c_int = 0x800;
+pub const AT_EMPTY_PATH: ::c_int = 0x1000;
+
+pub const LOG_CRON: ::c_int = 9 << 3;
+pub const LOG_AUTHPRIV: ::c_int = 10 << 3;
+pub const LOG_FTP: ::c_int = 11 << 3;
+pub const LOG_PERROR: ::c_int = 0x20;
+
+pub const PIPE_BUF: usize = 4096;
+
+pub const SI_LOAD_SHIFT: ::c_uint = 16;
+
+pub const CLD_EXITED: ::c_int = 1;
+pub const CLD_KILLED: ::c_int = 2;
+pub const CLD_DUMPED: ::c_int = 3;
+pub const CLD_TRAPPED: ::c_int = 4;
+pub const CLD_STOPPED: ::c_int = 5;
+pub const CLD_CONTINUED: ::c_int = 6;
+
+pub const SIGEV_SIGNAL: ::c_int = 0;
+pub const SIGEV_NONE: ::c_int = 1;
+pub const SIGEV_THREAD: ::c_int = 2;
+
+pub const P_ALL: idtype_t = 0;
+pub const P_PID: idtype_t = 1;
+pub const P_PGID: idtype_t = 2;
+
+pub const UTIME_OMIT: c_long = 1073741822;
+pub const UTIME_NOW: c_long = 1073741823;
+
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLPRI: ::c_short = 0x2;
+pub const POLLOUT: ::c_short = 0x4;
+pub const POLLERR: ::c_short = 0x8;
+pub const POLLHUP: ::c_short = 0x10;
+pub const POLLNVAL: ::c_short = 0x20;
+pub const POLLRDNORM: ::c_short = 0x040;
+pub const POLLRDBAND: ::c_short = 0x080;
+
+pub const ABDAY_1: ::nl_item = 0x20000;
+pub const ABDAY_2: ::nl_item = 0x20001;
+pub const ABDAY_3: ::nl_item = 0x20002;
+pub const ABDAY_4: ::nl_item = 0x20003;
+pub const ABDAY_5: ::nl_item = 0x20004;
+pub const ABDAY_6: ::nl_item = 0x20005;
+pub const ABDAY_7: ::nl_item = 0x20006;
+
+pub const DAY_1: ::nl_item = 0x20007;
+pub const DAY_2: ::nl_item = 0x20008;
+pub const DAY_3: ::nl_item = 0x20009;
+pub const DAY_4: ::nl_item = 0x2000A;
+pub const DAY_5: ::nl_item = 0x2000B;
+pub const DAY_6: ::nl_item = 0x2000C;
+pub const DAY_7: ::nl_item = 0x2000D;
+
+pub const ABMON_1: ::nl_item = 0x2000E;
+pub const ABMON_2: ::nl_item = 0x2000F;
+pub const ABMON_3: ::nl_item = 0x20010;
+pub const ABMON_4: ::nl_item = 0x20011;
+pub const ABMON_5: ::nl_item = 0x20012;
+pub const ABMON_6: ::nl_item = 0x20013;
+pub const ABMON_7: ::nl_item = 0x20014;
+pub const ABMON_8: ::nl_item = 0x20015;
+pub const ABMON_9: ::nl_item = 0x20016;
+pub const ABMON_10: ::nl_item = 0x20017;
+pub const ABMON_11: ::nl_item = 0x20018;
+pub const ABMON_12: ::nl_item = 0x20019;
+
+pub const MON_1: ::nl_item = 0x2001A;
+pub const MON_2: ::nl_item = 0x2001B;
+pub const MON_3: ::nl_item = 0x2001C;
+pub const MON_4: ::nl_item = 0x2001D;
+pub const MON_5: ::nl_item = 0x2001E;
+pub const MON_6: ::nl_item = 0x2001F;
+pub const MON_7: ::nl_item = 0x20020;
+pub const MON_8: ::nl_item = 0x20021;
+pub const MON_9: ::nl_item = 0x20022;
+pub const MON_10: ::nl_item = 0x20023;
+pub const MON_11: ::nl_item = 0x20024;
+pub const MON_12: ::nl_item = 0x20025;
+
+pub const AM_STR: ::nl_item = 0x20026;
+pub const PM_STR: ::nl_item = 0x20027;
+
+pub const D_T_FMT: ::nl_item = 0x20028;
+pub const D_FMT: ::nl_item = 0x20029;
+pub const T_FMT: ::nl_item = 0x2002A;
+pub const T_FMT_AMPM: ::nl_item = 0x2002B;
+
+pub const ERA: ::nl_item = 0x2002C;
+pub const ERA_D_FMT: ::nl_item = 0x2002E;
+pub const ALT_DIGITS: ::nl_item = 0x2002F;
+pub const ERA_D_T_FMT: ::nl_item = 0x20030;
+pub const ERA_T_FMT: ::nl_item = 0x20031;
+
+pub const CODESET: ::nl_item = 14;
+
+pub const CRNCYSTR: ::nl_item = 0x4000F;
+
+pub const RUSAGE_THREAD: ::c_int = 1;
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const RADIXCHAR: ::nl_item = 0x10000;
+pub const THOUSEP: ::nl_item = 0x10001;
+
+pub const YESEXPR: ::nl_item = 0x50000;
+pub const NOEXPR: ::nl_item = 0x50001;
+pub const YESSTR: ::nl_item = 0x50002;
+pub const NOSTR: ::nl_item = 0x50003;
+
+pub const FILENAME_MAX: ::c_uint = 4096;
+pub const L_tmpnam: ::c_uint = 20;
+pub const _PC_LINK_MAX: ::c_int = 0;
+pub const _PC_MAX_CANON: ::c_int = 1;
+pub const _PC_MAX_INPUT: ::c_int = 2;
+pub const _PC_NAME_MAX: ::c_int = 3;
+pub const _PC_PATH_MAX: ::c_int = 4;
+pub const _PC_PIPE_BUF: ::c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 6;
+pub const _PC_NO_TRUNC: ::c_int = 7;
+pub const _PC_VDISABLE: ::c_int = 8;
+pub const _PC_SYNC_IO: ::c_int = 9;
+pub const _PC_ASYNC_IO: ::c_int = 10;
+pub const _PC_PRIO_IO: ::c_int = 11;
+pub const _PC_SOCK_MAXBUF: ::c_int = 12;
+pub const _PC_FILESIZEBITS: ::c_int = 13;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 17;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 18;
+pub const _PC_SYMLINK_MAX: ::c_int = 19;
+pub const _PC_2_SYMLINKS: ::c_int = 20;
+
+pub const _SC_ARG_MAX: ::c_int = 0;
+pub const _SC_CHILD_MAX: ::c_int = 1;
+pub const _SC_CLK_TCK: ::c_int = 2;
+pub const _SC_NGROUPS_MAX: ::c_int = 3;
+pub const _SC_OPEN_MAX: ::c_int = 4;
+pub const _SC_STREAM_MAX: ::c_int = 5;
+pub const _SC_TZNAME_MAX: ::c_int = 6;
+pub const _SC_JOB_CONTROL: ::c_int = 7;
+pub const _SC_SAVED_IDS: ::c_int = 8;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 9;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 10;
+pub const _SC_TIMERS: ::c_int = 11;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 12;
+pub const _SC_PRIORITIZED_IO: ::c_int = 13;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 14;
+pub const _SC_FSYNC: ::c_int = 15;
+pub const _SC_MAPPED_FILES: ::c_int = 16;
+pub const _SC_MEMLOCK: ::c_int = 17;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 18;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 19;
+pub const _SC_MESSAGE_PASSING: ::c_int = 20;
+pub const _SC_SEMAPHORES: ::c_int = 21;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 22;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 23;
+pub const _SC_AIO_MAX: ::c_int = 24;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 25;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 26;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 27;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 28;
+pub const _SC_VERSION: ::c_int = 29;
+pub const _SC_PAGESIZE: ::c_int = 30;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_RTSIG_MAX: ::c_int = 31;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 32;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 33;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 34;
+pub const _SC_TIMER_MAX: ::c_int = 35;
+pub const _SC_BC_BASE_MAX: ::c_int = 36;
+pub const _SC_BC_DIM_MAX: ::c_int = 37;
+pub const _SC_BC_SCALE_MAX: ::c_int = 38;
+pub const _SC_BC_STRING_MAX: ::c_int = 39;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 40;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 42;
+pub const _SC_LINE_MAX: ::c_int = 43;
+pub const _SC_RE_DUP_MAX: ::c_int = 44;
+pub const _SC_2_VERSION: ::c_int = 46;
+pub const _SC_2_C_BIND: ::c_int = 47;
+pub const _SC_2_C_DEV: ::c_int = 48;
+pub const _SC_2_FORT_DEV: ::c_int = 49;
+pub const _SC_2_FORT_RUN: ::c_int = 50;
+pub const _SC_2_SW_DEV: ::c_int = 51;
+pub const _SC_2_LOCALEDEF: ::c_int = 52;
+pub const _SC_UIO_MAXIOV: ::c_int = 60;
+pub const _SC_IOV_MAX: ::c_int = 60;
+pub const _SC_THREADS: ::c_int = 67;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 68;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 69;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 70;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 71;
+pub const _SC_TTY_NAME_MAX: ::c_int = 72;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 73;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 74;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 75;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 79;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 80;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 81;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 82;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 83;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 84;
+pub const _SC_PHYS_PAGES: ::c_int = 85;
+pub const _SC_AVPHYS_PAGES: ::c_int = 86;
+pub const _SC_ATEXIT_MAX: ::c_int = 87;
+pub const _SC_PASS_MAX: ::c_int = 88;
+pub const _SC_XOPEN_VERSION: ::c_int = 89;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 90;
+pub const _SC_XOPEN_UNIX: ::c_int = 91;
+pub const _SC_XOPEN_CRYPT: ::c_int = 92;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 93;
+pub const _SC_XOPEN_SHM: ::c_int = 94;
+pub const _SC_2_CHAR_TERM: ::c_int = 95;
+pub const _SC_2_UPE: ::c_int = 97;
+pub const _SC_XOPEN_XPG2: ::c_int = 98;
+pub const _SC_XOPEN_XPG3: ::c_int = 99;
+pub const _SC_XOPEN_XPG4: ::c_int = 100;
+pub const _SC_NZERO: ::c_int = 109;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 125;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 126;
+pub const _SC_XBS5_LP64_OFF64: ::c_int = 127;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 128;
+pub const _SC_XOPEN_LEGACY: ::c_int = 129;
+pub const _SC_XOPEN_REALTIME: ::c_int = 130;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 131;
+pub const _SC_ADVISORY_INFO: ::c_int = 132;
+pub const _SC_BARRIERS: ::c_int = 133;
+pub const _SC_CLOCK_SELECTION: ::c_int = 137;
+pub const _SC_CPUTIME: ::c_int = 138;
+pub const _SC_THREAD_CPUTIME: ::c_int = 139;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 149;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 153;
+pub const _SC_SPIN_LOCKS: ::c_int = 154;
+pub const _SC_REGEXP: ::c_int = 155;
+pub const _SC_SHELL: ::c_int = 157;
+pub const _SC_SPAWN: ::c_int = 159;
+pub const _SC_SPORADIC_SERVER: ::c_int = 160;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 161;
+pub const _SC_TIMEOUTS: ::c_int = 164;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 165;
+pub const _SC_2_PBS: ::c_int = 168;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 169;
+pub const _SC_2_PBS_LOCATE: ::c_int = 170;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 171;
+pub const _SC_2_PBS_TRACK: ::c_int = 172;
+pub const _SC_SYMLOOP_MAX: ::c_int = 173;
+pub const _SC_STREAMS: ::c_int = 174;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 175;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 176;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 177;
+pub const _SC_V6_LP64_OFF64: ::c_int = 178;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 179;
+pub const _SC_HOST_NAME_MAX: ::c_int = 180;
+pub const _SC_TRACE: ::c_int = 181;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 182;
+pub const _SC_TRACE_INHERIT: ::c_int = 183;
+pub const _SC_TRACE_LOG: ::c_int = 184;
+pub const _SC_IPV6: ::c_int = 235;
+pub const _SC_RAW_SOCKETS: ::c_int = 236;
+pub const _SC_V7_ILP32_OFF32: ::c_int = 237;
+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 238;
+pub const _SC_V7_LP64_OFF64: ::c_int = 239;
+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 240;
+pub const _SC_SS_REPL_MAX: ::c_int = 241;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 242;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 243;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 244;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 245;
+pub const _SC_XOPEN_STREAMS: ::c_int = 246;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 247;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 248;
+
+pub const RLIM_SAVED_MAX: ::rlim_t = RLIM_INFINITY;
+pub const RLIM_SAVED_CUR: ::rlim_t = RLIM_INFINITY;
+
+pub const GLOB_ERR: ::c_int = 1 << 0;
+pub const GLOB_MARK: ::c_int = 1 << 1;
+pub const GLOB_NOSORT: ::c_int = 1 << 2;
+pub const GLOB_DOOFFS: ::c_int = 1 << 3;
+pub const GLOB_NOCHECK: ::c_int = 1 << 4;
+pub const GLOB_APPEND: ::c_int = 1 << 5;
+pub const GLOB_NOESCAPE: ::c_int = 1 << 6;
+
+pub const GLOB_NOSPACE: ::c_int = 1;
+pub const GLOB_ABORTED: ::c_int = 2;
+pub const GLOB_NOMATCH: ::c_int = 3;
+
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+
+pub const S_IEXEC: mode_t = 64;
+pub const S_IWRITE: mode_t = 128;
+pub const S_IREAD: mode_t = 256;
+
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+
+pub const IFF_LOWER_UP: ::c_int = 0x10000;
+pub const IFF_DORMANT: ::c_int = 0x20000;
+pub const IFF_ECHO: ::c_int = 0x40000;
+
+pub const ST_RDONLY: ::c_ulong = 1;
+pub const ST_NOSUID: ::c_ulong = 2;
+pub const ST_NODEV: ::c_ulong = 4;
+pub const ST_NOEXEC: ::c_ulong = 8;
+pub const ST_SYNCHRONOUS: ::c_ulong = 16;
+pub const ST_MANDLOCK: ::c_ulong = 64;
+pub const ST_WRITE: ::c_ulong = 128;
+pub const ST_APPEND: ::c_ulong = 256;
+pub const ST_IMMUTABLE: ::c_ulong = 512;
+pub const ST_NOATIME: ::c_ulong = 1024;
+pub const ST_NODIRATIME: ::c_ulong = 2048;
+
+pub const RTLD_NEXT: *mut ::c_void = -1i64 as *mut ::c_void;
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+pub const RTLD_NODELETE: ::c_int = 0x1000;
+pub const RTLD_NOW: ::c_int = 0x2;
+
+pub const TCP_MD5SIG: ::c_int = 14;
+
+align_const! {
+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+        size: [0; __SIZEOF_PTHREAD_MUTEX_T],
+    };
+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+        size: [0; __SIZEOF_PTHREAD_COND_T],
+    };
+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+        size: [0; __SIZEOF_PTHREAD_RWLOCK_T],
+    };
+}
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+pub const PTHREAD_PROCESS_PRIVATE: ::c_int = 0;
+pub const PTHREAD_PROCESS_SHARED: ::c_int = 1;
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+
+pub const RENAME_NOREPLACE: ::c_int = 1;
+pub const RENAME_EXCHANGE: ::c_int = 2;
+pub const RENAME_WHITEOUT: ::c_int = 4;
+
+pub const SCHED_OTHER: ::c_int = 0;
+pub const SCHED_FIFO: ::c_int = 1;
+pub const SCHED_RR: ::c_int = 2;
+pub const SCHED_BATCH: ::c_int = 3;
+pub const SCHED_IDLE: ::c_int = 5;
+
+// netinet/in.h
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+// IPPROTO_IP defined in src/unix/mod.rs
+/// Hop-by-hop option header
+pub const IPPROTO_HOPOPTS: ::c_int = 0;
+// IPPROTO_ICMP defined in src/unix/mod.rs
+/// group mgmt protocol
+pub const IPPROTO_IGMP: ::c_int = 2;
+/// for compatibility
+pub const IPPROTO_IPIP: ::c_int = 4;
+// IPPROTO_TCP defined in src/unix/mod.rs
+/// exterior gateway protocol
+pub const IPPROTO_EGP: ::c_int = 8;
+/// pup
+pub const IPPROTO_PUP: ::c_int = 12;
+// IPPROTO_UDP defined in src/unix/mod.rs
+/// xns idp
+pub const IPPROTO_IDP: ::c_int = 22;
+/// tp-4 w/ class negotiation
+pub const IPPROTO_TP: ::c_int = 29;
+/// DCCP
+pub const IPPROTO_DCCP: ::c_int = 33;
+// IPPROTO_IPV6 defined in src/unix/mod.rs
+/// IP6 routing header
+pub const IPPROTO_ROUTING: ::c_int = 43;
+/// IP6 fragmentation header
+pub const IPPROTO_FRAGMENT: ::c_int = 44;
+/// resource reservation
+pub const IPPROTO_RSVP: ::c_int = 46;
+/// General Routing Encap.
+pub const IPPROTO_GRE: ::c_int = 47;
+/// IP6 Encap Sec. Payload
+pub const IPPROTO_ESP: ::c_int = 50;
+/// IP6 Auth Header
+pub const IPPROTO_AH: ::c_int = 51;
+// IPPROTO_ICMPV6 defined in src/unix/mod.rs
+/// IP6 no next header
+pub const IPPROTO_NONE: ::c_int = 59;
+/// IP6 destination option
+pub const IPPROTO_DSTOPTS: ::c_int = 60;
+pub const IPPROTO_MTP: ::c_int = 92;
+pub const IPPROTO_BEETPH: ::c_int = 94;
+/// encapsulation header
+pub const IPPROTO_ENCAP: ::c_int = 98;
+/// Protocol indep. multicast
+pub const IPPROTO_PIM: ::c_int = 103;
+/// IP Payload Comp. Protocol
+pub const IPPROTO_COMP: ::c_int = 108;
+/// SCTP
+pub const IPPROTO_SCTP: ::c_int = 132;
+pub const IPPROTO_MH: ::c_int = 135;
+pub const IPPROTO_UDPLITE: ::c_int = 136;
+pub const IPPROTO_MPLS: ::c_int = 137;
+/// raw IP packet
+pub const IPPROTO_RAW: ::c_int = 255;
+pub const IPPROTO_MAX: ::c_int = 256;
+
+pub const AF_IB: ::c_int = 27;
+pub const AF_MPLS: ::c_int = 28;
+pub const AF_NFC: ::c_int = 39;
+pub const AF_VSOCK: ::c_int = 40;
+pub const PF_IB: ::c_int = AF_IB;
+pub const PF_MPLS: ::c_int = AF_MPLS;
+pub const PF_NFC: ::c_int = AF_NFC;
+pub const PF_VSOCK: ::c_int = AF_VSOCK;
+
+// System V IPC
+pub const IPC_PRIVATE: ::key_t = 0;
+
+pub const IPC_CREAT: ::c_int = 0o1000;
+pub const IPC_EXCL: ::c_int = 0o2000;
+pub const IPC_NOWAIT: ::c_int = 0o4000;
+
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+pub const IPC_INFO: ::c_int = 3;
+pub const MSG_STAT: ::c_int = 11;
+pub const MSG_INFO: ::c_int = 12;
+
+pub const MSG_NOERROR: ::c_int = 0o10000;
+pub const MSG_EXCEPT: ::c_int = 0o20000;
+pub const MSG_COPY: ::c_int = 0o40000;
+
+pub const SHM_R: ::c_int = 0o400;
+pub const SHM_W: ::c_int = 0o200;
+
+pub const SHM_RDONLY: ::c_int = 0o10000;
+pub const SHM_RND: ::c_int = 0o20000;
+pub const SHM_REMAP: ::c_int = 0o40000;
+pub const SHM_EXEC: ::c_int = 0o100000;
+
+pub const SHM_LOCK: ::c_int = 11;
+pub const SHM_UNLOCK: ::c_int = 12;
+
+pub const SHM_HUGETLB: ::c_int = 0o4000;
+pub const SHM_NORESERVE: ::c_int = 0o10000;
+
+pub const EPOLLRDHUP: ::c_int = 0x2000;
+pub const EPOLLEXCLUSIVE: ::c_int = 0x10000000;
+pub const EPOLLONESHOT: ::c_int = 0x40000000;
+
+pub const QFMT_VFS_OLD: ::c_int = 1;
+pub const QFMT_VFS_V0: ::c_int = 2;
+pub const QFMT_VFS_V1: ::c_int = 4;
+
+pub const EFD_SEMAPHORE: ::c_int = 0x1;
+
+pub const LOG_NFACILITIES: ::c_int = 24;
+
+pub const SEM_FAILED: *mut ::sem_t = 0 as *mut sem_t;
+
+pub const RB_AUTOBOOT: ::c_int = 0x01234567u32 as i32;
+pub const RB_HALT_SYSTEM: ::c_int = 0xcdef0123u32 as i32;
+pub const RB_ENABLE_CAD: ::c_int = 0x89abcdefu32 as i32;
+pub const RB_DISABLE_CAD: ::c_int = 0x00000000u32 as i32;
+pub const RB_POWER_OFF: ::c_int = 0x4321fedcu32 as i32;
+pub const RB_SW_SUSPEND: ::c_int = 0xd000fce2u32 as i32;
+pub const RB_KEXEC: ::c_int = 0x45584543u32 as i32;
+
+pub const AI_PASSIVE: ::c_int = 0x0001;
+pub const AI_CANONNAME: ::c_int = 0x0002;
+pub const AI_NUMERICHOST: ::c_int = 0x0004;
+pub const AI_V4MAPPED: ::c_int = 0x0008;
+pub const AI_ALL: ::c_int = 0x0010;
+pub const AI_ADDRCONFIG: ::c_int = 0x0020;
+
+pub const AI_NUMERICSERV: ::c_int = 0x0400;
+
+pub const EAI_BADFLAGS: ::c_int = -1;
+pub const EAI_NONAME: ::c_int = -2;
+pub const EAI_AGAIN: ::c_int = -3;
+pub const EAI_FAIL: ::c_int = -4;
+pub const EAI_FAMILY: ::c_int = -6;
+pub const EAI_SOCKTYPE: ::c_int = -7;
+pub const EAI_SERVICE: ::c_int = -8;
+pub const EAI_MEMORY: ::c_int = -10;
+pub const EAI_OVERFLOW: ::c_int = -12;
+
+pub const NI_NUMERICHOST: ::c_int = 1;
+pub const NI_NUMERICSERV: ::c_int = 2;
+pub const NI_NOFQDN: ::c_int = 4;
+pub const NI_NAMEREQD: ::c_int = 8;
+pub const NI_DGRAM: ::c_int = 16;
+
+pub const SYNC_FILE_RANGE_WAIT_BEFORE: ::c_uint = 1;
+pub const SYNC_FILE_RANGE_WRITE: ::c_uint = 2;
+pub const SYNC_FILE_RANGE_WAIT_AFTER: ::c_uint = 4;
+
+pub const EAI_SYSTEM: ::c_int = -11;
+
+pub const AIO_CANCELED: ::c_int = 0;
+pub const AIO_NOTCANCELED: ::c_int = 1;
+pub const AIO_ALLDONE: ::c_int = 2;
+pub const LIO_READ: ::c_int = 0;
+pub const LIO_WRITE: ::c_int = 1;
+pub const LIO_NOP: ::c_int = 2;
+pub const LIO_WAIT: ::c_int = 0;
+pub const LIO_NOWAIT: ::c_int = 1;
+
+pub const MREMAP_MAYMOVE: ::c_int = 1;
+pub const MREMAP_FIXED: ::c_int = 2;
+
+pub const PR_SET_PDEATHSIG: ::c_int = 1;
+pub const PR_GET_PDEATHSIG: ::c_int = 2;
+
+pub const PR_GET_DUMPABLE: ::c_int = 3;
+pub const PR_SET_DUMPABLE: ::c_int = 4;
+
+pub const PR_GET_UNALIGN: ::c_int = 5;
+pub const PR_SET_UNALIGN: ::c_int = 6;
+pub const PR_UNALIGN_NOPRINT: ::c_int = 1;
+pub const PR_UNALIGN_SIGBUS: ::c_int = 2;
+
+pub const PR_GET_KEEPCAPS: ::c_int = 7;
+pub const PR_SET_KEEPCAPS: ::c_int = 8;
+
+pub const PR_GET_FPEMU: ::c_int = 9;
+pub const PR_SET_FPEMU: ::c_int = 10;
+pub const PR_FPEMU_NOPRINT: ::c_int = 1;
+pub const PR_FPEMU_SIGFPE: ::c_int = 2;
+
+pub const PR_GET_FPEXC: ::c_int = 11;
+pub const PR_SET_FPEXC: ::c_int = 12;
+pub const PR_FP_EXC_SW_ENABLE: ::c_int = 0x80;
+pub const PR_FP_EXC_DIV: ::c_int = 0x010000;
+pub const PR_FP_EXC_OVF: ::c_int = 0x020000;
+pub const PR_FP_EXC_UND: ::c_int = 0x040000;
+pub const PR_FP_EXC_RES: ::c_int = 0x080000;
+pub const PR_FP_EXC_INV: ::c_int = 0x100000;
+pub const PR_FP_EXC_DISABLED: ::c_int = 0;
+pub const PR_FP_EXC_NONRECOV: ::c_int = 1;
+pub const PR_FP_EXC_ASYNC: ::c_int = 2;
+pub const PR_FP_EXC_PRECISE: ::c_int = 3;
+
+pub const PR_GET_TIMING: ::c_int = 13;
+pub const PR_SET_TIMING: ::c_int = 14;
+pub const PR_TIMING_STATISTICAL: ::c_int = 0;
+pub const PR_TIMING_TIMESTAMP: ::c_int = 1;
+
+pub const PR_SET_NAME: ::c_int = 15;
+pub const PR_GET_NAME: ::c_int = 16;
+
+pub const PR_GET_ENDIAN: ::c_int = 19;
+pub const PR_SET_ENDIAN: ::c_int = 20;
+pub const PR_ENDIAN_BIG: ::c_int = 0;
+pub const PR_ENDIAN_LITTLE: ::c_int = 1;
+pub const PR_ENDIAN_PPC_LITTLE: ::c_int = 2;
+
+pub const PR_GET_SECCOMP: ::c_int = 21;
+pub const PR_SET_SECCOMP: ::c_int = 22;
+
+pub const PR_CAPBSET_READ: ::c_int = 23;
+pub const PR_CAPBSET_DROP: ::c_int = 24;
+
+pub const PR_GET_TSC: ::c_int = 25;
+pub const PR_SET_TSC: ::c_int = 26;
+pub const PR_TSC_ENABLE: ::c_int = 1;
+pub const PR_TSC_SIGSEGV: ::c_int = 2;
+
+pub const PR_GET_SECUREBITS: ::c_int = 27;
+pub const PR_SET_SECUREBITS: ::c_int = 28;
+
+pub const PR_SET_TIMERSLACK: ::c_int = 29;
+pub const PR_GET_TIMERSLACK: ::c_int = 30;
+
+pub const PR_TASK_PERF_EVENTS_DISABLE: ::c_int = 31;
+pub const PR_TASK_PERF_EVENTS_ENABLE: ::c_int = 32;
+
+pub const PR_MCE_KILL: ::c_int = 33;
+pub const PR_MCE_KILL_CLEAR: ::c_int = 0;
+pub const PR_MCE_KILL_SET: ::c_int = 1;
+
+pub const PR_MCE_KILL_LATE: ::c_int = 0;
+pub const PR_MCE_KILL_EARLY: ::c_int = 1;
+pub const PR_MCE_KILL_DEFAULT: ::c_int = 2;
+
+pub const PR_MCE_KILL_GET: ::c_int = 34;
+
+pub const PR_SET_MM: ::c_int = 35;
+pub const PR_SET_MM_START_CODE: ::c_int = 1;
+pub const PR_SET_MM_END_CODE: ::c_int = 2;
+pub const PR_SET_MM_START_DATA: ::c_int = 3;
+pub const PR_SET_MM_END_DATA: ::c_int = 4;
+pub const PR_SET_MM_START_STACK: ::c_int = 5;
+pub const PR_SET_MM_START_BRK: ::c_int = 6;
+pub const PR_SET_MM_BRK: ::c_int = 7;
+pub const PR_SET_MM_ARG_START: ::c_int = 8;
+pub const PR_SET_MM_ARG_END: ::c_int = 9;
+pub const PR_SET_MM_ENV_START: ::c_int = 10;
+pub const PR_SET_MM_ENV_END: ::c_int = 11;
+pub const PR_SET_MM_AUXV: ::c_int = 12;
+pub const PR_SET_MM_EXE_FILE: ::c_int = 13;
+pub const PR_SET_MM_MAP: ::c_int = 14;
+pub const PR_SET_MM_MAP_SIZE: ::c_int = 15;
+
+pub const PR_SET_PTRACER: ::c_int = 0x59616d61;
+
+pub const PR_SET_CHILD_SUBREAPER: ::c_int = 36;
+pub const PR_GET_CHILD_SUBREAPER: ::c_int = 37;
+
+pub const PR_SET_NO_NEW_PRIVS: ::c_int = 38;
+pub const PR_GET_NO_NEW_PRIVS: ::c_int = 39;
+
+pub const PR_GET_TID_ADDRESS: ::c_int = 40;
+
+pub const PR_SET_THP_DISABLE: ::c_int = 41;
+pub const PR_GET_THP_DISABLE: ::c_int = 42;
+
+pub const PR_MPX_ENABLE_MANAGEMENT: ::c_int = 43;
+pub const PR_MPX_DISABLE_MANAGEMENT: ::c_int = 44;
+
+pub const PR_SET_FP_MODE: ::c_int = 45;
+pub const PR_GET_FP_MODE: ::c_int = 46;
+pub const PR_FP_MODE_FR: ::c_int = 1 << 0;
+pub const PR_FP_MODE_FRE: ::c_int = 1 << 1;
+
+pub const PR_CAP_AMBIENT: ::c_int = 47;
+pub const PR_CAP_AMBIENT_IS_SET: ::c_int = 1;
+pub const PR_CAP_AMBIENT_RAISE: ::c_int = 2;
+pub const PR_CAP_AMBIENT_LOWER: ::c_int = 3;
+pub const PR_CAP_AMBIENT_CLEAR_ALL: ::c_int = 4;
+
+pub const ITIMER_REAL: ::c_int = 0;
+pub const ITIMER_VIRTUAL: ::c_int = 1;
+pub const ITIMER_PROF: ::c_int = 2;
+
+pub const TFD_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const TFD_NONBLOCK: ::c_int = O_NONBLOCK;
+pub const TFD_TIMER_ABSTIME: ::c_int = 1;
+
+pub const XATTR_CREATE: ::c_int = 0x1;
+pub const XATTR_REPLACE: ::c_int = 0x2;
+
+pub const _POSIX_VDISABLE: ::cc_t = 0;
+
+pub const FALLOC_FL_KEEP_SIZE: ::c_int = 0x01;
+pub const FALLOC_FL_PUNCH_HOLE: ::c_int = 0x02;
+pub const FALLOC_FL_COLLAPSE_RANGE: ::c_int = 0x08;
+pub const FALLOC_FL_ZERO_RANGE: ::c_int = 0x10;
+pub const FALLOC_FL_INSERT_RANGE: ::c_int = 0x20;
+pub const FALLOC_FL_UNSHARE_RANGE: ::c_int = 0x40;
+
+// On Linux, libc doesn't define this constant, libattr does instead.
+// We still define it for Linux as it's defined by libc on other platforms,
+// and it's mentioned in the man pages for getxattr and setxattr.
+pub const ENOATTR: ::c_int = ::ENODATA;
+
+pub const SO_ORIGINAL_DST: ::c_int = 80;
+pub const IUTF8: ::tcflag_t = 0x00004000;
+pub const CMSPAR: ::tcflag_t = 0o10000000000;
+
+pub const MFD_CLOEXEC: ::c_uint = 0x0001;
+pub const MFD_ALLOW_SEALING: ::c_uint = 0x0002;
+
+// these are used in the p_type field of Elf32_Phdr and Elf64_Phdr, which has
+// the type Elf32Word and Elf64Word respectively. Luckily, both of those are u32
+// so we can use that type here to avoid having to cast.
+pub const PT_NULL: u32 = 0;
+pub const PT_LOAD: u32 = 1;
+pub const PT_DYNAMIC: u32 = 2;
+pub const PT_INTERP: u32 = 3;
+pub const PT_NOTE: u32 = 4;
+pub const PT_SHLIB: u32 = 5;
+pub const PT_PHDR: u32 = 6;
+pub const PT_TLS: u32 = 7;
+pub const PT_NUM: u32 = 8;
+pub const PT_LOOS: u32 = 0x60000000;
+pub const PT_GNU_EH_FRAME: u32 = 0x6474e550;
+pub const PT_GNU_STACK: u32 = 0x6474e551;
+pub const PT_GNU_RELRO: u32 = 0x6474e552;
+
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 0x00040000;
+pub const O_NOATIME: ::c_int = 0x00002000;
+pub const O_CLOEXEC: ::c_int = 0x00000100;
+pub const O_TMPFILE: ::c_int = 0x00004000;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const BUFSIZ: ::c_uint = 1024;
+pub const TMP_MAX: ::c_uint = 10000;
+pub const FOPEN_MAX: ::c_uint = 1000;
+pub const O_PATH: ::c_int = 0x00400000;
+pub const O_EXEC: ::c_int = O_PATH;
+pub const O_SEARCH: ::c_int = O_PATH;
+pub const O_ACCMODE: ::c_int = 03 | O_SEARCH;
+pub const O_NDELAY: ::c_int = O_NONBLOCK;
+pub const NI_MAXHOST: ::socklen_t = 255;
+pub const PTHREAD_STACK_MIN: ::size_t = 2048;
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const RLIMIT_RTTIME: ::c_int = 15;
+pub const RLIMIT_NLIMITS: ::c_int = 16;
+
+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;
+
+pub const SOCK_DCCP: ::c_int = 6;
+pub const SOCK_PACKET: ::c_int = 10;
+
+pub const TCP_COOKIE_TRANSACTIONS: ::c_int = 15;
+pub const TCP_THIN_LINEAR_TIMEOUTS: ::c_int = 16;
+pub const TCP_THIN_DUPACK: ::c_int = 17;
+pub const TCP_USER_TIMEOUT: ::c_int = 18;
+pub const TCP_REPAIR: ::c_int = 19;
+pub const TCP_REPAIR_QUEUE: ::c_int = 20;
+pub const TCP_QUEUE_SEQ: ::c_int = 21;
+pub const TCP_REPAIR_OPTIONS: ::c_int = 22;
+pub const TCP_FASTOPEN: ::c_int = 23;
+pub const TCP_TIMESTAMP: ::c_int = 24;
+
+pub const SIGUNUSED: ::c_int = ::SIGSYS;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+
+pub const CPU_SETSIZE: ::c_int = 128;
+
+pub const PTRACE_TRACEME: ::c_int = 0;
+pub const PTRACE_PEEKTEXT: ::c_int = 1;
+pub const PTRACE_PEEKDATA: ::c_int = 2;
+pub const PTRACE_PEEKUSER: ::c_int = 3;
+pub const PTRACE_POKETEXT: ::c_int = 4;
+pub const PTRACE_POKEDATA: ::c_int = 5;
+pub const PTRACE_POKEUSER: ::c_int = 6;
+pub const PTRACE_CONT: ::c_int = 7;
+pub const PTRACE_KILL: ::c_int = 8;
+pub const PTRACE_SINGLESTEP: ::c_int = 9;
+pub const PTRACE_GETREGS: ::c_int = 12;
+pub const PTRACE_SETREGS: ::c_int = 13;
+pub const PTRACE_GETFPREGS: ::c_int = 14;
+pub const PTRACE_SETFPREGS: ::c_int = 15;
+pub const PTRACE_ATTACH: ::c_int = 16;
+pub const PTRACE_DETACH: ::c_int = 17;
+pub const PTRACE_GETFPXREGS: ::c_int = 18;
+pub const PTRACE_SETFPXREGS: ::c_int = 19;
+pub const PTRACE_SYSCALL: ::c_int = 24;
+pub const PTRACE_SETOPTIONS: ::c_int = 0x4200;
+pub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;
+pub const PTRACE_GETSIGINFO: ::c_int = 0x4202;
+pub const PTRACE_SETSIGINFO: ::c_int = 0x4203;
+pub const PTRACE_GETREGSET: ::c_int = 0x4204;
+pub const PTRACE_SETREGSET: ::c_int = 0x4205;
+pub const PTRACE_SEIZE: ::c_int = 0x4206;
+pub const PTRACE_INTERRUPT: ::c_int = 0x4207;
+pub const PTRACE_LISTEN: ::c_int = 0x4208;
+pub const PTRACE_PEEKSIGINFO: ::c_int = 0x4209;
+
+pub const EPOLLWAKEUP: ::c_int = 0x20000000;
+
+pub const EFD_NONBLOCK: ::c_int = ::O_NONBLOCK;
+
+pub const SFD_NONBLOCK: ::c_int = ::O_NONBLOCK;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCINQ: ::c_int = ::FIONREAD;
+
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::c_int = 0x00000800;
+pub const TAB2: ::c_int = 0x00001000;
+pub const TAB3: ::c_int = 0x00001800;
+pub const CR1: ::c_int = 0x00000200;
+pub const CR2: ::c_int = 0x00000400;
+pub const CR3: ::c_int = 0x00000600;
+pub const FF1: ::c_int = 0x00008000;
+pub const BS1: ::c_int = 0x00002000;
+pub const VT1: ::c_int = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_BUSY_POLL: ::c_int = 46;
+
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+
+pub const O_ASYNC: ::c_int = 0x00000400;
+
+pub const FIOCLEX: ::c_int = 0x5451;
+pub const FIONBIO: ::c_int = 0x5421;
+
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+
+pub const O_APPEND: ::c_int = 0x00100000;
+pub const O_CREAT: ::c_int = 0x00010000;
+pub const O_EXCL: ::c_int = 0x00020000;
+pub const O_NOCTTY: ::c_int = 0x00000200;
+pub const O_NONBLOCK: ::c_int = 0x00000010;
+pub const O_SYNC: ::c_int = 0x00000040 | O_DSYNC;
+pub const O_RSYNC: ::c_int = O_SYNC;
+pub const O_DSYNC: ::c_int = 0x00000020;
+
+pub const SOCK_CLOEXEC: ::c_int = 0o2000000;
+pub const SOCK_NONBLOCK: ::c_int = 0o4000;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_SETOWN: ::c_int = 8;
+
+pub const VEOF: usize = 4;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+
+pub const TCGETS: ::c_int = 0x5401;
+pub const TCSETS: ::c_int = 0x5402;
+pub const TCSETSW: ::c_int = 0x5403;
+pub const TCSETSF: ::c_int = 0x5404;
+pub const TCGETA: ::c_int = 0x5405;
+pub const TCSETA: ::c_int = 0x5406;
+pub const TCSETAW: ::c_int = 0x5407;
+pub const TCSETAF: ::c_int = 0x5408;
+pub const TCSBRK: ::c_int = 0x5409;
+pub const TCXONC: ::c_int = 0x540A;
+pub const TCFLSH: ::c_int = 0x540B;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x540F;
+pub const TIOCSPGRP: ::c_int = 0x5410;
+pub const TIOCOUTQ: ::c_int = 0x5411;
+pub const TIOCSTI: ::c_int = 0x5412;
+pub const TIOCGWINSZ: ::c_int = 0x5413;
+pub const TIOCSWINSZ: ::c_int = 0x5414;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x541B;
+pub const TIOCCONS: ::c_int = 0x541D;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+pub const O_DIRECTORY: ::c_int = 0x00080000;
+pub const O_DIRECT: ::c_int = 0x00000800;
+pub const O_LARGEFILE: ::c_int = 0x00001000;
+pub const O_NOFOLLOW: ::c_int = 0x00000080;
+
+// intentionally not public, only used for fd_set
+cfg_if! {
+    if #[cfg(target_pointer_width = "32")] {
+        const ULONG_SIZE: usize = 32;
+    } else if #[cfg(target_pointer_width = "64")] {
+        const ULONG_SIZE: usize = 64;
+    } else {
+        // Unknown target_pointer_width
+    }
+}
+
+// END_PUB_CONST
+
+f! {
+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] &= !(1 << (fd % size));
+        return
+    }
+
+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0
+    }
+
+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] |= 1 << (fd % size);
+        return
+    }
+
+    pub fn FD_ZERO(set: *mut fd_set) -> () {
+        for slot in (*set).fds_bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+
+    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {
+        for slot in cpuset.bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+
+    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits
+            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] |= 1 << offset;
+        ()
+    }
+
+    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits
+            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] &= !(1 << offset);
+        ()
+    }
+
+    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {
+        let size_in_bits = 8 * ::mem::size_of_val(&cpuset.bits[0]);
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        0 != (cpuset.bits[idx] & (1 << offset))
+    }
+
+    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {
+        set1.bits == set2.bits
+    }
+
+    pub fn major(dev: ::dev_t) -> ::c_uint {
+        let mut major = 0;
+        major |= (dev & 0x00000000000fff00) >> 8;
+        major |= (dev & 0xfffff00000000000) >> 32;
+        major as ::c_uint
+    }
+
+    pub fn minor(dev: ::dev_t) -> ::c_uint {
+        let mut minor = 0;
+        minor |= (dev & 0x00000000000000ff) >> 0;
+        minor |= (dev & 0x00000ffffff00000) >> 12;
+        minor as ::c_uint
+    }
+
+    pub fn makedev(major: ::c_uint, minor: ::c_uint) -> ::dev_t {
+        let major = major as ::dev_t;
+        let minor = minor as ::dev_t;
+        let mut dev = 0;
+        dev |= (major & 0x00000fff) << 8;
+        dev |= (major & 0xfffff000) << 32;
+        dev |= (minor & 0x000000ff) << 0;
+        dev |= (minor & 0xffffff00) << 12;
+        dev
+    }
+
+    pub fn CMSG_DATA(cmsg: *const cmsghdr) -> *mut c_uchar {
+        cmsg.offset(1) as *mut c_uchar
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr)
+        -> *mut cmsghdr
+    {
+        if ((*cmsg).cmsg_len as ::size_t) < ::mem::size_of::<cmsghdr>() {
+            0 as *mut cmsghdr
+        } else if __CMSG_NEXT(cmsg).add(::mem::size_of::<cmsghdr>())
+            >= __MHDR_END(mhdr) {
+            0 as *mut cmsghdr
+        } else {
+            __CMSG_NEXT(cmsg).cast()
+        }
+    }
+
+    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {
+        if (*mhdr).msg_controllen as ::size_t >= ::mem::size_of::<cmsghdr>() {
+            (*mhdr).msg_control.cast()
+        } else {
+            0 as *mut cmsghdr
+        }
+    }
+
+    pub fn CMSG_ALIGN(len: ::size_t) -> ::size_t {
+        (len + ::mem::size_of::<::size_t>() - 1)
+            & !(::mem::size_of::<::size_t>() - 1)
+    }
+
+    pub fn CMSG_SPACE(len: ::c_uint) -> ::c_uint {
+        (CMSG_ALIGN(len as ::size_t) + CMSG_ALIGN(::mem::size_of::<cmsghdr>()))
+            as ::c_uint
+    }
+
+    pub fn CMSG_LEN(len: ::c_uint) -> ::c_uint {
+        (CMSG_ALIGN(::mem::size_of::<cmsghdr>()) + len as ::size_t) as ::c_uint
+    }
+}
+
+safe_f! {
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        (status & 0xff) == 0x7f
+    }
+
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        status == 0xffff
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        ((status & 0x7f) + 1) as i8 >= 2
+    }
+
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        status & 0x7f
+    }
+
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & 0x7f) == 0
+    }
+
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {
+        (status & 0x80) != 0
+    }
+
+    pub {const} fn QCMD(cmd: ::c_int, type_: ::c_int) -> ::c_int {
+        (cmd << 8) | (type_ & 0x00ff)
+    }
+}
+
+fn __CMSG_LEN(cmsg: *const cmsghdr) -> ::ssize_t {
+    ((unsafe { (*cmsg).cmsg_len as ::size_t } + ::mem::size_of::<::c_long>()
+        - 1)
+        & !(::mem::size_of::<::c_long>() - 1)) as ::ssize_t
+}
+
+fn __CMSG_NEXT(cmsg: *const cmsghdr) -> *mut c_uchar {
+    (unsafe { cmsg.offset(__CMSG_LEN(cmsg)) }) as *mut c_uchar
+}
+
+fn __MHDR_END(mhdr: *const msghdr) -> *mut c_uchar {
+    unsafe { (*mhdr).msg_control.offset((*mhdr).msg_controllen as isize) }
+        .cast()
+}
+
+// EXTERN_FN
+
+#[link(name = "c")]
+#[link(name = "fdio")]
+extern "C" {}
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum FILE {}
+impl ::Copy for FILE {}
+impl ::Clone for FILE {
+    fn clone(&self) -> FILE {
+        *self
+    }
+}
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum fpos_t {} // FIXME: fill this out with a struct
+impl ::Copy for fpos_t {}
+impl ::Clone for fpos_t {
+    fn clone(&self) -> fpos_t {
+        *self
+    }
+}
+
+extern "C" {
+    pub fn isalnum(c: c_int) -> c_int;
+    pub fn isalpha(c: c_int) -> c_int;
+    pub fn iscntrl(c: c_int) -> c_int;
+    pub fn isdigit(c: c_int) -> c_int;
+    pub fn isgraph(c: c_int) -> c_int;
+    pub fn islower(c: c_int) -> c_int;
+    pub fn isprint(c: c_int) -> c_int;
+    pub fn ispunct(c: c_int) -> c_int;
+    pub fn isspace(c: c_int) -> c_int;
+    pub fn isupper(c: c_int) -> c_int;
+    pub fn isxdigit(c: c_int) -> c_int;
+    pub fn isblank(c: c_int) -> c_int;
+    pub fn tolower(c: c_int) -> c_int;
+    pub fn toupper(c: c_int) -> c_int;
+    pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;
+    pub fn freopen(
+        filename: *const c_char,
+        mode: *const c_char,
+        file: *mut FILE,
+    ) -> *mut FILE;
+    pub fn fflush(file: *mut FILE) -> c_int;
+    pub fn fclose(file: *mut FILE) -> c_int;
+    pub fn remove(filename: *const c_char) -> c_int;
+    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;
+    pub fn tmpfile() -> *mut FILE;
+    pub fn setvbuf(
+        stream: *mut FILE,
+        buffer: *mut c_char,
+        mode: c_int,
+        size: size_t,
+    ) -> c_int;
+    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);
+    pub fn getchar() -> c_int;
+    pub fn putchar(c: c_int) -> c_int;
+    pub fn fgetc(stream: *mut FILE) -> c_int;
+    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE)
+        -> *mut c_char;
+    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;
+    pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;
+    pub fn puts(s: *const c_char) -> c_int;
+    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;
+    pub fn fread(
+        ptr: *mut c_void,
+        size: size_t,
+        nobj: size_t,
+        stream: *mut FILE,
+    ) -> size_t;
+    pub fn fwrite(
+        ptr: *const c_void,
+        size: size_t,
+        nobj: size_t,
+        stream: *mut FILE,
+    ) -> size_t;
+    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;
+    pub fn ftell(stream: *mut FILE) -> c_long;
+    pub fn rewind(stream: *mut FILE);
+    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;
+    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;
+    pub fn feof(stream: *mut FILE) -> c_int;
+    pub fn ferror(stream: *mut FILE) -> c_int;
+    pub fn perror(s: *const c_char);
+    pub fn atoi(s: *const c_char) -> c_int;
+    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;
+    pub fn strtol(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_long;
+    pub fn strtoul(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_ulong;
+    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;
+    pub fn malloc(size: size_t) -> *mut c_void;
+    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;
+    pub fn free(p: *mut c_void);
+    pub fn abort() -> !;
+    pub fn exit(status: c_int) -> !;
+    pub fn _exit(status: c_int) -> !;
+    pub fn atexit(cb: extern "C" fn()) -> c_int;
+    pub fn system(s: *const c_char) -> c_int;
+    pub fn getenv(s: *const c_char) -> *mut c_char;
+
+    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;
+    pub fn strncpy(
+        dst: *mut c_char,
+        src: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strncat(
+        s: *mut c_char,
+        ct: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;
+    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strdup(cs: *const c_char) -> *mut c_char;
+    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strlen(cs: *const c_char) -> size_t;
+    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;
+    pub fn strerror(n: c_int) -> *mut c_char;
+    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;
+    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;
+    pub fn wcslen(buf: *const wchar_t) -> size_t;
+    pub fn wcstombs(
+        dest: *mut c_char,
+        src: *const wchar_t,
+        n: size_t,
+    ) -> ::size_t;
+
+    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;
+    pub fn wmemchr(cx: *const wchar_t, c: wchar_t, n: size_t) -> *mut wchar_t;
+    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;
+    pub fn memcpy(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memmove(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;
+
+    pub fn abs(i: c_int) -> c_int;
+    pub fn atof(s: *const c_char) -> c_double;
+    pub fn labs(i: c_long) -> c_long;
+    pub fn rand() -> c_int;
+    pub fn srand(seed: c_uint);
+
+    pub fn getpwnam(name: *const ::c_char) -> *mut passwd;
+    pub fn getpwuid(uid: ::uid_t) -> *mut passwd;
+
+    pub fn fprintf(
+        stream: *mut ::FILE,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn printf(format: *const ::c_char, ...) -> ::c_int;
+    pub fn snprintf(
+        s: *mut ::c_char,
+        n: ::size_t,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn sprintf(s: *mut ::c_char, format: *const ::c_char, ...) -> ::c_int;
+    pub fn fscanf(
+        stream: *mut ::FILE,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn scanf(format: *const ::c_char, ...) -> ::c_int;
+    pub fn sscanf(s: *const ::c_char, format: *const ::c_char, ...)
+        -> ::c_int;
+    pub fn getchar_unlocked() -> ::c_int;
+    pub fn putchar_unlocked(c: ::c_int) -> ::c_int;
+
+    pub fn socket(domain: ::c_int, ty: ::c_int, protocol: ::c_int) -> ::c_int;
+    pub fn connect(
+        socket: ::c_int,
+        address: *const sockaddr,
+        len: socklen_t,
+    ) -> ::c_int;
+    pub fn listen(socket: ::c_int, backlog: ::c_int) -> ::c_int;
+    pub fn accept(
+        socket: ::c_int,
+        address: *mut sockaddr,
+        address_len: *mut socklen_t,
+    ) -> ::c_int;
+    pub fn getpeername(
+        socket: ::c_int,
+        address: *mut sockaddr,
+        address_len: *mut socklen_t,
+    ) -> ::c_int;
+    pub fn getsockname(
+        socket: ::c_int,
+        address: *mut sockaddr,
+        address_len: *mut socklen_t,
+    ) -> ::c_int;
+    pub fn setsockopt(
+        socket: ::c_int,
+        level: ::c_int,
+        name: ::c_int,
+        value: *const ::c_void,
+        option_len: socklen_t,
+    ) -> ::c_int;
+    pub fn socketpair(
+        domain: ::c_int,
+        type_: ::c_int,
+        protocol: ::c_int,
+        socket_vector: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn sendto(
+        socket: ::c_int,
+        buf: *const ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *const sockaddr,
+        addrlen: socklen_t,
+    ) -> ::ssize_t;
+    pub fn shutdown(socket: ::c_int, how: ::c_int) -> ::c_int;
+
+    pub fn chmod(path: *const c_char, mode: mode_t) -> ::c_int;
+    pub fn fchmod(fd: ::c_int, mode: mode_t) -> ::c_int;
+
+    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;
+
+    pub fn mkdir(path: *const c_char, mode: mode_t) -> ::c_int;
+
+    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;
+
+    pub fn pclose(stream: *mut ::FILE) -> ::c_int;
+    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;
+    pub fn fileno(stream: *mut ::FILE) -> ::c_int;
+
+    pub fn open(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;
+    pub fn creat(path: *const c_char, mode: mode_t) -> ::c_int;
+    pub fn fcntl(fd: ::c_int, cmd: ::c_int, ...) -> ::c_int;
+
+    pub fn opendir(dirname: *const c_char) -> *mut ::DIR;
+    pub fn readdir(dirp: *mut ::DIR) -> *mut ::dirent;
+    pub fn readdir_r(
+        dirp: *mut ::DIR,
+        entry: *mut ::dirent,
+        result: *mut *mut ::dirent,
+    ) -> ::c_int;
+    pub fn closedir(dirp: *mut ::DIR) -> ::c_int;
+    pub fn rewinddir(dirp: *mut ::DIR);
+
+    pub fn openat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        flags: ::c_int,
+        ...
+    ) -> ::c_int;
+    pub fn fchmodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn fchown(fd: ::c_int, owner: ::uid_t, group: ::gid_t) -> ::c_int;
+    pub fn fchownat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        owner: ::uid_t,
+        group: ::gid_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn fstatat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        buf: *mut stat,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn linkat(
+        olddirfd: ::c_int,
+        oldpath: *const ::c_char,
+        newdirfd: ::c_int,
+        newpath: *const ::c_char,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn mkdirat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn readlinkat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        buf: *mut ::c_char,
+        bufsiz: ::size_t,
+    ) -> ::ssize_t;
+    pub fn renameat(
+        olddirfd: ::c_int,
+        oldpath: *const ::c_char,
+        newdirfd: ::c_int,
+        newpath: *const ::c_char,
+    ) -> ::c_int;
+    pub fn symlinkat(
+        target: *const ::c_char,
+        newdirfd: ::c_int,
+        linkpath: *const ::c_char,
+    ) -> ::c_int;
+    pub fn unlinkat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;
+    pub fn alarm(seconds: ::c_uint) -> ::c_uint;
+    pub fn chdir(dir: *const c_char) -> ::c_int;
+    pub fn chown(path: *const c_char, uid: uid_t, gid: gid_t) -> ::c_int;
+    pub fn lchown(path: *const c_char, uid: uid_t, gid: gid_t) -> ::c_int;
+    pub fn close(fd: ::c_int) -> ::c_int;
+    pub fn dup(fd: ::c_int) -> ::c_int;
+    pub fn dup2(src: ::c_int, dst: ::c_int) -> ::c_int;
+    pub fn execl(path: *const c_char, arg0: *const c_char, ...) -> ::c_int;
+    pub fn execle(
+        path: *const ::c_char,
+        arg0: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn execlp(
+        file: *const ::c_char,
+        arg0: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn execv(prog: *const c_char, argv: *const *const c_char) -> ::c_int;
+    pub fn execve(
+        prog: *const c_char,
+        argv: *const *const c_char,
+        envp: *const *const c_char,
+    ) -> ::c_int;
+    pub fn execvp(c: *const c_char, argv: *const *const c_char) -> ::c_int;
+    pub fn fork() -> pid_t;
+    pub fn fpathconf(filedes: ::c_int, name: ::c_int) -> c_long;
+    pub fn getcwd(buf: *mut c_char, size: ::size_t) -> *mut c_char;
+    pub fn getegid() -> gid_t;
+    pub fn geteuid() -> uid_t;
+    pub fn getgid() -> gid_t;
+    pub fn getgroups(ngroups_max: ::c_int, groups: *mut gid_t) -> ::c_int;
+    pub fn getlogin() -> *mut c_char;
+    pub fn getopt(
+        argc: ::c_int,
+        argv: *const *mut c_char,
+        optstr: *const c_char,
+    ) -> ::c_int;
+    pub fn getpgid(pid: pid_t) -> pid_t;
+    pub fn getpgrp() -> pid_t;
+    pub fn getpid() -> pid_t;
+    pub fn getppid() -> pid_t;
+    pub fn getuid() -> uid_t;
+    pub fn isatty(fd: ::c_int) -> ::c_int;
+    pub fn link(src: *const c_char, dst: *const c_char) -> ::c_int;
+    pub fn lseek(fd: ::c_int, offset: off_t, whence: ::c_int) -> off_t;
+    pub fn pathconf(path: *const c_char, name: ::c_int) -> c_long;
+    pub fn pause() -> ::c_int;
+    pub fn pipe(fds: *mut ::c_int) -> ::c_int;
+    pub fn posix_memalign(
+        memptr: *mut *mut ::c_void,
+        align: ::size_t,
+        size: ::size_t,
+    ) -> ::c_int;
+    pub fn read(fd: ::c_int, buf: *mut ::c_void, count: ::size_t)
+        -> ::ssize_t;
+    pub fn rmdir(path: *const c_char) -> ::c_int;
+    pub fn seteuid(uid: uid_t) -> ::c_int;
+    pub fn setegid(gid: gid_t) -> ::c_int;
+    pub fn setgid(gid: gid_t) -> ::c_int;
+    pub fn setpgid(pid: pid_t, pgid: pid_t) -> ::c_int;
+    pub fn setsid() -> pid_t;
+    pub fn setuid(uid: uid_t) -> ::c_int;
+    pub fn sleep(secs: ::c_uint) -> ::c_uint;
+    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::c_int;
+    pub fn tcgetpgrp(fd: ::c_int) -> pid_t;
+    pub fn tcsetpgrp(fd: ::c_int, pgrp: ::pid_t) -> ::c_int;
+    pub fn ttyname(fd: ::c_int) -> *mut c_char;
+    pub fn unlink(c: *const c_char) -> ::c_int;
+    pub fn wait(status: *mut ::c_int) -> pid_t;
+    pub fn waitpid(
+        pid: pid_t,
+        status: *mut ::c_int,
+        options: ::c_int,
+    ) -> pid_t;
+    pub fn write(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    pub fn pread(
+        fd: ::c_int,
+        buf: *mut ::c_void,
+        count: ::size_t,
+        offset: off_t,
+    ) -> ::ssize_t;
+    pub fn pwrite(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::size_t,
+        offset: off_t,
+    ) -> ::ssize_t;
+    pub fn umask(mask: mode_t) -> mode_t;
+
+    pub fn utime(file: *const c_char, buf: *const utimbuf) -> ::c_int;
+
+    pub fn kill(pid: pid_t, sig: ::c_int) -> ::c_int;
+
+    pub fn mlock(addr: *const ::c_void, len: ::size_t) -> ::c_int;
+    pub fn munlock(addr: *const ::c_void, len: ::size_t) -> ::c_int;
+    pub fn mlockall(flags: ::c_int) -> ::c_int;
+    pub fn munlockall() -> ::c_int;
+
+    pub fn mmap(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+        flags: ::c_int,
+        fd: ::c_int,
+        offset: off_t,
+    ) -> *mut ::c_void;
+    pub fn munmap(addr: *mut ::c_void, len: ::size_t) -> ::c_int;
+
+    pub fn if_nametoindex(ifname: *const c_char) -> ::c_uint;
+    pub fn if_indextoname(
+        ifindex: ::c_uint,
+        ifname: *mut ::c_char,
+    ) -> *mut ::c_char;
+
+    pub fn lstat(path: *const c_char, buf: *mut stat) -> ::c_int;
+
+    pub fn fsync(fd: ::c_int) -> ::c_int;
+
+    pub fn setenv(
+        name: *const c_char,
+        val: *const c_char,
+        overwrite: ::c_int,
+    ) -> ::c_int;
+    pub fn unsetenv(name: *const c_char) -> ::c_int;
+
+    pub fn symlink(path1: *const c_char, path2: *const c_char) -> ::c_int;
+
+    pub fn ftruncate(fd: ::c_int, length: off_t) -> ::c_int;
+
+    pub fn signal(signum: ::c_int, handler: sighandler_t) -> sighandler_t;
+
+    pub fn realpath(
+        pathname: *const ::c_char,
+        resolved: *mut ::c_char,
+    ) -> *mut ::c_char;
+
+    pub fn flock(fd: ::c_int, operation: ::c_int) -> ::c_int;
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn times(buf: *mut ::tms) -> ::clock_t;
+
+    pub fn pthread_self() -> ::pthread_t;
+    pub fn pthread_join(
+        native: ::pthread_t,
+        value: *mut *mut ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_exit(value: *mut ::c_void) -> !;
+    pub fn pthread_attr_init(attr: *mut ::pthread_attr_t) -> ::c_int;
+    pub fn pthread_attr_destroy(attr: *mut ::pthread_attr_t) -> ::c_int;
+    pub fn pthread_attr_setstacksize(
+        attr: *mut ::pthread_attr_t,
+        stack_size: ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_setdetachstate(
+        attr: *mut ::pthread_attr_t,
+        state: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_detach(thread: ::pthread_t) -> ::c_int;
+    pub fn sched_yield() -> ::c_int;
+    pub fn pthread_key_create(
+        key: *mut pthread_key_t,
+        dtor: ::Option<unsafe extern "C" fn(*mut ::c_void)>,
+    ) -> ::c_int;
+    pub fn pthread_key_delete(key: pthread_key_t) -> ::c_int;
+    pub fn pthread_getspecific(key: pthread_key_t) -> *mut ::c_void;
+    pub fn pthread_setspecific(
+        key: pthread_key_t,
+        value: *const ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_mutex_init(
+        lock: *mut pthread_mutex_t,
+        attr: *const pthread_mutexattr_t,
+    ) -> ::c_int;
+    pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> ::c_int;
+    pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> ::c_int;
+    pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> ::c_int;
+    pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> ::c_int;
+
+    pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> ::c_int;
+    pub fn pthread_mutexattr_destroy(
+        attr: *mut pthread_mutexattr_t,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_settype(
+        attr: *mut pthread_mutexattr_t,
+        _type: ::c_int,
+    ) -> ::c_int;
+
+    pub fn pthread_cond_init(
+        cond: *mut pthread_cond_t,
+        attr: *const pthread_condattr_t,
+    ) -> ::c_int;
+    pub fn pthread_cond_wait(
+        cond: *mut pthread_cond_t,
+        lock: *mut pthread_mutex_t,
+    ) -> ::c_int;
+    pub fn pthread_cond_timedwait(
+        cond: *mut pthread_cond_t,
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> ::c_int;
+    pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> ::c_int;
+    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> ::c_int;
+    pub fn pthread_condattr_init(attr: *mut pthread_condattr_t) -> ::c_int;
+    pub fn pthread_condattr_destroy(attr: *mut pthread_condattr_t) -> ::c_int;
+    pub fn pthread_rwlock_init(
+        lock: *mut pthread_rwlock_t,
+        attr: *const pthread_rwlockattr_t,
+    ) -> ::c_int;
+    pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> ::c_int;
+    pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    pub fn pthread_rwlockattr_init(attr: *mut pthread_rwlockattr_t)
+        -> ::c_int;
+    pub fn pthread_rwlockattr_destroy(
+        attr: *mut pthread_rwlockattr_t,
+    ) -> ::c_int;
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn getsockopt(
+        sockfd: ::c_int,
+        level: ::c_int,
+        optname: ::c_int,
+        optval: *mut ::c_void,
+        optlen: *mut ::socklen_t,
+    ) -> ::c_int;
+    pub fn raise(signum: ::c_int) -> ::c_int;
+    pub fn sigaction(
+        signum: ::c_int,
+        act: *const sigaction,
+        oldact: *mut sigaction,
+    ) -> ::c_int;
+
+    pub fn utimes(
+        filename: *const ::c_char,
+        times: *const ::timeval,
+    ) -> ::c_int;
+    pub fn dlopen(filename: *const ::c_char, flag: ::c_int) -> *mut ::c_void;
+    pub fn dlerror() -> *mut ::c_char;
+    pub fn dlsym(
+        handle: *mut ::c_void,
+        symbol: *const ::c_char,
+    ) -> *mut ::c_void;
+    pub fn dlclose(handle: *mut ::c_void) -> ::c_int;
+    pub fn dladdr(addr: *const ::c_void, info: *mut Dl_info) -> ::c_int;
+
+    pub fn getaddrinfo(
+        node: *const c_char,
+        service: *const c_char,
+        hints: *const addrinfo,
+        res: *mut *mut addrinfo,
+    ) -> ::c_int;
+    pub fn freeaddrinfo(res: *mut addrinfo);
+    pub fn gai_strerror(errcode: ::c_int) -> *const ::c_char;
+    pub fn res_init() -> ::c_int;
+
+    pub fn gmtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;
+    pub fn localtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;
+    pub fn mktime(tm: *mut tm) -> time_t;
+    pub fn time(time: *mut time_t) -> time_t;
+    pub fn gmtime(time_p: *const time_t) -> *mut tm;
+    pub fn localtime(time_p: *const time_t) -> *mut tm;
+
+    pub fn mknod(
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: ::dev_t,
+    ) -> ::c_int;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+    pub fn gethostname(name: *mut ::c_char, len: ::size_t) -> ::c_int;
+    pub fn getservbyname(
+        name: *const ::c_char,
+        proto: *const ::c_char,
+    ) -> *mut servent;
+    pub fn getprotobyname(name: *const ::c_char) -> *mut protoent;
+    pub fn getprotobynumber(proto: ::c_int) -> *mut protoent;
+    pub fn usleep(secs: ::c_uint) -> ::c_int;
+    pub fn send(
+        socket: ::c_int,
+        buf: *const ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn recv(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn putenv(string: *mut c_char) -> ::c_int;
+    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::c_int) -> ::c_int;
+    pub fn select(
+        nfds: ::c_int,
+        readfs: *mut fd_set,
+        writefds: *mut fd_set,
+        errorfds: *mut fd_set,
+        timeout: *mut timeval,
+    ) -> ::c_int;
+    pub fn setlocale(
+        category: ::c_int,
+        locale: *const ::c_char,
+    ) -> *mut ::c_char;
+    pub fn localeconv() -> *mut lconv;
+
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_wait(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_trywait(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_post(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+    pub fn statvfs(path: *const c_char, buf: *mut statvfs) -> ::c_int;
+    pub fn fstatvfs(fd: ::c_int, buf: *mut statvfs) -> ::c_int;
+
+    pub fn readlink(
+        path: *const c_char,
+        buf: *mut c_char,
+        bufsz: ::size_t,
+    ) -> ::ssize_t;
+
+    pub fn sigemptyset(set: *mut sigset_t) -> ::c_int;
+    pub fn sigaddset(set: *mut sigset_t, signum: ::c_int) -> ::c_int;
+    pub fn sigfillset(set: *mut sigset_t) -> ::c_int;
+    pub fn sigdelset(set: *mut sigset_t, signum: ::c_int) -> ::c_int;
+    pub fn sigismember(set: *const sigset_t, signum: ::c_int) -> ::c_int;
+
+    pub fn sigprocmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sigpending(set: *mut sigset_t) -> ::c_int;
+
+    pub fn timegm(tm: *mut ::tm) -> time_t;
+
+    pub fn getsid(pid: pid_t) -> pid_t;
+
+    pub fn sysconf(name: ::c_int) -> ::c_long;
+
+    pub fn mkfifo(path: *const c_char, mode: mode_t) -> ::c_int;
+
+    pub fn pselect(
+        nfds: ::c_int,
+        readfs: *mut fd_set,
+        writefds: *mut fd_set,
+        errorfds: *mut fd_set,
+        timeout: *const timespec,
+        sigmask: *const sigset_t,
+    ) -> ::c_int;
+    pub fn fseeko(
+        stream: *mut ::FILE,
+        offset: ::off_t,
+        whence: ::c_int,
+    ) -> ::c_int;
+    pub fn ftello(stream: *mut ::FILE) -> ::off_t;
+    pub fn tcdrain(fd: ::c_int) -> ::c_int;
+    pub fn cfgetispeed(termios: *const ::termios) -> ::speed_t;
+    pub fn cfgetospeed(termios: *const ::termios) -> ::speed_t;
+    pub fn cfmakeraw(termios: *mut ::termios);
+    pub fn cfsetispeed(termios: *mut ::termios, speed: ::speed_t) -> ::c_int;
+    pub fn cfsetospeed(termios: *mut ::termios, speed: ::speed_t) -> ::c_int;
+    pub fn cfsetspeed(termios: *mut ::termios, speed: ::speed_t) -> ::c_int;
+    pub fn tcgetattr(fd: ::c_int, termios: *mut ::termios) -> ::c_int;
+    pub fn tcsetattr(
+        fd: ::c_int,
+        optional_actions: ::c_int,
+        termios: *const ::termios,
+    ) -> ::c_int;
+    pub fn tcflow(fd: ::c_int, action: ::c_int) -> ::c_int;
+    pub fn tcflush(fd: ::c_int, action: ::c_int) -> ::c_int;
+    pub fn tcgetsid(fd: ::c_int) -> ::pid_t;
+    pub fn tcsendbreak(fd: ::c_int, duration: ::c_int) -> ::c_int;
+    pub fn mkstemp(template: *mut ::c_char) -> ::c_int;
+    pub fn mkdtemp(template: *mut ::c_char) -> *mut ::c_char;
+
+    pub fn tmpnam(ptr: *mut ::c_char) -> *mut ::c_char;
+
+    pub fn openlog(ident: *const ::c_char, logopt: ::c_int, facility: ::c_int);
+    pub fn closelog();
+    pub fn setlogmask(maskpri: ::c_int) -> ::c_int;
+    pub fn syslog(priority: ::c_int, message: *const ::c_char, ...);
+
+    pub fn grantpt(fd: ::c_int) -> ::c_int;
+    pub fn posix_openpt(flags: ::c_int) -> ::c_int;
+    pub fn ptsname(fd: ::c_int) -> *mut ::c_char;
+    pub fn unlockpt(fd: ::c_int) -> ::c_int;
+
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_settime(
+        clk_id: ::clockid_t,
+        tp: *const ::timespec,
+    ) -> ::c_int;
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+
+    pub fn pthread_getattr_np(
+        native: ::pthread_t,
+        attr: *mut ::pthread_attr_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstack(
+        attr: *const ::pthread_attr_t,
+        stackaddr: *mut *mut ::c_void,
+        stacksize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;
+    pub fn setgroups(ngroups: ::size_t, ptr: *const ::gid_t) -> ::c_int;
+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;
+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;
+    pub fn memrchr(
+        cx: *const ::c_void,
+        c: ::c_int,
+        n: ::size_t,
+    ) -> *mut ::c_void;
+
+    pub fn posix_fadvise(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+        advise: ::c_int,
+    ) -> ::c_int;
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn utimensat(
+        dirfd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn duplocale(base: ::locale_t) -> ::locale_t;
+    pub fn freelocale(loc: ::locale_t);
+    pub fn newlocale(
+        mask: ::c_int,
+        locale: *const ::c_char,
+        base: ::locale_t,
+    ) -> ::locale_t;
+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;
+
+    pub fn fdopendir(fd: ::c_int) -> *mut ::DIR;
+
+    pub fn mknodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: dev_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getclock(
+        attr: *const pthread_condattr_t,
+        clock_id: *mut clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setclock(
+        attr: *mut pthread_condattr_t,
+        clock_id: ::clockid_t,
+    ) -> ::c_int;
+    pub fn accept4(
+        fd: ::c_int,
+        addr: *mut ::sockaddr,
+        len: *mut ::socklen_t,
+        flg: ::c_int,
+    ) -> ::c_int;
+    pub fn ptsname_r(
+        fd: ::c_int,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+    pub fn clearenv() -> ::c_int;
+    pub fn waitid(
+        idtype: idtype_t,
+        id: id_t,
+        infop: *mut ::siginfo_t,
+        options: ::c_int,
+    ) -> ::c_int;
+    pub fn setreuid(ruid: ::uid_t, euid: ::uid_t) -> ::c_int;
+    pub fn setregid(rgid: ::gid_t, egid: ::gid_t) -> ::c_int;
+    pub fn getresuid(
+        ruid: *mut ::uid_t,
+        euid: *mut ::uid_t,
+        suid: *mut ::uid_t,
+    ) -> ::c_int;
+    pub fn getresgid(
+        rgid: *mut ::gid_t,
+        egid: *mut ::gid_t,
+        sgid: *mut ::gid_t,
+    ) -> ::c_int;
+    pub fn acct(filename: *const ::c_char) -> ::c_int;
+    pub fn brk(addr: *mut ::c_void) -> ::c_int;
+    pub fn setresgid(rgid: ::gid_t, egid: ::gid_t, sgid: ::gid_t) -> ::c_int;
+    pub fn setresuid(ruid: ::uid_t, euid: ::uid_t, suid: ::uid_t) -> ::c_int;
+    pub fn openpty(
+        amaster: *mut ::c_int,
+        aslave: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *const termios,
+        winp: *const ::winsize,
+    ) -> ::c_int;
+    pub fn execvpe(
+        file: *const ::c_char,
+        argv: *const *const ::c_char,
+        envp: *const *const ::c_char,
+    ) -> ::c_int;
+    pub fn fexecve(
+        fd: ::c_int,
+        argv: *const *const ::c_char,
+        envp: *const *const ::c_char,
+    ) -> ::c_int;
+
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+
+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;
+
+    pub fn setpwent();
+    pub fn endpwent();
+    pub fn getpwent() -> *mut passwd;
+
+    pub fn shm_open(
+        name: *const c_char,
+        oflag: ::c_int,
+        mode: mode_t,
+    ) -> ::c_int;
+
+    // System V IPC
+    pub fn shmget(key: ::key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;
+    pub fn shmat(
+        shmid: ::c_int,
+        shmaddr: *const ::c_void,
+        shmflg: ::c_int,
+    ) -> *mut ::c_void;
+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;
+    pub fn shmctl(
+        shmid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::shmid_ds,
+    ) -> ::c_int;
+    pub fn ftok(pathname: *const ::c_char, proj_id: ::c_int) -> ::key_t;
+    pub fn semget(key: ::key_t, nsems: ::c_int, semflag: ::c_int) -> ::c_int;
+    pub fn semop(
+        semid: ::c_int,
+        sops: *mut ::sembuf,
+        nsops: ::size_t,
+    ) -> ::c_int;
+    pub fn semctl(
+        semid: ::c_int,
+        semnum: ::c_int,
+        cmd: ::c_int,
+        ...
+    ) -> ::c_int;
+    pub fn msgctl(msqid: ::c_int, cmd: ::c_int, buf: *mut msqid_ds)
+        -> ::c_int;
+    pub fn msgget(key: ::key_t, msgflg: ::c_int) -> ::c_int;
+    pub fn msgrcv(
+        msqid: ::c_int,
+        msgp: *mut ::c_void,
+        msgsz: ::size_t,
+        msgtyp: ::c_long,
+        msgflg: ::c_int,
+    ) -> ::ssize_t;
+    pub fn msgsnd(
+        msqid: ::c_int,
+        msgp: *const ::c_void,
+        msgsz: ::size_t,
+        msgflg: ::c_int,
+    ) -> ::c_int;
+
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn __errno_location() -> *mut ::c_int;
+
+    pub fn fallocate(
+        fd: ::c_int,
+        mode: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+    pub fn posix_fallocate(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+    pub fn readahead(
+        fd: ::c_int,
+        offset: ::off64_t,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    pub fn signalfd(
+        fd: ::c_int,
+        mask: *const ::sigset_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn timerfd_create(clockid: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn timerfd_gettime(
+        fd: ::c_int,
+        curr_value: *mut itimerspec,
+    ) -> ::c_int;
+    pub fn timerfd_settime(
+        fd: ::c_int,
+        flags: ::c_int,
+        new_value: *const itimerspec,
+        old_value: *mut itimerspec,
+    ) -> ::c_int;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn quotactl(
+        cmd: ::c_int,
+        special: *const ::c_char,
+        id: ::c_int,
+        data: *mut ::c_char,
+    ) -> ::c_int;
+    pub fn dup3(oldfd: ::c_int, newfd: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn mkostemps(
+        template: *mut ::c_char,
+        suffixlen: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn sigtimedwait(
+        set: *const sigset_t,
+        info: *mut siginfo_t,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> ::c_int;
+    pub fn nl_langinfo_l(item: ::nl_item, locale: ::locale_t)
+        -> *mut ::c_char;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::socklen_t,
+        serv: *mut ::c_char,
+        sevlen: ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn reboot(how_to: ::c_int) -> ::c_int;
+    pub fn setfsgid(gid: ::gid_t) -> ::c_int;
+    pub fn setfsuid(uid: ::uid_t) -> ::c_int;
+
+    // Not available now on Android
+    pub fn mkfifoat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn if_nameindex() -> *mut if_nameindex;
+    pub fn if_freenameindex(ptr: *mut if_nameindex);
+    pub fn sync_file_range(
+        fd: ::c_int,
+        offset: ::off64_t,
+        nbytes: ::off64_t,
+        flags: ::c_uint,
+    ) -> ::c_int;
+    pub fn getifaddrs(ifap: *mut *mut ::ifaddrs) -> ::c_int;
+    pub fn freeifaddrs(ifa: *mut ::ifaddrs);
+
+    pub fn glob(
+        pattern: *const c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut ::glob_t,
+    ) -> ::c_int;
+    pub fn globfree(pglob: *mut ::glob_t);
+
+    pub fn posix_madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;
+
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+    pub fn madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;
+    pub fn futimes(fd: ::c_int, times: *const ::timeval) -> ::c_int;
+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;
+
+    pub fn bind(
+        socket: ::c_int,
+        address: *const ::sockaddr,
+        address_len: ::socklen_t,
+    ) -> ::c_int;
+
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+
+    pub fn sendmsg(
+        fd: ::c_int,
+        msg: *const ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn recvmsg(
+        fd: ::c_int,
+        msg: *mut ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn getdomainname(name: *mut ::c_char, len: ::size_t) -> ::c_int;
+    pub fn setdomainname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn vhangup() -> ::c_int;
+    pub fn sendmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn recvmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn sync();
+    pub fn syscall(num: ::c_long, ...) -> ::c_long;
+    pub fn sched_getaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut cpu_set_t,
+    ) -> ::c_int;
+    pub fn sched_setaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        cpuset: *const cpu_set_t,
+    ) -> ::c_int;
+    pub fn umount(target: *const ::c_char) -> ::c_int;
+    pub fn sched_get_priority_max(policy: ::c_int) -> ::c_int;
+    pub fn tee(
+        fd_in: ::c_int,
+        fd_out: ::c_int,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn settimeofday(
+        tv: *const ::timeval,
+        tz: *const ::timezone,
+    ) -> ::c_int;
+    pub fn splice(
+        fd_in: ::c_int,
+        off_in: *mut ::loff_t,
+        fd_out: ::c_int,
+        off_out: *mut ::loff_t,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn eventfd(init: ::c_uint, flags: ::c_int) -> ::c_int;
+    pub fn sched_rr_get_interval(pid: ::pid_t, tp: *mut ::timespec)
+        -> ::c_int;
+    pub fn sem_timedwait(
+        sem: *mut sem_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;
+    pub fn sched_setparam(
+        pid: ::pid_t,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn swapoff(puath: *const ::c_char) -> ::c_int;
+    pub fn vmsplice(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        nr_segs: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mount(
+        src: *const ::c_char,
+        target: *const ::c_char,
+        fstype: *const ::c_char,
+        flags: ::c_ulong,
+        data: *const ::c_void,
+    ) -> ::c_int;
+    pub fn personality(persona: ::c_ulong) -> ::c_int;
+    pub fn sched_getparam(pid: ::pid_t, param: *mut ::sched_param) -> ::c_int;
+    pub fn ppoll(
+        fds: *mut ::pollfd,
+        nfds: nfds_t,
+        timeout: *const ::timespec,
+        sigmask: *const sigset_t,
+    ) -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn clone(
+        cb: extern "C" fn(*mut ::c_void) -> ::c_int,
+        child_stack: *mut ::c_void,
+        flags: ::c_int,
+        arg: *mut ::c_void,
+        ...
+    ) -> ::c_int;
+    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;
+    pub fn clock_nanosleep(
+        clk_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const ::pthread_attr_t,
+        guardsize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn sched_get_priority_min(policy: ::c_int) -> ::c_int;
+    pub fn umount2(target: *const ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn swapon(path: *const ::c_char, swapflags: ::c_int) -> ::c_int;
+    pub fn sched_setscheduler(
+        pid: ::pid_t,
+        policy: ::c_int,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn sigsuspend(mask: *const ::sigset_t) -> ::c_int;
+    pub fn getgrgid_r(
+        gid: ::gid_t,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;
+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;
+    pub fn getdtablesize() -> ::c_int;
+    pub fn getgrnam_r(
+        name: *const ::c_char,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn initgroups(user: *const ::c_char, group: ::gid_t) -> ::c_int;
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;
+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;
+    pub fn pthread_cancel(thread: ::pthread_t) -> ::c_int;
+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;
+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    pub fn getpwnam_r(
+        name: *const ::c_char,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;
+    pub fn getgrouplist(
+        user: *const ::c_char,
+        group: ::gid_t,
+        groups: *mut ::gid_t,
+        ngroups: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+    pub fn faccessat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_create(
+        native: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        f: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn dl_iterate_phdr(
+        callback: ::Option<
+            unsafe extern "C" fn(
+                info: *mut ::dl_phdr_info,
+                size: ::size_t,
+                data: *mut ::c_void,
+            ) -> ::c_int,
+        >,
+        data: *mut ::c_void,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(any(target_arch = "x86_64"))] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        #[macro_use]
+        mod align;
+    } else {
+        #[macro_use]
+        mod no_align;
+    }
+}
+expand_align!();
+
+cfg_if! {
+    if #[cfg(libc_core_cvoid)] {
+        pub use ::ffi::c_void;
+    } else {
+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help
+        // enable more optimization opportunities around it recognizing things
+        // like malloc/free.
+        #[repr(u8)]
+        #[allow(missing_copy_implementations)]
+        #[allow(missing_debug_implementations)]
+        pub enum c_void {
+            // Two dummy variants so the #[repr] attribute can be used.
+            #[doc(hidden)]
+            __variant1,
+            #[doc(hidden)]
+            __variant2,
+        }
+    }
+}
diff --git a/library/libc/src/fuchsia/no_align.rs b/library/libc/src/fuchsia/no_align.rs
new file mode 100644
index 00000000..7ca90e0e
--- /dev/null
+++ b/library/libc/src/fuchsia/no_align.rs
@@ -0,0 +1,129 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            pub struct pthread_mutexattr_t {
+                #[cfg(target_arch = "x86_64")]
+                __align: [::c_int; 0],
+                #[cfg(not(target_arch = "x86_64"))]
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            pub struct pthread_rwlockattr_t {
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],
+            }
+
+            pub struct pthread_condattr_t {
+                __align: [::c_int; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+
+        s_no_extra_traits! {
+            pub struct pthread_mutex_t {
+                #[cfg(any(target_arch = "arm",
+                          all(target_arch = "x86_64",
+                              target_pointer_width = "32")))]
+                __align: [::c_long; 0],
+                #[cfg(not(any(target_arch = "arm",
+                              all(target_arch = "x86_64",
+                                  target_pointer_width = "32"))))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            pub struct pthread_rwlock_t {
+                __align: [::c_long; 0],
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+
+            pub struct pthread_cond_t {
+                __align: [*const ::c_void; 0],
+                #[cfg(not(target_env = "musl"))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for pthread_cond_t {
+                    fn eq(&self, other: &pthread_cond_t) -> bool {
+                        // Ignore __align field
+                        self.size
+                            .iter()
+                            .zip(other.size.iter())
+                            .all(|(a,b)| a == b)
+                    }
+                }
+                impl Eq for pthread_cond_t {}
+                impl ::fmt::Debug for pthread_cond_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("pthread_cond_t")
+                            // Ignore __align field
+                            // FIXME: .field("size", &self.size)
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for pthread_cond_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        // Ignore __align field
+                        self.size.hash(state);
+                    }
+                }
+
+                impl PartialEq for pthread_mutex_t {
+                    fn eq(&self, other: &pthread_mutex_t) -> bool {
+                        // Ignore __align field
+                        self.size
+                            .iter()
+                            .zip(other.size.iter())
+                            .all(|(a,b)| a == b)
+                    }
+                }
+                impl Eq for pthread_mutex_t {}
+                impl ::fmt::Debug for pthread_mutex_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("pthread_mutex_t")
+                            // Ignore __align field
+                            // FIXME: .field("size", &self.size)
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for pthread_mutex_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        // Ignore __align field
+                        self.size.hash(state);
+                    }
+                }
+
+                impl PartialEq for pthread_rwlock_t {
+                    fn eq(&self, other: &pthread_rwlock_t) -> bool {
+                        // Ignore __align field
+                        self.size
+                            .iter()
+                            .zip(other.size.iter())
+                            .all(|(a,b)| a == b)
+                    }
+                }
+                impl Eq for pthread_rwlock_t {}
+                impl ::fmt::Debug for pthread_rwlock_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("pthread_rwlock_t")
+                            // Ignore __align field
+                            // FIXME: .field("size", &self.size)
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for pthread_rwlock_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        // Ignore __align field
+                        self.size.hash(state);
+                    }
+                }
+            }
+        }
+    };
+}
diff --git a/library/libc/src/fuchsia/x86_64.rs b/library/libc/src/fuchsia/x86_64.rs
new file mode 100644
index 00000000..dca3c247
--- /dev/null
+++ b/library/libc/src/fuchsia/x86_64.rs
@@ -0,0 +1,152 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type nlink_t = u64;
+pub type blksize_t = ::c_long;
+pub type __u64 = ::c_ulonglong;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 3],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __reserved: [::c_long; 3],
+    }
+
+    pub struct mcontext_t {
+        __private: [u64; 32],
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __unused1: ::c_long,
+        __unused2: ::c_long
+    }
+}
+
+s_no_extra_traits! {
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_mcontext: mcontext_t,
+        pub uc_sigmask: ::sigset_t,
+        __private: [u8; 512],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for ucontext_t {
+            fn eq(&self, other: &ucontext_t) -> bool {
+                self.uc_flags == other.uc_flags
+                    && self.uc_link == other.uc_link
+                    && self.uc_stack == other.uc_stack
+                    && self.uc_mcontext == other.uc_mcontext
+                    && self.uc_sigmask == other.uc_sigmask
+                    && self
+                    .__private
+                    .iter()
+                    .zip(other.__private.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for ucontext_t {}
+        impl ::fmt::Debug for ucontext_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("ucontext_t")
+                    .field("uc_flags", &self.uc_flags)
+                    .field("uc_link", &self.uc_link)
+                    .field("uc_stack", &self.uc_stack)
+                    .field("uc_mcontext", &self.uc_mcontext)
+                    .field("uc_sigmask", &self.uc_sigmask)
+                    // FIXME: .field("__private", &self.__private)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for ucontext_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uc_flags.hash(state);
+                self.uc_link.hash(state);
+                self.uc_stack.hash(state);
+                self.uc_mcontext.hash(state);
+                self.uc_sigmask.hash(state);
+                self.__private.hash(state);
+            }
+        }
+    }
+}
+
+// offsets in user_regs_structs, from sys/reg.h
+pub const R15: ::c_int = 0;
+pub const R14: ::c_int = 1;
+pub const R13: ::c_int = 2;
+pub const R12: ::c_int = 3;
+pub const RBP: ::c_int = 4;
+pub const RBX: ::c_int = 5;
+pub const R11: ::c_int = 6;
+pub const R10: ::c_int = 7;
+pub const R9: ::c_int = 8;
+pub const R8: ::c_int = 9;
+pub const RAX: ::c_int = 10;
+pub const RCX: ::c_int = 11;
+pub const RDX: ::c_int = 12;
+pub const RSI: ::c_int = 13;
+pub const RDI: ::c_int = 14;
+pub const ORIG_RAX: ::c_int = 15;
+pub const RIP: ::c_int = 16;
+pub const CS: ::c_int = 17;
+pub const EFLAGS: ::c_int = 18;
+pub const RSP: ::c_int = 19;
+pub const SS: ::c_int = 20;
+pub const FS_BASE: ::c_int = 21;
+pub const GS_BASE: ::c_int = 22;
+pub const DS: ::c_int = 23;
+pub const ES: ::c_int = 24;
+pub const FS: ::c_int = 25;
+pub const GS: ::c_int = 26;
+
+pub const MAP_32BIT: ::c_int = 0x0040;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
diff --git a/library/libc/src/hermit/aarch64.rs b/library/libc/src/hermit/aarch64.rs
new file mode 100644
index 00000000..1a92e3b4
--- /dev/null
+++ b/library/libc/src/hermit/aarch64.rs
@@ -0,0 +1,2 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
diff --git a/library/libc/src/hermit/mod.rs b/library/libc/src/hermit/mod.rs
new file mode 100644
index 00000000..bffcefdd
--- /dev/null
+++ b/library/libc/src/hermit/mod.rs
@@ -0,0 +1,64 @@
+// libc port for HermitCore (https://hermitcore.org)
+//
+// Ported by Colin Fink <colin.finck@rwth-aachen.de>
+//       and Stefan Lankes <slankes@eonerc.rwth-aachen.de>
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_float = f32;
+pub type c_double = f64;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+
+pub type size_t = usize;
+pub type ptrdiff_t = isize;
+pub type intptr_t = isize;
+pub type uintptr_t = usize;
+pub type ssize_t = isize;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+pub type wint_t = u32;
+pub type wctype_t = i64;
+
+pub type regoff_t = size_t;
+pub type off_t = c_long;
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_core_cvoid)] {
+        pub use ::ffi::c_void;
+    } else {
+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help
+        // enable more optimization opportunities around it recognizing things
+        // like malloc/free.
+        #[repr(u8)]
+        #[allow(missing_copy_implementations)]
+        #[allow(missing_debug_implementations)]
+        pub enum c_void {
+            // Two dummy variants so the #[repr] attribute can be used.
+            #[doc(hidden)]
+            __variant1,
+            #[doc(hidden)]
+            __variant2,
+        }
+    }
+}
diff --git a/library/libc/src/hermit/x86_64.rs b/library/libc/src/hermit/x86_64.rs
new file mode 100644
index 00000000..76ec3ce8
--- /dev/null
+++ b/library/libc/src/hermit/x86_64.rs
@@ -0,0 +1,2 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
diff --git a/library/libc/src/lib.rs b/library/libc/src/lib.rs
new file mode 100644
index 00000000..30c94b09
--- /dev/null
+++ b/library/libc/src/lib.rs
@@ -0,0 +1,153 @@
+//! libc - Raw FFI bindings to platforms' system libraries
+//!
+//! [Documentation for other platforms][pd].
+//!
+//! [pd]: https://rust-lang.github.io/libc/#platform-specific-documentation
+#![crate_name = "libc"]
+#![crate_type = "rlib"]
+#![allow(
+    renamed_and_removed_lints, // Keep this order.
+    unknown_lints, // Keep this order.
+    bad_style,
+    overflowing_literals,
+    improper_ctypes,
+    // This lint is renamed but we run CI for old stable rustc so should be here.
+    redundant_semicolon,
+    redundant_semicolons
+)]
+#![cfg_attr(libc_deny_warnings, deny(warnings))]
+// Attributes needed when building as part of the standard library
+#![cfg_attr(feature = "rustc-dep-of-std", feature(link_cfg, no_core))]
+#![cfg_attr(libc_thread_local, feature(thread_local))]
+// Enable extra lints:
+#![cfg_attr(feature = "extra_traits", deny(missing_debug_implementations))]
+#![deny(missing_copy_implementations, safe_packed_borrows)]
+#![cfg_attr(not(feature = "rustc-dep-of-std"), no_std)]
+#![cfg_attr(feature = "rustc-dep-of-std", no_core)]
+#![cfg_attr(
+    any(feature = "rustc-dep-of-std", target_os = "redox"),
+    feature(static_nobundle)
+)]
+#![cfg_attr(libc_const_extern_fn, feature(const_extern_fn))]
+
+#[macro_use]
+mod macros;
+
+cfg_if! {
+    if #[cfg(feature = "rustc-dep-of-std")] {
+        extern crate rustc_std_workspace_core as core;
+        #[allow(unused_imports)]
+        use core::iter;
+        #[allow(unused_imports)]
+        use core::ops;
+        #[allow(unused_imports)]
+        use core::option;
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_priv_mod_use)] {
+        #[cfg(libc_core_cvoid)]
+        #[allow(unused_imports)]
+        use core::ffi;
+        #[allow(unused_imports)]
+        use core::fmt;
+        #[allow(unused_imports)]
+        use core::hash;
+        #[allow(unused_imports)]
+        use core::num;
+        #[allow(unused_imports)]
+        use core::mem;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        use core::clone::Clone;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        use core::marker::Copy;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        use core::option::Option;
+    } else {
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        pub use core::fmt;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        pub use core::hash;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        pub use core::num;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        pub use core::mem;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        pub use core::clone::Clone;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        pub use core::marker::Copy;
+        #[doc(hidden)]
+        #[allow(unused_imports)]
+        pub use core::option::Option;
+    }
+}
+
+cfg_if! {
+    if #[cfg(windows)] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod windows;
+        pub use windows::*;
+    } else if #[cfg(target_os = "fuchsia")] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod fuchsia;
+        pub use fuchsia::*;
+    } else if #[cfg(target_os = "switch")] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod switch;
+        pub use switch::*;
+    } else if #[cfg(target_os = "psp")] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod psp;
+        pub use psp::*;
+    } else if #[cfg(target_os = "vxworks")] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod vxworks;
+        pub use vxworks::*;
+    } else if #[cfg(unix)] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod unix;
+        pub use unix::*;
+    } else if #[cfg(target_os = "hermit")] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod hermit;
+        pub use hermit::*;
+    } else if #[cfg(all(target_env = "sgx", target_vendor = "fortanix"))] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod sgx;
+        pub use sgx::*;
+    } else if #[cfg(any(target_env = "wasi", target_os = "wasi"))] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod wasi;
+        pub use wasi::*;
+    } else {
+        // non-supported targets: empty...
+    }
+}
diff --git a/library/libc/src/macros.rs b/library/libc/src/macros.rs
new file mode 100644
index 00000000..1871cfaf
--- /dev/null
+++ b/library/libc/src/macros.rs
@@ -0,0 +1,343 @@
+/// A macro for defining #[cfg] if-else statements.
+///
+/// This is similar to the `if/elif` C preprocessor macro by allowing definition
+/// of a cascade of `#[cfg]` cases, emitting the implementation which matches
+/// first.
+///
+/// This allows you to conveniently provide a long list #[cfg]'d blocks of code
+/// without having to rewrite each clause multiple times.
+#[allow(unused_macros)]
+macro_rules! cfg_if {
+    // match if/else chains with a final `else`
+    ($(
+        if #[cfg($($meta:meta),*)] { $($it:item)* }
+    ) else * else {
+        $($it2:item)*
+    }) => {
+        cfg_if! {
+            @__items
+            () ;
+            $( ( ($($meta),*) ($($it)*) ), )*
+            ( () ($($it2)*) ),
+        }
+    };
+
+    // match if/else chains lacking a final `else`
+    (
+        if #[cfg($($i_met:meta),*)] { $($i_it:item)* }
+        $(
+            else if #[cfg($($e_met:meta),*)] { $($e_it:item)* }
+        )*
+    ) => {
+        cfg_if! {
+            @__items
+            () ;
+            ( ($($i_met),*) ($($i_it)*) ),
+            $( ( ($($e_met),*) ($($e_it)*) ), )*
+            ( () () ),
+        }
+    };
+
+    // Internal and recursive macro to emit all the items
+    //
+    // Collects all the negated `cfg`s in a list at the beginning and after the
+    // semicolon is all the remaining items
+    (@__items ($($not:meta,)*) ; ) => {};
+    (@__items ($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ),
+     $($rest:tt)*) => {
+        // Emit all items within one block, applying an appropriate #[cfg]. The
+        // #[cfg] will require all `$m` matchers specified and must also negate
+        // all previous matchers.
+        cfg_if! { @__apply cfg(all($($m,)* not(any($($not),*)))), $($it)* }
+
+        // Recurse to emit all other items in `$rest`, and when we do so add all
+        // our `$m` matchers to the list of `$not` matchers as future emissions
+        // will have to negate everything we just matched as well.
+        cfg_if! { @__items ($($not,)* $($m,)*) ; $($rest)* }
+    };
+
+    // Internal macro to Apply a cfg attribute to a list of items
+    (@__apply $m:meta, $($it:item)*) => {
+        $(#[$m] $it)*
+    };
+}
+
+#[allow(unused_macros)]
+macro_rules! s {
+    ($($(#[$attr:meta])* pub $t:ident $i:ident { $($field:tt)* })*) => ($(
+        s!(it: $(#[$attr])* pub $t $i { $($field)* });
+    )*);
+    (it: $(#[$attr:meta])* pub union $i:ident { $($field:tt)* }) => (
+        compile_error!("unions cannot derive extra traits, use s_no_extra_traits instead");
+    );
+    (it: $(#[$attr:meta])* pub struct $i:ident { $($field:tt)* }) => (
+        __item! {
+            #[repr(C)]
+            #[cfg_attr(feature = "extra_traits", derive(Debug, Eq, Hash, PartialEq))]
+            #[allow(deprecated)]
+            $(#[$attr])*
+            pub struct $i { $($field)* }
+        }
+        #[allow(deprecated)]
+        impl ::Copy for $i {}
+        #[allow(deprecated)]
+        impl ::Clone for $i {
+            fn clone(&self) -> $i { *self }
+        }
+    );
+}
+
+#[allow(unused_macros)]
+macro_rules! s_no_extra_traits {
+    ($($(#[$attr:meta])* pub $t:ident $i:ident { $($field:tt)* })*) => ($(
+        s_no_extra_traits!(it: $(#[$attr])* pub $t $i { $($field)* });
+    )*);
+    (it: $(#[$attr:meta])* pub union $i:ident { $($field:tt)* }) => (
+        cfg_if! {
+            if #[cfg(libc_union)] {
+                __item! {
+                    #[repr(C)]
+                    $(#[$attr])*
+                    pub union $i { $($field)* }
+                }
+
+                impl ::Copy for $i {}
+                impl ::Clone for $i {
+                    fn clone(&self) -> $i { *self }
+                }
+            }
+        }
+    );
+    (it: $(#[$attr:meta])* pub struct $i:ident { $($field:tt)* }) => (
+        __item! {
+            #[repr(C)]
+            $(#[$attr])*
+            pub struct $i { $($field)* }
+        }
+        #[allow(deprecated)]
+        impl ::Copy for $i {}
+        #[allow(deprecated)]
+        impl ::Clone for $i {
+            fn clone(&self) -> $i { *self }
+        }
+    );
+}
+
+#[allow(unused_macros)]
+macro_rules! e {
+    ($($(#[$attr:meta])* pub enum $i:ident { $($field:tt)* })*) => ($(
+        __item! {
+            #[cfg_attr(feature = "extra_traits", derive(Debug, Eq, Hash, PartialEq))]
+            $(#[$attr])*
+            pub enum $i { $($field)* }
+        }
+        impl ::Copy for $i {}
+        impl ::Clone for $i {
+            fn clone(&self) -> $i { *self }
+        }
+    )*);
+}
+
+#[allow(unused_macros)]
+macro_rules! s_paren {
+    ($($(#[$attr:meta])* pub struct $i:ident ( $($field:tt)* ); )* ) => ($(
+        __item! {
+            #[cfg_attr(feature = "extra_traits", derive(Debug, Eq, Hash, PartialEq))]
+            $(#[$attr])*
+            pub struct $i ( $($field)* );
+        }
+        impl ::Copy for $i {}
+        impl ::Clone for $i {
+            fn clone(&self) -> $i { *self }
+        }
+    )*);
+}
+
+// This is a pretty horrible hack to allow us to conditionally mark
+// some functions as 'const', without requiring users of this macro
+// to care about the "const-extern-fn" feature.
+//
+// When 'const-extern-fn' is enabled, we emit the captured 'const' keyword
+// in the expanded function.
+//
+// When 'const-extern-fn' is disabled, we always emit a plain 'pub unsafe extern fn'.
+// Note that the expression matched by the macro is exactly the same - this allows
+// users of this macro to work whether or not 'const-extern-fn' is enabled
+//
+// Unfortunately, we need to duplicate most of this macro between the 'cfg_if' blocks.
+// This is because 'const unsafe extern fn' won't even parse on older compilers,
+// so we need to avoid emitting it at all of 'const-extern-fn'.
+//
+// Specifically, moving the 'cfg_if' into the macro body will *not* work.
+// Doing so would cause the '#[cfg(feature = "const-extern-fn")]' to be emitted
+// into user code. The 'cfg' gate will not stop Rust from trying to parse the
+// 'pub const unsafe extern fn', so users would get a compiler error even when
+// the 'const-extern-fn' feature is disabled
+//
+// Note that users of this macro need to place 'const' in a weird position
+// (after the closing ')' for the arguments, but before the return type).
+// This was the only way I could satisfy the following two requirements:
+// 1. Avoid ambiguity errors from 'macro_rules!' (which happen when writing '$foo:ident fn'
+// 2. Allow users of this macro to mix 'pub fn foo' and 'pub const fn bar' within the same
+// 'f!' block
+cfg_if! {
+    if #[cfg(libc_const_extern_fn)] {
+        #[allow(unused_macros)]
+        macro_rules! f {
+            ($($(#[$attr:meta])* pub $({$constness:ident})* fn $i:ident(
+                        $($arg:ident: $argty:ty),*
+            ) -> $ret:ty {
+                $($body:stmt);*
+            })*) => ($(
+                #[inline]
+                $(#[$attr])*
+                pub $($constness)* unsafe extern fn $i($($arg: $argty),*
+                ) -> $ret {
+                    $($body);*
+                }
+            )*)
+        }
+
+        #[allow(unused_macros)]
+        macro_rules! safe_f {
+            ($($(#[$attr:meta])* pub $({$constness:ident})* fn $i:ident(
+                        $($arg:ident: $argty:ty),*
+            ) -> $ret:ty {
+                $($body:stmt);*
+            })*) => ($(
+                #[inline]
+                $(#[$attr])*
+                pub $($constness)* extern fn $i($($arg: $argty),*
+                ) -> $ret {
+                    $($body);*
+                }
+            )*)
+        }
+
+        #[allow(unused_macros)]
+        macro_rules! const_fn {
+            ($($(#[$attr:meta])* $({$constness:ident})* fn $i:ident(
+                        $($arg:ident: $argty:ty),*
+            ) -> $ret:ty {
+                $($body:stmt);*
+            })*) => ($(
+                #[inline]
+                $(#[$attr])*
+                $($constness)* fn $i($($arg: $argty),*
+                ) -> $ret {
+                    $($body);*
+                }
+            )*)
+        }
+
+    } else {
+        #[allow(unused_macros)]
+        macro_rules! f {
+            ($($(#[$attr:meta])* pub $({$constness:ident})* fn $i:ident(
+                        $($arg:ident: $argty:ty),*
+            ) -> $ret:ty {
+                $($body:stmt);*
+            })*) => ($(
+                #[inline]
+                $(#[$attr])*
+                pub unsafe extern fn $i($($arg: $argty),*
+                ) -> $ret {
+                    $($body);*
+                }
+            )*)
+        }
+
+        #[allow(unused_macros)]
+        macro_rules! safe_f {
+            ($($(#[$attr:meta])* pub $({$constness:ident})* fn $i:ident(
+                        $($arg:ident: $argty:ty),*
+            ) -> $ret:ty {
+                $($body:stmt);*
+            })*) => ($(
+                #[inline]
+                $(#[$attr])*
+                pub extern fn $i($($arg: $argty),*
+                ) -> $ret {
+                    $($body);*
+                }
+            )*)
+        }
+
+        #[allow(unused_macros)]
+        macro_rules! const_fn {
+            ($($(#[$attr:meta])* $({$constness:ident})* fn $i:ident(
+                        $($arg:ident: $argty:ty),*
+            ) -> $ret:ty {
+                $($body:stmt);*
+            })*) => ($(
+                #[inline]
+                $(#[$attr])*
+                fn $i($($arg: $argty),*
+                ) -> $ret {
+                    $($body);*
+                }
+            )*)
+        }
+    }
+}
+
+#[allow(unused_macros)]
+macro_rules! __item {
+    ($i:item) => {
+        $i
+    };
+}
+
+#[allow(unused_macros)]
+macro_rules! align_const {
+    ($($(#[$attr:meta])*
+       pub const $name:ident : $t1:ty
+       = $t2:ident { $($field:tt)* };)*) => ($(
+        #[cfg(libc_align)]
+        $(#[$attr])*
+        pub const $name : $t1 = $t2 {
+            $($field)*
+        };
+        #[cfg(not(libc_align))]
+        $(#[$attr])*
+        pub const $name : $t1 = $t2 {
+            $($field)*
+            __align: [],
+        };
+    )*)
+}
+
+// This macro is used to deprecate items that should be accessed via the mach crate
+#[allow(unused_macros)]
+macro_rules! deprecated_mach {
+    (pub const $id:ident: $ty:ty = $expr:expr;) => {
+        #[deprecated(
+            since = "0.2.55",
+            note = "Use the `mach` crate instead",
+        )]
+        #[allow(deprecated)]
+        pub const $id: $ty = $expr;
+    };
+    ($(pub const $id:ident: $ty:ty = $expr:expr;)*) => {
+        $(
+            deprecated_mach!(
+                pub const $id: $ty = $expr;
+            );
+        )*
+    };
+    (pub type $id:ident = $ty:ty;) => {
+        #[deprecated(
+            since = "0.2.55",
+            note = "Use the `mach` crate instead",
+        )]
+        #[allow(deprecated)]
+        pub type $id = $ty;
+    };
+    ($(pub type $id:ident = $ty:ty;)*) => {
+        $(
+            deprecated_mach!(
+                pub type $id = $ty;
+            );
+        )*
+    }
+}
diff --git a/library/libc/src/psp.rs b/library/libc/src/psp.rs
new file mode 100644
index 00000000..9babe1c0
--- /dev/null
+++ b/library/libc/src/psp.rs
@@ -0,0 +1,4716 @@
+//! PSP C type definitions
+//!
+//! These type declarations are not enough, as they must be ultimately resolved
+//! by the linker. Crates that use these definitions must, somewhere in the
+//! crate graph, include a stub provider crate such as the `psp` crate.
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_float = f32;
+pub type c_double = f64;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+
+pub type size_t = usize;
+pub type ptrdiff_t = isize;
+pub type intptr_t = isize;
+pub type uintptr_t = usize;
+pub type ssize_t = isize;
+
+pub type c_char = u8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+cfg_if! {
+    if #[cfg(libc_core_cvoid)] {
+        pub use ::ffi::c_void;
+    } else {
+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help
+        // enable more optimization opportunities around it recognizing things
+        // like malloc/free.
+        #[repr(u8)]
+        #[allow(missing_copy_implementations)]
+        #[allow(missing_debug_implementations)]
+        pub enum c_void {
+            // Two dummy variants so the #[repr] attribute can be used.
+            #[doc(hidden)]
+            __variant1,
+            #[doc(hidden)]
+            __variant2,
+        }
+    }
+}
+
+pub type SceKernelVTimerHandler = unsafe extern "C" fn(
+    uid: SceUid,
+    arg1: *mut SceKernelSysClock,
+    arg2: *mut SceKernelSysClock,
+    arg3: *mut c_void,
+) -> u32;
+
+pub type SceKernelVTimerHandlerWide = unsafe extern "C" fn(
+    uid: SceUid,
+    arg1: i64,
+    arg2: i64,
+    arg3: *mut c_void,
+) -> u32;
+
+pub type SceKernelThreadEventHandler =
+    unsafe extern "C" fn(mask: i32, thid: SceUid, common: *mut c_void) -> i32;
+
+pub type SceKernelAlarmHandler =
+    unsafe extern "C" fn(common: *mut c_void) -> u32;
+
+pub type SceKernelCallbackFunction =
+    unsafe extern "C" fn(arg1: i32, arg2: i32, arg: *mut c_void) -> i32;
+
+pub type SceKernelThreadEntry =
+    unsafe extern "C" fn(args: usize, argp: *mut c_void) -> i32;
+
+pub type PowerCallback = extern "C" fn(unknown: i32, power_info: i32);
+
+pub type IoPermissions = i32;
+
+pub type UmdCallback = fn(unknown: i32, event: i32) -> i32;
+
+pub type SceMpegRingbufferCb = ::Option<
+    unsafe extern "C" fn(
+        data: *mut c_void,
+        num_packets: i32,
+        param: *mut c_void,
+    ) -> i32,
+>;
+
+pub type GuCallback = ::Option<extern "C" fn(id: i32, arg: *mut c_void)>;
+pub type GuSwapBuffersCallback = ::Option<
+    extern "C" fn(display: *mut *mut c_void, render: *mut *mut c_void),
+>;
+
+pub type SceNetAdhocctlHandler = ::Option<
+    unsafe extern "C" fn(flag: i32, error: i32, unknown: *mut c_void),
+>;
+
+pub type AdhocMatchingCallback = ::Option<
+    unsafe extern "C" fn(
+        matching_id: i32,
+        event: i32,
+        mac: *mut u8,
+        opt_len: i32,
+        opt_data: *mut c_void,
+    ),
+>;
+
+pub type SceNetApctlHandler = ::Option<
+    unsafe extern "C" fn(
+        oldState: i32,
+        newState: i32,
+        event: i32,
+        error: i32,
+        pArg: *mut c_void,
+    ),
+>;
+
+pub type HttpMallocFunction =
+    ::Option<unsafe extern "C" fn(size: usize) -> *mut c_void>;
+pub type HttpReallocFunction =
+    ::Option<unsafe extern "C" fn(p: *mut c_void, size: usize) -> *mut c_void>;
+pub type HttpFreeFunction = ::Option<unsafe extern "C" fn(p: *mut c_void)>;
+pub type HttpPasswordCB = ::Option<
+    unsafe extern "C" fn(
+        request: i32,
+        auth_type: HttpAuthType,
+        realm: *const u8,
+        username: *mut u8,
+        password: *mut u8,
+        need_entity: i32,
+        entity_body: *mut *mut u8,
+        entity_size: *mut usize,
+        save: *mut i32,
+    ) -> i32,
+>;
+
+pub type socklen_t = u32;
+
+e! {
+    #[repr(u32)]
+    pub enum AudioFormat {
+        Stereo = 0,
+        Mono = 0x10,
+    }
+
+    #[repr(u32)]
+    pub enum DisplayMode {
+        Lcd = 0,
+    }
+
+    #[repr(u32)]
+    pub enum DisplayPixelFormat {
+        Psm5650 = 0,
+        Psm5551 = 1,
+        Psm4444 = 2,
+        Psm8888 = 3,
+    }
+
+    #[repr(u32)]
+    pub enum DisplaySetBufSync {
+        Immediate = 0,
+        NextFrame = 1,
+    }
+
+    #[repr(i32)]
+    pub enum AudioOutputFrequency {
+        Khz48 = 48000,
+        Khz44_1 = 44100,
+        Khz32 = 32000,
+        Khz24 = 24000,
+        Khz22_05 = 22050,
+        Khz16 = 16000,
+        Khz12 = 12000,
+        Khz11_025 = 11025,
+        Khz8 = 8000,
+    }
+
+    #[repr(i32)]
+    pub enum AudioInputFrequency {
+        Khz44_1 = 44100,
+        Khz22_05 = 22050,
+        Khz11_025 = 11025,
+    }
+
+    #[repr(u32)]
+    pub enum CtrlMode {
+        Digital = 0,
+        Analog,
+    }
+
+    #[repr(i32)]
+    pub enum GeMatrixType {
+        Bone0 = 0,
+        Bone1,
+        Bone2,
+        Bone3,
+        Bone4,
+        Bone5,
+        Bone6,
+        Bone7,
+        World,
+        View,
+        Projection,
+        TexGen,
+    }
+
+    #[repr(i32)]
+    pub enum GeListState {
+        Done = 0,
+        Queued,
+        DrawingDone,
+        StallReached,
+        CancelDone,
+    }
+
+    #[repr(u8)]
+    pub enum GeCommand {
+        Nop = 0,
+        Vaddr = 0x1,
+        Iaddr = 0x2,
+        Prim = 0x4,
+        Bezier = 0x5,
+        Spline = 0x6,
+        BoundingBox = 0x7,
+        Jump = 0x8,
+        BJump = 0x9,
+        Call = 0xa,
+        Ret = 0xb,
+        End = 0xc,
+        Signal = 0xe,
+        Finish = 0xf,
+        Base = 0x10,
+        VertexType = 0x12,
+        OffsetAddr = 0x13,
+        Origin = 0x14,
+        Region1 = 0x15,
+        Region2 = 0x16,
+        LightingEnable = 0x17,
+        LightEnable0 = 0x18,
+        LightEnable1 = 0x19,
+        LightEnable2 = 0x1a,
+        LightEnable3 = 0x1b,
+        DepthClampEnable = 0x1c,
+        CullFaceEnable = 0x1d,
+        TextureMapEnable = 0x1e,
+        FogEnable = 0x1f,
+        DitherEnable = 0x20,
+        AlphaBlendEnable = 0x21,
+        AlphaTestEnable = 0x22,
+        ZTestEnable = 0x23,
+        StencilTestEnable = 0x24,
+        AntiAliasEnable = 0x25,
+        PatchCullEnable = 0x26,
+        ColorTestEnable = 0x27,
+        LogicOpEnable = 0x28,
+        BoneMatrixNumber = 0x2a,
+        BoneMatrixData = 0x2b,
+        MorphWeight0 = 0x2c,
+        MorphWeight1 = 0x2d,
+        MorphWeight2 = 0x2e,
+        MorphWeight3 = 0x2f,
+        MorphWeight4 = 0x30,
+        MorphWeight5 = 0x31,
+        MorphWeight6 = 0x32,
+        MorphWeight7 = 0x33,
+        PatchDivision = 0x36,
+        PatchPrimitive = 0x37,
+        PatchFacing = 0x38,
+        WorldMatrixNumber = 0x3a,
+        WorldMatrixData = 0x3b,
+        ViewMatrixNumber = 0x3c,
+        ViewMatrixData = 0x3d,
+        ProjMatrixNumber = 0x3e,
+        ProjMatrixData = 0x3f,
+        TGenMatrixNumber = 0x40,
+        TGenMatrixData = 0x41,
+        ViewportXScale = 0x42,
+        ViewportYScale = 0x43,
+        ViewportZScale = 0x44,
+        ViewportXCenter = 0x45,
+        ViewportYCenter = 0x46,
+        ViewportZCenter = 0x47,
+        TexScaleU = 0x48,
+        TexScaleV = 0x49,
+        TexOffsetU = 0x4a,
+        TexOffsetV = 0x4b,
+        OffsetX = 0x4c,
+        OffsetY = 0x4d,
+        ShadeMode = 0x50,
+        ReverseNormal = 0x51,
+        MaterialUpdate = 0x53,
+        MaterialEmissive = 0x54,
+        MaterialAmbient = 0x55,
+        MaterialDiffuse = 0x56,
+        MaterialSpecular = 0x57,
+        MaterialAlpha = 0x58,
+        MaterialSpecularCoef = 0x5b,
+        AmbientColor = 0x5c,
+        AmbientAlpha = 0x5d,
+        LightMode = 0x5e,
+        LightType0 = 0x5f,
+        LightType1 = 0x60,
+        LightType2 = 0x61,
+        LightType3 = 0x62,
+        Light0X = 0x63,
+        Light0Y,
+        Light0Z,
+        Light1X,
+        Light1Y,
+        Light1Z,
+        Light2X,
+        Light2Y,
+        Light2Z,
+        Light3X,
+        Light3Y,
+        Light3Z,
+        Light0DirectionX = 0x6f,
+        Light0DirectionY,
+        Light0DirectionZ,
+        Light1DirectionX,
+        Light1DirectionY,
+        Light1DirectionZ,
+        Light2DirectionX,
+        Light2DirectionY,
+        Light2DirectionZ,
+        Light3DirectionX,
+        Light3DirectionY,
+        Light3DirectionZ,
+        Light0ConstantAtten = 0x7b,
+        Light0LinearAtten,
+        Light0QuadtraticAtten,
+        Light1ConstantAtten,
+        Light1LinearAtten,
+        Light1QuadtraticAtten,
+        Light2ConstantAtten,
+        Light2LinearAtten,
+        Light2QuadtraticAtten,
+        Light3ConstantAtten,
+        Light3LinearAtten,
+        Light3QuadtraticAtten,
+        Light0ExponentAtten = 0x87,
+        Light1ExponentAtten,
+        Light2ExponentAtten,
+        Light3ExponentAtten,
+        Light0CutoffAtten = 0x8b,
+        Light1CutoffAtten,
+        Light2CutoffAtten,
+        Light3CutoffAtten,
+        Light0Ambient = 0x8f,
+        Light0Diffuse,
+        Light0Specular,
+        Light1Ambient,
+        Light1Diffuse,
+        Light1Specular,
+        Light2Ambient,
+        Light2Diffuse,
+        Light2Specular,
+        Light3Ambient,
+        Light3Diffuse,
+        Light3Specular,
+        Cull = 0x9b,
+        FrameBufPtr = 0x9c,
+        FrameBufWidth = 0x9d,
+        ZBufPtr = 0x9e,
+        ZBufWidth = 0x9f,
+        TexAddr0 = 0xa0,
+        TexAddr1,
+        TexAddr2,
+        TexAddr3,
+        TexAddr4,
+        TexAddr5,
+        TexAddr6,
+        TexAddr7,
+        TexBufWidth0 = 0xa8,
+        TexBufWidth1,
+        TexBufWidth2,
+        TexBufWidth3,
+        TexBufWidth4,
+        TexBufWidth5,
+        TexBufWidth6,
+        TexBufWidth7,
+        ClutAddr = 0xb0,
+        ClutAddrUpper = 0xb1,
+        TransferSrc,
+        TransferSrcW,
+        TransferDst,
+        TransferDstW,
+        TexSize0 = 0xb8,
+        TexSize1,
+        TexSize2,
+        TexSize3,
+        TexSize4,
+        TexSize5,
+        TexSize6,
+        TexSize7,
+        TexMapMode = 0xc0,
+        TexShadeLs = 0xc1,
+        TexMode = 0xc2,
+        TexFormat = 0xc3,
+        LoadClut = 0xc4,
+        ClutFormat = 0xc5,
+        TexFilter = 0xc6,
+        TexWrap = 0xc7,
+        TexLevel = 0xc8,
+        TexFunc = 0xc9,
+        TexEnvColor = 0xca,
+        TexFlush = 0xcb,
+        TexSync = 0xcc,
+        Fog1 = 0xcd,
+        Fog2 = 0xce,
+        FogColor = 0xcf,
+        TexLodSlope = 0xd0,
+        FramebufPixFormat = 0xd2,
+        ClearMode = 0xd3,
+        Scissor1 = 0xd4,
+        Scissor2 = 0xd5,
+        MinZ = 0xd6,
+        MaxZ = 0xd7,
+        ColorTest = 0xd8,
+        ColorRef = 0xd9,
+        ColorTestmask = 0xda,
+        AlphaTest = 0xdb,
+        StencilTest = 0xdc,
+        StencilOp = 0xdd,
+        ZTest = 0xde,
+        BlendMode = 0xdf,
+        BlendFixedA = 0xe0,
+        BlendFixedB = 0xe1,
+        Dith0 = 0xe2,
+        Dith1,
+        Dith2,
+        Dith3,
+        LogicOp = 0xe6,
+        ZWriteDisable = 0xe7,
+        MaskRgb = 0xe8,
+        MaskAlpha = 0xe9,
+        TransferStart = 0xea,
+        TransferSrcPos = 0xeb,
+        TransferDstPos = 0xec,
+        TransferSize = 0xee,
+        Vscx = 0xf0,
+        Vscy = 0xf1,
+        Vscz = 0xf2,
+        Vtcs = 0xf3,
+        Vtct = 0xf4,
+        Vtcq = 0xf5,
+        Vcv = 0xf6,
+        Vap = 0xf7,
+        Vfc = 0xf8,
+        Vscv = 0xf9,
+
+        Unknown03 = 0x03,
+        Unknown0D = 0x0d,
+        Unknown11 = 0x11,
+        Unknown29 = 0x29,
+        Unknown34 = 0x34,
+        Unknown35 = 0x35,
+        Unknown39 = 0x39,
+        Unknown4E = 0x4e,
+        Unknown4F = 0x4f,
+        Unknown52 = 0x52,
+        Unknown59 = 0x59,
+        Unknown5A = 0x5a,
+        UnknownB6 = 0xb6,
+        UnknownB7 = 0xb7,
+        UnknownD1 = 0xd1,
+        UnknownED = 0xed,
+        UnknownEF = 0xef,
+        UnknownFA = 0xfa,
+        UnknownFB = 0xfb,
+        UnknownFC = 0xfc,
+        UnknownFD = 0xfd,
+        UnknownFE = 0xfe,
+        NopFF = 0xff,
+    }
+
+    #[repr(i32)]
+    pub enum SceSysMemPartitionId {
+        SceKernelUnknownPartition = 0,
+        SceKernelPrimaryKernelPartition = 1,
+        SceKernelPrimaryUserPartition = 2,
+        SceKernelOtherKernelPartition1 = 3,
+        SceKernelOtherKernelPartition2 = 4,
+        SceKernelVshellPARTITION = 5,
+        SceKernelScUserPartition = 6,
+        SceKernelMeUserPartition = 7,
+        SceKernelExtendedScKernelPartition = 8,
+        SceKernelExtendedSc2KernelPartition = 9,
+        SceKernelExtendedMeKernelPartition = 10,
+        SceKernelVshellKernelPartition = 11,
+        SceKernelExtendedKernelPartition = 12,
+    }
+
+    #[repr(i32)]
+    pub enum SceSysMemBlockTypes {
+        Low = 0,
+        High,
+        Addr,
+    }
+
+    #[repr(u32)]
+    pub enum Interrupt {
+        Gpio = 4,
+        Ata = 5,
+        Umd = 6,
+        Mscm0 = 7,
+        Wlan = 8,
+        Audio = 10,
+        I2c = 12,
+        Sircs = 14,
+        Systimer0 = 15,
+        Systimer1 = 16,
+        Systimer2 = 17,
+        Systimer3 = 18,
+        Thread0 = 19,
+        Nand = 20,
+        Dmacplus = 21,
+        Dma0 = 22,
+        Dma1 = 23,
+        Memlmd = 24,
+        Ge = 25,
+        Vblank = 30,
+        Mecodec = 31,
+        Hpremote = 36,
+        Mscm1 = 60,
+        Mscm2 = 61,
+        Thread1 = 65,
+        Interrupt = 66,
+    }
+
+    #[repr(u32)]
+    pub enum SubInterrupt {
+        Gpio = Interrupt::Gpio as u32,
+        Ata = Interrupt::Ata as u32,
+        Umd = Interrupt::Umd as u32,
+        Dmacplus = Interrupt::Dmacplus as u32,
+        Ge = Interrupt::Ge as u32,
+        Display = Interrupt::Vblank as u32,
+    }
+
+    #[repr(u32)]
+    pub enum SceKernelIdListType {
+        Thread = 1,
+        Semaphore = 2,
+        EventFlag = 3,
+        Mbox = 4,
+        Vpl = 5,
+        Fpl = 6,
+        Mpipe = 7,
+        Callback = 8,
+        ThreadEventHandler = 9,
+        Alarm = 10,
+        VTimer = 11,
+        SleepThread = 64,
+        DelayThread = 65,
+        SuspendThread = 66,
+        DormantThread = 67,
+    }
+
+    #[repr(i32)]
+    pub enum UsbCamResolution {
+        Px160_120 = 0,
+        Px176_144 = 1,
+        Px320_240 = 2,
+        Px352_288 = 3,
+        Px640_480 = 4,
+        Px1024_768 = 5,
+        Px1280_960 = 6,
+        Px480_272 = 7,
+        Px360_272 = 8,
+    }
+
+    #[repr(i32)]
+    pub enum UsbCamResolutionEx {
+        Px160_120 = 0,
+        Px176_144 = 1,
+        Px320_240 = 2,
+        Px352_288 = 3,
+        Px360_272 = 4,
+        Px480_272 = 5,
+        Px640_480 = 6,
+        Px1024_768 = 7,
+        Px1280_960 = 8,
+    }
+
+    #[repr(i32)]
+    pub enum UsbCamDelay {
+        NoDelay = 0,
+        Delay10Sec = 1,
+        Delay20Sec = 2,
+        Delay30Sec = 3,
+    }
+
+    #[repr(i32)]
+    pub enum UsbCamFrameRate {
+        Fps3_75 = 0,
+        Fps5 = 1,
+        Fps7_5 = 2,
+        Fps10 = 3,
+        Fps15 = 4,
+        Fps20 = 5,
+        Fps30 = 6,
+        Fps60 = 7,
+    }
+
+    #[repr(i32)]
+    pub enum UsbCamWb {
+        Auto = 0,
+        Daylight = 1,
+        Fluorescent = 2,
+        Incadescent = 3,
+    }
+
+    #[repr(i32)]
+    pub enum UsbCamEffectMode {
+        Normal = 0,
+        Negative = 1,
+        Blackwhite = 2,
+        Sepia = 3,
+        Blue = 4,
+        Red = 5,
+        Green = 6,
+    }
+
+    #[repr(i32)]
+    pub enum UsbCamEvLevel {
+        Pos2_0 = 0,
+        Pos1_7 = 1,
+        Pos1_5 = 2,
+        Pos1_3 = 3,
+        Pos1_0 = 4,
+        Pos0_7 = 5,
+        Pos0_5 = 6,
+        Pos0_3 = 7,
+        Zero = 8,
+        Neg0_3,
+        Neg0_5,
+        Neg0_7,
+        Neg1_0,
+        Neg1_3,
+        Neg1_5,
+        Neg1_7,
+        Neg2_0,
+    }
+
+    #[repr(i32)]
+    pub enum RtcCheckValidError {
+        InvalidYear = -1,
+        InvalidMonth = -2,
+        InvalidDay = -3,
+        InvalidHour = -4,
+        InvalidMinutes = -5,
+        InvalidSeconds = -6,
+        InvalidMicroseconds = -7,
+    }
+
+    #[repr(u32)]
+    pub enum PowerTick {
+        All = 0,
+        Suspend = 1,
+        Display = 6,
+    }
+
+    #[repr(u32)]
+    pub enum IoAssignPerms {
+        RdWr = 0,
+        RdOnly = 1,
+    }
+
+    #[repr(u32)]
+    pub enum IoWhence {
+        Set = 0,
+        Cur = 1,
+        End = 2,
+    }
+
+    #[repr(u32)]
+    pub enum UmdType {
+        Game = 0x10,
+        Video = 0x20,
+        Audio = 0x40,
+    }
+
+    #[repr(u32)]
+    pub enum GuPrimitive {
+        Points = 0,
+        Lines = 1,
+        LineStrip = 2,
+        Triangles = 3,
+        TriangleStrip = 4,
+        TriangleFan = 5,
+        Sprites = 6,
+    }
+
+    #[repr(u32)]
+    pub enum PatchPrimitive {
+        Points = 0,
+        LineStrip = 2,
+        TriangleStrip = 4,
+    }
+
+    #[repr(u32)]
+    pub enum GuState {
+        AlphaTest = 0,
+        DepthTest = 1,
+        ScissorTest = 2,
+        StencilTest = 3,
+        Blend = 4,
+        CullFace = 5,
+        Dither = 6,
+        Fog = 7,
+        ClipPlanes = 8,
+        Texture2D = 9,
+        Lighting = 10,
+        Light0 = 11,
+        Light1 = 12,
+        Light2 = 13,
+        Light3 = 14,
+        LineSmooth = 15,
+        PatchCullFace = 16,
+        ColorTest = 17,
+        ColorLogicOp = 18,
+        FaceNormalReverse = 19,
+        PatchFace = 20,
+        Fragment2X = 21,
+    }
+
+    #[repr(u32)]
+    pub enum MatrixMode {
+        Projection = 0,
+        View = 1,
+        Model = 2,
+        Texture = 3,
+    }
+
+    #[repr(u32)]
+    pub enum TexturePixelFormat {
+        Psm5650 = 0,
+        Psm5551 = 1,
+        Psm4444 = 2,
+        Psm8888 = 3,
+        PsmT4 = 4,
+        PsmT8 = 5,
+        PsmT16 = 6,
+        PsmT32 = 7,
+        PsmDxt1 = 8,
+        PsmDxt3 = 9,
+        PsmDxt5 = 10,
+    }
+
+    #[repr(u32)]
+    pub enum SplineMode {
+        FillFill = 0,
+        OpenFill = 1,
+        FillOpen = 2,
+        OpenOpen = 3,
+    }
+
+    #[repr(u32)]
+    pub enum ShadingModel {
+        Flat = 0,
+        Smooth = 1,
+    }
+
+    #[repr(u32)]
+    pub enum LogicalOperation {
+        Clear = 0,
+        And = 1,
+        AndReverse = 2,
+        Copy = 3,
+        AndInverted = 4,
+        Noop = 5,
+        Xor = 6,
+        Or = 7,
+        Nor = 8,
+        Equiv = 9,
+        Inverted = 10,
+        OrReverse = 11,
+        CopyInverted = 12,
+        OrInverted = 13,
+        Nand = 14,
+        Set = 15,
+    }
+
+    #[repr(u32)]
+    pub enum TextureFilter {
+        Nearest = 0,
+        Linear = 1,
+        NearestMipmapNearest = 4,
+        LinearMipmapNearest = 5,
+        NearestMipmapLinear = 6,
+        LinearMipmapLinear = 7,
+    }
+
+    #[repr(u32)]
+    pub enum TextureMapMode {
+        TextureCoords = 0,
+        TextureMatrix = 1,
+        EnvironmentMap = 2,
+    }
+
+    #[repr(u32)]
+    pub enum TextureLevelMode {
+        Auto = 0,
+        Const = 1,
+        Slope = 2,
+    }
+
+    #[repr(u32)]
+    pub enum TextureProjectionMapMode {
+        Position = 0,
+        Uv = 1,
+        NormalizedNormal = 2,
+        Normal = 3,
+    }
+
+    #[repr(u32)]
+    pub enum GuTexWrapMode {
+        Repeat = 0,
+        Clamp = 1,
+    }
+
+    #[repr(u32)]
+    pub enum FrontFaceDirection {
+        Clockwise = 0,
+        CounterClockwise = 1,
+    }
+
+    #[repr(u32)]
+    pub enum AlphaFunc {
+        Never = 0,
+        Always,
+        Equal,
+        NotEqual,
+        Less,
+        LessOrEqual,
+        Greater,
+        GreaterOrEqual,
+    }
+
+    #[repr(u32)]
+    pub enum StencilFunc {
+        Never = 0,
+        Always,
+        Equal,
+        NotEqual,
+        Less,
+        LessOrEqual,
+        Greater,
+        GreaterOrEqual,
+    }
+
+    #[repr(u32)]
+    pub enum ColorFunc {
+        Never = 0,
+        Always,
+        Equal,
+        NotEqual,
+    }
+
+    #[repr(u32)]
+    pub enum DepthFunc {
+        Never = 0,
+        Always,
+        Equal,
+        NotEqual,
+        Less,
+        LessOrEqual,
+        Greater,
+        GreaterOrEqual,
+    }
+
+    #[repr(u32)]
+    pub enum TextureEffect {
+        Modulate = 0,
+        Decal = 1,
+        Blend = 2,
+        Replace = 3,
+        Add = 4,
+    }
+
+    #[repr(u32)]
+    pub enum TextureColorComponent {
+        Rgb = 0,
+        Rgba = 1,
+    }
+
+    #[repr(u32)]
+    pub enum MipmapLevel {
+        None = 0,
+        Level1,
+        Level2,
+        Level3,
+        Level4,
+        Level5,
+        Level6,
+        Level7,
+    }
+
+    #[repr(u32)]
+    pub enum BlendOp {
+        Add = 0,
+        Subtract = 1,
+        ReverseSubtract = 2,
+        Min = 3,
+        Max = 4,
+        Abs = 5,
+    }
+
+    #[repr(u32)]
+    pub enum BlendSrc {
+        SrcColor = 0,
+        OneMinusSrcColor = 1,
+        SrcAlpha = 2,
+        OneMinusSrcAlpha = 3,
+        Fix = 10,
+    }
+
+    #[repr(u32)]
+    pub enum BlendDst {
+        DstColor = 0,
+        OneMinusDstColor = 1,
+        DstAlpha = 4,
+        OneMinusDstAlpha = 5,
+        Fix = 10,
+    }
+
+    #[repr(u32)]
+    pub enum StencilOperation {
+        Keep = 0,
+        Zero = 1,
+        Replace = 2,
+        Invert = 3,
+        Incr = 4,
+        Decr = 5,
+    }
+
+    #[repr(u32)]
+    pub enum LightMode {
+        SingleColor = 0,
+        SeparateSpecularColor = 1,
+    }
+
+    #[repr(u32)]
+    pub enum LightType {
+        Directional = 0,
+        Pointlight = 1,
+        Spotlight = 2,
+    }
+
+    #[repr(u32)]
+    pub enum GuContextType {
+        Direct = 0,
+        Call = 1,
+        Send = 2,
+    }
+
+    #[repr(u32)]
+    pub enum GuQueueMode {
+        Tail = 0,
+        Head = 1,
+    }
+
+    #[repr(u32)]
+    pub enum GuSyncMode {
+        Finish = 0,
+        Signal = 1,
+        Done = 2,
+        List = 3,
+        Send = 4,
+    }
+
+    #[repr(u32)]
+    pub enum GuSyncBehavior {
+        Wait = 0,
+        NoWait = 1,
+    }
+
+    #[repr(u32)]
+    pub enum GuCallbackId {
+        Signal = 1,
+        Finish = 4,
+    }
+
+    #[repr(u32)]
+    pub enum SignalBehavior {
+        Suspend = 1,
+        Continue = 2,
+    }
+
+    #[repr(u32)]
+    pub enum ClutPixelFormat {
+        Psm5650 = 0,
+        Psm5551 = 1,
+        Psm4444 = 2,
+        Psm8888 = 3,
+    }
+
+    #[repr(C)]
+    pub enum KeyType {
+        Directory = 1,
+        Integer = 2,
+        String = 3,
+        Bytes = 4,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityMsgDialogMode {
+        Error,
+        Text,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityMsgDialogPressed {
+        Unknown1,
+        Yes,
+        No,
+        Back,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityDialogButtonAccept {
+        Circle,
+        Cross,
+    }
+
+    #[repr(u32)]
+    pub enum SceUtilityOskInputLanguage {
+        Default,
+        Japanese,
+        English,
+        French,
+        Spanish,
+        German,
+        Italian,
+        Dutch,
+        Portugese,
+        Russian,
+        Korean,
+    }
+
+    #[repr(u32)]
+    pub enum SceUtilityOskInputType {
+        All,
+        LatinDigit,
+        LatinSymbol,
+        LatinLowercase = 4,
+        LatinUppercase = 8,
+        JapaneseDigit = 0x100,
+        JapaneseSymbol = 0x200,
+        JapaneseLowercase = 0x400,
+        JapaneseUppercase = 0x800,
+        JapaneseHiragana = 0x1000,
+        JapaneseHalfWidthKatakana = 0x2000,
+        JapaneseKatakana = 0x4000,
+        JapaneseKanji = 0x8000,
+        RussianLowercase = 0x10000,
+        RussianUppercase = 0x20000,
+        Korean = 0x40000,
+        Url = 0x80000,
+    }
+
+    #[repr(u32)]
+    pub enum SceUtilityOskState {
+        None,
+        Initializing,
+        Initialized,
+        Visible,
+        Quit,
+        Finished,
+    }
+
+    #[repr(u32)]
+    pub enum SceUtilityOskResult {
+        Unchanged,
+        Cancelled,
+        Changed,
+    }
+
+    #[repr(u32)]
+    pub enum SystemParamLanguage {
+        Japanese,
+        English,
+        French,
+        Spanish,
+        German,
+        Italian,
+        Dutch,
+        Portugese,
+        Russian,
+        Korean,
+        ChineseTraditional,
+        ChineseSimplified,
+    }
+
+    #[repr(u32)]
+    pub enum SystemParamId {
+        StringNickname = 1,
+        AdhocChannel,
+        WlanPowerSave,
+        DateFormat,
+        TimeFormat,
+        Timezone,
+        DaylightSavings,
+        Language,
+        Unknown,
+    }
+
+    #[repr(u32)]
+    pub enum SystemParamAdhocChannel {
+        ChannelAutomatic = 0,
+        Channel1 = 1,
+        Channel6 = 6,
+        Channel11 = 11,
+    }
+
+    #[repr(u32)]
+    pub enum SystemParamWlanPowerSaveState {
+        Off,
+        On,
+    }
+
+    #[repr(u32)]
+    pub enum SystemParamDateFormat {
+        YYYYMMDD,
+        MMDDYYYY,
+        DDMMYYYY,
+    }
+
+    #[repr(u32)]
+    pub enum SystemParamTimeFormat {
+        Hour24,
+        Hour12,
+    }
+
+    #[repr(u32)]
+    pub enum SystemParamDaylightSavings {
+        Std,
+        Dst,
+    }
+
+    #[repr(u32)]
+    pub enum AvModule {
+        AvCodec,
+        SasCore,
+        Atrac3Plus,
+        MpegBase,
+        Mp3,
+        Vaudio,
+        Aac,
+        G729,
+    }
+
+    #[repr(u32)]
+    pub enum Module {
+        NetCommon = 0x100,
+        NetAdhoc,
+        NetInet,
+        NetParseUri,
+        NetHttp,
+        NetSsl,
+
+        UsbPspCm = 0x200,
+        UsbMic,
+        UsbCam,
+        UsbGps,
+
+        AvCodec = 0x300,
+        AvSascore,
+        AvAtrac3Plus,
+        AvMpegBase,
+        AvMp3,
+        AvVaudio,
+        AvAac,
+        AvG729,
+
+        NpCommon = 0x400,
+        NpService,
+        NpMatching2,
+        NpDrm = 0x500,
+
+        Irda = 0x600,
+    }
+
+    #[repr(u32)]
+    pub enum NetModule {
+        NetCommon = 1,
+        NetAdhoc,
+        NetInet,
+        NetParseUri,
+        NetHttp,
+        NetSsl,
+    }
+
+    #[repr(u32)]
+    pub enum UsbModule {
+        UsbPspCm = 1,
+        UsbAcc,
+        UsbMic,
+        UsbCam,
+        UsbGps,
+    }
+
+    #[repr(u32)]
+    pub enum NetParam {
+        Name,
+        Ssid,
+        Secure,
+        WepKey,
+        IsStaticIp,
+        Ip,
+        NetMask,
+        Route,
+        ManualDns,
+        PrimaryDns,
+        SecondaryDns,
+        ProxyUser,
+        ProxyPass,
+        UseProxy,
+        ProxyServer,
+        ProxyPort,
+        Unknown1,
+        Unknown2,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityNetconfAction {
+        ConnectAP,
+        DisplayStatus,
+        ConnectAdhoc,
+    }
+
+    #[repr(u32)]
+    pub enum UtilitySavedataMode {
+        AutoLoad,
+        AutoSave,
+        Load,
+        Save,
+        ListLoad,
+        ListSave,
+        ListDelete,
+        Delete,
+    }
+
+    #[repr(u32)]
+    pub enum UtilitySavedataFocus {
+        Unknown1,
+        FirstList,
+        LastList,
+        Latest,
+        Oldest,
+        Unknown2,
+        Unknown3,
+        FirstEmpty,
+        LastEmpty,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityGameSharingMode {
+        Single = 1,
+        Multiple,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityGameSharingDataType {
+        File = 1,
+        Memory,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityHtmlViewerInterfaceMode {
+        Full,
+        Limited,
+        None,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityHtmlViewerCookieMode {
+        Disabled = 0,
+        Enabled,
+        Confirm,
+        Default,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityHtmlViewerTextSize {
+        Large,
+        Normal,
+        Small,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityHtmlViewerDisplayMode {
+        Normal,
+        Fit,
+        SmartFit,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityHtmlViewerConnectMode {
+        Last,
+        ManualOnce,
+        ManualAll,
+    }
+
+    #[repr(u32)]
+    pub enum UtilityHtmlViewerDisconnectMode {
+        Enable,
+        Disable,
+        Confirm,
+    }
+
+    #[repr(u32)]
+    pub enum ScePspnetAdhocPtpState {
+        Closed,
+        Listen,
+        SynSent,
+        SynReceived,
+        Established,
+    }
+
+    #[repr(u32)]
+    pub enum AdhocMatchingMode {
+        Host = 1,
+        Client,
+        Ptp,
+    }
+
+    #[repr(u32)]
+    pub enum ApctlState {
+        Disconnected,
+        Scanning,
+        Joining,
+        GettingIp,
+        GotIp,
+        EapAuth,
+        KeyExchange,
+    }
+
+    #[repr(u32)]
+    pub enum ApctlEvent {
+        ConnectRequest,
+        ScanRequest,
+        ScanComplete,
+        Established,
+        GetIp,
+        DisconnectRequest,
+        Error,
+        Info,
+        EapAuth,
+        KeyExchange,
+        Reconnect,
+    }
+
+    #[repr(u32)]
+    pub enum ApctlInfo {
+        ProfileName,
+        Bssid,
+        Ssid,
+        SsidLength,
+        SecurityType,
+        Strength,
+        Channel,
+        PowerSave,
+        Ip,
+        SubnetMask,
+        Gateway,
+        PrimaryDns,
+        SecondaryDns,
+        UseProxy,
+        ProxyUrl,
+        ProxyPort,
+        EapType,
+        StartBrowser,
+        Wifisp,
+    }
+
+    #[repr(u32)]
+    pub enum ApctlInfoSecurityType {
+        None,
+        Wep,
+        Wpa,
+    }
+
+    #[repr(u32)]
+    pub enum HttpMethod {
+        Get,
+        Post,
+        Head,
+    }
+
+    #[repr(u32)]
+    pub enum HttpAuthType {
+        Basic,
+        Digest,
+    }
+}
+
+s_paren! {
+    #[repr(transparent)]
+    pub struct SceUid(pub i32);
+
+    #[repr(transparent)]
+    pub struct SceMpeg(*mut *mut c_void);
+
+    #[repr(transparent)]
+    pub struct SceMpegStream(*mut c_void);
+
+    #[repr(transparent)]
+    pub struct Mp3Handle(pub i32);
+
+    #[repr(transparent)]
+    pub struct RegHandle(u32);
+}
+
+s! {
+    pub struct sockaddr {
+        pub sa_len: u8,
+        pub sa_family: u8,
+        pub sa_data: [u8;14],
+    }
+
+    pub struct in_addr {
+        pub s_addr: u32,
+    }
+
+    pub struct AudioInputParams {
+        pub unknown1: i32,
+        pub gain: i32,
+        pub unknown2: i32,
+        pub unknown3: i32,
+        pub unknown4: i32,
+        pub unknown5: i32,
+    }
+
+    pub struct Atrac3BufferInfo {
+        pub puc_write_position_first_buf: *mut u8,
+        pub ui_writable_byte_first_buf: u32,
+        pub ui_min_write_byte_first_buf: u32,
+        pub ui_read_position_first_buf: u32,
+        pub puc_write_position_second_buf: *mut u8,
+        pub ui_writable_byte_second_buf: u32,
+        pub ui_min_write_byte_second_buf: u32,
+        pub ui_read_position_second_buf: u32,
+    }
+
+    pub struct SceCtrlData {
+        pub timestamp: u32,
+        pub buttons: i32,
+        pub lx: u8,
+        pub ly: u8,
+        pub rsrv: [u8; 6],
+    }
+
+    pub struct SceCtrlLatch {
+        pub ui_make: u32,
+        pub ui_break: u32,
+        pub ui_press: u32,
+        pub ui_release: u32,
+    }
+
+    pub struct GeStack {
+        pub stack: [u32; 8],
+    }
+
+    pub struct GeCallbackData {
+        pub signal_func: ::Option<extern "C" fn(id: i32, arg: *mut c_void)>,
+        pub signal_arg: *mut c_void,
+        pub finish_func: ::Option<extern "C" fn(id: i32, arg: *mut c_void)>,
+        pub finish_arg: *mut c_void,
+    }
+
+    pub struct GeListArgs {
+        pub size: u32,
+        pub context: *mut GeContext,
+        pub num_stacks: u32,
+        pub stacks: *mut GeStack,
+    }
+
+    pub struct GeBreakParam {
+        pub buf: [u32; 4],
+    }
+
+    pub struct SceKernelLoadExecParam {
+        pub size: usize,
+        pub args: usize,
+        pub argp: *mut c_void,
+        pub key: *const u8,
+    }
+
+    pub struct timeval {
+        pub tv_sec: i32,
+        pub tv_usec: i32,
+    }
+
+    pub struct timezone {
+        pub tz_minutes_west: i32,
+        pub tz_dst_time: i32,
+    }
+
+    pub struct IntrHandlerOptionParam {
+        size: i32,
+        entry: u32,
+        common: u32,
+        gp: u32,
+        intr_code: u16,
+        sub_count: u16,
+        intr_level: u16,
+        enabled: u16,
+        calls: u32,
+        field_1c: u32,
+        total_clock_lo: u32,
+        total_clock_hi: u32,
+        min_clock_lo: u32,
+        min_clock_hi: u32,
+        max_clock_lo: u32,
+        max_clock_hi: u32,
+    }
+
+    pub struct SceKernelLMOption {
+        pub size: usize,
+        pub m_pid_text: SceUid,
+        pub m_pid_data: SceUid,
+        pub flags: u32,
+        pub position: u8,
+        pub access: u8,
+        pub c_reserved: [u8; 2usize],
+    }
+
+    pub struct SceKernelSMOption {
+        pub size: usize,
+        pub m_pid_stack: SceUid,
+        pub stack_size: usize,
+        pub priority: i32,
+        pub attribute: u32,
+    }
+
+    pub struct SceKernelModuleInfo {
+        pub size: usize,
+        pub n_segment: u8,
+        pub reserved: [u8; 3usize],
+        pub segment_addr: [i32; 4usize],
+        pub segment_size: [i32; 4usize],
+        pub entry_addr: u32,
+        pub gp_value: u32,
+        pub text_addr: u32,
+        pub text_size: u32,
+        pub data_size: u32,
+        pub bss_size: u32,
+        pub attribute: u16,
+        pub version: [u8; 2usize],
+        pub name: [u8; 28usize],
+    }
+
+    pub struct DebugProfilerRegs {
+        pub enable: u32,
+        pub systemck: u32,
+        pub cpuck: u32,
+        pub internal: u32,
+        pub memory: u32,
+        pub copz: u32,
+        pub vfpu: u32,
+        pub sleep: u32,
+        pub bus_access: u32,
+        pub uncached_load: u32,
+        pub uncached_store: u32,
+        pub cached_load: u32,
+        pub cached_store: u32,
+        pub i_miss: u32,
+        pub d_miss: u32,
+        pub d_writeback: u32,
+        pub cop0_inst: u32,
+        pub fpu_inst: u32,
+        pub vfpu_inst: u32,
+        pub local_bus: u32,
+    }
+
+    pub struct SceKernelSysClock {
+        pub low: u32,
+        pub hi: u32,
+    }
+
+    pub struct SceKernelThreadOptParam {
+        pub size: usize,
+        pub stack_mpid: SceUid,
+    }
+
+    pub struct SceKernelThreadInfo {
+        pub size: usize,
+        pub name: [u8; 32],
+        pub attr: u32,
+        pub status: i32,
+        pub entry: SceKernelThreadEntry,
+        pub stack: *mut c_void,
+        pub stack_size: i32,
+        pub gp_reg: *mut c_void,
+        pub init_priority: i32,
+        pub current_priority: i32,
+        pub wait_type: i32,
+        pub wait_id: SceUid,
+        pub wakeup_count: i32,
+        pub exit_status: i32,
+        pub run_clocks: SceKernelSysClock,
+        pub intr_preempt_count: u32,
+        pub thread_preempt_count: u32,
+        pub release_count: u32,
+    }
+
+    pub struct SceKernelThreadRunStatus {
+        pub size: usize,
+        pub status: i32,
+        pub current_priority: i32,
+        pub wait_type: i32,
+        pub wait_id: i32,
+        pub wakeup_count: i32,
+        pub run_clocks: SceKernelSysClock,
+        pub intr_preempt_count: u32,
+        pub thread_preempt_count: u32,
+        pub release_count: u32,
+    }
+
+    pub struct SceKernelSemaOptParam {
+        pub size: usize,
+    }
+
+    pub struct SceKernelSemaInfo {
+        pub size: usize,
+        pub name: [u8; 32],
+        pub attr: u32,
+        pub init_count: i32,
+        pub current_count: i32,
+        pub max_count: i32,
+        pub num_wait_threads: i32,
+    }
+
+    pub struct SceKernelEventFlagInfo {
+        pub size: usize,
+        pub name: [u8; 32],
+        pub attr: u32,
+        pub init_pattern: u32,
+        pub current_pattern: u32,
+        pub num_wait_threads: i32,
+    }
+
+    pub struct SceKernelEventFlagOptParam {
+        pub size: usize,
+    }
+
+    pub struct SceKernelMbxOptParam {
+        pub size: usize,
+    }
+
+    pub struct SceKernelMbxInfo {
+        pub size: usize,
+        pub name: [u8; 32usize],
+        pub attr: u32,
+        pub num_wait_threads: i32,
+        pub num_messages: i32,
+        pub first_message: *mut c_void,
+    }
+
+    pub struct SceKernelVTimerInfo {
+        pub size: usize,
+        pub name: [u8; 32],
+        pub active: i32,
+        pub base: SceKernelSysClock,
+        pub current: SceKernelSysClock,
+        pub schedule: SceKernelSysClock,
+        pub handler: SceKernelVTimerHandler,
+        pub common: *mut c_void,
+    }
+
+    pub struct SceKernelThreadEventHandlerInfo {
+        pub size: usize,
+        pub name: [u8; 32],
+        pub thread_id: SceUid,
+        pub mask: i32,
+        pub handler: SceKernelThreadEventHandler,
+        pub common: *mut c_void,
+    }
+
+    pub struct SceKernelAlarmInfo {
+        pub size: usize,
+        pub schedule: SceKernelSysClock,
+        pub handler: SceKernelAlarmHandler,
+        pub common: *mut c_void,
+    }
+
+    pub struct SceKernelSystemStatus {
+        pub size: usize,
+        pub status: u32,
+        pub idle_clocks: SceKernelSysClock,
+        pub comes_out_of_idle_count: u32,
+        pub thread_switch_count: u32,
+        pub vfpu_switch_count: u32,
+    }
+
+    pub struct SceKernelMppInfo {
+        pub size: usize,
+        pub name: [u8; 32],
+        pub attr: u32,
+        pub buf_size: i32,
+        pub free_size: i32,
+        pub num_send_wait_threads: i32,
+        pub num_receive_wait_threads: i32,
+    }
+
+    pub struct SceKernelVplOptParam {
+        pub size: usize,
+    }
+
+    pub struct SceKernelVplInfo {
+        pub size: usize,
+        pub name: [u8; 32],
+        pub attr: u32,
+        pub pool_size: i32,
+        pub free_size: i32,
+        pub num_wait_threads: i32,
+    }
+
+    pub struct SceKernelFplOptParam {
+        pub size: usize,
+    }
+
+    pub struct SceKernelFplInfo {
+        pub size: usize,
+        pub name: [u8; 32usize],
+        pub attr: u32,
+        pub block_size: i32,
+        pub num_blocks: i32,
+        pub free_blocks: i32,
+        pub num_wait_threads: i32,
+    }
+
+    pub struct SceKernelVTimerOptParam {
+        pub size: usize,
+    }
+
+    pub struct SceKernelCallbackInfo {
+        pub size: usize,
+        pub name: [u8; 32usize],
+        pub thread_id: SceUid,
+        pub callback: SceKernelCallbackFunction,
+        pub common: *mut c_void,
+        pub notify_count: i32,
+        pub notify_arg: i32,
+    }
+
+    pub struct UsbCamSetupStillParam {
+        pub size: i32,
+        pub resolution: UsbCamResolution,
+        pub jpeg_size: i32,
+        pub reverse_flags: i32,
+        pub delay: UsbCamDelay,
+        pub comp_level: i32,
+    }
+
+    pub struct UsbCamSetupStillExParam {
+        pub size: i32,
+        pub unk: u32,
+        pub resolution: UsbCamResolutionEx,
+        pub jpeg_size: i32,
+        pub comp_level: i32,
+        pub unk2: u32,
+        pub unk3: u32,
+        pub flip: i32,
+        pub mirror: i32,
+        pub delay: UsbCamDelay,
+        pub unk4: [u32; 5usize],
+    }
+
+    pub struct UsbCamSetupVideoParam {
+        pub size: i32,
+        pub resolution: UsbCamResolution,
+        pub framerate: UsbCamFrameRate,
+        pub white_balance: UsbCamWb,
+        pub saturation: i32,
+        pub brightness: i32,
+        pub contrast: i32,
+        pub sharpness: i32,
+        pub effect_mode: UsbCamEffectMode,
+        pub frame_size: i32,
+        pub unk: u32,
+        pub evl_evel: UsbCamEvLevel,
+    }
+
+    pub struct UsbCamSetupVideoExParam {
+        pub size: i32,
+        pub unk: u32,
+        pub resolution: UsbCamResolutionEx,
+        pub framerate: UsbCamFrameRate,
+        pub unk2: u32,
+        pub unk3: u32,
+        pub white_balance: UsbCamWb,
+        pub saturation: i32,
+        pub brightness: i32,
+        pub contrast: i32,
+        pub sharpness: i32,
+        pub unk4: u32,
+        pub unk5: u32,
+        pub unk6: [u32; 3usize],
+        pub effect_mode: UsbCamEffectMode,
+        pub unk7: u32,
+        pub unk8: u32,
+        pub unk9: u32,
+        pub unk10: u32,
+        pub unk11: u32,
+        pub frame_size: i32,
+        pub unk12: u32,
+        pub ev_level: UsbCamEvLevel,
+    }
+
+    pub struct ScePspDateTime {
+        pub year: u16,
+        pub month: u16,
+        pub day: u16,
+        pub hour: u16,
+        pub minutes: u16,
+        pub seconds: u16,
+        pub microseconds: u32,
+    }
+
+    pub struct SceIoStat {
+        pub st_mode: i32,
+        pub st_attr: i32,
+        pub st_size: i64,
+        pub st_ctime: ScePspDateTime,
+        pub st_atime: ScePspDateTime,
+        pub st_mtime: ScePspDateTime,
+        pub st_private: [u32; 6usize],
+    }
+
+    pub struct UmdInfo {
+        pub size: u32,
+        pub type_: UmdType,
+    }
+
+    pub struct SceMpegRingbuffer {
+        pub packets: i32,
+        pub unk0: u32,
+        pub unk1: u32,
+        pub unk2: u32,
+        pub unk3: u32,
+        pub data: *mut c_void,
+        pub callback: SceMpegRingbufferCb,
+        pub cb_param: *mut c_void,
+        pub unk4: u32,
+        pub unk5: u32,
+        pub sce_mpeg: *mut c_void,
+    }
+
+    pub struct SceMpegAu {
+        pub pts_msb: u32,
+        pub pts: u32,
+        pub dts_msb: u32,
+        pub dts: u32,
+        pub es_buffer: u32,
+        pub au_size: u32,
+    }
+
+    pub struct SceMpegAvcMode {
+        pub unk0: i32,
+        pub pixel_format: super::DisplayPixelFormat,
+    }
+
+    #[repr(align(64))]
+    pub struct SceMpegLLI {
+        pub src: *mut c_void,
+        pub dst: *mut c_void,
+        pub next: *mut c_void,
+        pub size: i32,
+    }
+
+    #[repr(align(64))]
+    pub struct SceMpegYCrCbBuffer {
+        pub frame_buffer_height16: i32,
+        pub frame_buffer_width16: i32,
+        pub unknown: i32,
+        pub unknown2: i32,
+        pub y_buffer: *mut c_void,
+        pub y_buffer2: *mut c_void,
+        pub cr_buffer: *mut c_void,
+        pub cb_buffer: *mut c_void,
+        pub cr_buffer2: *mut c_void,
+        pub cb_buffer2: *mut c_void,
+
+        pub frame_height: i32,
+        pub frame_width: i32,
+        pub frame_buffer_width: i32,
+        pub unknown3: [i32; 11usize],
+    }
+
+    pub struct ScePspSRect {
+        pub x: i16,
+        pub y: i16,
+        pub w: i16,
+        pub h: i16,
+    }
+
+    pub struct ScePspIRect {
+        pub x: i32,
+        pub y: i32,
+        pub w: i32,
+        pub h: i32,
+    }
+
+    pub struct ScePspL64Rect {
+        pub x: u64,
+        pub y: u64,
+        pub w: u64,
+        pub h: u64,
+    }
+
+    pub struct ScePspSVector2 {
+        pub x: i16,
+        pub y: i16,
+    }
+
+    pub struct ScePspIVector2 {
+        pub x: i32,
+        pub y: i32,
+    }
+
+    pub struct ScePspL64Vector2 {
+        pub x: u64,
+        pub y: u64,
+    }
+
+    pub struct ScePspSVector3 {
+        pub x: i16,
+        pub y: i16,
+        pub z: i16,
+    }
+
+    pub struct ScePspIVector3 {
+        pub x: i32,
+        pub y: i32,
+        pub z: i32,
+    }
+
+    pub struct ScePspL64Vector3 {
+        pub x: u64,
+        pub y: u64,
+        pub z: u64,
+    }
+
+    pub struct ScePspSVector4 {
+        pub x: i16,
+        pub y: i16,
+        pub z: i16,
+        pub w: i16,
+    }
+
+    pub struct ScePspIVector4 {
+        pub x: i32,
+        pub y: i32,
+        pub z: i32,
+        pub w: i32,
+    }
+
+    pub struct ScePspL64Vector4 {
+        pub x: u64,
+        pub y: u64,
+        pub z: u64,
+        pub w: u64,
+    }
+
+    pub struct ScePspIMatrix2 {
+        pub x: ScePspIVector2,
+        pub y: ScePspIVector2,
+    }
+
+    pub struct ScePspIMatrix3 {
+        pub x: ScePspIVector3,
+        pub y: ScePspIVector3,
+        pub z: ScePspIVector3,
+    }
+
+    #[repr(align(16))]
+    pub struct ScePspIMatrix4 {
+        pub x: ScePspIVector4,
+        pub y: ScePspIVector4,
+        pub z: ScePspIVector4,
+        pub w: ScePspIVector4,
+    }
+
+    pub struct ScePspIMatrix4Unaligned {
+        pub x: ScePspIVector4,
+        pub y: ScePspIVector4,
+        pub z: ScePspIVector4,
+        pub w: ScePspIVector4,
+    }
+
+    pub struct SceMp3InitArg {
+        pub mp3_stream_start: u32,
+        pub unk1: u32,
+        pub mp3_stream_end: u32,
+        pub unk2: u32,
+        pub mp3_buf: *mut c_void,
+        pub mp3_buf_size: i32,
+        pub pcm_buf: *mut c_void,
+        pub pcm_buf_size: i32,
+    }
+
+    pub struct OpenPSID {
+        pub data: [u8; 16usize],
+    }
+
+    pub struct UtilityDialogCommon {
+        pub size: u32,
+        pub language: SystemParamLanguage,
+        pub button_accept: UtilityDialogButtonAccept,
+        pub graphics_thread: i32,
+        pub access_thread: i32,
+        pub font_thread: i32,
+        pub sound_thread: i32,
+        pub result: i32,
+        pub reserved: [i32; 4usize],
+    }
+
+    pub struct UtilityNetconfAdhoc {
+        pub name: [u8; 8usize],
+        pub timeout: u32,
+    }
+
+    pub struct UtilityNetconfData {
+        pub base: UtilityDialogCommon,
+        pub action: UtilityNetconfAction,
+        pub adhocparam: *mut UtilityNetconfAdhoc,
+        pub hotspot: i32,
+        pub hotspot_connected: i32,
+        pub wifisp: i32,
+    }
+
+    pub struct UtilitySavedataFileData {
+        pub buf: *mut c_void,
+        pub buf_size: usize,
+        pub size: usize,
+        pub unknown: i32,
+    }
+
+    pub struct UtilitySavedataListSaveNewData {
+        pub icon0: UtilitySavedataFileData,
+        pub title: *mut u8,
+    }
+
+    pub struct UtilityGameSharingParams {
+        pub base: UtilityDialogCommon,
+        pub unknown1: i32,
+        pub unknown2: i32,
+        pub name: [u8; 8usize],
+        pub unknown3: i32,
+        pub unknown4: i32,
+        pub unknown5: i32,
+        pub result: i32,
+        pub filepath: *mut u8,
+        pub mode: UtilityGameSharingMode,
+        pub datatype: UtilityGameSharingDataType,
+        pub data: *mut c_void,
+        pub datasize: u32,
+    }
+
+    pub struct UtilityHtmlViewerParam {
+        pub base: UtilityDialogCommon,
+        pub memaddr: *mut c_void,
+        pub memsize: u32,
+        pub unknown1: i32,
+        pub unknown2: i32,
+        pub initialurl: *mut u8,
+        pub numtabs: u32,
+        pub interfacemode: UtilityHtmlViewerInterfaceMode,
+        pub options: i32,
+        pub dldirname: *mut u8,
+        pub dlfilename: *mut u8,
+        pub uldirname: *mut u8,
+        pub ulfilename: *mut u8,
+        pub cookiemode: UtilityHtmlViewerCookieMode,
+        pub unknown3: u32,
+        pub homeurl: *mut u8,
+        pub textsize: UtilityHtmlViewerTextSize,
+        pub displaymode: UtilityHtmlViewerDisplayMode,
+        pub connectmode: UtilityHtmlViewerConnectMode,
+        pub disconnectmode: UtilityHtmlViewerDisconnectMode,
+        pub memused: u32,
+        pub unknown4: [i32; 10usize],
+    }
+
+    pub struct SceUtilityOskData {
+        pub unk_00: i32,
+        pub unk_04: i32,
+        pub language: SceUtilityOskInputLanguage,
+        pub unk_12: i32,
+        pub inputtype: SceUtilityOskInputType,
+        pub lines: i32,
+        pub unk_24: i32,
+        pub desc: *mut u16,
+        pub intext: *mut u16,
+        pub outtextlength: i32,
+        pub outtext: *mut u16,
+        pub result: SceUtilityOskResult,
+        pub outtextlimit: i32,
+    }
+
+    pub struct SceUtilityOskParams {
+        pub base: UtilityDialogCommon,
+        pub datacount: i32,
+        pub data: *mut SceUtilityOskData,
+        pub state: SceUtilityOskState,
+        pub unk_60: i32,
+    }
+
+    pub struct SceNetMallocStat {
+        pub pool: i32,
+        pub maximum: i32,
+        pub free: i32,
+    }
+
+    pub struct SceNetAdhocctlAdhocId {
+        pub unknown: i32,
+        pub adhoc_id: [u8; 9usize],
+        pub unk: [u8; 3usize],
+    }
+
+    pub struct SceNetAdhocctlScanInfo {
+        pub next: *mut SceNetAdhocctlScanInfo,
+        pub channel: i32,
+        pub name: [u8; 8usize],
+        pub bssid: [u8; 6usize],
+        pub unknown: [u8; 2usize],
+        pub unknown2: i32,
+    }
+
+    pub struct SceNetAdhocctlGameModeInfo {
+        pub count: i32,
+        pub macs: [[u8; 6usize]; 16usize],
+    }
+
+    pub struct SceNetAdhocPtpStat {
+        pub next: *mut SceNetAdhocPtpStat,
+        pub ptp_id: i32,
+        pub mac: [u8; 6usize],
+        pub peermac: [u8; 6usize],
+        pub port: u16,
+        pub peerport: u16,
+        pub sent_data: u32,
+        pub rcvd_data: u32,
+        pub state: ScePspnetAdhocPtpState,
+    }
+
+    pub struct SceNetAdhocPdpStat {
+        pub next: *mut SceNetAdhocPdpStat,
+        pub pdp_id: i32,
+        pub mac: [u8; 6usize],
+        pub port: u16,
+        pub rcvd_data: u32,
+    }
+
+    pub struct AdhocPoolStat {
+        pub size: i32,
+        pub maxsize: i32,
+        pub freesize: i32,
+    }
+}
+
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    pub struct GeContext {
+        pub context: [u32; 512],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct SceKernelUtilsSha1Context {
+        pub h: [u32; 5usize],
+        pub us_remains: u16,
+        pub us_computed: u16,
+        pub ull_total_len: u64,
+        pub buf: [u8; 64usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct SceKernelUtilsMt19937Context {
+        pub count: u32,
+        pub state: [u32; 624usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct SceKernelUtilsMd5Context {
+        pub h: [u32; 4usize],
+        pub pad: u32,
+        pub us_remains: u16,
+        pub us_computed: u16,
+        pub ull_total_len: u64,
+        pub buf: [u8; 64usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct SceIoDirent {
+        pub d_stat: SceIoStat,
+        pub d_name: [u8; 256usize],
+        pub d_private: *mut c_void,
+        pub dummy: i32,
+    }
+
+    #[cfg_attr(feature = "extra_traits", derive(Debug))]
+    pub struct ScePspFRect {
+        pub x: f32,
+        pub y: f32,
+        pub w: f32,
+        pub h: f32,
+    }
+
+    #[repr(align(16))]
+    #[cfg_attr(feature = "extra_traits", derive(Debug))]
+    pub struct ScePspFVector3 {
+        pub x: f32,
+        pub y: f32,
+        pub z: f32,
+    }
+
+    #[repr(align(16))]
+    #[cfg_attr(feature = "extra_traits", derive(Debug))]
+    pub struct ScePspFVector4 {
+        pub x: f32,
+        pub y: f32,
+        pub z: f32,
+        pub w: f32,
+    }
+
+    #[cfg_attr(feature = "extra_traits", derive(Debug))]
+    pub struct ScePspFVector4Unaligned {
+        pub x: f32,
+        pub y: f32,
+        pub z: f32,
+        pub w: f32,
+    }
+
+    #[cfg_attr(feature = "extra_traits", derive(Debug))]
+    pub struct ScePspFVector2 {
+        pub x: f32,
+        pub y: f32,
+    }
+
+    #[cfg_attr(feature = "extra_traits", derive(Debug))]
+    pub struct ScePspFMatrix2 {
+        pub x: ScePspFVector2,
+        pub y: ScePspFVector2,
+    }
+
+    #[cfg_attr(feature = "extra_traits", derive(Debug))]
+    pub struct ScePspFMatrix3 {
+        pub x: ScePspFVector3,
+        pub y: ScePspFVector3,
+        pub z: ScePspFVector3,
+    }
+
+    #[cfg_attr(feature = "extra_traits", derive(Debug))]
+    #[repr(align(16))]
+    pub struct ScePspFMatrix4 {
+        pub x: ScePspFVector4,
+        pub y: ScePspFVector4,
+        pub z: ScePspFVector4,
+        pub w: ScePspFVector4,
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct ScePspFMatrix4Unaligned {
+        pub x: ScePspFVector4,
+        pub y: ScePspFVector4,
+        pub z: ScePspFVector4,
+        pub w: ScePspFVector4,
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub union ScePspVector3 {
+        pub fv: ScePspFVector3,
+        pub iv: ScePspIVector3,
+        pub f: [f32; 3usize],
+        pub i: [i32; 3usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub union ScePspVector4 {
+        pub fv: ScePspFVector4,
+        pub iv: ScePspIVector4,
+        pub qw: u128,
+        pub f: [f32; 4usize],
+        pub i: [i32; 4usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub union ScePspMatrix2 {
+        pub fm: ScePspFMatrix2,
+        pub im: ScePspIMatrix2,
+        pub fv: [ScePspFVector2; 2usize],
+        pub iv: [ScePspIVector2; 2usize],
+        pub v: [ScePspVector2; 2usize],
+        pub f: [[f32; 2usize]; 2usize],
+        pub i: [[i32; 2usize]; 2usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub union ScePspMatrix3 {
+        pub fm: ScePspFMatrix3,
+        pub im: ScePspIMatrix3,
+        pub fv: [ScePspFVector3; 3usize],
+        pub iv: [ScePspIVector3; 3usize],
+        pub v: [ScePspVector3; 3usize],
+        pub f: [[f32; 3usize]; 3usize],
+        pub i: [[i32; 3usize]; 3usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub union ScePspVector2 {
+        pub fv: ScePspFVector2,
+        pub iv: ScePspIVector2,
+        pub f: [f32; 2usize],
+        pub i: [i32; 2usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub union ScePspMatrix4 {
+        pub fm: ScePspFMatrix4,
+        pub im: ScePspIMatrix4,
+        pub fv: [ScePspFVector4; 4usize],
+        pub iv: [ScePspIVector4; 4usize],
+        pub v: [ScePspVector4; 4usize],
+        pub f: [[f32; 4usize]; 4usize],
+        pub i: [[i32; 4usize]; 4usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct Key {
+        pub key_type: KeyType,
+        pub name: [u8; 256usize],
+        pub name_len: u32,
+        pub unk2: u32,
+        pub unk3: u32,
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct UtilityMsgDialogParams {
+        pub base: UtilityDialogCommon,
+        pub unknown: i32,
+        pub mode: UtilityMsgDialogMode,
+        pub error_value: u32,
+        pub message: [u8; 512usize],
+        pub options: i32,
+        pub button_pressed: UtilityMsgDialogPressed,
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub union UtilityNetData {
+        pub as_uint: u32,
+        pub as_string: [u8; 128usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct UtilitySavedataSFOParam {
+        pub title: [u8; 128usize],
+        pub savedata_title: [u8; 128usize],
+        pub detail: [u8; 1024usize],
+        pub parental_level: u8,
+        pub unknown: [u8; 3usize],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct SceUtilitySavedataParam {
+        pub base: UtilityDialogCommon,
+        pub mode: UtilitySavedataMode,
+        pub unknown1: i32,
+        pub overwrite: i32,
+        pub game_name: [u8; 13usize],
+        pub reserved: [u8; 3usize],
+        pub save_name: [u8; 20usize],
+        pub save_name_list: *mut [u8; 20usize],
+        pub file_name: [u8; 13usize],
+        pub reserved1: [u8; 3usize],
+        pub data_buf: *mut c_void,
+        pub data_buf_size: usize,
+        pub data_size: usize,
+        pub sfo_param: UtilitySavedataSFOParam,
+        pub icon0_file_data: UtilitySavedataFileData,
+        pub icon1_file_data: UtilitySavedataFileData,
+        pub pic1_file_data: UtilitySavedataFileData,
+        pub snd0_file_data: UtilitySavedataFileData,
+        pub new_data: *mut UtilitySavedataListSaveNewData,
+        pub focus: UtilitySavedataFocus,
+        pub unknown2: [i32; 4usize],
+        pub key: [u8; 16],
+        pub unknown3: [u8; 20],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct SceNetAdhocctlPeerInfo {
+        pub next: *mut SceNetAdhocctlPeerInfo,
+        pub nickname: [u8; 128usize],
+        pub mac: [u8; 6usize],
+        pub unknown: [u8; 6usize],
+        pub timestamp: u32,
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct SceNetAdhocctlParams {
+        pub channel: i32,
+        pub name: [u8; 8usize],
+        pub bssid: [u8; 6usize],
+        pub nickname: [u8; 128usize],
+    }
+
+    #[cfg_attr(feature = "extra_traits", allow(missing_debug_implementations))]
+    pub union SceNetApctlInfo {
+        pub name: [u8; 64usize],
+        pub bssid: [u8; 6usize],
+        pub ssid: [u8; 32usize],
+        pub ssid_length: u32,
+        pub security_type: u32,
+        pub strength: u8,
+        pub channel: u8,
+        pub power_save: u8,
+        pub ip: [u8; 16usize],
+        pub sub_net_mask: [u8; 16usize],
+        pub gateway: [u8; 16usize],
+        pub primary_dns: [u8; 16usize],
+        pub secondary_dns: [u8; 16usize],
+        pub use_proxy: u32,
+        pub proxy_url: [u8; 128usize],
+        pub proxy_port: u16,
+        pub eap_type: u32,
+        pub start_browser: u32,
+        pub wifisp: u32,
+    }
+}
+
+pub const INT_MIN: c_int = -2147483648;
+pub const INT_MAX: c_int = 2147483647;
+
+pub const AUDIO_VOLUME_MAX: u32 = 0x8000;
+pub const AUDIO_CHANNEL_MAX: u32 = 8;
+pub const AUDIO_NEXT_CHANNEL: i32 = -1;
+pub const AUDIO_SAMPLE_MIN: u32 = 64;
+pub const AUDIO_SAMPLE_MAX: u32 = 65472;
+
+pub const PSP_CTRL_SELECT: i32 = 0x000001;
+pub const PSP_CTRL_START: i32 = 0x000008;
+pub const PSP_CTRL_UP: i32 = 0x000010;
+pub const PSP_CTRL_RIGHT: i32 = 0x000020;
+pub const PSP_CTRL_DOWN: i32 = 0x000040;
+pub const PSP_CTRL_LEFT: i32 = 0x000080;
+pub const PSP_CTRL_LTRIGGER: i32 = 0x000100;
+pub const PSP_CTRL_RTRIGGER: i32 = 0x000200;
+pub const PSP_CTRL_TRIANGLE: i32 = 0x001000;
+pub const PSP_CTRL_CIRCLE: i32 = 0x002000;
+pub const PSP_CTRL_CROSS: i32 = 0x004000;
+pub const PSP_CTRL_SQUARE: i32 = 0x008000;
+pub const PSP_CTRL_HOME: i32 = 0x010000;
+pub const PSP_CTRL_HOLD: i32 = 0x020000;
+pub const PSP_CTRL_NOTE: i32 = 0x800000;
+pub const PSP_CTRL_SCREEN: i32 = 0x400000;
+pub const PSP_CTRL_VOLUP: i32 = 0x100000;
+pub const PSP_CTRL_VOLDOWN: i32 = 0x200000;
+pub const PSP_CTRL_WLAN_UP: i32 = 0x040000;
+pub const PSP_CTRL_REMOTE: i32 = 0x080000;
+pub const PSP_CTRL_DISC: i32 = 0x1000000;
+pub const PSP_CTRL_MS: i32 = 0x2000000;
+
+pub const USB_CAM_PID: i32 = 0x282;
+pub const USB_BUS_DRIVER_NAME: &str = "USBBusDriver";
+pub const USB_CAM_DRIVER_NAME: &str = "USBCamDriver";
+pub const USB_CAM_MIC_DRIVER_NAME: &str = "USBCamMicDriver";
+pub const USB_STOR_DRIVER_NAME: &str = "USBStor_Driver";
+
+pub const ACTIVATED: i32 = 0x200;
+pub const CONNECTED: i32 = 0x020;
+pub const ESTABLISHED: i32 = 0x002;
+
+pub const USB_CAM_FLIP: i32 = 1;
+pub const USB_CAM_MIRROR: i32 = 0x100;
+
+pub const THREAD_ATTR_VFPU: i32 = 0x00004000;
+pub const THREAD_ATTR_USER: i32 = 0x80000000;
+pub const THREAD_ATTR_USBWLAN: i32 = 0xa0000000;
+pub const THREAD_ATTR_VSH: i32 = 0xc0000000;
+pub const THREAD_ATTR_SCRATCH_SRAM: i32 = 0x00008000;
+pub const THREAD_ATTR_NO_FILLSTACK: i32 = 0x00100000;
+pub const THREAD_ATTR_CLEAR_STACK: i32 = 0x00200000;
+
+pub const EVENT_WAIT_MULTIPLE: i32 = 0x200;
+
+pub const EVENT_WAIT_AND: i32 = 0;
+pub const EVENT_WAIT_OR: i32 = 1;
+pub const EVENT_WAIT_CLEAR: i32 = 0x20;
+
+pub const POWER_INFO_POWER_SWITCH: i32 = 0x80000000;
+pub const POWER_INFO_HOLD_SWITCH: i32 = 0x40000000;
+pub const POWER_INFO_STANDBY: i32 = 0x00080000;
+pub const POWER_INFO_RESUME_COMPLETE: i32 = 0x00040000;
+pub const POWER_INFO_RESUMING: i32 = 0x00020000;
+pub const POWER_INFO_SUSPENDING: i32 = 0x00010000;
+pub const POWER_INFO_AC_POWER: i32 = 0x00001000;
+pub const POWER_INFO_BATTERY_LOW: i32 = 0x00000100;
+pub const POWER_INFO_BATTERY_EXIST: i32 = 0x00000080;
+pub const POWER_INFO_BATTERY_POWER: i32 = 0x0000007;
+
+pub const FIO_S_IFLNK: i32 = 0x4000;
+pub const FIO_S_IFDIR: i32 = 0x1000;
+pub const FIO_S_IFREG: i32 = 0x2000;
+pub const FIO_S_ISUID: i32 = 0x0800;
+pub const FIO_S_ISGID: i32 = 0x0400;
+pub const FIO_S_ISVTX: i32 = 0x0200;
+pub const FIO_S_IRUSR: i32 = 0x0100;
+pub const FIO_S_IWUSR: i32 = 0x0080;
+pub const FIO_S_IXUSR: i32 = 0x0040;
+pub const FIO_S_IRGRP: i32 = 0x0020;
+pub const FIO_S_IWGRP: i32 = 0x0010;
+pub const FIO_S_IXGRP: i32 = 0x0008;
+pub const FIO_S_IROTH: i32 = 0x0004;
+pub const FIO_S_IWOTH: i32 = 0x0002;
+pub const FIO_S_IXOTH: i32 = 0x0001;
+
+pub const FIO_SO_IFLNK: i32 = 0x0008;
+pub const FIO_SO_IFDIR: i32 = 0x0010;
+pub const FIO_SO_IFREG: i32 = 0x0020;
+pub const FIO_SO_IROTH: i32 = 0x0004;
+pub const FIO_SO_IWOTH: i32 = 0x0002;
+pub const FIO_SO_IXOTH: i32 = 0x0001;
+
+pub const PSP_O_RD_ONLY: i32 = 0x0001;
+pub const PSP_O_WR_ONLY: i32 = 0x0002;
+pub const PSP_O_RD_WR: i32 = 0x0003;
+pub const PSP_O_NBLOCK: i32 = 0x0004;
+pub const PSP_O_DIR: i32 = 0x0008;
+pub const PSP_O_APPEND: i32 = 0x0100;
+pub const PSP_O_CREAT: i32 = 0x0200;
+pub const PSP_O_TRUNC: i32 = 0x0400;
+pub const PSP_O_EXCL: i32 = 0x0800;
+pub const PSP_O_NO_WAIT: i32 = 0x8000;
+
+pub const UMD_NOT_PRESENT: i32 = 0x01;
+pub const UMD_PRESENT: i32 = 0x02;
+pub const UMD_CHANGED: i32 = 0x04;
+pub const UMD_INITING: i32 = 0x08;
+pub const UMD_INITED: i32 = 0x10;
+pub const UMD_READY: i32 = 0x20;
+
+pub const PLAY_PAUSE: i32 = 0x1;
+pub const FORWARD: i32 = 0x4;
+pub const BACK: i32 = 0x8;
+pub const VOL_UP: i32 = 0x10;
+pub const VOL_DOWN: i32 = 0x20;
+pub const HOLD: i32 = 0x80;
+
+pub const GU_PI: f32 = 3.141593;
+
+pub const GU_TEXTURE_8BIT: i32 = 1;
+pub const GU_TEXTURE_16BIT: i32 = 2;
+pub const GU_TEXTURE_32BITF: i32 = 3;
+pub const GU_COLOR_5650: i32 = 4 << 2;
+pub const GU_COLOR_5551: i32 = 5 << 2;
+pub const GU_COLOR_4444: i32 = 6 << 2;
+pub const GU_COLOR_8888: i32 = 7 << 2;
+pub const GU_NORMAL_8BIT: i32 = 1 << 5;
+pub const GU_NORMAL_16BIT: i32 = 2 << 5;
+pub const GU_NORMAL_32BITF: i32 = 3 << 5;
+pub const GU_VERTEX_8BIT: i32 = 1 << 7;
+pub const GU_VERTEX_16BIT: i32 = 2 << 7;
+pub const GU_VERTEX_32BITF: i32 = 3 << 7;
+pub const GU_WEIGHT_8BIT: i32 = 1 << 9;
+pub const GU_WEIGHT_16BIT: i32 = 2 << 9;
+pub const GU_WEIGHT_32BITF: i32 = 3 << 9;
+pub const GU_INDEX_8BIT: i32 = 1 << 11;
+pub const GU_INDEX_16BIT: i32 = 2 << 11;
+pub const GU_WEIGHTS1: i32 = (((1 - 1) & 7) << 14) as i32;
+pub const GU_WEIGHTS2: i32 = (((2 - 1) & 7) << 14) as i32;
+pub const GU_WEIGHTS3: i32 = (((3 - 1) & 7) << 14) as i32;
+pub const GU_WEIGHTS4: i32 = (((4 - 1) & 7) << 14) as i32;
+pub const GU_WEIGHTS5: i32 = (((5 - 1) & 7) << 14) as i32;
+pub const GU_WEIGHTS6: i32 = (((6 - 1) & 7) << 14) as i32;
+pub const GU_WEIGHTS7: i32 = (((7 - 1) & 7) << 14) as i32;
+pub const GU_WEIGHTS8: i32 = (((8 - 1) & 7) << 14) as i32;
+pub const GU_VERTICES1: i32 = (((1 - 1) & 7) << 18) as i32;
+pub const GU_VERTICES2: i32 = (((2 - 1) & 7) << 18) as i32;
+pub const GU_VERTICES3: i32 = (((3 - 1) & 7) << 18) as i32;
+pub const GU_VERTICES4: i32 = (((4 - 1) & 7) << 18) as i32;
+pub const GU_VERTICES5: i32 = (((5 - 1) & 7) << 18) as i32;
+pub const GU_VERTICES6: i32 = (((6 - 1) & 7) << 18) as i32;
+pub const GU_VERTICES7: i32 = (((7 - 1) & 7) << 18) as i32;
+pub const GU_VERTICES8: i32 = (((8 - 1) & 7) << 18) as i32;
+pub const GU_TRANSFORM_2D: i32 = 1 << 23;
+pub const GU_TRANSFORM_3D: i32 = 0;
+
+pub const GU_COLOR_BUFFER_BIT: i32 = 1;
+pub const GU_STENCIL_BUFFER_BIT: i32 = 2;
+pub const GU_DEPTH_BUFFER_BIT: i32 = 4;
+pub const GU_FAST_CLEAR_BIT: i32 = 16;
+
+pub const GU_AMBIENT: i32 = 1;
+pub const GU_DIFFUSE: i32 = 2;
+pub const GU_SPECULAR: i32 = 4;
+pub const GU_UNKNOWN_LIGHT_COMPONENT: i32 = 8;
+
+pub const SYSTEM_REGISTRY: [u8; 7] = *b"/system";
+pub const REG_KEYNAME_SIZE: u32 = 27;
+
+pub const UTILITY_MSGDIALOG_ERROR: i32 = 0;
+pub const UTILITY_MSGDIALOG_TEXT: i32 = 1;
+pub const UTILITY_MSGDIALOG_YES_NO_BUTTONS: i32 = 0x10;
+pub const UTILITY_MSGDIALOG_DEFAULT_NO: i32 = 0x100;
+
+pub const UTILITY_HTMLVIEWER_OPEN_SCE_START_PAGE: i32 = 0x000001;
+pub const UTILITY_HTMLVIEWER_DISABLE_STARTUP_LIMITS: i32 = 0x000002;
+pub const UTILITY_HTMLVIEWER_DISABLE_EXIT_DIALOG: i32 = 0x000004;
+pub const UTILITY_HTMLVIEWER_DISABLE_CURSOR: i32 = 0x000008;
+pub const UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_COMPLETE_DIALOG: i32 = 0x000010;
+pub const UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_START_DIALOG: i32 = 0x000020;
+pub const UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_DESTINATION_DIALOG: i32 =
+    0x000040;
+pub const UTILITY_HTMLVIEWER_LOCK_DOWNLOAD_DESTINATION_DIALOG: i32 = 0x000080;
+pub const UTILITY_HTMLVIEWER_DISABLE_TAB_DISPLAY: i32 = 0x000100;
+pub const UTILITY_HTMLVIEWER_ENABLE_ANALOG_HOLD: i32 = 0x000200;
+pub const UTILITY_HTMLVIEWER_ENABLE_FLASH: i32 = 0x000400;
+pub const UTILITY_HTMLVIEWER_DISABLE_LRTRIGGER: i32 = 0x000800;
+
+extern "C" {
+    pub fn sceAudioChReserve(
+        channel: i32,
+        sample_count: i32,
+        format: AudioFormat,
+    ) -> i32;
+    pub fn sceAudioChRelease(channel: i32) -> i32;
+    pub fn sceAudioOutput(channel: i32, vol: i32, buf: *mut c_void) -> i32;
+    pub fn sceAudioOutputBlocking(
+        channel: i32,
+        vol: i32,
+        buf: *mut c_void,
+    ) -> i32;
+    pub fn sceAudioOutputPanned(
+        channel: i32,
+        left_vol: i32,
+        right_vol: i32,
+        buf: *mut c_void,
+    ) -> i32;
+    pub fn sceAudioOutputPannedBlocking(
+        channel: i32,
+        left_vol: i32,
+        right_vol: i32,
+        buf: *mut c_void,
+    ) -> i32;
+    pub fn sceAudioGetChannelRestLen(channel: i32) -> i32;
+    pub fn sceAudioGetChannelRestLength(channel: i32) -> i32;
+    pub fn sceAudioSetChannelDataLen(channel: i32, sample_count: i32) -> i32;
+    pub fn sceAudioChangeChannelConfig(
+        channel: i32,
+        format: AudioFormat,
+    ) -> i32;
+    pub fn sceAudioChangeChannelVolume(
+        channel: i32,
+        left_vol: i32,
+        right_vol: i32,
+    ) -> i32;
+    pub fn sceAudioOutput2Reserve(sample_count: i32) -> i32;
+    pub fn sceAudioOutput2Release() -> i32;
+    pub fn sceAudioOutput2ChangeLength(sample_count: i32) -> i32;
+    pub fn sceAudioOutput2OutputBlocking(vol: i32, buf: *mut c_void) -> i32;
+    pub fn sceAudioOutput2GetRestSample() -> i32;
+    pub fn sceAudioSRCChReserve(
+        sample_count: i32,
+        freq: AudioOutputFrequency,
+        channels: i32,
+    ) -> i32;
+    pub fn sceAudioSRCChRelease() -> i32;
+    pub fn sceAudioSRCOutputBlocking(vol: i32, buf: *mut c_void) -> i32;
+    pub fn sceAudioInputInit(unknown1: i32, gain: i32, unknown2: i32) -> i32;
+    pub fn sceAudioInputInitEx(params: *mut AudioInputParams) -> i32;
+    pub fn sceAudioInputBlocking(
+        sample_count: i32,
+        freq: AudioInputFrequency,
+        buf: *mut c_void,
+    );
+    pub fn sceAudioInput(
+        sample_count: i32,
+        freq: AudioInputFrequency,
+        buf: *mut c_void,
+    );
+    pub fn sceAudioGetInputLength() -> i32;
+    pub fn sceAudioWaitInputEnd() -> i32;
+    pub fn sceAudioPollInputEnd() -> i32;
+
+    pub fn sceAtracGetAtracID(ui_codec_type: u32) -> i32;
+    pub fn sceAtracSetDataAndGetID(buf: *mut c_void, bufsize: usize) -> i32;
+    pub fn sceAtracDecodeData(
+        atrac_id: i32,
+        out_samples: *mut u16,
+        out_n: *mut i32,
+        out_end: *mut i32,
+        out_remain_frame: *mut i32,
+    ) -> i32;
+    pub fn sceAtracGetRemainFrame(
+        atrac_id: i32,
+        out_remain_frame: *mut i32,
+    ) -> i32;
+    pub fn sceAtracGetStreamDataInfo(
+        atrac_id: i32,
+        write_pointer: *mut *mut u8,
+        available_bytes: *mut u32,
+        read_offset: *mut u32,
+    ) -> i32;
+    pub fn sceAtracAddStreamData(atrac_id: i32, bytes_to_add: u32) -> i32;
+    pub fn sceAtracGetBitrate(atrac_id: i32, out_bitrate: *mut i32) -> i32;
+    pub fn sceAtracSetLoopNum(atrac_id: i32, nloops: i32) -> i32;
+    pub fn sceAtracReleaseAtracID(atrac_id: i32) -> i32;
+    pub fn sceAtracGetNextSample(atrac_id: i32, out_n: *mut i32) -> i32;
+    pub fn sceAtracGetMaxSample(atrac_id: i32, out_max: *mut i32) -> i32;
+    pub fn sceAtracGetBufferInfoForReseting(
+        atrac_id: i32,
+        ui_sample: u32,
+        pbuffer_info: *mut Atrac3BufferInfo,
+    ) -> i32;
+    pub fn sceAtracGetChannel(atrac_id: i32, pui_channel: *mut u32) -> i32;
+    pub fn sceAtracGetInternalErrorInfo(
+        atrac_id: i32,
+        pi_result: *mut i32,
+    ) -> i32;
+    pub fn sceAtracGetLoopStatus(
+        atrac_id: i32,
+        pi_loop_num: *mut i32,
+        pui_loop_status: *mut u32,
+    ) -> i32;
+    pub fn sceAtracGetNextDecodePosition(
+        atrac_id: i32,
+        pui_sample_position: *mut u32,
+    ) -> i32;
+    pub fn sceAtracGetSecondBufferInfo(
+        atrac_id: i32,
+        pui_position: *mut u32,
+        pui_data_byte: *mut u32,
+    ) -> i32;
+    pub fn sceAtracGetSoundSample(
+        atrac_id: i32,
+        pi_end_sample: *mut i32,
+        pi_loop_start_sample: *mut i32,
+        pi_loop_end_sample: *mut i32,
+    ) -> i32;
+    pub fn sceAtracResetPlayPosition(
+        atrac_id: i32,
+        ui_sample: u32,
+        ui_write_byte_first_buf: u32,
+        ui_write_byte_second_buf: u32,
+    ) -> i32;
+    pub fn sceAtracSetData(
+        atrac_id: i32,
+        puc_buffer_addr: *mut u8,
+        ui_buffer_byte: u32,
+    ) -> i32;
+    pub fn sceAtracSetHalfwayBuffer(
+        atrac_id: i32,
+        puc_buffer_addr: *mut u8,
+        ui_read_byte: u32,
+        ui_buffer_byte: u32,
+    ) -> i32;
+    pub fn sceAtracSetHalfwayBufferAndGetID(
+        puc_buffer_addr: *mut u8,
+        ui_read_byte: u32,
+        ui_buffer_byte: u32,
+    ) -> i32;
+    pub fn sceAtracSetSecondBuffer(
+        atrac_id: i32,
+        puc_second_buffer_addr: *mut u8,
+        ui_second_buffer_byte: u32,
+    ) -> i32;
+
+    pub fn sceCtrlSetSamplingCycle(cycle: i32) -> i32;
+    pub fn sceCtrlGetSamplingCycle(pcycle: *mut i32) -> i32;
+    pub fn sceCtrlSetSamplingMode(mode: CtrlMode) -> i32;
+    pub fn sceCtrlGetSamplingMode(pmode: *mut i32) -> i32;
+    pub fn sceCtrlPeekBufferPositive(
+        pad_data: *mut SceCtrlData,
+        count: i32,
+    ) -> i32;
+    pub fn sceCtrlPeekBufferNegative(
+        pad_data: *mut SceCtrlData,
+        count: i32,
+    ) -> i32;
+    pub fn sceCtrlReadBufferPositive(
+        pad_data: *mut SceCtrlData,
+        count: i32,
+    ) -> i32;
+    pub fn sceCtrlReadBufferNegative(
+        pad_data: *mut SceCtrlData,
+        count: i32,
+    ) -> i32;
+    pub fn sceCtrlPeekLatch(latch_data: *mut SceCtrlLatch) -> i32;
+    pub fn sceCtrlReadLatch(latch_data: *mut SceCtrlLatch) -> i32;
+    pub fn sceCtrlSetIdleCancelThreshold(idlereset: i32, idleback: i32)
+        -> i32;
+    pub fn sceCtrlGetIdleCancelThreshold(
+        idlereset: *mut i32,
+        idleback: *mut i32,
+    ) -> i32;
+
+    pub fn sceDisplaySetMode(
+        mode: DisplayMode,
+        width: usize,
+        height: usize,
+    ) -> u32;
+    pub fn sceDisplayGetMode(
+        pmode: *mut i32,
+        pwidth: *mut i32,
+        pheight: *mut i32,
+    ) -> i32;
+    pub fn sceDisplaySetFrameBuf(
+        top_addr: *const u8,
+        buffer_width: usize,
+        pixel_format: DisplayPixelFormat,
+        sync: DisplaySetBufSync,
+    ) -> u32;
+    pub fn sceDisplayGetFrameBuf(
+        top_addr: *mut *mut c_void,
+        buffer_width: *mut usize,
+        pixel_format: *mut DisplayPixelFormat,
+        sync: DisplaySetBufSync,
+    ) -> i32;
+    pub fn sceDisplayGetVcount() -> u32;
+    pub fn sceDisplayWaitVblank() -> i32;
+    pub fn sceDisplayWaitVblankCB() -> i32;
+    pub fn sceDisplayWaitVblankStart() -> i32;
+    pub fn sceDisplayWaitVblankStartCB() -> i32;
+    pub fn sceDisplayGetAccumulatedHcount() -> i32;
+    pub fn sceDisplayGetCurrentHcount() -> i32;
+    pub fn sceDisplayGetFramePerSec() -> f32;
+    pub fn sceDisplayIsForeground() -> i32;
+    pub fn sceDisplayIsVblank() -> i32;
+
+    pub fn sceGeEdramGetSize() -> u32;
+    pub fn sceGeEdramGetAddr() -> *mut u8;
+    pub fn sceGeEdramSetAddrTranslation(width: i32) -> i32;
+    pub fn sceGeGetCmd(cmd: i32) -> u32;
+    pub fn sceGeGetMtx(type_: GeMatrixType, matrix: *mut c_void) -> i32;
+    pub fn sceGeGetStack(stack_id: i32, stack: *mut GeStack) -> i32;
+    pub fn sceGeSaveContext(context: *mut GeContext) -> i32;
+    pub fn sceGeRestoreContext(context: *const GeContext) -> i32;
+    pub fn sceGeListEnQueue(
+        list: *const c_void,
+        stall: *mut c_void,
+        cbid: i32,
+        arg: *mut GeListArgs,
+    ) -> i32;
+    pub fn sceGeListEnQueueHead(
+        list: *const c_void,
+        stall: *mut c_void,
+        cbid: i32,
+        arg: *mut GeListArgs,
+    ) -> i32;
+    pub fn sceGeListDeQueue(qid: i32) -> i32;
+    pub fn sceGeListUpdateStallAddr(qid: i32, stall: *mut c_void) -> i32;
+    pub fn sceGeListSync(qid: i32, sync_type: i32) -> GeListState;
+    pub fn sceGeDrawSync(sync_type: i32) -> GeListState;
+    pub fn sceGeBreak(mode: i32, p_param: *mut GeBreakParam) -> i32;
+    pub fn sceGeContinue() -> i32;
+    pub fn sceGeSetCallback(cb: *mut GeCallbackData) -> i32;
+    pub fn sceGeUnsetCallback(cbid: i32) -> i32;
+
+    pub fn sceKernelExitGame();
+    pub fn sceKernelRegisterExitCallback(id: SceUid) -> i32;
+    pub fn sceKernelLoadExec(
+        file: *const u8,
+        param: *mut SceKernelLoadExecParam,
+    ) -> i32;
+
+    pub fn sceKernelAllocPartitionMemory(
+        partition: SceSysMemPartitionId,
+        name: *const u8,
+        type_: SceSysMemBlockTypes,
+        size: u32,
+        addr: *mut c_void,
+    ) -> SceUid;
+    pub fn sceKernelGetBlockHeadAddr(blockid: SceUid) -> *mut c_void;
+    pub fn sceKernelFreePartitionMemory(blockid: SceUid) -> i32;
+    pub fn sceKernelTotalFreeMemSize() -> usize;
+    pub fn sceKernelMaxFreeMemSize() -> usize;
+    pub fn sceKernelDevkitVersion() -> u32;
+    pub fn sceKernelSetCompiledSdkVersion(version: u32) -> i32;
+    pub fn sceKernelGetCompiledSdkVersion() -> u32;
+
+    pub fn sceKernelLibcTime(t: *mut i32) -> i32;
+    pub fn sceKernelLibcClock() -> u32;
+    pub fn sceKernelLibcGettimeofday(
+        tp: *mut timeval,
+        tzp: *mut timezone,
+    ) -> i32;
+    pub fn sceKernelDcacheWritebackAll();
+    pub fn sceKernelDcacheWritebackInvalidateAll();
+    pub fn sceKernelDcacheWritebackRange(p: *const c_void, size: u32);
+    pub fn sceKernelDcacheWritebackInvalidateRange(
+        p: *const c_void,
+        size: u32,
+    );
+    pub fn sceKernelDcacheInvalidateRange(p: *const c_void, size: u32);
+    pub fn sceKernelIcacheInvalidateAll();
+    pub fn sceKernelIcacheInvalidateRange(p: *const c_void, size: u32);
+    pub fn sceKernelUtilsMt19937Init(
+        ctx: *mut SceKernelUtilsMt19937Context,
+        seed: u32,
+    ) -> i32;
+    pub fn sceKernelUtilsMt19937UInt(
+        ctx: *mut SceKernelUtilsMt19937Context,
+    ) -> u32;
+    pub fn sceKernelUtilsMd5Digest(
+        data: *mut u8,
+        size: u32,
+        digest: *mut u8,
+    ) -> i32;
+    pub fn sceKernelUtilsMd5BlockInit(
+        ctx: *mut SceKernelUtilsMd5Context,
+    ) -> i32;
+    pub fn sceKernelUtilsMd5BlockUpdate(
+        ctx: *mut SceKernelUtilsMd5Context,
+        data: *mut u8,
+        size: u32,
+    ) -> i32;
+    pub fn sceKernelUtilsMd5BlockResult(
+        ctx: *mut SceKernelUtilsMd5Context,
+        digest: *mut u8,
+    ) -> i32;
+    pub fn sceKernelUtilsSha1Digest(
+        data: *mut u8,
+        size: u32,
+        digest: *mut u8,
+    ) -> i32;
+    pub fn sceKernelUtilsSha1BlockInit(
+        ctx: *mut SceKernelUtilsSha1Context,
+    ) -> i32;
+    pub fn sceKernelUtilsSha1BlockUpdate(
+        ctx: *mut SceKernelUtilsSha1Context,
+        data: *mut u8,
+        size: u32,
+    ) -> i32;
+    pub fn sceKernelUtilsSha1BlockResult(
+        ctx: *mut SceKernelUtilsSha1Context,
+        digest: *mut u8,
+    ) -> i32;
+
+    pub fn sceKernelRegisterSubIntrHandler(
+        int_no: i32,
+        no: i32,
+        handler: *mut c_void,
+        arg: *mut c_void,
+    ) -> i32;
+    pub fn sceKernelReleaseSubIntrHandler(int_no: i32, no: i32) -> i32;
+    pub fn sceKernelEnableSubIntr(int_no: i32, no: i32) -> i32;
+    pub fn sceKernelDisableSubIntr(int_no: i32, no: i32) -> i32;
+    pub fn QueryIntrHandlerInfo(
+        intr_code: SceUid,
+        sub_intr_code: SceUid,
+        data: *mut IntrHandlerOptionParam,
+    ) -> i32;
+
+    pub fn sceKernelCpuSuspendIntr() -> u32;
+    pub fn sceKernelCpuResumeIntr(flags: u32);
+    pub fn sceKernelCpuResumeIntrWithSync(flags: u32);
+    pub fn sceKernelIsCpuIntrSuspended(flags: u32) -> i32;
+    pub fn sceKernelIsCpuIntrEnable() -> i32;
+
+    pub fn sceKernelLoadModule(
+        path: *const u8,
+        flags: i32,
+        option: *mut SceKernelLMOption,
+    ) -> SceUid;
+    pub fn sceKernelLoadModuleMs(
+        path: *const u8,
+        flags: i32,
+        option: *mut SceKernelLMOption,
+    ) -> SceUid;
+    pub fn sceKernelLoadModuleByID(
+        fid: SceUid,
+        flags: i32,
+        option: *mut SceKernelLMOption,
+    ) -> SceUid;
+    pub fn sceKernelLoadModuleBufferUsbWlan(
+        buf_size: usize,
+        buf: *mut c_void,
+        flags: i32,
+        option: *mut SceKernelLMOption,
+    ) -> SceUid;
+    pub fn sceKernelStartModule(
+        mod_id: SceUid,
+        arg_size: usize,
+        argp: *mut c_void,
+        status: *mut i32,
+        option: *mut SceKernelSMOption,
+    ) -> i32;
+    pub fn sceKernelStopModule(
+        mod_id: SceUid,
+        arg_size: usize,
+        argp: *mut c_void,
+        status: *mut i32,
+        option: *mut SceKernelSMOption,
+    ) -> i32;
+    pub fn sceKernelUnloadModule(mod_id: SceUid) -> i32;
+    pub fn sceKernelSelfStopUnloadModule(
+        unknown: i32,
+        arg_size: usize,
+        argp: *mut c_void,
+    ) -> i32;
+    pub fn sceKernelStopUnloadSelfModule(
+        arg_size: usize,
+        argp: *mut c_void,
+        status: *mut i32,
+        option: *mut SceKernelSMOption,
+    ) -> i32;
+    pub fn sceKernelQueryModuleInfo(
+        mod_id: SceUid,
+        info: *mut SceKernelModuleInfo,
+    ) -> i32;
+    pub fn sceKernelGetModuleIdList(
+        read_buf: *mut SceUid,
+        read_buf_size: i32,
+        id_count: *mut i32,
+    ) -> i32;
+
+    pub fn sceKernelVolatileMemLock(
+        unk: i32,
+        ptr: *mut *mut c_void,
+        size: *mut i32,
+    ) -> i32;
+    pub fn sceKernelVolatileMemTryLock(
+        unk: i32,
+        ptr: *mut *mut c_void,
+        size: *mut i32,
+    ) -> i32;
+    pub fn sceKernelVolatileMemUnlock(unk: i32) -> i32;
+
+    pub fn sceKernelStdin() -> SceUid;
+    pub fn sceKernelStdout() -> SceUid;
+    pub fn sceKernelStderr() -> SceUid;
+
+    pub fn sceKernelGetThreadmanIdType(uid: SceUid) -> SceKernelIdListType;
+    pub fn sceKernelCreateThread(
+        name: *const u8,
+        entry: SceKernelThreadEntry,
+        init_priority: i32,
+        stack_size: i32,
+        attr: i32,
+        option: *mut SceKernelThreadOptParam,
+    ) -> SceUid;
+    pub fn sceKernelDeleteThread(thid: SceUid) -> i32;
+    pub fn sceKernelStartThread(
+        id: SceUid,
+        arg_len: usize,
+        arg_p: *mut c_void,
+    ) -> i32;
+    pub fn sceKernelExitThread(status: i32) -> i32;
+    pub fn sceKernelExitDeleteThread(status: i32) -> i32;
+    pub fn sceKernelTerminateThread(thid: SceUid) -> i32;
+    pub fn sceKernelTerminateDeleteThread(thid: SceUid) -> i32;
+    pub fn sceKernelSuspendDispatchThread() -> i32;
+    pub fn sceKernelResumeDispatchThread(state: i32) -> i32;
+    pub fn sceKernelSleepThread() -> i32;
+    pub fn sceKernelSleepThreadCB() -> i32;
+    pub fn sceKernelWakeupThread(thid: SceUid) -> i32;
+    pub fn sceKernelCancelWakeupThread(thid: SceUid) -> i32;
+    pub fn sceKernelSuspendThread(thid: SceUid) -> i32;
+    pub fn sceKernelResumeThread(thid: SceUid) -> i32;
+    pub fn sceKernelWaitThreadEnd(thid: SceUid, timeout: *mut u32) -> i32;
+    pub fn sceKernelWaitThreadEndCB(thid: SceUid, timeout: *mut u32) -> i32;
+    pub fn sceKernelDelayThread(delay: u32) -> i32;
+    pub fn sceKernelDelayThreadCB(delay: u32) -> i32;
+    pub fn sceKernelDelaySysClockThread(delay: *mut SceKernelSysClock) -> i32;
+    pub fn sceKernelDelaySysClockThreadCB(
+        delay: *mut SceKernelSysClock,
+    ) -> i32;
+    pub fn sceKernelChangeCurrentThreadAttr(unknown: i32, attr: i32) -> i32;
+    pub fn sceKernelChangeThreadPriority(thid: SceUid, priority: i32) -> i32;
+    pub fn sceKernelRotateThreadReadyQueue(priority: i32) -> i32;
+    pub fn sceKernelReleaseWaitThread(thid: SceUid) -> i32;
+    pub fn sceKernelGetThreadId() -> i32;
+    pub fn sceKernelGetThreadCurrentPriority() -> i32;
+    pub fn sceKernelGetThreadExitStatus(thid: SceUid) -> i32;
+    pub fn sceKernelCheckThreadStack() -> i32;
+    pub fn sceKernelGetThreadStackFreeSize(thid: SceUid) -> i32;
+    pub fn sceKernelReferThreadStatus(
+        thid: SceUid,
+        info: *mut SceKernelThreadInfo,
+    ) -> i32;
+    pub fn sceKernelReferThreadRunStatus(
+        thid: SceUid,
+        status: *mut SceKernelThreadRunStatus,
+    ) -> i32;
+    pub fn sceKernelCreateSema(
+        name: *const u8,
+        attr: u32,
+        init_val: i32,
+        max_val: i32,
+        option: *mut SceKernelSemaOptParam,
+    ) -> SceUid;
+    pub fn sceKernelDeleteSema(sema_id: SceUid) -> i32;
+    pub fn sceKernelSignalSema(sema_id: SceUid, signal: i32) -> i32;
+    pub fn sceKernelWaitSema(
+        sema_id: SceUid,
+        signal: i32,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelWaitSemaCB(
+        sema_id: SceUid,
+        signal: i32,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelPollSema(sema_id: SceUid, signal: i32) -> i32;
+    pub fn sceKernelReferSemaStatus(
+        sema_id: SceUid,
+        info: *mut SceKernelSemaInfo,
+    ) -> i32;
+    pub fn sceKernelCreateEventFlag(
+        name: *const u8,
+        attr: i32,
+        bits: i32,
+        opt: *mut SceKernelEventFlagOptParam,
+    ) -> SceUid;
+    pub fn sceKernelSetEventFlag(ev_id: SceUid, bits: u32) -> i32;
+    pub fn sceKernelClearEventFlag(ev_id: SceUid, bits: u32) -> i32;
+    pub fn sceKernelPollEventFlag(
+        ev_id: SceUid,
+        bits: u32,
+        wait: i32,
+        out_bits: *mut u32,
+    ) -> i32;
+    pub fn sceKernelWaitEventFlag(
+        ev_id: SceUid,
+        bits: u32,
+        wait: i32,
+        out_bits: *mut u32,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelWaitEventFlagCB(
+        ev_id: SceUid,
+        bits: u32,
+        wait: i32,
+        out_bits: *mut u32,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelDeleteEventFlag(ev_id: SceUid) -> i32;
+    pub fn sceKernelReferEventFlagStatus(
+        event: SceUid,
+        status: *mut SceKernelEventFlagInfo,
+    ) -> i32;
+    pub fn sceKernelCreateMbx(
+        name: *const u8,
+        attr: u32,
+        option: *mut SceKernelMbxOptParam,
+    ) -> SceUid;
+    pub fn sceKernelDeleteMbx(mbx_id: SceUid) -> i32;
+    pub fn sceKernelSendMbx(mbx_id: SceUid, message: *mut c_void) -> i32;
+    pub fn sceKernelReceiveMbx(
+        mbx_id: SceUid,
+        message: *mut *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelReceiveMbxCB(
+        mbx_id: SceUid,
+        message: *mut *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelPollMbx(mbx_id: SceUid, pmessage: *mut *mut c_void)
+        -> i32;
+    pub fn sceKernelCancelReceiveMbx(mbx_id: SceUid, num: *mut i32) -> i32;
+    pub fn sceKernelReferMbxStatus(
+        mbx_id: SceUid,
+        info: *mut SceKernelMbxInfo,
+    ) -> i32;
+    pub fn sceKernelSetAlarm(
+        clock: u32,
+        handler: SceKernelAlarmHandler,
+        common: *mut c_void,
+    ) -> SceUid;
+    pub fn sceKernelSetSysClockAlarm(
+        clock: *mut SceKernelSysClock,
+        handler: *mut SceKernelAlarmHandler,
+        common: *mut c_void,
+    ) -> SceUid;
+    pub fn sceKernelCancelAlarm(alarm_id: SceUid) -> i32;
+    pub fn sceKernelReferAlarmStatus(
+        alarm_id: SceUid,
+        info: *mut SceKernelAlarmInfo,
+    ) -> i32;
+    pub fn sceKernelCreateCallback(
+        name: *const u8,
+        func: SceKernelCallbackFunction,
+        arg: *mut c_void,
+    ) -> SceUid;
+    pub fn sceKernelReferCallbackStatus(
+        cb: SceUid,
+        status: *mut SceKernelCallbackInfo,
+    ) -> i32;
+    pub fn sceKernelDeleteCallback(cb: SceUid) -> i32;
+    pub fn sceKernelNotifyCallback(cb: SceUid, arg2: i32) -> i32;
+    pub fn sceKernelCancelCallback(cb: SceUid) -> i32;
+    pub fn sceKernelGetCallbackCount(cb: SceUid) -> i32;
+    pub fn sceKernelCheckCallback() -> i32;
+    pub fn sceKernelGetThreadmanIdList(
+        type_: SceKernelIdListType,
+        read_buf: *mut SceUid,
+        read_buf_size: i32,
+        id_count: *mut i32,
+    ) -> i32;
+    pub fn sceKernelReferSystemStatus(
+        status: *mut SceKernelSystemStatus,
+    ) -> i32;
+    pub fn sceKernelCreateMsgPipe(
+        name: *const u8,
+        part: i32,
+        attr: i32,
+        unk1: *mut c_void,
+        opt: *mut c_void,
+    ) -> SceUid;
+    pub fn sceKernelDeleteMsgPipe(uid: SceUid) -> i32;
+    pub fn sceKernelSendMsgPipe(
+        uid: SceUid,
+        message: *mut c_void,
+        size: u32,
+        unk1: i32,
+        unk2: *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelSendMsgPipeCB(
+        uid: SceUid,
+        message: *mut c_void,
+        size: u32,
+        unk1: i32,
+        unk2: *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelTrySendMsgPipe(
+        uid: SceUid,
+        message: *mut c_void,
+        size: u32,
+        unk1: i32,
+        unk2: *mut c_void,
+    ) -> i32;
+    pub fn sceKernelReceiveMsgPipe(
+        uid: SceUid,
+        message: *mut c_void,
+        size: u32,
+        unk1: i32,
+        unk2: *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelReceiveMsgPipeCB(
+        uid: SceUid,
+        message: *mut c_void,
+        size: u32,
+        unk1: i32,
+        unk2: *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelTryReceiveMsgPipe(
+        uid: SceUid,
+        message: *mut c_void,
+        size: u32,
+        unk1: i32,
+        unk2: *mut c_void,
+    ) -> i32;
+    pub fn sceKernelCancelMsgPipe(
+        uid: SceUid,
+        send: *mut i32,
+        recv: *mut i32,
+    ) -> i32;
+    pub fn sceKernelReferMsgPipeStatus(
+        uid: SceUid,
+        info: *mut SceKernelMppInfo,
+    ) -> i32;
+    pub fn sceKernelCreateVpl(
+        name: *const u8,
+        part: i32,
+        attr: i32,
+        size: u32,
+        opt: *mut SceKernelVplOptParam,
+    ) -> SceUid;
+    pub fn sceKernelDeleteVpl(uid: SceUid) -> i32;
+    pub fn sceKernelAllocateVpl(
+        uid: SceUid,
+        size: u32,
+        data: *mut *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelAllocateVplCB(
+        uid: SceUid,
+        size: u32,
+        data: *mut *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelTryAllocateVpl(
+        uid: SceUid,
+        size: u32,
+        data: *mut *mut c_void,
+    ) -> i32;
+    pub fn sceKernelFreeVpl(uid: SceUid, data: *mut c_void) -> i32;
+    pub fn sceKernelCancelVpl(uid: SceUid, num: *mut i32) -> i32;
+    pub fn sceKernelReferVplStatus(
+        uid: SceUid,
+        info: *mut SceKernelVplInfo,
+    ) -> i32;
+    pub fn sceKernelCreateFpl(
+        name: *const u8,
+        part: i32,
+        attr: i32,
+        size: u32,
+        blocks: u32,
+        opt: *mut SceKernelFplOptParam,
+    ) -> i32;
+    pub fn sceKernelDeleteFpl(uid: SceUid) -> i32;
+    pub fn sceKernelAllocateFpl(
+        uid: SceUid,
+        data: *mut *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelAllocateFplCB(
+        uid: SceUid,
+        data: *mut *mut c_void,
+        timeout: *mut u32,
+    ) -> i32;
+    pub fn sceKernelTryAllocateFpl(uid: SceUid, data: *mut *mut c_void)
+        -> i32;
+    pub fn sceKernelFreeFpl(uid: SceUid, data: *mut c_void) -> i32;
+    pub fn sceKernelCancelFpl(uid: SceUid, pnum: *mut i32) -> i32;
+    pub fn sceKernelReferFplStatus(
+        uid: SceUid,
+        info: *mut SceKernelFplInfo,
+    ) -> i32;
+    pub fn sceKernelUSec2SysClock(
+        usec: u32,
+        clock: *mut SceKernelSysClock,
+    ) -> i32;
+    pub fn sceKernelUSec2SysClockWide(usec: u32) -> i64;
+    pub fn sceKernelSysClock2USec(
+        clock: *mut SceKernelSysClock,
+        low: *mut u32,
+        high: *mut u32,
+    ) -> i32;
+    pub fn sceKernelSysClock2USecWide(
+        clock: i64,
+        low: *mut u32,
+        high: *mut u32,
+    ) -> i32;
+    pub fn sceKernelGetSystemTime(time: *mut SceKernelSysClock) -> i32;
+    pub fn sceKernelGetSystemTimeWide() -> i64;
+    pub fn sceKernelGetSystemTimeLow() -> u32;
+    pub fn sceKernelCreateVTimer(
+        name: *const u8,
+        opt: *mut SceKernelVTimerOptParam,
+    ) -> SceUid;
+    pub fn sceKernelDeleteVTimer(uid: SceUid) -> i32;
+    pub fn sceKernelGetVTimerBase(
+        uid: SceUid,
+        base: *mut SceKernelSysClock,
+    ) -> i32;
+    pub fn sceKernelGetVTimerBaseWide(uid: SceUid) -> i64;
+    pub fn sceKernelGetVTimerTime(
+        uid: SceUid,
+        time: *mut SceKernelSysClock,
+    ) -> i32;
+    pub fn sceKernelGetVTimerTimeWide(uid: SceUid) -> i64;
+    pub fn sceKernelSetVTimerTime(
+        uid: SceUid,
+        time: *mut SceKernelSysClock,
+    ) -> i32;
+    pub fn sceKernelSetVTimerTimeWide(uid: SceUid, time: i64) -> i64;
+    pub fn sceKernelStartVTimer(uid: SceUid) -> i32;
+    pub fn sceKernelStopVTimer(uid: SceUid) -> i32;
+    pub fn sceKernelSetVTimerHandler(
+        uid: SceUid,
+        time: *mut SceKernelSysClock,
+        handler: SceKernelVTimerHandler,
+        common: *mut c_void,
+    ) -> i32;
+    pub fn sceKernelSetVTimerHandlerWide(
+        uid: SceUid,
+        time: i64,
+        handler: SceKernelVTimerHandlerWide,
+        common: *mut c_void,
+    ) -> i32;
+    pub fn sceKernelCancelVTimerHandler(uid: SceUid) -> i32;
+    pub fn sceKernelReferVTimerStatus(
+        uid: SceUid,
+        info: *mut SceKernelVTimerInfo,
+    ) -> i32;
+    pub fn sceKernelRegisterThreadEventHandler(
+        name: *const u8,
+        thread_id: SceUid,
+        mask: i32,
+        handler: SceKernelThreadEventHandler,
+        common: *mut c_void,
+    ) -> SceUid;
+    pub fn sceKernelReleaseThreadEventHandler(uid: SceUid) -> i32;
+    pub fn sceKernelReferThreadEventHandlerStatus(
+        uid: SceUid,
+        info: *mut SceKernelThreadEventHandlerInfo,
+    ) -> i32;
+    pub fn sceKernelReferThreadProfiler() -> *mut DebugProfilerRegs;
+    pub fn sceKernelReferGlobalProfiler() -> *mut DebugProfilerRegs;
+
+    pub fn sceUsbStart(
+        driver_name: *const u8,
+        size: i32,
+        args: *mut c_void,
+    ) -> i32;
+    pub fn sceUsbStop(
+        driver_name: *const u8,
+        size: i32,
+        args: *mut c_void,
+    ) -> i32;
+    pub fn sceUsbActivate(pid: u32) -> i32;
+    pub fn sceUsbDeactivate(pid: u32) -> i32;
+    pub fn sceUsbGetState() -> i32;
+    pub fn sceUsbGetDrvState(driver_name: *const u8) -> i32;
+}
+
+extern "C" {
+    pub fn sceUsbCamSetupStill(param: *mut UsbCamSetupStillParam) -> i32;
+    pub fn sceUsbCamSetupStillEx(param: *mut UsbCamSetupStillExParam) -> i32;
+    pub fn sceUsbCamStillInputBlocking(buf: *mut u8, size: usize) -> i32;
+    pub fn sceUsbCamStillInput(buf: *mut u8, size: usize) -> i32;
+    pub fn sceUsbCamStillWaitInputEnd() -> i32;
+    pub fn sceUsbCamStillPollInputEnd() -> i32;
+    pub fn sceUsbCamStillCancelInput() -> i32;
+    pub fn sceUsbCamStillGetInputLength() -> i32;
+    pub fn sceUsbCamSetupVideo(
+        param: *mut UsbCamSetupVideoParam,
+        work_area: *mut c_void,
+        work_area_size: i32,
+    ) -> i32;
+    pub fn sceUsbCamSetupVideoEx(
+        param: *mut UsbCamSetupVideoExParam,
+        work_area: *mut c_void,
+        work_area_size: i32,
+    ) -> i32;
+    pub fn sceUsbCamStartVideo() -> i32;
+    pub fn sceUsbCamStopVideo() -> i32;
+    pub fn sceUsbCamReadVideoFrameBlocking(buf: *mut u8, size: usize) -> i32;
+    pub fn sceUsbCamReadVideoFrame(buf: *mut u8, size: usize) -> i32;
+    pub fn sceUsbCamWaitReadVideoFrameEnd() -> i32;
+    pub fn sceUsbCamPollReadVideoFrameEnd() -> i32;
+    pub fn sceUsbCamGetReadVideoFrameSize() -> i32;
+    pub fn sceUsbCamSetSaturation(saturation: i32) -> i32;
+    pub fn sceUsbCamSetBrightness(brightness: i32) -> i32;
+    pub fn sceUsbCamSetContrast(contrast: i32) -> i32;
+    pub fn sceUsbCamSetSharpness(sharpness: i32) -> i32;
+    pub fn sceUsbCamSetImageEffectMode(effect_mode: UsbCamEffectMode) -> i32;
+    pub fn sceUsbCamSetEvLevel(exposure_level: UsbCamEvLevel) -> i32;
+    pub fn sceUsbCamSetReverseMode(reverse_flags: i32) -> i32;
+    pub fn sceUsbCamSetZoom(zoom: i32) -> i32;
+    pub fn sceUsbCamGetSaturation(saturation: *mut i32) -> i32;
+    pub fn sceUsbCamGetBrightness(brightness: *mut i32) -> i32;
+    pub fn sceUsbCamGetContrast(contrast: *mut i32) -> i32;
+    pub fn sceUsbCamGetSharpness(sharpness: *mut i32) -> i32;
+    pub fn sceUsbCamGetImageEffectMode(
+        effect_mode: *mut UsbCamEffectMode,
+    ) -> i32;
+    pub fn sceUsbCamGetEvLevel(exposure_level: *mut UsbCamEvLevel) -> i32;
+    pub fn sceUsbCamGetReverseMode(reverse_flags: *mut i32) -> i32;
+    pub fn sceUsbCamGetZoom(zoom: *mut i32) -> i32;
+    pub fn sceUsbCamAutoImageReverseSW(on: i32) -> i32;
+    pub fn sceUsbCamGetAutoImageReverseState() -> i32;
+    pub fn sceUsbCamGetLensDirection() -> i32;
+
+    pub fn sceUsbstorBootRegisterNotify(event_flag: SceUid) -> i32;
+    pub fn sceUsbstorBootUnregisterNotify(event_flag: u32) -> i32;
+    pub fn sceUsbstorBootSetCapacity(size: u32) -> i32;
+
+    pub fn scePowerRegisterCallback(slot: i32, cbid: SceUid) -> i32;
+    pub fn scePowerUnregisterCallback(slot: i32) -> i32;
+    pub fn scePowerIsPowerOnline() -> i32;
+    pub fn scePowerIsBatteryExist() -> i32;
+    pub fn scePowerIsBatteryCharging() -> i32;
+    pub fn scePowerGetBatteryChargingStatus() -> i32;
+    pub fn scePowerIsLowBattery() -> i32;
+    pub fn scePowerGetBatteryLifePercent() -> i32;
+    pub fn scePowerGetBatteryLifeTime() -> i32;
+    pub fn scePowerGetBatteryTemp() -> i32;
+    pub fn scePowerGetBatteryElec() -> i32;
+    pub fn scePowerGetBatteryVolt() -> i32;
+    pub fn scePowerSetCpuClockFrequency(cpufreq: i32) -> i32;
+    pub fn scePowerSetBusClockFrequency(busfreq: i32) -> i32;
+    pub fn scePowerGetCpuClockFrequency() -> i32;
+    pub fn scePowerGetCpuClockFrequencyInt() -> i32;
+    pub fn scePowerGetCpuClockFrequencyFloat() -> f32;
+    pub fn scePowerGetBusClockFrequency() -> i32;
+    pub fn scePowerGetBusClockFrequencyInt() -> i32;
+    pub fn scePowerGetBusClockFrequencyFloat() -> f32;
+    pub fn scePowerSetClockFrequency(
+        pllfreq: i32,
+        cpufreq: i32,
+        busfreq: i32,
+    ) -> i32;
+    pub fn scePowerLock(unknown: i32) -> i32;
+    pub fn scePowerUnlock(unknown: i32) -> i32;
+    pub fn scePowerTick(t: PowerTick) -> i32;
+    pub fn scePowerGetIdleTimer() -> i32;
+    pub fn scePowerIdleTimerEnable(unknown: i32) -> i32;
+    pub fn scePowerIdleTimerDisable(unknown: i32) -> i32;
+    pub fn scePowerRequestStandby() -> i32;
+    pub fn scePowerRequestSuspend() -> i32;
+
+    pub fn sceWlanDevIsPowerOn() -> i32;
+    pub fn sceWlanGetSwitchState() -> i32;
+    pub fn sceWlanGetEtherAddr(ether_addr: *mut u8) -> i32;
+
+    pub fn sceWlanDevAttach() -> i32;
+    pub fn sceWlanDevDetach() -> i32;
+
+    pub fn sceRtcGetTickResolution() -> u32;
+    pub fn sceRtcGetCurrentTick(tick: *mut u64) -> i32;
+    pub fn sceRtcGetCurrentClock(tm: *mut ScePspDateTime, tz: i32) -> i32;
+    pub fn sceRtcGetCurrentClockLocalTime(tm: *mut ScePspDateTime) -> i32;
+    pub fn sceRtcConvertUtcToLocalTime(
+        tick_utc: *const u64,
+        tick_local: *mut u64,
+    ) -> i32;
+    pub fn sceRtcConvertLocalTimeToUTC(
+        tick_local: *const u64,
+        tick_utc: *mut u64,
+    ) -> i32;
+    pub fn sceRtcIsLeapYear(year: i32) -> i32;
+    pub fn sceRtcGetDaysInMonth(year: i32, month: i32) -> i32;
+    pub fn sceRtcGetDayOfWeek(year: i32, month: i32, day: i32) -> i32;
+    pub fn sceRtcCheckValid(date: *const ScePspDateTime) -> i32;
+    pub fn sceRtcSetTick(date: *mut ScePspDateTime, tick: *const u64) -> i32;
+    pub fn sceRtcGetTick(date: *const ScePspDateTime, tick: *mut u64) -> i32;
+    pub fn sceRtcCompareTick(tick1: *const u64, tick2: *const u64) -> i32;
+    pub fn sceRtcTickAddTicks(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_ticks: u64,
+    ) -> i32;
+    pub fn sceRtcTickAddMicroseconds(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_ms: u64,
+    ) -> i32;
+    pub fn sceRtcTickAddSeconds(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_seconds: u64,
+    ) -> i32;
+    pub fn sceRtcTickAddMinutes(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_minutes: u64,
+    ) -> i32;
+    pub fn sceRtcTickAddHours(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_hours: u64,
+    ) -> i32;
+    pub fn sceRtcTickAddDays(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_days: u64,
+    ) -> i32;
+    pub fn sceRtcTickAddWeeks(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_weeks: u64,
+    ) -> i32;
+    pub fn sceRtcTickAddMonths(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_months: u64,
+    ) -> i32;
+    pub fn sceRtcTickAddYears(
+        dest_tick: *mut u64,
+        src_tick: *const u64,
+        num_years: u64,
+    ) -> i32;
+    pub fn sceRtcSetTime_t(date: *mut ScePspDateTime, time: u32) -> i32;
+    pub fn sceRtcGetTime_t(date: *const ScePspDateTime, time: *mut u32)
+        -> i32;
+    pub fn sceRtcSetTime64_t(date: *mut ScePspDateTime, time: u64) -> i32;
+    pub fn sceRtcGetTime64_t(
+        date: *const ScePspDateTime,
+        time: *mut u64,
+    ) -> i32;
+    pub fn sceRtcSetDosTime(date: *mut ScePspDateTime, dos_time: u32) -> i32;
+    pub fn sceRtcGetDosTime(date: *mut ScePspDateTime, dos_time: u32) -> i32;
+    pub fn sceRtcSetWin32FileTime(
+        date: *mut ScePspDateTime,
+        time: *mut u64,
+    ) -> i32;
+    pub fn sceRtcGetWin32FileTime(
+        date: *mut ScePspDateTime,
+        time: *mut u64,
+    ) -> i32;
+    pub fn sceRtcParseDateTime(
+        dest_tick: *mut u64,
+        date_string: *const u8,
+    ) -> i32;
+    pub fn sceRtcFormatRFC3339(
+        psz_date_time: *mut char,
+        p_utc: *const u64,
+        time_zone_minutes: i32,
+    ) -> i32;
+    pub fn sceRtcFormatRFC3339LocalTime(
+        psz_date_time: *mut char,
+        p_utc: *const u64,
+    ) -> i32;
+    pub fn sceRtcParseRFC3339(
+        p_utc: *mut u64,
+        psz_date_time: *const u8,
+    ) -> i32;
+    pub fn sceRtcFormatRFC2822(
+        psz_date_time: *mut char,
+        p_utc: *const u64,
+        time_zone_minutes: i32,
+    ) -> i32;
+    pub fn sceRtcFormatRFC2822LocalTime(
+        psz_date_time: *mut char,
+        p_utc: *const u64,
+    ) -> i32;
+
+    pub fn sceIoOpen(
+        file: *const u8,
+        flags: i32,
+        permissions: IoPermissions,
+    ) -> SceUid;
+    pub fn sceIoOpenAsync(
+        file: *const u8,
+        flags: i32,
+        permissions: IoPermissions,
+    ) -> SceUid;
+    pub fn sceIoClose(fd: SceUid) -> i32;
+    pub fn sceIoCloseAsync(fd: SceUid) -> i32;
+    pub fn sceIoRead(fd: SceUid, data: *mut c_void, size: u32) -> i32;
+    pub fn sceIoReadAsync(fd: SceUid, data: *mut c_void, size: u32) -> i32;
+    pub fn sceIoWrite(fd: SceUid, data: *const c_void, size: usize) -> i32;
+    pub fn sceIoWriteAsync(fd: SceUid, data: *const c_void, size: u32) -> i32;
+    pub fn sceIoLseek(fd: SceUid, offset: i64, whence: IoWhence) -> i64;
+    pub fn sceIoLseekAsync(fd: SceUid, offset: i64, whence: IoWhence) -> i32;
+    pub fn sceIoLseek32(fd: SceUid, offset: i32, whence: IoWhence) -> i32;
+    pub fn sceIoLseek32Async(fd: SceUid, offset: i32, whence: IoWhence)
+        -> i32;
+    pub fn sceIoRemove(file: *const u8) -> i32;
+    pub fn sceIoMkdir(dir: *const u8, mode: IoPermissions) -> i32;
+    pub fn sceIoRmdir(path: *const u8) -> i32;
+    pub fn sceIoChdir(path: *const u8) -> i32;
+    pub fn sceIoRename(oldname: *const u8, newname: *const u8) -> i32;
+    pub fn sceIoDopen(dirname: *const u8) -> SceUid;
+    pub fn sceIoDread(fd: SceUid, dir: *mut SceIoDirent) -> i32;
+    pub fn sceIoDclose(fd: SceUid) -> i32;
+    pub fn sceIoDevctl(
+        dev: *const u8,
+        cmd: u32,
+        indata: *mut c_void,
+        inlen: i32,
+        outdata: *mut c_void,
+        outlen: i32,
+    ) -> i32;
+    pub fn sceIoAssign(
+        dev1: *const u8,
+        dev2: *const u8,
+        dev3: *const u8,
+        mode: IoAssignPerms,
+        unk1: *mut c_void,
+        unk2: i32,
+    ) -> i32;
+    pub fn sceIoUnassign(dev: *const u8) -> i32;
+    pub fn sceIoGetstat(file: *const u8, stat: *mut SceIoStat) -> i32;
+    pub fn sceIoChstat(
+        file: *const u8,
+        stat: *mut SceIoStat,
+        bits: i32,
+    ) -> i32;
+    pub fn sceIoIoctl(
+        fd: SceUid,
+        cmd: u32,
+        indata: *mut c_void,
+        inlen: i32,
+        outdata: *mut c_void,
+        outlen: i32,
+    ) -> i32;
+    pub fn sceIoIoctlAsync(
+        fd: SceUid,
+        cmd: u32,
+        indata: *mut c_void,
+        inlen: i32,
+        outdata: *mut c_void,
+        outlen: i32,
+    ) -> i32;
+    pub fn sceIoSync(device: *const u8, unk: u32) -> i32;
+    pub fn sceIoWaitAsync(fd: SceUid, res: *mut i64) -> i32;
+    pub fn sceIoWaitAsyncCB(fd: SceUid, res: *mut i64) -> i32;
+    pub fn sceIoPollAsync(fd: SceUid, res: *mut i64) -> i32;
+    pub fn sceIoGetAsyncStat(fd: SceUid, poll: i32, res: *mut i64) -> i32;
+    pub fn sceIoCancel(fd: SceUid) -> i32;
+    pub fn sceIoGetDevType(fd: SceUid) -> i32;
+    pub fn sceIoChangeAsyncPriority(fd: SceUid, pri: i32) -> i32;
+    pub fn sceIoSetAsyncCallback(
+        fd: SceUid,
+        cb: SceUid,
+        argp: *mut c_void,
+    ) -> i32;
+
+    pub fn sceJpegInitMJpeg() -> i32;
+    pub fn sceJpegFinishMJpeg() -> i32;
+    pub fn sceJpegCreateMJpeg(width: i32, height: i32) -> i32;
+    pub fn sceJpegDeleteMJpeg() -> i32;
+    pub fn sceJpegDecodeMJpeg(
+        jpeg_buf: *mut u8,
+        size: usize,
+        rgba: *mut c_void,
+        unk: u32,
+    ) -> i32;
+
+    pub fn sceUmdCheckMedium() -> i32;
+    pub fn sceUmdGetDiscInfo(info: *mut UmdInfo) -> i32;
+    pub fn sceUmdActivate(unit: i32, drive: *const u8) -> i32;
+    pub fn sceUmdDeactivate(unit: i32, drive: *const u8) -> i32;
+    pub fn sceUmdWaitDriveStat(state: i32) -> i32;
+    pub fn sceUmdWaitDriveStatWithTimer(state: i32, timeout: u32) -> i32;
+    pub fn sceUmdWaitDriveStatCB(state: i32, timeout: u32) -> i32;
+    pub fn sceUmdCancelWaitDriveStat() -> i32;
+    pub fn sceUmdGetDriveStat() -> i32;
+    pub fn sceUmdGetErrorStat() -> i32;
+    pub fn sceUmdRegisterUMDCallBack(cbid: i32) -> i32;
+    pub fn sceUmdUnRegisterUMDCallBack(cbid: i32) -> i32;
+    pub fn sceUmdReplacePermit() -> i32;
+    pub fn sceUmdReplaceProhibit() -> i32;
+
+    pub fn sceMpegInit() -> i32;
+    pub fn sceMpegFinish();
+    pub fn sceMpegRingbufferQueryMemSize(packets: i32) -> i32;
+    pub fn sceMpegRingbufferConstruct(
+        ringbuffer: *mut SceMpegRingbuffer,
+        packets: i32,
+        data: *mut c_void,
+        size: i32,
+        callback: SceMpegRingbufferCb,
+        cb_param: *mut c_void,
+    ) -> i32;
+    pub fn sceMpegRingbufferDestruct(ringbuffer: *mut SceMpegRingbuffer);
+    pub fn sceMpegRingbufferAvailableSize(
+        ringbuffer: *mut SceMpegRingbuffer,
+    ) -> i32;
+    pub fn sceMpegRingbufferPut(
+        ringbuffer: *mut SceMpegRingbuffer,
+        num_packets: i32,
+        available: i32,
+    ) -> i32;
+    pub fn sceMpegQueryMemSize(unk: i32) -> i32;
+    pub fn sceMpegCreate(
+        handle: SceMpeg,
+        data: *mut c_void,
+        size: i32,
+        ringbuffer: *mut SceMpegRingbuffer,
+        frame_width: i32,
+        unk1: i32,
+        unk2: i32,
+    ) -> i32;
+    pub fn sceMpegDelete(handle: SceMpeg);
+    pub fn sceMpegQueryStreamOffset(
+        handle: SceMpeg,
+        buffer: *mut c_void,
+        offset: *mut i32,
+    ) -> i32;
+    pub fn sceMpegQueryStreamSize(buffer: *mut c_void, size: *mut i32) -> i32;
+    pub fn sceMpegRegistStream(
+        handle: SceMpeg,
+        stream_id: i32,
+        unk: i32,
+    ) -> SceMpegStream;
+    pub fn sceMpegUnRegistStream(handle: SceMpeg, stream: SceMpegStream);
+    pub fn sceMpegFlushAllStream(handle: SceMpeg) -> i32;
+    pub fn sceMpegMallocAvcEsBuf(handle: SceMpeg) -> *mut c_void;
+    pub fn sceMpegFreeAvcEsBuf(handle: SceMpeg, buf: *mut c_void);
+    pub fn sceMpegQueryAtracEsSize(
+        handle: SceMpeg,
+        es_size: *mut i32,
+        out_size: *mut i32,
+    ) -> i32;
+    pub fn sceMpegInitAu(
+        handle: SceMpeg,
+        es_buffer: *mut c_void,
+        au: *mut SceMpegAu,
+    ) -> i32;
+    pub fn sceMpegGetAvcAu(
+        handle: SceMpeg,
+        stream: SceMpegStream,
+        au: *mut SceMpegAu,
+        unk: *mut i32,
+    ) -> i32;
+    pub fn sceMpegAvcDecodeMode(
+        handle: SceMpeg,
+        mode: *mut SceMpegAvcMode,
+    ) -> i32;
+    pub fn sceMpegAvcDecode(
+        handle: SceMpeg,
+        au: *mut SceMpegAu,
+        iframe_width: i32,
+        buffer: *mut c_void,
+        init: *mut i32,
+    ) -> i32;
+    pub fn sceMpegAvcDecodeStop(
+        handle: SceMpeg,
+        frame_width: i32,
+        buffer: *mut c_void,
+        status: *mut i32,
+    ) -> i32;
+    pub fn sceMpegGetAtracAu(
+        handle: SceMpeg,
+        stream: SceMpegStream,
+        au: *mut SceMpegAu,
+        unk: *mut c_void,
+    ) -> i32;
+    pub fn sceMpegAtracDecode(
+        handle: SceMpeg,
+        au: *mut SceMpegAu,
+        buffer: *mut c_void,
+        init: i32,
+    ) -> i32;
+
+    pub fn sceMpegBaseYCrCbCopyVme(
+        yuv_buffer: *mut c_void,
+        buffer: *mut i32,
+        type_: i32,
+    ) -> i32;
+    pub fn sceMpegBaseCscInit(width: i32) -> i32;
+    pub fn sceMpegBaseCscVme(
+        rgb_buffer: *mut c_void,
+        rgb_buffer2: *mut c_void,
+        width: i32,
+        y_cr_cb_buffer: *mut SceMpegYCrCbBuffer,
+    ) -> i32;
+    pub fn sceMpegbase_BEA18F91(lli: *mut SceMpegLLI) -> i32;
+
+    pub fn sceHprmPeekCurrentKey(key: *mut i32) -> i32;
+    pub fn sceHprmPeekLatch(latch: *mut [u32; 4]) -> i32;
+    pub fn sceHprmReadLatch(latch: *mut [u32; 4]) -> i32;
+    pub fn sceHprmIsHeadphoneExist() -> i32;
+    pub fn sceHprmIsRemoteExist() -> i32;
+    pub fn sceHprmIsMicrophoneExist() -> i32;
+
+    pub fn sceGuDepthBuffer(zbp: *mut c_void, zbw: i32);
+    pub fn sceGuDispBuffer(
+        width: i32,
+        height: i32,
+        dispbp: *mut c_void,
+        dispbw: i32,
+    );
+    pub fn sceGuDrawBuffer(
+        psm: DisplayPixelFormat,
+        fbp: *mut c_void,
+        fbw: i32,
+    );
+    pub fn sceGuDrawBufferList(
+        psm: DisplayPixelFormat,
+        fbp: *mut c_void,
+        fbw: i32,
+    );
+    pub fn sceGuDisplay(state: bool) -> bool;
+    pub fn sceGuDepthFunc(function: DepthFunc);
+    pub fn sceGuDepthMask(mask: i32);
+    pub fn sceGuDepthOffset(offset: i32);
+    pub fn sceGuDepthRange(near: i32, far: i32);
+    pub fn sceGuFog(near: f32, far: f32, color: u32);
+    pub fn sceGuInit();
+    pub fn sceGuTerm();
+    pub fn sceGuBreak(mode: i32);
+    pub fn sceGuContinue();
+    pub fn sceGuSetCallback(
+        signal: GuCallbackId,
+        callback: GuCallback,
+    ) -> GuCallback;
+    pub fn sceGuSignal(behavior: SignalBehavior, signal: i32);
+    pub fn sceGuSendCommandf(cmd: GeCommand, argument: f32);
+    pub fn sceGuSendCommandi(cmd: GeCommand, argument: i32);
+    pub fn sceGuGetMemory(size: i32) -> *mut c_void;
+    pub fn sceGuStart(context_type: GuContextType, list: *mut c_void);
+    pub fn sceGuFinish() -> i32;
+    pub fn sceGuFinishId(id: u32) -> i32;
+    pub fn sceGuCallList(list: *const c_void);
+    pub fn sceGuCallMode(mode: i32);
+    pub fn sceGuCheckList() -> i32;
+    pub fn sceGuSendList(
+        mode: GuQueueMode,
+        list: *const c_void,
+        context: *mut GeContext,
+    );
+    pub fn sceGuSwapBuffers() -> *mut c_void;
+    pub fn sceGuSync(
+        mode: GuSyncMode,
+        behavior: GuSyncBehavior,
+    ) -> GeListState;
+    pub fn sceGuDrawArray(
+        prim: GuPrimitive,
+        vtype: i32,
+        count: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+    pub fn sceGuBeginObject(
+        vtype: i32,
+        count: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+    pub fn sceGuEndObject();
+    pub fn sceGuSetStatus(state: GuState, status: i32);
+    pub fn sceGuGetStatus(state: GuState) -> bool;
+    pub fn sceGuSetAllStatus(status: i32);
+    pub fn sceGuGetAllStatus() -> i32;
+    pub fn sceGuEnable(state: GuState);
+    pub fn sceGuDisable(state: GuState);
+    pub fn sceGuLight(
+        light: i32,
+        type_: LightType,
+        components: i32,
+        position: &ScePspFVector3,
+    );
+    pub fn sceGuLightAtt(light: i32, atten0: f32, atten1: f32, atten2: f32);
+    pub fn sceGuLightColor(light: i32, component: i32, color: u32);
+    pub fn sceGuLightMode(mode: LightMode);
+    pub fn sceGuLightSpot(
+        light: i32,
+        direction: &ScePspFVector3,
+        exponent: f32,
+        cutoff: f32,
+    );
+    pub fn sceGuClear(flags: i32);
+    pub fn sceGuClearColor(color: u32);
+    pub fn sceGuClearDepth(depth: u32);
+    pub fn sceGuClearStencil(stencil: u32);
+    pub fn sceGuPixelMask(mask: u32);
+    pub fn sceGuColor(color: u32);
+    pub fn sceGuColorFunc(func: ColorFunc, color: u32, mask: u32);
+    pub fn sceGuColorMaterial(components: i32);
+    pub fn sceGuAlphaFunc(func: AlphaFunc, value: i32, mask: i32);
+    pub fn sceGuAmbient(color: u32);
+    pub fn sceGuAmbientColor(color: u32);
+    pub fn sceGuBlendFunc(
+        op: BlendOp,
+        src: BlendSrc,
+        dest: BlendDst,
+        src_fix: u32,
+        dest_fix: u32,
+    );
+    pub fn sceGuMaterial(components: i32, color: u32);
+    pub fn sceGuModelColor(
+        emissive: u32,
+        ambient: u32,
+        diffuse: u32,
+        specular: u32,
+    );
+    pub fn sceGuStencilFunc(func: StencilFunc, ref_: i32, mask: i32);
+    pub fn sceGuStencilOp(
+        fail: StencilOperation,
+        zfail: StencilOperation,
+        zpass: StencilOperation,
+    );
+    pub fn sceGuSpecular(power: f32);
+    pub fn sceGuFrontFace(order: FrontFaceDirection);
+    pub fn sceGuLogicalOp(op: LogicalOperation);
+    pub fn sceGuSetDither(matrix: &ScePspIMatrix4);
+    pub fn sceGuShadeModel(mode: ShadingModel);
+    pub fn sceGuCopyImage(
+        psm: DisplayPixelFormat,
+        sx: i32,
+        sy: i32,
+        width: i32,
+        height: i32,
+        srcw: i32,
+        src: *mut c_void,
+        dx: i32,
+        dy: i32,
+        destw: i32,
+        dest: *mut c_void,
+    );
+    pub fn sceGuTexEnvColor(color: u32);
+    pub fn sceGuTexFilter(min: TextureFilter, mag: TextureFilter);
+    pub fn sceGuTexFlush();
+    pub fn sceGuTexFunc(tfx: TextureEffect, tcc: TextureColorComponent);
+    pub fn sceGuTexImage(
+        mipmap: MipmapLevel,
+        width: i32,
+        height: i32,
+        tbw: i32,
+        tbp: *const c_void,
+    );
+    pub fn sceGuTexLevelMode(mode: TextureLevelMode, bias: f32);
+    pub fn sceGuTexMapMode(mode: TextureMapMode, a1: u32, a2: u32);
+    pub fn sceGuTexMode(
+        tpsm: TexturePixelFormat,
+        maxmips: i32,
+        a2: i32,
+        swizzle: i32,
+    );
+    pub fn sceGuTexOffset(u: f32, v: f32);
+    pub fn sceGuTexProjMapMode(mode: TextureProjectionMapMode);
+    pub fn sceGuTexScale(u: f32, v: f32);
+    pub fn sceGuTexSlope(slope: f32);
+    pub fn sceGuTexSync();
+    pub fn sceGuTexWrap(u: GuTexWrapMode, v: GuTexWrapMode);
+    pub fn sceGuClutLoad(num_blocks: i32, cbp: *const c_void);
+    pub fn sceGuClutMode(
+        cpsm: ClutPixelFormat,
+        shift: u32,
+        mask: u32,
+        a3: u32,
+    );
+    pub fn sceGuOffset(x: u32, y: u32);
+    pub fn sceGuScissor(x: i32, y: i32, w: i32, h: i32);
+    pub fn sceGuViewport(cx: i32, cy: i32, width: i32, height: i32);
+    pub fn sceGuDrawBezier(
+        v_type: i32,
+        u_count: i32,
+        v_count: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+    pub fn sceGuPatchDivide(ulevel: u32, vlevel: u32);
+    pub fn sceGuPatchFrontFace(a0: u32);
+    pub fn sceGuPatchPrim(prim: PatchPrimitive);
+    pub fn sceGuDrawSpline(
+        v_type: i32,
+        u_count: i32,
+        v_count: i32,
+        u_edge: i32,
+        v_edge: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+    pub fn sceGuSetMatrix(type_: MatrixMode, matrix: &ScePspFMatrix4);
+    pub fn sceGuBoneMatrix(index: u32, matrix: &ScePspFMatrix4);
+    pub fn sceGuMorphWeight(index: i32, weight: f32);
+    pub fn sceGuDrawArrayN(
+        primitive_type: GuPrimitive,
+        v_type: i32,
+        count: i32,
+        a3: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+
+    pub fn sceGumDrawArray(
+        prim: GuPrimitive,
+        v_type: i32,
+        count: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+    pub fn sceGumDrawArrayN(
+        prim: GuPrimitive,
+        v_type: i32,
+        count: i32,
+        a3: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+    pub fn sceGumDrawBezier(
+        v_type: i32,
+        u_count: i32,
+        v_count: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+    pub fn sceGumDrawSpline(
+        v_type: i32,
+        u_count: i32,
+        v_count: i32,
+        u_edge: i32,
+        v_edge: i32,
+        indices: *const c_void,
+        vertices: *const c_void,
+    );
+    pub fn sceGumFastInverse();
+    pub fn sceGumFullInverse();
+    pub fn sceGumLoadIdentity();
+    pub fn sceGumLoadMatrix(m: &ScePspFMatrix4);
+    pub fn sceGumLookAt(
+        eye: &ScePspFVector3,
+        center: &ScePspFVector3,
+        up: &ScePspFVector3,
+    );
+    pub fn sceGumMatrixMode(mode: MatrixMode);
+    pub fn sceGumMultMatrix(m: &ScePspFMatrix4);
+    pub fn sceGumOrtho(
+        left: f32,
+        right: f32,
+        bottom: f32,
+        top: f32,
+        near: f32,
+        far: f32,
+    );
+    pub fn sceGumPerspective(fovy: f32, aspect: f32, near: f32, far: f32);
+    pub fn sceGumPopMatrix();
+    pub fn sceGumPushMatrix();
+    pub fn sceGumRotateX(angle: f32);
+    pub fn sceGumRotateY(angle: f32);
+    pub fn sceGumRotateZ(angle: f32);
+    pub fn sceGumRotateXYZ(v: &ScePspFVector3);
+    pub fn sceGumRotateZYX(v: &ScePspFVector3);
+    pub fn sceGumScale(v: &ScePspFVector3);
+    pub fn sceGumStoreMatrix(m: &mut ScePspFMatrix4);
+    pub fn sceGumTranslate(v: &ScePspFVector3);
+    pub fn sceGumUpdateMatrix();
+
+    pub fn sceMp3ReserveMp3Handle(args: *mut SceMp3InitArg) -> i32;
+    pub fn sceMp3ReleaseMp3Handle(handle: Mp3Handle) -> i32;
+    pub fn sceMp3InitResource() -> i32;
+    pub fn sceMp3TermResource() -> i32;
+    pub fn sceMp3Init(handle: Mp3Handle) -> i32;
+    pub fn sceMp3Decode(handle: Mp3Handle, dst: *mut *mut i16) -> i32;
+    pub fn sceMp3GetInfoToAddStreamData(
+        handle: Mp3Handle,
+        dst: *mut *mut u8,
+        to_write: *mut i32,
+        src_pos: *mut i32,
+    ) -> i32;
+    pub fn sceMp3NotifyAddStreamData(handle: Mp3Handle, size: i32) -> i32;
+    pub fn sceMp3CheckStreamDataNeeded(handle: Mp3Handle) -> i32;
+    pub fn sceMp3SetLoopNum(handle: Mp3Handle, loop_: i32) -> i32;
+    pub fn sceMp3GetLoopNum(handle: Mp3Handle) -> i32;
+    pub fn sceMp3GetSumDecodedSample(handle: Mp3Handle) -> i32;
+    pub fn sceMp3GetMaxOutputSample(handle: Mp3Handle) -> i32;
+    pub fn sceMp3GetSamplingRate(handle: Mp3Handle) -> i32;
+    pub fn sceMp3GetBitRate(handle: Mp3Handle) -> i32;
+    pub fn sceMp3GetMp3ChannelNum(handle: Mp3Handle) -> i32;
+    pub fn sceMp3ResetPlayPosition(handle: Mp3Handle) -> i32;
+
+    pub fn sceRegOpenRegistry(
+        reg: *mut Key,
+        mode: i32,
+        handle: *mut RegHandle,
+    ) -> i32;
+    pub fn sceRegFlushRegistry(handle: RegHandle) -> i32;
+    pub fn sceRegCloseRegistry(handle: RegHandle) -> i32;
+    pub fn sceRegOpenCategory(
+        handle: RegHandle,
+        name: *const u8,
+        mode: i32,
+        dir_handle: *mut RegHandle,
+    ) -> i32;
+    pub fn sceRegRemoveCategory(handle: RegHandle, name: *const u8) -> i32;
+    pub fn sceRegCloseCategory(dir_handle: RegHandle) -> i32;
+    pub fn sceRegFlushCategory(dir_handle: RegHandle) -> i32;
+    pub fn sceRegGetKeyInfo(
+        dir_handle: RegHandle,
+        name: *const u8,
+        key_handle: *mut RegHandle,
+        type_: *mut KeyType,
+        size: *mut usize,
+    ) -> i32;
+    pub fn sceRegGetKeyInfoByName(
+        dir_handle: RegHandle,
+        name: *const u8,
+        type_: *mut KeyType,
+        size: *mut usize,
+    ) -> i32;
+    pub fn sceRegGetKeyValue(
+        dir_handle: RegHandle,
+        key_handle: RegHandle,
+        buf: *mut c_void,
+        size: usize,
+    ) -> i32;
+    pub fn sceRegGetKeyValueByName(
+        dir_handle: RegHandle,
+        name: *const u8,
+        buf: *mut c_void,
+        size: usize,
+    ) -> i32;
+    pub fn sceRegSetKeyValue(
+        dir_handle: RegHandle,
+        name: *const u8,
+        buf: *const c_void,
+        size: usize,
+    ) -> i32;
+    pub fn sceRegGetKeysNum(dir_handle: RegHandle, num: *mut i32) -> i32;
+    pub fn sceRegGetKeys(dir_handle: RegHandle, buf: *mut u8, num: i32)
+        -> i32;
+    pub fn sceRegCreateKey(
+        dir_handle: RegHandle,
+        name: *const u8,
+        type_: i32,
+        size: usize,
+    ) -> i32;
+    pub fn sceRegRemoveRegistry(key: *mut Key) -> i32;
+
+    pub fn sceOpenPSIDGetOpenPSID(openpsid: *mut OpenPSID) -> i32;
+
+    pub fn sceUtilityMsgDialogInitStart(
+        params: *mut UtilityMsgDialogParams,
+    ) -> i32;
+    pub fn sceUtilityMsgDialogShutdownStart();
+    pub fn sceUtilityMsgDialogGetStatus() -> i32;
+    pub fn sceUtilityMsgDialogUpdate(n: i32);
+    pub fn sceUtilityMsgDialogAbort() -> i32;
+    pub fn sceUtilityNetconfInitStart(data: *mut UtilityNetconfData) -> i32;
+    pub fn sceUtilityNetconfShutdownStart() -> i32;
+    pub fn sceUtilityNetconfUpdate(unknown: i32) -> i32;
+    pub fn sceUtilityNetconfGetStatus() -> i32;
+    pub fn sceUtilityCheckNetParam(id: i32) -> i32;
+    pub fn sceUtilityGetNetParam(
+        conf: i32,
+        param: NetParam,
+        data: *mut UtilityNetData,
+    ) -> i32;
+    pub fn sceUtilitySavedataInitStart(
+        params: *mut SceUtilitySavedataParam,
+    ) -> i32;
+    pub fn sceUtilitySavedataGetStatus() -> i32;
+    pub fn sceUtilitySavedataShutdownStart() -> i32;
+    pub fn sceUtilitySavedataUpdate(unknown: i32);
+    pub fn sceUtilityGameSharingInitStart(
+        params: *mut UtilityGameSharingParams,
+    ) -> i32;
+    pub fn sceUtilityGameSharingShutdownStart();
+    pub fn sceUtilityGameSharingGetStatus() -> i32;
+    pub fn sceUtilityGameSharingUpdate(n: i32);
+    pub fn sceUtilityHtmlViewerInitStart(
+        params: *mut UtilityHtmlViewerParam,
+    ) -> i32;
+    pub fn sceUtilityHtmlViewerShutdownStart() -> i32;
+    pub fn sceUtilityHtmlViewerUpdate(n: i32) -> i32;
+    pub fn sceUtilityHtmlViewerGetStatus() -> i32;
+    pub fn sceUtilitySetSystemParamInt(id: SystemParamId, value: i32) -> i32;
+    pub fn sceUtilitySetSystemParamString(
+        id: SystemParamId,
+        str: *const u8,
+    ) -> i32;
+    pub fn sceUtilityGetSystemParamInt(
+        id: SystemParamId,
+        value: *mut i32,
+    ) -> i32;
+    pub fn sceUtilityGetSystemParamString(
+        id: SystemParamId,
+        str: *mut u8,
+        len: i32,
+    ) -> i32;
+    pub fn sceUtilityOskInitStart(params: *mut SceUtilityOskParams) -> i32;
+    pub fn sceUtilityOskShutdownStart() -> i32;
+    pub fn sceUtilityOskUpdate(n: i32) -> i32;
+    pub fn sceUtilityOskGetStatus() -> i32;
+    pub fn sceUtilityLoadNetModule(module: NetModule) -> i32;
+    pub fn sceUtilityUnloadNetModule(module: NetModule) -> i32;
+    pub fn sceUtilityLoadAvModule(module: AvModule) -> i32;
+    pub fn sceUtilityUnloadAvModule(module: AvModule) -> i32;
+    pub fn sceUtilityLoadUsbModule(module: UsbModule) -> i32;
+    pub fn sceUtilityUnloadUsbModule(module: UsbModule) -> i32;
+    pub fn sceUtilityLoadModule(module: Module) -> i32;
+    pub fn sceUtilityUnloadModule(module: Module) -> i32;
+    pub fn sceUtilityCreateNetParam(conf: i32) -> i32;
+    pub fn sceUtilitySetNetParam(param: NetParam, val: *const c_void) -> i32;
+    pub fn sceUtilityCopyNetParam(src: i32, dest: i32) -> i32;
+    pub fn sceUtilityDeleteNetParam(conf: i32) -> i32;
+
+    pub fn sceNetInit(
+        poolsize: i32,
+        calloutprio: i32,
+        calloutstack: i32,
+        netintrprio: i32,
+        netintrstack: i32,
+    ) -> i32;
+    pub fn sceNetTerm() -> i32;
+    pub fn sceNetFreeThreadinfo(thid: i32) -> i32;
+    pub fn sceNetThreadAbort(thid: i32) -> i32;
+    pub fn sceNetEtherStrton(name: *mut u8, mac: *mut u8);
+    pub fn sceNetEtherNtostr(mac: *mut u8, name: *mut u8);
+    pub fn sceNetGetLocalEtherAddr(mac: *mut u8) -> i32;
+    pub fn sceNetGetMallocStat(stat: *mut SceNetMallocStat) -> i32;
+
+    pub fn sceNetAdhocctlInit(
+        stacksize: i32,
+        priority: i32,
+        adhoc_id: *mut SceNetAdhocctlAdhocId,
+    ) -> i32;
+    pub fn sceNetAdhocctlTerm() -> i32;
+    pub fn sceNetAdhocctlConnect(name: *const u8) -> i32;
+    pub fn sceNetAdhocctlDisconnect() -> i32;
+    pub fn sceNetAdhocctlGetState(event: *mut i32) -> i32;
+    pub fn sceNetAdhocctlCreate(name: *const u8) -> i32;
+    pub fn sceNetAdhocctlJoin(scaninfo: *mut SceNetAdhocctlScanInfo) -> i32;
+    pub fn sceNetAdhocctlGetAdhocId(id: *mut SceNetAdhocctlAdhocId) -> i32;
+    pub fn sceNetAdhocctlCreateEnterGameMode(
+        name: *const u8,
+        unknown: i32,
+        num: i32,
+        macs: *mut u8,
+        timeout: u32,
+        unknown2: i32,
+    ) -> i32;
+    pub fn sceNetAdhocctlJoinEnterGameMode(
+        name: *const u8,
+        hostmac: *mut u8,
+        timeout: u32,
+        unknown: i32,
+    ) -> i32;
+    pub fn sceNetAdhocctlGetGameModeInfo(
+        gamemodeinfo: *mut SceNetAdhocctlGameModeInfo,
+    ) -> i32;
+    pub fn sceNetAdhocctlExitGameMode() -> i32;
+    pub fn sceNetAdhocctlGetPeerList(
+        length: *mut i32,
+        buf: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocctlGetPeerInfo(
+        mac: *mut u8,
+        size: i32,
+        peerinfo: *mut SceNetAdhocctlPeerInfo,
+    ) -> i32;
+    pub fn sceNetAdhocctlScan() -> i32;
+    pub fn sceNetAdhocctlGetScanInfo(
+        length: *mut i32,
+        buf: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocctlAddHandler(
+        handler: SceNetAdhocctlHandler,
+        unknown: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocctlDelHandler(id: i32) -> i32;
+    pub fn sceNetAdhocctlGetNameByAddr(mac: *mut u8, nickname: *mut u8)
+        -> i32;
+    pub fn sceNetAdhocctlGetAddrByName(
+        nickname: *mut u8,
+        length: *mut i32,
+        buf: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocctlGetParameter(
+        params: *mut SceNetAdhocctlParams,
+    ) -> i32;
+
+    pub fn sceNetAdhocInit() -> i32;
+    pub fn sceNetAdhocTerm() -> i32;
+    pub fn sceNetAdhocPdpCreate(
+        mac: *mut u8,
+        port: u16,
+        buf_size: u32,
+        unk1: i32,
+    ) -> i32;
+    pub fn sceNetAdhocPdpDelete(id: i32, unk1: i32) -> i32;
+    pub fn sceNetAdhocPdpSend(
+        id: i32,
+        dest_mac_addr: *mut u8,
+        port: u16,
+        data: *mut c_void,
+        len: u32,
+        timeout: u32,
+        nonblock: i32,
+    ) -> i32;
+    pub fn sceNetAdhocPdpRecv(
+        id: i32,
+        src_mac_addr: *mut u8,
+        port: *mut u16,
+        data: *mut c_void,
+        data_length: *mut c_void,
+        timeout: u32,
+        nonblock: i32,
+    ) -> i32;
+    pub fn sceNetAdhocGetPdpStat(
+        size: *mut i32,
+        stat: *mut SceNetAdhocPdpStat,
+    ) -> i32;
+    pub fn sceNetAdhocGameModeCreateMaster(
+        data: *mut c_void,
+        size: i32,
+    ) -> i32;
+    pub fn sceNetAdhocGameModeCreateReplica(
+        mac: *mut u8,
+        data: *mut c_void,
+        size: i32,
+    ) -> i32;
+    pub fn sceNetAdhocGameModeUpdateMaster() -> i32;
+    pub fn sceNetAdhocGameModeUpdateReplica(id: i32, unk1: i32) -> i32;
+    pub fn sceNetAdhocGameModeDeleteMaster() -> i32;
+    pub fn sceNetAdhocGameModeDeleteReplica(id: i32) -> i32;
+    pub fn sceNetAdhocPtpOpen(
+        srcmac: *mut u8,
+        srcport: u16,
+        destmac: *mut u8,
+        destport: u16,
+        buf_size: u32,
+        delay: u32,
+        count: i32,
+        unk1: i32,
+    ) -> i32;
+    pub fn sceNetAdhocPtpConnect(id: i32, timeout: u32, nonblock: i32) -> i32;
+    pub fn sceNetAdhocPtpListen(
+        srcmac: *mut u8,
+        srcport: u16,
+        buf_size: u32,
+        delay: u32,
+        count: i32,
+        queue: i32,
+        unk1: i32,
+    ) -> i32;
+    pub fn sceNetAdhocPtpAccept(
+        id: i32,
+        mac: *mut u8,
+        port: *mut u16,
+        timeout: u32,
+        nonblock: i32,
+    ) -> i32;
+    pub fn sceNetAdhocPtpSend(
+        id: i32,
+        data: *mut c_void,
+        data_size: *mut i32,
+        timeout: u32,
+        nonblock: i32,
+    ) -> i32;
+    pub fn sceNetAdhocPtpRecv(
+        id: i32,
+        data: *mut c_void,
+        data_size: *mut i32,
+        timeout: u32,
+        nonblock: i32,
+    ) -> i32;
+    pub fn sceNetAdhocPtpFlush(id: i32, timeout: u32, nonblock: i32) -> i32;
+    pub fn sceNetAdhocPtpClose(id: i32, unk1: i32) -> i32;
+    pub fn sceNetAdhocGetPtpStat(
+        size: *mut i32,
+        stat: *mut SceNetAdhocPtpStat,
+    ) -> i32;
+}
+
+extern "C" {
+    pub fn sceNetAdhocMatchingInit(memsize: i32) -> i32;
+    pub fn sceNetAdhocMatchingTerm() -> i32;
+    pub fn sceNetAdhocMatchingCreate(
+        mode: AdhocMatchingMode,
+        max_peers: i32,
+        port: u16,
+        buf_size: i32,
+        hello_delay: u32,
+        ping_delay: u32,
+        init_count: i32,
+        msg_delay: u32,
+        callback: AdhocMatchingCallback,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingDelete(matching_id: i32) -> i32;
+    pub fn sceNetAdhocMatchingStart(
+        matching_id: i32,
+        evth_pri: i32,
+        evth_stack: i32,
+        inth_pri: i32,
+        inth_stack: i32,
+        opt_len: i32,
+        opt_data: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingStop(matching_id: i32) -> i32;
+    pub fn sceNetAdhocMatchingSelectTarget(
+        matching_id: i32,
+        mac: *mut u8,
+        opt_len: i32,
+        opt_data: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingCancelTarget(
+        matching_id: i32,
+        mac: *mut u8,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingCancelTargetWithOpt(
+        matching_id: i32,
+        mac: *mut u8,
+        opt_len: i32,
+        opt_data: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingSendData(
+        matching_id: i32,
+        mac: *mut u8,
+        data_len: i32,
+        data: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingAbortSendData(
+        matching_id: i32,
+        mac: *mut u8,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingSetHelloOpt(
+        matching_id: i32,
+        opt_len: i32,
+        opt_data: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingGetHelloOpt(
+        matching_id: i32,
+        opt_len: *mut i32,
+        opt_data: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingGetMembers(
+        matching_id: i32,
+        length: *mut i32,
+        buf: *mut c_void,
+    ) -> i32;
+    pub fn sceNetAdhocMatchingGetPoolMaxAlloc() -> i32;
+    pub fn sceNetAdhocMatchingGetPoolStat(poolstat: *mut AdhocPoolStat)
+        -> i32;
+}
+
+extern "C" {
+    pub fn sceNetApctlInit(stack_size: i32, init_priority: i32) -> i32;
+    pub fn sceNetApctlTerm() -> i32;
+    pub fn sceNetApctlGetInfo(
+        code: ApctlInfo,
+        pinfo: *mut SceNetApctlInfo,
+    ) -> i32;
+    pub fn sceNetApctlAddHandler(
+        handler: SceNetApctlHandler,
+        parg: *mut c_void,
+    ) -> i32;
+    pub fn sceNetApctlDelHandler(handler_id: i32) -> i32;
+    pub fn sceNetApctlConnect(conn_index: i32) -> i32;
+    pub fn sceNetApctlDisconnect() -> i32;
+    pub fn sceNetApctlGetState(pstate: *mut ApctlState) -> i32;
+
+    pub fn sceNetInetInit() -> i32;
+    pub fn sceNetInetTerm() -> i32;
+    pub fn sceNetInetAccept(
+        s: i32,
+        addr: *mut sockaddr,
+        addr_len: *mut socklen_t,
+    ) -> i32;
+    pub fn sceNetInetBind(
+        s: i32,
+        my_addr: *const sockaddr,
+        addr_len: socklen_t,
+    ) -> i32;
+    pub fn sceNetInetConnect(
+        s: i32,
+        serv_addr: *const sockaddr,
+        addr_len: socklen_t,
+    ) -> i32;
+    pub fn sceNetInetGetsockopt(
+        s: i32,
+        level: i32,
+        opt_name: i32,
+        opt_val: *mut c_void,
+        optl_en: *mut socklen_t,
+    ) -> i32;
+    pub fn sceNetInetListen(s: i32, backlog: i32) -> i32;
+    pub fn sceNetInetRecv(
+        s: i32,
+        buf: *mut c_void,
+        len: usize,
+        flags: i32,
+    ) -> usize;
+    pub fn sceNetInetRecvfrom(
+        s: i32,
+        buf: *mut c_void,
+        flags: usize,
+        arg1: i32,
+        from: *mut sockaddr,
+        from_len: *mut socklen_t,
+    ) -> usize;
+    pub fn sceNetInetSend(
+        s: i32,
+        buf: *const c_void,
+        len: usize,
+        flags: i32,
+    ) -> usize;
+    pub fn sceNetInetSendto(
+        s: i32,
+        buf: *const c_void,
+        len: usize,
+        flags: i32,
+        to: *const sockaddr,
+        to_len: socklen_t,
+    ) -> usize;
+    pub fn sceNetInetSetsockopt(
+        s: i32,
+        level: i32,
+        opt_name: i32,
+        opt_val: *const c_void,
+        opt_len: socklen_t,
+    ) -> i32;
+    pub fn sceNetInetShutdown(s: i32, how: i32) -> i32;
+    pub fn sceNetInetSocket(domain: i32, type_: i32, protocol: i32) -> i32;
+    pub fn sceNetInetClose(s: i32) -> i32;
+    pub fn sceNetInetGetErrno() -> i32;
+
+    pub fn sceSslInit(unknown1: i32) -> i32;
+    pub fn sceSslEnd() -> i32;
+    pub fn sceSslGetUsedMemoryMax(memory: *mut u32) -> i32;
+    pub fn sceSslGetUsedMemoryCurrent(memory: *mut u32) -> i32;
+
+    pub fn sceHttpInit(unknown1: u32) -> i32;
+    pub fn sceHttpEnd() -> i32;
+    pub fn sceHttpCreateTemplate(
+        agent: *mut u8,
+        unknown1: i32,
+        unknown2: i32,
+    ) -> i32;
+    pub fn sceHttpDeleteTemplate(templateid: i32) -> i32;
+    pub fn sceHttpCreateConnection(
+        templateid: i32,
+        host: *mut u8,
+        unknown1: *mut u8,
+        port: u16,
+        unknown2: i32,
+    ) -> i32;
+    pub fn sceHttpCreateConnectionWithURL(
+        templateid: i32,
+        url: *const u8,
+        unknown1: i32,
+    ) -> i32;
+    pub fn sceHttpDeleteConnection(connection_id: i32) -> i32;
+    pub fn sceHttpCreateRequest(
+        connection_id: i32,
+        method: HttpMethod,
+        path: *mut u8,
+        content_length: u64,
+    ) -> i32;
+    pub fn sceHttpCreateRequestWithURL(
+        connection_id: i32,
+        method: HttpMethod,
+        url: *mut u8,
+        content_length: u64,
+    ) -> i32;
+    pub fn sceHttpDeleteRequest(request_id: i32) -> i32;
+    pub fn sceHttpSendRequest(
+        request_id: i32,
+        data: *mut c_void,
+        data_size: u32,
+    ) -> i32;
+    pub fn sceHttpAbortRequest(request_id: i32) -> i32;
+    pub fn sceHttpReadData(
+        request_id: i32,
+        data: *mut c_void,
+        data_size: u32,
+    ) -> i32;
+    pub fn sceHttpGetContentLength(
+        request_id: i32,
+        content_length: *mut u64,
+    ) -> i32;
+    pub fn sceHttpGetStatusCode(request_id: i32, status_code: *mut i32)
+        -> i32;
+    pub fn sceHttpSetResolveTimeOut(id: i32, timeout: u32) -> i32;
+    pub fn sceHttpSetResolveRetry(id: i32, count: i32) -> i32;
+    pub fn sceHttpSetConnectTimeOut(id: i32, timeout: u32) -> i32;
+    pub fn sceHttpSetSendTimeOut(id: i32, timeout: u32) -> i32;
+    pub fn sceHttpSetRecvTimeOut(id: i32, timeout: u32) -> i32;
+    pub fn sceHttpEnableKeepAlive(id: i32) -> i32;
+    pub fn sceHttpDisableKeepAlive(id: i32) -> i32;
+    pub fn sceHttpEnableRedirect(id: i32) -> i32;
+    pub fn sceHttpDisableRedirect(id: i32) -> i32;
+    pub fn sceHttpEnableCookie(id: i32) -> i32;
+    pub fn sceHttpDisableCookie(id: i32) -> i32;
+    pub fn sceHttpSaveSystemCookie() -> i32;
+    pub fn sceHttpLoadSystemCookie() -> i32;
+    pub fn sceHttpAddExtraHeader(
+        id: i32,
+        name: *mut u8,
+        value: *mut u8,
+        unknown1: i32,
+    ) -> i32;
+    pub fn sceHttpDeleteHeader(id: i32, name: *const u8) -> i32;
+    pub fn sceHttpsInit(
+        unknown1: i32,
+        unknown2: i32,
+        unknown3: i32,
+        unknown4: i32,
+    ) -> i32;
+    pub fn sceHttpsEnd() -> i32;
+    pub fn sceHttpsLoadDefaultCert(unknown1: i32, unknown2: i32) -> i32;
+    pub fn sceHttpDisableAuth(id: i32) -> i32;
+    pub fn sceHttpDisableCache(id: i32) -> i32;
+    pub fn sceHttpEnableAuth(id: i32) -> i32;
+    pub fn sceHttpEnableCache(id: i32) -> i32;
+    pub fn sceHttpEndCache() -> i32;
+    pub fn sceHttpGetAllHeader(
+        request: i32,
+        header: *mut *mut u8,
+        header_size: *mut u32,
+    ) -> i32;
+    pub fn sceHttpGetNetworkErrno(request: i32, err_num: *mut i32) -> i32;
+    pub fn sceHttpGetProxy(
+        id: i32,
+        activate_flag: *mut i32,
+        mode: *mut i32,
+        proxy_host: *mut u8,
+        len: usize,
+        proxy_port: *mut u16,
+    ) -> i32;
+    pub fn sceHttpInitCache(max_size: usize) -> i32;
+    pub fn sceHttpSetAuthInfoCB(id: i32, cbfunc: HttpPasswordCB) -> i32;
+    pub fn sceHttpSetProxy(
+        id: i32,
+        activate_flag: i32,
+        mode: i32,
+        new_proxy_host: *const u8,
+        new_proxy_port: u16,
+    ) -> i32;
+    pub fn sceHttpSetResHeaderMaxSize(id: i32, header_size: u32) -> i32;
+    pub fn sceHttpSetMallocFunction(
+        malloc_func: HttpMallocFunction,
+        free_func: HttpFreeFunction,
+        realloc_func: HttpReallocFunction,
+    ) -> i32;
+
+    pub fn sceNetResolverInit() -> i32;
+    pub fn sceNetResolverCreate(
+        rid: *mut i32,
+        buf: *mut c_void,
+        buf_length: u32,
+    ) -> i32;
+    pub fn sceNetResolverDelete(rid: i32) -> i32;
+    pub fn sceNetResolverStartNtoA(
+        rid: i32,
+        hostname: *const u8,
+        addr: *mut in_addr,
+        timeout: u32,
+        retry: i32,
+    ) -> i32;
+    pub fn sceNetResolverStartAtoN(
+        rid: i32,
+        addr: *const in_addr,
+        hostname: *mut u8,
+        hostname_len: u32,
+        timeout: u32,
+        retry: i32,
+    ) -> i32;
+    pub fn sceNetResolverStop(rid: i32) -> i32;
+    pub fn sceNetResolverTerm() -> i32;
+}
diff --git a/library/libc/src/sgx.rs b/library/libc/src/sgx.rs
new file mode 100644
index 00000000..7da62693
--- /dev/null
+++ b/library/libc/src/sgx.rs
@@ -0,0 +1,47 @@
+//! SGX C types definition
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_float = f32;
+pub type c_double = f64;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+
+pub type size_t = usize;
+pub type ptrdiff_t = isize;
+pub type intptr_t = isize;
+pub type uintptr_t = usize;
+pub type ssize_t = isize;
+
+pub type c_char = i8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+pub const INT_MIN: c_int = -2147483648;
+pub const INT_MAX: c_int = 2147483647;
+
+cfg_if! {
+    if #[cfg(libc_core_cvoid)] {
+        pub use ::ffi::c_void;
+    } else {
+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help
+        // enable more optimization opportunities around it recognizing things
+        // like malloc/free.
+        #[repr(u8)]
+        #[allow(missing_copy_implementations)]
+        #[allow(missing_debug_implementations)]
+        pub enum c_void {
+            // Two dummy variants so the #[repr] attribute can be used.
+            #[doc(hidden)]
+            __variant1,
+            #[doc(hidden)]
+            __variant2,
+        }
+    }
+}
diff --git a/library/libc/src/switch.rs b/library/libc/src/switch.rs
new file mode 100644
index 00000000..030ab20d
--- /dev/null
+++ b/library/libc/src/switch.rs
@@ -0,0 +1,49 @@
+//! Switch C type definitions
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_float = f32;
+pub type c_double = f64;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+
+pub type size_t = usize;
+pub type ptrdiff_t = isize;
+pub type intptr_t = isize;
+pub type uintptr_t = usize;
+pub type ssize_t = isize;
+
+pub type off_t = i64;
+pub type c_char = u8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type wchar_t = u32;
+
+pub const INT_MIN: c_int = -2147483648;
+pub const INT_MAX: c_int = 2147483647;
+
+cfg_if! {
+    if #[cfg(libc_core_cvoid)] {
+        pub use ::ffi::c_void;
+    } else {
+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help
+        // enable more optimization opportunities around it recognizing things
+        // like malloc/free.
+        #[repr(u8)]
+        #[allow(missing_copy_implementations)]
+        #[allow(missing_debug_implementations)]
+        pub enum c_void {
+            // Two dummy variants so the #[repr] attribute can be used.
+            #[doc(hidden)]
+            __variant1,
+            #[doc(hidden)]
+            __variant2,
+        }
+    }
+}
diff --git a/library/libc/src/unix/align.rs b/library/libc/src/unix/align.rs
new file mode 100644
index 00000000..4fdba9a6
--- /dev/null
+++ b/library/libc/src/unix/align.rs
@@ -0,0 +1,6 @@
+s! {
+    #[repr(align(4))]
+    pub struct in6_addr {
+        pub s6_addr: [u8; 16],
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/b32/align.rs b/library/libc/src/unix/bsd/apple/b32/align.rs
new file mode 100644
index 00000000..ca1fe1ce
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/b32/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 2]
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/b32/mod.rs b/library/libc/src/unix/bsd/apple/b32/mod.rs
new file mode 100644
index 00000000..9248e3ad
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/b32/mod.rs
@@ -0,0 +1,115 @@
+//! 32-bit specific Apple (ios/darwin) definitions
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type boolean_t = ::c_int;
+
+s! {
+    pub struct if_data {
+        pub ifi_type: ::c_uchar,
+        pub ifi_typelen: ::c_uchar,
+        pub ifi_physical: ::c_uchar,
+        pub ifi_addrlen: ::c_uchar,
+        pub ifi_hdrlen: ::c_uchar,
+        pub ifi_recvquota: ::c_uchar,
+        pub ifi_xmitquota: ::c_uchar,
+        pub ifi_unused1: ::c_uchar,
+        pub ifi_mtu: u32,
+        pub ifi_metric: u32,
+        pub ifi_baudrate: u32,
+        pub ifi_ipackets: u32,
+        pub ifi_ierrors: u32,
+        pub ifi_opackets: u32,
+        pub ifi_oerrors: u32,
+        pub ifi_collisions: u32,
+        pub ifi_ibytes: u32,
+        pub ifi_obytes: u32,
+        pub ifi_imcasts: u32,
+        pub ifi_omcasts: u32,
+        pub ifi_iqdrops: u32,
+        pub ifi_noproto: u32,
+        pub ifi_recvtiming: u32,
+        pub ifi_xmittiming: u32,
+        pub ifi_lastchange: ::timeval,
+        pub ifi_unused2: u32,
+        pub ifi_hwassist: u32,
+        pub ifi_reserved1: u32,
+        pub ifi_reserved2: u32,
+    }
+
+    pub struct bpf_hdr {
+        pub bh_tstamp: ::timeval,
+        pub bh_caplen: u32,
+        pub bh_datalen: u32,
+        pub bh_hdrlen: ::c_ushort,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct pthread_attr_t {
+        __sig: c_long,
+        __opaque: [::c_char; 36]
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for pthread_attr_t {
+            fn eq(&self, other: &pthread_attr_t) -> bool {
+                self.__sig == other.__sig
+                    && self.__opaque
+                    .iter()
+                    .zip(other.__opaque.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for pthread_attr_t {}
+        impl ::fmt::Debug for pthread_attr_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_attr_t")
+                    .field("__sig", &self.__sig)
+                // FIXME: .field("__opaque", &self.__opaque)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for pthread_attr_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.__sig.hash(state);
+                self.__opaque.hash(state);
+            }
+        }
+    }
+}
+
+#[doc(hidden)]
+#[deprecated(since = "0.2.55")]
+pub const NET_RT_MAXID: ::c_int = 10;
+
+pub const __PTHREAD_MUTEX_SIZE__: usize = 40;
+pub const __PTHREAD_COND_SIZE__: usize = 24;
+pub const __PTHREAD_CONDATTR_SIZE__: usize = 4;
+pub const __PTHREAD_RWLOCK_SIZE__: usize = 124;
+pub const __PTHREAD_RWLOCKATTR_SIZE__: usize = 12;
+
+pub const TIOCTIMESTAMP: ::c_ulong = 0x40087459;
+pub const TIOCDCDTIMESTAMP: ::c_ulong = 0x40087458;
+
+pub const BIOCSETF: ::c_ulong = 0x80084267;
+pub const BIOCSRTIMEOUT: ::c_ulong = 0x8008426d;
+pub const BIOCGRTIMEOUT: ::c_ulong = 0x4008426e;
+pub const BIOCSETFNR: ::c_ulong = 0x8008427e;
+
+extern "C" {
+    pub fn exchangedata(
+        path1: *const ::c_char,
+        path2: *const ::c_char,
+        options: ::c_ulong,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/b64/aarch64/align.rs b/library/libc/src/unix/bsd/apple/b64/aarch64/align.rs
new file mode 100644
index 00000000..10d55039
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/b64/aarch64/align.rs
@@ -0,0 +1,48 @@
+pub type mcontext_t = *mut __darwin_mcontext64;
+
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    pub struct max_align_t {
+        priv_: f64
+    }
+}
+
+s! {
+    pub struct ucontext_t {
+        pub uc_onstack: ::c_int,
+        pub uc_sigmask: ::sigset_t,
+        pub uc_stack: ::stack_t,
+        pub uc_link: *mut ::ucontext_t,
+        pub uc_mcsize: usize,
+        pub uc_mcontext: mcontext_t,
+    }
+
+    pub struct __darwin_mcontext64 {
+        pub __es: __darwin_arm_exception_state64,
+        pub __ss: __darwin_arm_thread_state64,
+        pub __ns: __darwin_arm_neon_state64,
+    }
+
+    pub struct __darwin_arm_exception_state64 {
+        pub __far: u64,
+        pub __esr: u32,
+        pub __exception: u32,
+    }
+
+    pub struct __darwin_arm_thread_state64 {
+        pub __x: [u64; 29],
+        pub __fp: u64,
+        pub __lr: u64,
+        pub __sp: u64,
+        pub __pc: u64,
+        pub __cpsr: u32,
+        pub __pad: u32,
+    }
+
+    #[repr(align(16))]
+    pub struct __darwin_arm_neon_state64 {
+        pub __v: [[u64; 2]; 32],
+        pub __fpsr: u32,
+        pub __fpcr: u32,
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/b64/aarch64/mod.rs b/library/libc/src/unix/bsd/apple/b64/aarch64/mod.rs
new file mode 100644
index 00000000..83b62e97
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/b64/aarch64/mod.rs
@@ -0,0 +1,8 @@
+pub type boolean_t = ::c_int;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/b64/align.rs b/library/libc/src/unix/bsd/apple/b64/align.rs
new file mode 100644
index 00000000..ca1fe1ce
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/b64/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 2]
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/b64/mod.rs b/library/libc/src/unix/bsd/apple/b64/mod.rs
new file mode 100644
index 00000000..48d94bcd
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/b64/mod.rs
@@ -0,0 +1,124 @@
+//! 64-bit specific Apple (ios/darwin) definitions
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+s! {
+    pub struct timeval32 {
+        pub tv_sec: i32,
+        pub tv_usec: i32,
+    }
+
+    pub struct if_data {
+        pub ifi_type: ::c_uchar,
+        pub ifi_typelen: ::c_uchar,
+        pub ifi_physical: ::c_uchar,
+        pub ifi_addrlen: ::c_uchar,
+        pub ifi_hdrlen: ::c_uchar,
+        pub ifi_recvquota: ::c_uchar,
+        pub ifi_xmitquota: ::c_uchar,
+        pub ifi_unused1: ::c_uchar,
+        pub ifi_mtu: u32,
+        pub ifi_metric: u32,
+        pub ifi_baudrate: u32,
+        pub ifi_ipackets: u32,
+        pub ifi_ierrors: u32,
+        pub ifi_opackets: u32,
+        pub ifi_oerrors: u32,
+        pub ifi_collisions: u32,
+        pub ifi_ibytes: u32,
+        pub ifi_obytes: u32,
+        pub ifi_imcasts: u32,
+        pub ifi_omcasts: u32,
+        pub ifi_iqdrops: u32,
+        pub ifi_noproto: u32,
+        pub ifi_recvtiming: u32,
+        pub ifi_xmittiming: u32,
+        pub ifi_lastchange: timeval32,
+        pub ifi_unused2: u32,
+        pub ifi_hwassist: u32,
+        pub ifi_reserved1: u32,
+        pub ifi_reserved2: u32,
+    }
+
+    pub struct bpf_hdr {
+        pub bh_tstamp: ::timeval32,
+        pub bh_caplen: u32,
+        pub bh_datalen: u32,
+        pub bh_hdrlen: ::c_ushort,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct pthread_attr_t {
+        __sig: c_long,
+        __opaque: [::c_char; 56]
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for pthread_attr_t {
+            fn eq(&self, other: &pthread_attr_t) -> bool {
+                self.__sig == other.__sig
+                    && self.__opaque
+                    .iter()
+                    .zip(other.__opaque.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for pthread_attr_t {}
+        impl ::fmt::Debug for pthread_attr_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_attr_t")
+                    .field("__sig", &self.__sig)
+                // FIXME: .field("__opaque", &self.__opaque)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for pthread_attr_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.__sig.hash(state);
+                self.__opaque.hash(state);
+            }
+        }
+    }
+}
+
+#[doc(hidden)]
+#[deprecated(since = "0.2.55")]
+pub const NET_RT_MAXID: ::c_int = 11;
+
+pub const __PTHREAD_MUTEX_SIZE__: usize = 56;
+pub const __PTHREAD_COND_SIZE__: usize = 40;
+pub const __PTHREAD_CONDATTR_SIZE__: usize = 8;
+pub const __PTHREAD_RWLOCK_SIZE__: usize = 192;
+pub const __PTHREAD_RWLOCKATTR_SIZE__: usize = 16;
+
+pub const TIOCTIMESTAMP: ::c_ulong = 0x40107459;
+pub const TIOCDCDTIMESTAMP: ::c_ulong = 0x40107458;
+
+pub const BIOCSETF: ::c_ulong = 0x80104267;
+pub const BIOCSRTIMEOUT: ::c_ulong = 0x8010426d;
+pub const BIOCGRTIMEOUT: ::c_ulong = 0x4010426e;
+pub const BIOCSETFNR: ::c_ulong = 0x8010427e;
+
+extern "C" {
+    pub fn exchangedata(
+        path1: *const ::c_char,
+        path2: *const ::c_char,
+        options: ::c_uint,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/b64/x86_64/align.rs b/library/libc/src/unix/bsd/apple/b64/x86_64/align.rs
new file mode 100644
index 00000000..ca1fe1ce
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/b64/x86_64/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 2]
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/b64/x86_64/mod.rs b/library/libc/src/unix/bsd/apple/b64/x86_64/mod.rs
new file mode 100644
index 00000000..07866665
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/b64/x86_64/mod.rs
@@ -0,0 +1,112 @@
+pub type boolean_t = ::c_uint;
+pub type mcontext_t = *mut __darwin_mcontext64;
+
+s! {
+    pub struct ucontext_t {
+        pub uc_onstack: ::c_int,
+        pub uc_sigmask: ::sigset_t,
+        pub uc_stack: ::stack_t,
+        pub uc_link: *mut ::ucontext_t,
+        pub uc_mcsize: usize,
+        pub uc_mcontext: mcontext_t,
+    }
+
+    pub struct __darwin_mcontext64 {
+        pub __es: __darwin_x86_exception_state64,
+        pub __ss: __darwin_x86_thread_state64,
+        pub __fs: __darwin_x86_float_state64,
+    }
+
+    pub struct __darwin_x86_exception_state64 {
+        pub __trapno: u16,
+        pub __cpu: u16,
+        pub __err: u32,
+        pub __faultvaddr: u64,
+    }
+
+    pub struct __darwin_x86_thread_state64 {
+        pub __rax: u64,
+        pub __rbx: u64,
+        pub __rcx: u64,
+        pub __rdx: u64,
+        pub __rdi: u64,
+        pub __rsi: u64,
+        pub __rbp: u64,
+        pub __rsp: u64,
+        pub __r8: u64,
+        pub __r9: u64,
+        pub __r10: u64,
+        pub __r11: u64,
+        pub __r12: u64,
+        pub __r13: u64,
+        pub __r14: u64,
+        pub __r15: u64,
+        pub __rip: u64,
+        pub __rflags: u64,
+        pub __cs: u64,
+        pub __fs: u64,
+        pub __gs: u64,
+    }
+
+    pub struct __darwin_x86_float_state64 {
+        pub __fpu_reserved: [::c_int; 2],
+        __fpu_fcw: ::c_short,
+        __fpu_fsw: ::c_short,
+        pub __fpu_ftw: u8,
+        pub __fpu_rsrv1: u8,
+        pub __fpu_fop: u16,
+        pub __fpu_ip: u32,
+        pub __fpu_cs: u16,
+        pub __fpu_rsrv2: u16,
+        pub __fpu_dp: u32,
+        pub __fpu_ds: u16,
+        pub __fpu_rsrv3: u16,
+        pub __fpu_mxcsr: u32,
+        pub __fpu_mxcsrmask: u32,
+        pub __fpu_stmm0: __darwin_mmst_reg,
+        pub __fpu_stmm1: __darwin_mmst_reg,
+        pub __fpu_stmm2: __darwin_mmst_reg,
+        pub __fpu_stmm3: __darwin_mmst_reg,
+        pub __fpu_stmm4: __darwin_mmst_reg,
+        pub __fpu_stmm5: __darwin_mmst_reg,
+        pub __fpu_stmm6: __darwin_mmst_reg,
+        pub __fpu_stmm7: __darwin_mmst_reg,
+        pub __fpu_xmm0: __darwin_xmm_reg,
+        pub __fpu_xmm1: __darwin_xmm_reg,
+        pub __fpu_xmm2: __darwin_xmm_reg,
+        pub __fpu_xmm3: __darwin_xmm_reg,
+        pub __fpu_xmm4: __darwin_xmm_reg,
+        pub __fpu_xmm5: __darwin_xmm_reg,
+        pub __fpu_xmm6: __darwin_xmm_reg,
+        pub __fpu_xmm7: __darwin_xmm_reg,
+        pub __fpu_xmm8: __darwin_xmm_reg,
+        pub __fpu_xmm9: __darwin_xmm_reg,
+        pub __fpu_xmm10: __darwin_xmm_reg,
+        pub __fpu_xmm11: __darwin_xmm_reg,
+        pub __fpu_xmm12: __darwin_xmm_reg,
+        pub __fpu_xmm13: __darwin_xmm_reg,
+        pub __fpu_xmm14: __darwin_xmm_reg,
+        pub __fpu_xmm15: __darwin_xmm_reg,
+        // this field is actually [u8; 96], but defining it with a bigger type
+        // allows us to auto-implement traits for it since the length of the
+        // array is less than 32
+        __fpu_rsrv4: [u32; 24],
+        pub __fpu_reserved1: ::c_int,
+    }
+
+    pub struct __darwin_mmst_reg {
+        pub __mmst_reg: [::c_char; 10],
+        pub __mmst_rsrv: [::c_char; 6],
+    }
+
+    pub struct __darwin_xmm_reg {
+        pub __xmm_reg: [::c_char; 16],
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/bsd/apple/mod.rs b/library/libc/src/unix/bsd/apple/mod.rs
new file mode 100644
index 00000000..c167ceb1
--- /dev/null
+++ b/library/libc/src/unix/bsd/apple/mod.rs
@@ -0,0 +1,3759 @@
+//! Apple (ios/darwin)-specific definitions
+//!
+//! This covers *-apple-* triples currently
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type clock_t = c_ulong;
+pub type time_t = c_long;
+pub type suseconds_t = i32;
+pub type dev_t = i32;
+pub type ino_t = u64;
+pub type mode_t = u16;
+pub type nlink_t = u16;
+pub type blksize_t = i32;
+pub type rlim_t = u64;
+pub type pthread_key_t = c_ulong;
+pub type sigset_t = u32;
+pub type clockid_t = ::c_uint;
+pub type fsblkcnt_t = ::c_uint;
+pub type fsfilcnt_t = ::c_uint;
+pub type speed_t = ::c_ulong;
+pub type tcflag_t = ::c_ulong;
+pub type nl_item = ::c_int;
+pub type id_t = ::c_uint;
+pub type sem_t = ::c_int;
+pub type idtype_t = ::c_uint;
+pub type integer_t = ::c_int;
+pub type cpu_type_t = integer_t;
+pub type cpu_subtype_t = integer_t;
+
+pub type posix_spawnattr_t = *mut ::c_void;
+pub type posix_spawn_file_actions_t = *mut ::c_void;
+pub type key_t = ::c_int;
+pub type shmatt_t = ::c_ushort;
+
+pub type sae_associd_t = u32;
+pub type sae_connid_t = u32;
+
+pub type mach_port_t = ::c_uint;
+
+deprecated_mach! {
+    pub type vm_prot_t = ::c_int;
+    pub type vm_size_t = ::uintptr_t;
+    pub type mach_timebase_info_data_t = mach_timebase_info;
+}
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+
+s! {
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct aiocb {
+        pub aio_fildes: ::c_int,
+        pub aio_offset: ::off_t,
+        pub aio_buf: *mut ::c_void,
+        pub aio_nbytes: ::size_t,
+        pub aio_reqprio: ::c_int,
+        pub aio_sigevent: sigevent,
+        pub aio_lio_opcode: ::c_int
+    }
+
+    pub struct glob_t {
+        pub gl_pathc:  ::size_t,
+        __unused1: ::c_int,
+        pub gl_offs:   ::size_t,
+        __unused2: ::c_int,
+        pub gl_pathv:  *mut *mut ::c_char,
+
+        __unused3: *mut ::c_void,
+
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+        __unused6: *mut ::c_void,
+        __unused7: *mut ::c_void,
+        __unused8: *mut ::c_void,
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: ::socklen_t,
+        pub ai_canonname: *mut ::c_char,
+        pub ai_addr: *mut ::sockaddr,
+        pub ai_next: *mut addrinfo,
+    }
+
+    #[deprecated(
+        since = "0.2.55",
+        note = "Use the `mach` crate instead",
+    )]
+    pub struct mach_timebase_info {
+        pub numer: u32,
+        pub denom: u32,
+    }
+
+    pub struct stat {
+        pub st_dev: dev_t,
+        pub st_mode: mode_t,
+        pub st_nlink: nlink_t,
+        pub st_ino: ino_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: dev_t,
+        pub st_atime: time_t,
+        pub st_atime_nsec: c_long,
+        pub st_mtime: time_t,
+        pub st_mtime_nsec: c_long,
+        pub st_ctime: time_t,
+        pub st_ctime_nsec: c_long,
+        pub st_birthtime: time_t,
+        pub st_birthtime_nsec: c_long,
+        pub st_size: ::off_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_blksize: blksize_t,
+        pub st_flags: u32,
+        pub st_gen: u32,
+        pub st_lspare: i32,
+        pub st_qspare: [i64; 2],
+    }
+
+    pub struct pthread_mutexattr_t {
+        __sig: ::c_long,
+        __opaque: [u8; 8],
+    }
+
+    pub struct pthread_condattr_t {
+        __sig: ::c_long,
+        __opaque: [u8; __PTHREAD_CONDATTR_SIZE__],
+    }
+
+    pub struct pthread_rwlockattr_t {
+        __sig: ::c_long,
+        __opaque: [u8; __PTHREAD_RWLOCKATTR_SIZE__],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub si_pid: ::pid_t,
+        pub si_uid: ::uid_t,
+        pub si_status: ::c_int,
+        pub si_addr: *mut ::c_void,
+        //Requires it to be union for tests
+        //pub si_value: ::sigval,
+        _pad: [usize; 9],
+    }
+
+    pub struct sigaction {
+        // FIXME: this field is actually a union
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: sigset_t,
+        pub sa_flags: ::c_int,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct fstore_t {
+        pub fst_flags: ::c_uint,
+        pub fst_posmode: ::c_int,
+        pub fst_offset: ::off_t,
+        pub fst_length: ::off_t,
+        pub fst_bytesalloc: ::off_t,
+    }
+
+    pub struct radvisory {
+        pub ra_offset: ::off_t,
+        pub ra_count: ::c_int,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct sockaddr_in {
+        pub sin_len: u8,
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [::c_char; 8],
+    }
+
+    pub struct kevent64_s {
+        pub ident: u64,
+        pub filter: i16,
+        pub flags: u16,
+        pub fflags: u32,
+        pub data: i64,
+        pub udata: u64,
+        pub ext: [u64; 2],
+    }
+
+    pub struct dqblk {
+        pub dqb_bhardlimit: u64,
+        pub dqb_bsoftlimit: u64,
+        pub dqb_curbytes: u64,
+        pub dqb_ihardlimit: u32,
+        pub dqb_isoftlimit: u32,
+        pub dqb_curinodes: u32,
+        pub dqb_btime: u32,
+        pub dqb_itime: u32,
+        pub dqb_id: u32,
+        pub dqb_spare: [u32; 4],
+    }
+
+    pub struct if_msghdr {
+        pub ifm_msglen: ::c_ushort,
+        pub ifm_version: ::c_uchar,
+        pub ifm_type: ::c_uchar,
+        pub ifm_addrs: ::c_int,
+        pub ifm_flags: ::c_int,
+        pub ifm_index: ::c_ushort,
+        pub ifm_data: if_data,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct flock {
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+    }
+
+    pub struct sf_hdtr {
+        pub headers: *mut ::iovec,
+        pub hdr_cnt: ::c_int,
+        pub trailers: *mut ::iovec,
+        pub trl_cnt: ::c_int,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct proc_taskinfo {
+        pub pti_virtual_size: u64,
+        pub pti_resident_size: u64,
+        pub pti_total_user: u64,
+        pub pti_total_system: u64,
+        pub pti_threads_user: u64,
+        pub pti_threads_system: u64,
+        pub pti_policy: i32,
+        pub pti_faults: i32,
+        pub pti_pageins: i32,
+        pub pti_cow_faults: i32,
+        pub pti_messages_sent: i32,
+        pub pti_messages_received: i32,
+        pub pti_syscalls_mach: i32,
+        pub pti_syscalls_unix: i32,
+        pub pti_csw: i32,
+        pub pti_threadnum: i32,
+        pub pti_numrunning: i32,
+        pub pti_priority: i32,
+    }
+
+    pub struct proc_bsdinfo {
+        pub pbi_flags: u32,
+        pub pbi_status: u32,
+        pub pbi_xstatus: u32,
+        pub pbi_pid: u32,
+        pub pbi_ppid: u32,
+        pub pbi_uid: ::uid_t,
+        pub pbi_gid: ::gid_t,
+        pub pbi_ruid: ::uid_t,
+        pub pbi_rgid: ::gid_t,
+        pub pbi_svuid: ::uid_t,
+        pub pbi_svgid: ::gid_t,
+        pub rfu_1: u32,
+        pub pbi_comm: [::c_char; MAXCOMLEN],
+        pub pbi_name: [::c_char; 32], // MAXCOMLEN * 2, but macro isn't happy...
+        pub pbi_nfiles: u32,
+        pub pbi_pgid: u32,
+        pub pbi_pjobc: u32,
+        pub e_tdev: u32,
+        pub e_tpgid: u32,
+        pub pbi_nice: i32,
+        pub pbi_start_tvsec: u64,
+        pub pbi_start_tvusec: u64,
+    }
+
+    pub struct proc_taskallinfo {
+        pub pbsd: proc_bsdinfo,
+        pub ptinfo: proc_taskinfo,
+    }
+
+    pub struct xsw_usage {
+        pub xsu_total: u64,
+        pub xsu_avail: u64,
+        pub xsu_used: u64,
+        pub xsu_pagesize: u32,
+        pub xsu_encrypted: ::boolean_t,
+    }
+
+    pub struct xucred {
+        pub cr_version: ::c_uint,
+        pub cr_uid: ::uid_t,
+        pub cr_ngroups: ::c_short,
+        pub cr_groups: [::gid_t;16]
+    }
+
+    #[deprecated(
+        since = "0.2.55",
+        note = "Use the `mach` crate instead",
+    )]
+    pub struct mach_header {
+        pub magic: u32,
+        pub cputype: cpu_type_t,
+        pub cpusubtype: cpu_subtype_t,
+        pub filetype: u32,
+        pub ncmds: u32,
+        pub sizeofcmds: u32,
+        pub flags: u32,
+    }
+
+    #[deprecated(
+        since = "0.2.55",
+        note = "Use the `mach` crate instead",
+    )]
+    pub struct mach_header_64 {
+        pub magic: u32,
+        pub cputype: cpu_type_t,
+        pub cpusubtype: cpu_subtype_t,
+        pub filetype: u32,
+        pub ncmds: u32,
+        pub sizeofcmds: u32,
+        pub flags: u32,
+        pub reserved: u32,
+    }
+
+    pub struct segment_command {
+        pub cmd: u32,
+        pub cmdsize: u32,
+        pub segname: [::c_char; 16],
+        pub vmaddr: u32,
+        pub vmsize: u32,
+        pub fileoff: u32,
+        pub filesize: u32,
+        pub maxprot: vm_prot_t,
+        pub initprot: vm_prot_t,
+        pub nsects: u32,
+        pub flags: u32,
+    }
+
+    pub struct segment_command_64 {
+        pub cmd: u32,
+        pub cmdsize: u32,
+        pub segname: [::c_char; 16],
+        pub vmaddr: u64,
+        pub vmsize: u64,
+        pub fileoff: u64,
+        pub filesize: u64,
+        pub maxprot: vm_prot_t,
+        pub initprot: vm_prot_t,
+        pub nsects: u32,
+        pub flags: u32,
+    }
+
+    pub struct load_command {
+        pub cmd: u32,
+        pub cmdsize: u32,
+    }
+
+    pub struct sockaddr_dl {
+        pub sdl_len: ::c_uchar,
+        pub sdl_family: ::c_uchar,
+        pub sdl_index: ::c_ushort,
+        pub sdl_type: ::c_uchar,
+        pub sdl_nlen: ::c_uchar,
+        pub sdl_alen: ::c_uchar,
+        pub sdl_slen: ::c_uchar,
+        pub sdl_data: [::c_char; 12],
+    }
+
+    pub struct sockaddr_inarp {
+        pub sin_len: ::c_uchar,
+        pub sin_family: ::c_uchar,
+        pub sin_port: ::c_ushort,
+        pub sin_addr: ::in_addr,
+        pub sin_srcaddr: ::in_addr,
+        pub sin_tos: ::c_ushort,
+        pub sin_other: ::c_ushort,
+    }
+
+    pub struct sockaddr_ctl {
+        pub sc_len: ::c_uchar,
+        pub sc_family: ::c_uchar,
+        pub ss_sysaddr: u16,
+        pub sc_id: u32,
+        pub sc_unit: u32,
+        pub sc_reserved: [u32; 5],
+    }
+
+    pub struct in_pktinfo {
+        pub ipi_ifindex: ::c_uint,
+        pub ipi_spec_dst: ::in_addr,
+        pub ipi_addr: ::in_addr,
+    }
+
+    pub struct in6_pktinfo {
+        pub ipi6_addr: ::in6_addr,
+        pub ipi6_ifindex: ::c_uint,
+    }
+
+    // sys/ipc.h:
+
+    pub struct ipc_perm {
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub _seq: ::c_ushort,
+        pub _key: ::key_t,
+    }
+
+    // sys/sem.h
+
+    pub struct sembuf {
+        pub sem_num: ::c_ushort,
+        pub sem_op: ::c_short,
+        pub sem_flg: ::c_short,
+    }
+
+    // sys/shm.h
+
+    pub struct arphdr {
+        pub ar_hrd: u16,
+        pub ar_pro: u16,
+        pub ar_hln: u8,
+        pub ar_pln: u8,
+        pub ar_op: u16,
+    }
+
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    // sys/socket.h
+
+    pub struct sa_endpoints_t {
+        pub sae_srcif: ::c_uint, // optional source interface
+        pub sae_srcaddr: *const ::sockaddr, // optional source address
+        pub sae_srcaddrlen: ::socklen_t, // size of source address
+        pub sae_dstaddr: *const ::sockaddr, // destination address
+        pub sae_dstaddrlen: ::socklen_t, // size of destination address
+    }
+
+    pub struct timex {
+        pub modes: ::c_uint,
+        pub offset: ::c_long,
+        pub freq: ::c_long,
+        pub maxerror: ::c_long,
+        pub esterror: ::c_long,
+        pub status: ::c_int,
+        pub constant: ::c_long,
+        pub precision: ::c_long,
+        pub tolerance: ::c_long,
+        pub ppsfreq: ::c_long,
+        pub jitter: ::c_long,
+        pub shift: ::c_int,
+        pub stabil: ::c_long,
+        pub jitcnt: ::c_long,
+        pub calcnt: ::c_long,
+        pub errcnt: ::c_long,
+        pub stbcnt: ::c_long,
+    }
+
+    pub struct ntptimeval {
+        pub time: ::timespec,
+        pub maxerror: ::c_long,
+        pub esterror: ::c_long,
+        pub tai: ::c_long,
+        pub time_state: ::c_int,
+    }
+}
+
+s_no_extra_traits! {
+    #[cfg_attr(libc_packedN, repr(packed(4)))]
+    pub struct kevent {
+        pub ident: ::uintptr_t,
+        pub filter: i16,
+        pub flags: u16,
+        pub fflags: u32,
+        pub data: ::intptr_t,
+        pub udata: *mut ::c_void,
+    }
+
+    #[cfg_attr(libc_packedN, repr(packed(4)))]
+    pub struct semid_ds {
+        // Note the manpage shows different types than the system header.
+        pub sem_perm: ipc_perm,
+        pub sem_base: i32,
+        pub sem_nsems: ::c_ushort,
+        pub sem_otime: ::time_t,
+        pub sem_pad1: i32,
+        pub sem_ctime: ::time_t,
+        pub sem_pad2: i32,
+        pub sem_pad3: [i32; 4],
+    }
+
+    #[cfg_attr(libc_packedN, repr(packed(4)))]
+    pub struct shmid_ds {
+        pub shm_perm: ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        pub shm_atime: ::time_t,  // FIXME: 64-bit wrong align => wrong offset
+        pub shm_dtime: ::time_t,  // FIXME: 64-bit wrong align => wrong offset
+        pub shm_ctime: ::time_t,  // FIXME: 64-bit wrong align => wrong offset
+        // FIXME: 64-bit wrong align => wrong offset:
+        pub shm_internal: *mut ::c_void,
+    }
+
+    pub struct proc_threadinfo {
+        pub pth_user_time: u64,
+        pub pth_system_time: u64,
+        pub pth_cpu_usage: i32,
+        pub pth_policy: i32,
+        pub pth_run_state: i32,
+        pub pth_flags: i32,
+        pub pth_sleep_time: i32,
+        pub pth_curpri: i32,
+        pub pth_priority: i32,
+        pub pth_maxpriority: i32,
+        pub pth_name: [::c_char; MAXTHREADNAMESIZE],
+    }
+
+    pub struct statfs {
+        pub f_bsize: u32,
+        pub f_iosize: i32,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_owner: ::uid_t,
+        pub f_type: u32,
+        pub f_flags: u32,
+        pub f_fssubtype: u32,
+        pub f_fstypename: [::c_char; 16],
+        pub f_mntonname: [::c_char; 1024],
+        pub f_mntfromname: [::c_char; 1024],
+        pub f_reserved: [u32; 8],
+    }
+
+    pub struct dirent {
+        pub d_ino: u64,
+        pub d_seekoff: u64,
+        pub d_reclen: u16,
+        pub d_namlen: u16,
+        pub d_type: u8,
+        pub d_name: [::c_char; 1024],
+    }
+
+    pub struct pthread_rwlock_t {
+        __sig: ::c_long,
+        __opaque: [u8; __PTHREAD_RWLOCK_SIZE__],
+    }
+
+    pub struct pthread_mutex_t {
+        __sig: ::c_long,
+        __opaque: [u8; __PTHREAD_MUTEX_SIZE__],
+    }
+
+    pub struct pthread_cond_t {
+        __sig: ::c_long,
+        __opaque: [u8; __PTHREAD_COND_SIZE__],
+    }
+
+    pub struct sockaddr_storage {
+        pub ss_len: u8,
+        pub ss_family: ::sa_family_t,
+        __ss_pad1: [u8; 6],
+        __ss_align: i64,
+        __ss_pad2: [u8; 112],
+    }
+
+    pub struct utmpx {
+        pub ut_user: [::c_char; _UTX_USERSIZE],
+        pub ut_id: [::c_char; _UTX_IDSIZE],
+        pub ut_line: [::c_char; _UTX_LINESIZE],
+        pub ut_pid: ::pid_t,
+        pub ut_type: ::c_short,
+        pub ut_tv: ::timeval,
+        pub ut_host: [::c_char; _UTX_HOSTSIZE],
+        ut_pad: [u32; 16],
+    }
+
+    pub struct sigevent {
+        pub sigev_notify: ::c_int,
+        pub sigev_signo: ::c_int,
+        pub sigev_value: ::sigval,
+        __unused1: *mut ::c_void,       //actually a function pointer
+        pub sigev_notify_attributes: *mut ::pthread_attr_t
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_addr(&self) -> *mut ::c_void {
+        self.si_addr
+    }
+
+    pub unsafe fn si_value(&self) -> ::sigval {
+        #[repr(C)]
+        struct siginfo_timer {
+            _si_signo: ::c_int,
+            _si_errno: ::c_int,
+            _si_code: ::c_int,
+            _si_pid: ::pid_t,
+            _si_uid: ::uid_t,
+            _si_status: ::c_int,
+            _si_addr: *mut ::c_void,
+            si_value: ::sigval,
+        }
+
+        (*(self as *const siginfo_t as *const siginfo_timer)).si_value
+    }
+
+    pub unsafe fn si_pid(&self) -> ::pid_t {
+        self.si_pid
+    }
+
+    pub unsafe fn si_uid(&self) -> ::uid_t {
+        self.si_uid
+    }
+
+    pub unsafe fn si_status(&self) -> ::c_int {
+        self.si_status
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        s_no_extra_traits! {
+            pub union semun {
+                pub val: ::c_int,
+                pub buf: *mut semid_ds,
+                pub array: *mut ::c_ushort,
+            }
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for semun {
+                    fn eq(&self, other: &semun) -> bool {
+                        unsafe { self.val == other.val }
+                    }
+                }
+                impl Eq for semun {}
+                impl ::fmt::Debug for semun {
+                    fn fmt(&self, f: &mut ::fmt::Formatter)
+                           -> ::fmt::Result {
+                        f.debug_struct("semun")
+                            .field("val", unsafe { &self.val })
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for semun {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        unsafe { self.val.hash(state) };
+                    }
+                }
+            }
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for kevent {
+            fn eq(&self, other: &kevent) -> bool {
+                self.ident == other.ident
+                    && self.filter == other.filter
+                    && self.flags == other.flags
+                    && self.fflags == other.fflags
+                    && self.data == other.data
+                    && self.udata == other.udata
+            }
+        }
+        impl Eq for kevent {}
+        impl ::fmt::Debug for kevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                let ident = self.ident;
+                let filter = self.filter;
+                let flags = self.flags;
+                let fflags = self.fflags;
+                let data = self.data;
+                let udata = self.udata;
+                f.debug_struct("kevent")
+                    .field("ident", &ident)
+                    .field("filter", &filter)
+                    .field("flags", &flags)
+                    .field("fflags", &fflags)
+                    .field("data", &data)
+                    .field("udata", &udata)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for kevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                let ident = self.ident;
+                let filter = self.filter;
+                let flags = self.flags;
+                let fflags = self.fflags;
+                let data = self.data;
+                let udata = self.udata;
+                ident.hash(state);
+                filter.hash(state);
+                flags.hash(state);
+                fflags.hash(state);
+                data.hash(state);
+                udata.hash(state);
+            }
+        }
+
+        impl PartialEq for semid_ds {
+            fn eq(&self, other: &semid_ds) -> bool {
+                let sem_perm = self.sem_perm;
+                let sem_pad3 = self.sem_pad3;
+                let other_sem_perm = other.sem_perm;
+                let other_sem_pad3 = other.sem_pad3;
+                sem_perm == other_sem_perm
+                    && self.sem_base == other.sem_base
+                    && self.sem_nsems == other.sem_nsems
+                    && self.sem_otime == other.sem_otime
+                    && self.sem_pad1 == other.sem_pad1
+                    && self.sem_ctime == other.sem_ctime
+                    && self.sem_pad2 == other.sem_pad2
+                    && sem_pad3 == other_sem_pad3
+            }
+        }
+        impl Eq for semid_ds {}
+        impl ::fmt::Debug for semid_ds {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                let sem_perm = self.sem_perm;
+                let sem_base = self.sem_base;
+                let sem_nsems = self.sem_nsems;
+                let sem_otime = self.sem_otime;
+                let sem_pad1 = self.sem_pad1;
+                let sem_ctime = self.sem_ctime;
+                let sem_pad2 = self.sem_pad2;
+                let sem_pad3 = self.sem_pad3;
+                f.debug_struct("semid_ds")
+                    .field("sem_perm", &sem_perm)
+                    .field("sem_base", &sem_base)
+                    .field("sem_nsems", &sem_nsems)
+                    .field("sem_otime", &sem_otime)
+                    .field("sem_pad1", &sem_pad1)
+                    .field("sem_ctime", &sem_ctime)
+                    .field("sem_pad2", &sem_pad2)
+                    .field("sem_pad3", &sem_pad3)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for semid_ds {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                let sem_perm = self.sem_perm;
+                let sem_base = self.sem_base;
+                let sem_nsems = self.sem_nsems;
+                let sem_otime = self.sem_otime;
+                let sem_pad1 = self.sem_pad1;
+                let sem_ctime = self.sem_ctime;
+                let sem_pad2 = self.sem_pad2;
+                let sem_pad3 = self.sem_pad3;
+                sem_perm.hash(state);
+                sem_base.hash(state);
+                sem_nsems.hash(state);
+                sem_otime.hash(state);
+                sem_pad1.hash(state);
+                sem_ctime.hash(state);
+                sem_pad2.hash(state);
+                sem_pad3.hash(state);
+            }
+        }
+
+        impl PartialEq for shmid_ds {
+            fn eq(&self, other: &shmid_ds) -> bool {
+                let shm_perm = self.shm_perm;
+                let other_shm_perm = other.shm_perm;
+                shm_perm == other_shm_perm
+                    && self.shm_segsz == other.shm_segsz
+                    && self.shm_lpid == other.shm_lpid
+                    && self.shm_cpid == other.shm_cpid
+                    && self.shm_nattch == other.shm_nattch
+                    && self.shm_atime == other.shm_atime
+                    && self.shm_dtime == other.shm_dtime
+                    && self.shm_ctime == other.shm_ctime
+                    && self.shm_internal == other.shm_internal
+            }
+        }
+        impl Eq for shmid_ds {}
+        impl ::fmt::Debug for shmid_ds {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                let shm_perm = self.shm_perm;
+                let shm_segsz = self.shm_segsz;
+                let shm_lpid = self.shm_lpid;
+                let shm_cpid = self.shm_cpid;
+                let shm_nattch = self.shm_nattch;
+                let shm_atime = self.shm_atime;
+                let shm_dtime = self.shm_dtime;
+                let shm_ctime = self.shm_ctime;
+                let shm_internal = self.shm_internal;
+                f.debug_struct("shmid_ds")
+                    .field("shm_perm", &shm_perm)
+                    .field("shm_segsz", &shm_segsz)
+                    .field("shm_lpid", &shm_lpid)
+                    .field("shm_cpid", &shm_cpid)
+                    .field("shm_nattch", &shm_nattch)
+                    .field("shm_atime", &shm_atime)
+                    .field("shm_dtime", &shm_dtime)
+                    .field("shm_ctime", &shm_ctime)
+                    .field("shm_internal", &shm_internal)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for shmid_ds {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                let shm_perm = self.shm_perm;
+                let shm_segsz = self.shm_segsz;
+                let shm_lpid = self.shm_lpid;
+                let shm_cpid = self.shm_cpid;
+                let shm_nattch = self.shm_nattch;
+                let shm_atime = self.shm_atime;
+                let shm_dtime = self.shm_dtime;
+                let shm_ctime = self.shm_ctime;
+                let shm_internal = self.shm_internal;
+                shm_perm.hash(state);
+                shm_segsz.hash(state);
+                shm_lpid.hash(state);
+                shm_cpid.hash(state);
+                shm_nattch.hash(state);
+                shm_atime.hash(state);
+                shm_dtime.hash(state);
+                shm_ctime.hash(state);
+                shm_internal.hash(state);
+            }
+        }
+
+        impl PartialEq for proc_threadinfo {
+            fn eq(&self, other: &proc_threadinfo) -> bool {
+                self.pth_user_time == other.pth_user_time
+                    && self.pth_system_time == other.pth_system_time
+                    && self.pth_cpu_usage == other.pth_cpu_usage
+                    && self.pth_policy == other.pth_policy
+                    && self.pth_run_state == other.pth_run_state
+                    && self.pth_flags == other.pth_flags
+                    && self.pth_sleep_time == other.pth_sleep_time
+                    && self.pth_curpri == other.pth_curpri
+                    && self.pth_priority == other.pth_priority
+                    && self.pth_maxpriority == other.pth_maxpriority
+                    && self.pth_name
+                           .iter()
+                           .zip(other.pth_name.iter())
+                           .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for proc_threadinfo {}
+        impl ::fmt::Debug for proc_threadinfo {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("proc_threadinfo")
+                    .field("pth_user_time", &self.pth_user_time)
+                    .field("pth_system_time", &self.pth_system_time)
+                    .field("pth_cpu_usage", &self.pth_cpu_usage)
+                    .field("pth_policy", &self.pth_policy)
+                    .field("pth_run_state", &self.pth_run_state)
+                    .field("pth_flags", &self.pth_flags)
+                    .field("pth_sleep_time", &self.pth_sleep_time)
+                    .field("pth_curpri", &self.pth_curpri)
+                    .field("pth_priority", &self.pth_priority)
+                    .field("pth_maxpriority", &self.pth_maxpriority)
+                      // FIXME: .field("pth_name", &self.pth_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for proc_threadinfo {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.pth_user_time.hash(state);
+                self.pth_system_time.hash(state);
+                self.pth_cpu_usage.hash(state);
+                self.pth_policy.hash(state);
+                self.pth_run_state.hash(state);
+                self.pth_flags.hash(state);
+                self.pth_sleep_time.hash(state);
+                self.pth_curpri.hash(state);
+                self.pth_priority.hash(state);
+                self.pth_maxpriority.hash(state);
+                self.pth_name.hash(state);
+            }
+        }
+
+        impl PartialEq for statfs {
+            fn eq(&self, other: &statfs) -> bool {
+                self.f_bsize == other.f_bsize
+                    && self.f_iosize == other.f_iosize
+                    && self.f_blocks == other.f_blocks
+                    && self.f_bfree == other.f_bfree
+                    && self.f_bavail == other.f_bavail
+                    && self.f_files == other.f_files
+                    && self.f_ffree == other.f_ffree
+                    && self.f_fsid == other.f_fsid
+                    && self.f_owner == other.f_owner
+                    && self.f_flags == other.f_flags
+                    && self.f_fssubtype == other.f_fssubtype
+                    && self.f_fstypename == other.f_fstypename
+                    && self.f_type == other.f_type
+                    && self
+                    .f_mntonname
+                    .iter()
+                    .zip(other.f_mntonname.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .f_mntfromname
+                    .iter()
+                    .zip(other.f_mntfromname.iter())
+                    .all(|(a,b)| a == b)
+                    && self.f_reserved == other.f_reserved
+            }
+        }
+
+        impl Eq for statfs {}
+        impl ::fmt::Debug for statfs {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("statfs")
+                    .field("f_bsize", &self.f_bsize)
+                    .field("f_iosize", &self.f_iosize)
+                    .field("f_blocks", &self.f_blocks)
+                    .field("f_bfree", &self.f_bfree)
+                    .field("f_bavail", &self.f_bavail)
+                    .field("f_files", &self.f_files)
+                    .field("f_ffree", &self.f_ffree)
+                    .field("f_fsid", &self.f_fsid)
+                    .field("f_owner", &self.f_owner)
+                    .field("f_flags", &self.f_flags)
+                    .field("f_fssubtype", &self.f_fssubtype)
+                    .field("f_fstypename", &self.f_fstypename)
+                    .field("f_type", &self.f_type)
+                // FIXME: .field("f_mntonname", &self.f_mntonname)
+                // FIXME: .field("f_mntfromname", &self.f_mntfromname)
+                    .field("f_reserved", &self.f_reserved)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for statfs {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.f_bsize.hash(state);
+                self.f_iosize.hash(state);
+                self.f_blocks.hash(state);
+                self.f_bfree.hash(state);
+                self.f_bavail.hash(state);
+                self.f_files.hash(state);
+                self.f_ffree.hash(state);
+                self.f_fsid.hash(state);
+                self.f_owner.hash(state);
+                self.f_flags.hash(state);
+                self.f_fssubtype.hash(state);
+                self.f_fstypename.hash(state);
+                self.f_type.hash(state);
+                self.f_mntonname.hash(state);
+                self.f_mntfromname.hash(state);
+                self.f_reserved.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_seekoff == other.d_seekoff
+                    && self.d_reclen == other.d_reclen
+                    && self.d_namlen == other.d_namlen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_seekoff", &self.d_seekoff)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_namlen", &self.d_namlen)
+                    .field("d_type", &self.d_type)
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_seekoff.hash(state);
+                self.d_reclen.hash(state);
+                self.d_namlen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+        impl PartialEq for pthread_rwlock_t {
+            fn eq(&self, other: &pthread_rwlock_t) -> bool {
+                self.__sig == other.__sig
+                    && self.
+                    __opaque
+                    .iter()
+                    .zip(other.__opaque.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for pthread_rwlock_t {}
+        impl ::fmt::Debug for pthread_rwlock_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_rwlock_t")
+                    .field("__sig", &self.__sig)
+                    // FIXME: .field("__opaque", &self.__opaque)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for pthread_rwlock_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.__sig.hash(state);
+                self.__opaque.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_mutex_t {
+            fn eq(&self, other: &pthread_mutex_t) -> bool {
+                self.__sig == other.__sig
+                    && self.
+                    __opaque
+                    .iter()
+                    .zip(other.__opaque.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_mutex_t {}
+
+        impl ::fmt::Debug for pthread_mutex_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_mutex_t")
+                    .field("__sig", &self.__sig)
+                    // FIXME: .field("__opaque", &self.__opaque)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for pthread_mutex_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.__sig.hash(state);
+                self.__opaque.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_cond_t {
+            fn eq(&self, other: &pthread_cond_t) -> bool {
+                self.__sig == other.__sig
+                    && self.
+                    __opaque
+                    .iter()
+                    .zip(other.__opaque.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_cond_t {}
+
+        impl ::fmt::Debug for pthread_cond_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_cond_t")
+                    .field("__sig", &self.__sig)
+                    // FIXME: .field("__opaque", &self.__opaque)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for pthread_cond_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.__sig.hash(state);
+                self.__opaque.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_len == other.ss_len
+                    && self.ss_family == other.ss_family
+                    && self
+                    .__ss_pad1
+                    .iter()
+                    .zip(other.__ss_pad1.iter())
+                    .all(|(a, b)| a == b)
+                    && self.__ss_align == other.__ss_align
+                    && self
+                    .__ss_pad2
+                    .iter()
+                    .zip(other.__ss_pad2.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+
+        impl Eq for sockaddr_storage {}
+
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_len", &self.ss_len)
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_pad1", &self.__ss_pad1)
+                    .field("__ss_align", &self.__ss_align)
+                    // FIXME: .field("__ss_pad2", &self.__ss_pad2)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_len.hash(state);
+                self.ss_family.hash(state);
+                self.__ss_pad1.hash(state);
+                self.__ss_align.hash(state);
+                self.__ss_pad2.hash(state);
+            }
+        }
+
+        impl PartialEq for utmpx {
+            fn eq(&self, other: &utmpx) -> bool {
+                self.ut_user
+                    .iter()
+                    .zip(other.ut_user.iter())
+                    .all(|(a,b)| a == b)
+                    && self.ut_id == other.ut_id
+                    && self.ut_line == other.ut_line
+                    && self.ut_pid == other.ut_pid
+                    && self.ut_type == other.ut_type
+                    && self.ut_tv == other.ut_tv
+                    && self
+                    .ut_host
+                    .iter()
+                    .zip(other.ut_host.iter())
+                    .all(|(a,b)| a == b)
+                    && self.ut_pad == other.ut_pad
+            }
+        }
+
+        impl Eq for utmpx {}
+
+        impl ::fmt::Debug for utmpx {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmpx")
+                    // FIXME: .field("ut_user", &self.ut_user)
+                    .field("ut_id", &self.ut_id)
+                    .field("ut_line", &self.ut_line)
+                    .field("ut_pid", &self.ut_pid)
+                    .field("ut_type", &self.ut_type)
+                    .field("ut_tv", &self.ut_tv)
+                    // FIXME: .field("ut_host", &self.ut_host)
+                    .field("ut_pad", &self.ut_pad)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utmpx {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_user.hash(state);
+                self.ut_id.hash(state);
+                self.ut_line.hash(state);
+                self.ut_pid.hash(state);
+                self.ut_type.hash(state);
+                self.ut_tv.hash(state);
+                self.ut_host.hash(state);
+                self.ut_pad.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_notify == other.sigev_notify
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_value == other.sigev_value
+                    && self.sigev_notify_attributes
+                        == other.sigev_notify_attributes
+            }
+        }
+
+        impl Eq for sigevent {}
+
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_value", &self.sigev_value)
+                    .field("sigev_notify_attributes",
+                           &self.sigev_notify_attributes)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_notify.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_value.hash(state);
+                self.sigev_notify_attributes.hash(state);
+            }
+        }
+    }
+}
+
+pub const _UTX_USERSIZE: usize = 256;
+pub const _UTX_LINESIZE: usize = 32;
+pub const _UTX_IDSIZE: usize = 4;
+pub const _UTX_HOSTSIZE: usize = 256;
+
+pub const EMPTY: ::c_short = 0;
+pub const RUN_LVL: ::c_short = 1;
+pub const BOOT_TIME: ::c_short = 2;
+pub const OLD_TIME: ::c_short = 3;
+pub const NEW_TIME: ::c_short = 4;
+pub const INIT_PROCESS: ::c_short = 5;
+pub const LOGIN_PROCESS: ::c_short = 6;
+pub const USER_PROCESS: ::c_short = 7;
+pub const DEAD_PROCESS: ::c_short = 8;
+pub const ACCOUNTING: ::c_short = 9;
+pub const SIGNATURE: ::c_short = 10;
+pub const SHUTDOWN_TIME: ::c_short = 11;
+
+pub const LC_COLLATE_MASK: ::c_int = 1 << 0;
+pub const LC_CTYPE_MASK: ::c_int = 1 << 1;
+pub const LC_MESSAGES_MASK: ::c_int = 1 << 2;
+pub const LC_MONETARY_MASK: ::c_int = 1 << 3;
+pub const LC_NUMERIC_MASK: ::c_int = 1 << 4;
+pub const LC_TIME_MASK: ::c_int = 1 << 5;
+pub const LC_ALL_MASK: ::c_int = LC_COLLATE_MASK
+    | LC_CTYPE_MASK
+    | LC_MESSAGES_MASK
+    | LC_MONETARY_MASK
+    | LC_NUMERIC_MASK
+    | LC_TIME_MASK;
+
+pub const CODESET: ::nl_item = 0;
+pub const D_T_FMT: ::nl_item = 1;
+pub const D_FMT: ::nl_item = 2;
+pub const T_FMT: ::nl_item = 3;
+pub const T_FMT_AMPM: ::nl_item = 4;
+pub const AM_STR: ::nl_item = 5;
+pub const PM_STR: ::nl_item = 6;
+
+pub const DAY_1: ::nl_item = 7;
+pub const DAY_2: ::nl_item = 8;
+pub const DAY_3: ::nl_item = 9;
+pub const DAY_4: ::nl_item = 10;
+pub const DAY_5: ::nl_item = 11;
+pub const DAY_6: ::nl_item = 12;
+pub const DAY_7: ::nl_item = 13;
+
+pub const ABDAY_1: ::nl_item = 14;
+pub const ABDAY_2: ::nl_item = 15;
+pub const ABDAY_3: ::nl_item = 16;
+pub const ABDAY_4: ::nl_item = 17;
+pub const ABDAY_5: ::nl_item = 18;
+pub const ABDAY_6: ::nl_item = 19;
+pub const ABDAY_7: ::nl_item = 20;
+
+pub const MON_1: ::nl_item = 21;
+pub const MON_2: ::nl_item = 22;
+pub const MON_3: ::nl_item = 23;
+pub const MON_4: ::nl_item = 24;
+pub const MON_5: ::nl_item = 25;
+pub const MON_6: ::nl_item = 26;
+pub const MON_7: ::nl_item = 27;
+pub const MON_8: ::nl_item = 28;
+pub const MON_9: ::nl_item = 29;
+pub const MON_10: ::nl_item = 30;
+pub const MON_11: ::nl_item = 31;
+pub const MON_12: ::nl_item = 32;
+
+pub const ABMON_1: ::nl_item = 33;
+pub const ABMON_2: ::nl_item = 34;
+pub const ABMON_3: ::nl_item = 35;
+pub const ABMON_4: ::nl_item = 36;
+pub const ABMON_5: ::nl_item = 37;
+pub const ABMON_6: ::nl_item = 38;
+pub const ABMON_7: ::nl_item = 39;
+pub const ABMON_8: ::nl_item = 40;
+pub const ABMON_9: ::nl_item = 41;
+pub const ABMON_10: ::nl_item = 42;
+pub const ABMON_11: ::nl_item = 43;
+pub const ABMON_12: ::nl_item = 44;
+
+pub const CLOCK_REALTIME: ::clockid_t = 0;
+pub const CLOCK_MONOTONIC: ::clockid_t = 6;
+pub const CLOCK_PROCESS_CPUTIME_ID: ::clockid_t = 12;
+pub const CLOCK_THREAD_CPUTIME_ID: ::clockid_t = 16;
+
+pub const ERA: ::nl_item = 45;
+pub const ERA_D_FMT: ::nl_item = 46;
+pub const ERA_D_T_FMT: ::nl_item = 47;
+pub const ERA_T_FMT: ::nl_item = 48;
+pub const ALT_DIGITS: ::nl_item = 49;
+
+pub const RADIXCHAR: ::nl_item = 50;
+pub const THOUSEP: ::nl_item = 51;
+
+pub const YESEXPR: ::nl_item = 52;
+pub const NOEXPR: ::nl_item = 53;
+
+pub const YESSTR: ::nl_item = 54;
+pub const NOSTR: ::nl_item = 55;
+
+pub const CRNCYSTR: ::nl_item = 56;
+
+pub const D_MD_ORDER: ::nl_item = 57;
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const RAND_MAX: ::c_int = 2147483647;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 2;
+pub const _IOLBF: ::c_int = 1;
+pub const BUFSIZ: ::c_uint = 1024;
+pub const FOPEN_MAX: ::c_uint = 20;
+pub const FILENAME_MAX: ::c_uint = 1024;
+pub const L_tmpnam: ::c_uint = 1024;
+pub const TMP_MAX: ::c_uint = 308915776;
+pub const _PC_LINK_MAX: ::c_int = 1;
+pub const _PC_MAX_CANON: ::c_int = 2;
+pub const _PC_MAX_INPUT: ::c_int = 3;
+pub const _PC_NAME_MAX: ::c_int = 4;
+pub const _PC_PATH_MAX: ::c_int = 5;
+pub const _PC_PIPE_BUF: ::c_int = 6;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 7;
+pub const _PC_NO_TRUNC: ::c_int = 8;
+pub const _PC_VDISABLE: ::c_int = 9;
+pub const O_DSYNC: ::c_int = 0x400000;
+pub const O_NOCTTY: ::c_int = 0x20000;
+pub const O_CLOEXEC: ::c_int = 0x1000000;
+pub const O_DIRECTORY: ::c_int = 0x100000;
+pub const O_SYMLINK: ::c_int = 0x200000;
+pub const S_IFIFO: mode_t = 4096;
+pub const S_IFCHR: mode_t = 8192;
+pub const S_IFBLK: mode_t = 24576;
+pub const S_IFDIR: mode_t = 16384;
+pub const S_IFREG: mode_t = 32768;
+pub const S_IFLNK: mode_t = 40960;
+pub const S_IFSOCK: mode_t = 49152;
+pub const S_IFMT: mode_t = 61440;
+pub const S_IEXEC: mode_t = 64;
+pub const S_IWRITE: mode_t = 128;
+pub const S_IREAD: mode_t = 256;
+pub const S_IRWXU: mode_t = 448;
+pub const S_IXUSR: mode_t = 64;
+pub const S_IWUSR: mode_t = 128;
+pub const S_IRUSR: mode_t = 256;
+pub const S_IRWXG: mode_t = 56;
+pub const S_IXGRP: mode_t = 8;
+pub const S_IWGRP: mode_t = 16;
+pub const S_IRGRP: mode_t = 32;
+pub const S_IRWXO: mode_t = 7;
+pub const S_IXOTH: mode_t = 1;
+pub const S_IWOTH: mode_t = 2;
+pub const S_IROTH: mode_t = 4;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+pub const F_GETLK: ::c_int = 7;
+pub const F_SETLK: ::c_int = 8;
+pub const F_SETLKW: ::c_int = 9;
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGEMT: ::c_int = 7;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+
+pub const PROT_NONE: ::c_int = 0;
+pub const PROT_READ: ::c_int = 1;
+pub const PROT_WRITE: ::c_int = 2;
+pub const PROT_EXEC: ::c_int = 4;
+
+pub const PT_TRACE_ME: ::c_int = 0;
+pub const PT_READ_I: ::c_int = 1;
+pub const PT_READ_D: ::c_int = 2;
+pub const PT_READ_U: ::c_int = 3;
+pub const PT_WRITE_I: ::c_int = 4;
+pub const PT_WRITE_D: ::c_int = 5;
+pub const PT_WRITE_U: ::c_int = 6;
+pub const PT_CONTINUE: ::c_int = 7;
+pub const PT_KILL: ::c_int = 8;
+pub const PT_STEP: ::c_int = 9;
+pub const PT_ATTACH: ::c_int = 10;
+pub const PT_DETACH: ::c_int = 11;
+pub const PT_SIGEXC: ::c_int = 12;
+pub const PT_THUPDATE: ::c_int = 13;
+pub const PT_ATTACHEXC: ::c_int = 14;
+
+pub const PT_FORCEQUOTA: ::c_int = 30;
+pub const PT_DENY_ATTACH: ::c_int = 31;
+pub const PT_FIRSTMACH: ::c_int = 32;
+
+pub const MAP_FILE: ::c_int = 0x0000;
+pub const MAP_SHARED: ::c_int = 0x0001;
+pub const MAP_PRIVATE: ::c_int = 0x0002;
+pub const MAP_FIXED: ::c_int = 0x0010;
+pub const MAP_ANON: ::c_int = 0x1000;
+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;
+
+deprecated_mach! {
+    pub const VM_FLAGS_FIXED: ::c_int = 0x0000;
+    pub const VM_FLAGS_ANYWHERE: ::c_int = 0x0001;
+    pub const VM_FLAGS_PURGABLE: ::c_int = 0x0002;
+    pub const VM_FLAGS_RANDOM_ADDR: ::c_int = 0x0008;
+    pub const VM_FLAGS_NO_CACHE: ::c_int = 0x0010;
+    pub const VM_FLAGS_RESILIENT_CODESIGN: ::c_int = 0x0020;
+    pub const VM_FLAGS_RESILIENT_MEDIA: ::c_int = 0x0040;
+    pub const VM_FLAGS_OVERWRITE: ::c_int = 0x4000;
+    pub const VM_FLAGS_SUPERPAGE_MASK: ::c_int = 0x70000;
+    pub const VM_FLAGS_RETURN_DATA_ADDR: ::c_int = 0x100000;
+    pub const VM_FLAGS_RETURN_4K_DATA_ADDR: ::c_int = 0x800000;
+    pub const VM_FLAGS_ALIAS_MASK: ::c_int = 0xFF000000;
+    pub const VM_FLAGS_USER_ALLOCATE: ::c_int = 0xff07401f;
+    pub const VM_FLAGS_USER_MAP: ::c_int = 0xff97401f;
+    pub const VM_FLAGS_USER_REMAP: ::c_int = VM_FLAGS_FIXED |
+                                             VM_FLAGS_ANYWHERE |
+                                             VM_FLAGS_RANDOM_ADDR |
+                                             VM_FLAGS_OVERWRITE |
+                                             VM_FLAGS_RETURN_DATA_ADDR |
+                                             VM_FLAGS_RESILIENT_CODESIGN;
+
+    pub const VM_FLAGS_SUPERPAGE_SHIFT: ::c_int = 16;
+    pub const SUPERPAGE_NONE: ::c_int = 0;
+    pub const SUPERPAGE_SIZE_ANY: ::c_int = 1;
+    pub const VM_FLAGS_SUPERPAGE_NONE: ::c_int = SUPERPAGE_NONE <<
+                                                 VM_FLAGS_SUPERPAGE_SHIFT;
+    pub const VM_FLAGS_SUPERPAGE_SIZE_ANY: ::c_int = SUPERPAGE_SIZE_ANY <<
+                                                     VM_FLAGS_SUPERPAGE_SHIFT;
+    pub const SUPERPAGE_SIZE_2MB: ::c_int = 2;
+    pub const VM_FLAGS_SUPERPAGE_SIZE_2MB: ::c_int = SUPERPAGE_SIZE_2MB <<
+                                                     VM_FLAGS_SUPERPAGE_SHIFT;
+
+    pub const VM_MEMORY_MALLOC: ::c_int = 1;
+    pub const VM_MEMORY_MALLOC_SMALL: ::c_int = 2;
+    pub const VM_MEMORY_MALLOC_LARGE: ::c_int = 3;
+    pub const VM_MEMORY_MALLOC_HUGE: ::c_int = 4;
+    pub const VM_MEMORY_SBRK: ::c_int = 5;
+    pub const VM_MEMORY_REALLOC: ::c_int = 6;
+    pub const VM_MEMORY_MALLOC_TINY: ::c_int = 7;
+    pub const VM_MEMORY_MALLOC_LARGE_REUSABLE: ::c_int = 8;
+    pub const VM_MEMORY_MALLOC_LARGE_REUSED: ::c_int = 9;
+    pub const VM_MEMORY_ANALYSIS_TOOL: ::c_int = 10;
+    pub const VM_MEMORY_MALLOC_NANO: ::c_int = 11;
+    pub const VM_MEMORY_MACH_MSG: ::c_int = 20;
+    pub const VM_MEMORY_IOKIT: ::c_int = 21;
+    pub const VM_MEMORY_STACK: ::c_int = 30;
+    pub const VM_MEMORY_GUARD: ::c_int = 31;
+    pub const VM_MEMORY_SHARED_PMAP: ::c_int = 32;
+    pub const VM_MEMORY_DYLIB: ::c_int = 33;
+    pub const VM_MEMORY_OBJC_DISPATCHERS: ::c_int = 34;
+    pub const VM_MEMORY_UNSHARED_PMAP: ::c_int = 35;
+    pub const VM_MEMORY_APPKIT: ::c_int = 40;
+    pub const VM_MEMORY_FOUNDATION: ::c_int = 41;
+    pub const VM_MEMORY_COREGRAPHICS: ::c_int = 42;
+    pub const VM_MEMORY_CORESERVICES: ::c_int = 43;
+    pub const VM_MEMORY_CARBON: ::c_int = VM_MEMORY_CORESERVICES;
+    pub const VM_MEMORY_JAVA: ::c_int = 44;
+    pub const VM_MEMORY_COREDATA: ::c_int = 45;
+    pub const VM_MEMORY_COREDATA_OBJECTIDS: ::c_int = 46;
+    pub const VM_MEMORY_ATS: ::c_int = 50;
+    pub const VM_MEMORY_LAYERKIT: ::c_int = 51;
+    pub const VM_MEMORY_CGIMAGE: ::c_int = 52;
+    pub const VM_MEMORY_TCMALLOC: ::c_int = 53;
+    pub const VM_MEMORY_COREGRAPHICS_DATA: ::c_int = 54;
+    pub const VM_MEMORY_COREGRAPHICS_SHARED: ::c_int = 55;
+    pub const VM_MEMORY_COREGRAPHICS_FRAMEBUFFERS: ::c_int = 56;
+    pub const VM_MEMORY_COREGRAPHICS_BACKINGSTORES: ::c_int = 57;
+    pub const VM_MEMORY_COREGRAPHICS_XALLOC: ::c_int = 58;
+    pub const VM_MEMORY_COREGRAPHICS_MISC: ::c_int = VM_MEMORY_COREGRAPHICS;
+    pub const VM_MEMORY_DYLD: ::c_int = 60;
+    pub const VM_MEMORY_DYLD_MALLOC: ::c_int = 61;
+    pub const VM_MEMORY_SQLITE: ::c_int = 62;
+    pub const VM_MEMORY_JAVASCRIPT_CORE: ::c_int = 63;
+    pub const VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR: ::c_int = 64;
+    pub const VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE: ::c_int = 65;
+    pub const VM_MEMORY_GLSL: ::c_int = 66;
+    pub const VM_MEMORY_OPENCL: ::c_int = 67;
+    pub const VM_MEMORY_COREIMAGE: ::c_int = 68;
+    pub const VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS: ::c_int = 69;
+    pub const VM_MEMORY_IMAGEIO: ::c_int = 70;
+    pub const VM_MEMORY_COREPROFILE: ::c_int = 71;
+    pub const VM_MEMORY_ASSETSD: ::c_int = 72;
+    pub const VM_MEMORY_OS_ALLOC_ONCE: ::c_int = 73;
+    pub const VM_MEMORY_LIBDISPATCH: ::c_int = 74;
+    pub const VM_MEMORY_ACCELERATE: ::c_int = 75;
+    pub const VM_MEMORY_COREUI: ::c_int = 76;
+    pub const VM_MEMORY_COREUIFILE: ::c_int = 77;
+    pub const VM_MEMORY_GENEALOGY: ::c_int = 78;
+    pub const VM_MEMORY_RAWCAMERA: ::c_int = 79;
+    pub const VM_MEMORY_CORPSEINFO: ::c_int = 80;
+    pub const VM_MEMORY_ASL: ::c_int = 81;
+    pub const VM_MEMORY_SWIFT_RUNTIME: ::c_int = 82;
+    pub const VM_MEMORY_SWIFT_METADATA: ::c_int = 83;
+    pub const VM_MEMORY_DHMM: ::c_int = 84;
+    pub const VM_MEMORY_SCENEKIT: ::c_int = 86;
+    pub const VM_MEMORY_SKYWALK: ::c_int = 87;
+    pub const VM_MEMORY_APPLICATION_SPECIFIC_1: ::c_int = 240;
+    pub const VM_MEMORY_APPLICATION_SPECIFIC_16: ::c_int = 255;
+}
+
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const MS_ASYNC: ::c_int = 0x0001;
+pub const MS_INVALIDATE: ::c_int = 0x0002;
+pub const MS_SYNC: ::c_int = 0x0010;
+
+pub const MS_KILLPAGES: ::c_int = 0x0004;
+pub const MS_DEACTIVATE: ::c_int = 0x0008;
+
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EDEADLK: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EAGAIN: ::c_int = 35;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+pub const EINPROGRESS: ::c_int = 36;
+pub const EALREADY: ::c_int = 37;
+pub const ENOTSOCK: ::c_int = 38;
+pub const EDESTADDRREQ: ::c_int = 39;
+pub const EMSGSIZE: ::c_int = 40;
+pub const EPROTOTYPE: ::c_int = 41;
+pub const ENOPROTOOPT: ::c_int = 42;
+pub const EPROTONOSUPPORT: ::c_int = 43;
+pub const ESOCKTNOSUPPORT: ::c_int = 44;
+pub const ENOTSUP: ::c_int = 45;
+pub const EPFNOSUPPORT: ::c_int = 46;
+pub const EAFNOSUPPORT: ::c_int = 47;
+pub const EADDRINUSE: ::c_int = 48;
+pub const EADDRNOTAVAIL: ::c_int = 49;
+pub const ENETDOWN: ::c_int = 50;
+pub const ENETUNREACH: ::c_int = 51;
+pub const ENETRESET: ::c_int = 52;
+pub const ECONNABORTED: ::c_int = 53;
+pub const ECONNRESET: ::c_int = 54;
+pub const ENOBUFS: ::c_int = 55;
+pub const EISCONN: ::c_int = 56;
+pub const ENOTCONN: ::c_int = 57;
+pub const ESHUTDOWN: ::c_int = 58;
+pub const ETOOMANYREFS: ::c_int = 59;
+pub const ETIMEDOUT: ::c_int = 60;
+pub const ECONNREFUSED: ::c_int = 61;
+pub const ELOOP: ::c_int = 62;
+pub const ENAMETOOLONG: ::c_int = 63;
+pub const EHOSTDOWN: ::c_int = 64;
+pub const EHOSTUNREACH: ::c_int = 65;
+pub const ENOTEMPTY: ::c_int = 66;
+pub const EPROCLIM: ::c_int = 67;
+pub const EUSERS: ::c_int = 68;
+pub const EDQUOT: ::c_int = 69;
+pub const ESTALE: ::c_int = 70;
+pub const EREMOTE: ::c_int = 71;
+pub const EBADRPC: ::c_int = 72;
+pub const ERPCMISMATCH: ::c_int = 73;
+pub const EPROGUNAVAIL: ::c_int = 74;
+pub const EPROGMISMATCH: ::c_int = 75;
+pub const EPROCUNAVAIL: ::c_int = 76;
+pub const ENOLCK: ::c_int = 77;
+pub const ENOSYS: ::c_int = 78;
+pub const EFTYPE: ::c_int = 79;
+pub const EAUTH: ::c_int = 80;
+pub const ENEEDAUTH: ::c_int = 81;
+pub const EPWROFF: ::c_int = 82;
+pub const EDEVERR: ::c_int = 83;
+pub const EOVERFLOW: ::c_int = 84;
+pub const EBADEXEC: ::c_int = 85;
+pub const EBADARCH: ::c_int = 86;
+pub const ESHLIBVERS: ::c_int = 87;
+pub const EBADMACHO: ::c_int = 88;
+pub const ECANCELED: ::c_int = 89;
+pub const EIDRM: ::c_int = 90;
+pub const ENOMSG: ::c_int = 91;
+pub const EILSEQ: ::c_int = 92;
+pub const ENOATTR: ::c_int = 93;
+pub const EBADMSG: ::c_int = 94;
+pub const EMULTIHOP: ::c_int = 95;
+pub const ENODATA: ::c_int = 96;
+pub const ENOLINK: ::c_int = 97;
+pub const ENOSR: ::c_int = 98;
+pub const ENOSTR: ::c_int = 99;
+pub const EPROTO: ::c_int = 100;
+pub const ETIME: ::c_int = 101;
+pub const EOPNOTSUPP: ::c_int = 102;
+pub const ENOPOLICY: ::c_int = 103;
+pub const ENOTRECOVERABLE: ::c_int = 104;
+pub const EOWNERDEAD: ::c_int = 105;
+pub const EQFULL: ::c_int = 106;
+pub const ELAST: ::c_int = 106;
+
+pub const EAI_AGAIN: ::c_int = 2;
+pub const EAI_BADFLAGS: ::c_int = 3;
+pub const EAI_FAIL: ::c_int = 4;
+pub const EAI_FAMILY: ::c_int = 5;
+pub const EAI_MEMORY: ::c_int = 6;
+pub const EAI_NODATA: ::c_int = 7;
+pub const EAI_NONAME: ::c_int = 8;
+pub const EAI_SERVICE: ::c_int = 9;
+pub const EAI_SOCKTYPE: ::c_int = 10;
+pub const EAI_SYSTEM: ::c_int = 11;
+pub const EAI_OVERFLOW: ::c_int = 14;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_DUPFD_CLOEXEC: ::c_int = 67;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+pub const F_PREALLOCATE: ::c_int = 42;
+pub const F_RDADVISE: ::c_int = 44;
+pub const F_RDAHEAD: ::c_int = 45;
+pub const F_NOCACHE: ::c_int = 48;
+pub const F_GETPATH: ::c_int = 50;
+pub const F_FULLFSYNC: ::c_int = 51;
+pub const F_FREEZE_FS: ::c_int = 53;
+pub const F_THAW_FS: ::c_int = 54;
+pub const F_GLOBAL_NOCACHE: ::c_int = 55;
+pub const F_NODIRECT: ::c_int = 62;
+
+pub const F_ALLOCATECONTIG: ::c_uint = 0x02;
+pub const F_ALLOCATEALL: ::c_uint = 0x04;
+
+pub const F_PEOFPOSMODE: ::c_int = 3;
+pub const F_VOLPOSMODE: ::c_int = 4;
+
+pub const AT_FDCWD: ::c_int = -2;
+pub const AT_EACCESS: ::c_int = 0x0010;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x0020;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x0040;
+pub const AT_REMOVEDIR: ::c_int = 0x0080;
+
+pub const TIOCMODG: ::c_ulong = 0x40047403;
+pub const TIOCMODS: ::c_ulong = 0x80047404;
+pub const TIOCM_LE: ::c_int = 0x1;
+pub const TIOCM_DTR: ::c_int = 0x2;
+pub const TIOCM_RTS: ::c_int = 0x4;
+pub const TIOCM_ST: ::c_int = 0x8;
+pub const TIOCM_SR: ::c_int = 0x10;
+pub const TIOCM_CTS: ::c_int = 0x20;
+pub const TIOCM_CAR: ::c_int = 0x40;
+pub const TIOCM_CD: ::c_int = 0x40;
+pub const TIOCM_RNG: ::c_int = 0x80;
+pub const TIOCM_RI: ::c_int = 0x80;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCEXCL: ::c_int = 0x2000740d;
+pub const TIOCNXCL: ::c_int = 0x2000740e;
+pub const TIOCFLUSH: ::c_ulong = 0x80047410;
+pub const TIOCGETD: ::c_ulong = 0x4004741a;
+pub const TIOCSETD: ::c_ulong = 0x8004741b;
+pub const TIOCIXON: ::c_uint = 0x20007481;
+pub const TIOCIXOFF: ::c_uint = 0x20007480;
+pub const TIOCSDTR: ::c_uint = 0x20007479;
+pub const TIOCCDTR: ::c_uint = 0x20007478;
+pub const TIOCGPGRP: ::c_ulong = 0x40047477;
+pub const TIOCSPGRP: ::c_ulong = 0x80047476;
+pub const TIOCOUTQ: ::c_ulong = 0x40047473;
+pub const TIOCSTI: ::c_ulong = 0x80017472;
+pub const TIOCNOTTY: ::c_uint = 0x20007471;
+pub const TIOCPKT: ::c_ulong = 0x80047470;
+pub const TIOCPKT_DATA: ::c_int = 0x0;
+pub const TIOCPKT_FLUSHREAD: ::c_int = 0x1;
+pub const TIOCPKT_FLUSHWRITE: ::c_int = 0x2;
+pub const TIOCPKT_STOP: ::c_int = 0x4;
+pub const TIOCPKT_START: ::c_int = 0x8;
+pub const TIOCPKT_NOSTOP: ::c_int = 0x10;
+pub const TIOCPKT_DOSTOP: ::c_int = 0x20;
+pub const TIOCPKT_IOCTL: ::c_int = 0x40;
+pub const TIOCSTOP: ::c_uint = 0x2000746f;
+pub const TIOCSTART: ::c_uint = 0x2000746e;
+pub const TIOCMSET: ::c_ulong = 0x8004746d;
+pub const TIOCMBIS: ::c_ulong = 0x8004746c;
+pub const TIOCMBIC: ::c_ulong = 0x8004746b;
+pub const TIOCMGET: ::c_ulong = 0x4004746a;
+pub const TIOCREMOTE: ::c_ulong = 0x80047469;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const TIOCUCNTL: ::c_ulong = 0x80047466;
+pub const TIOCSTAT: ::c_uint = 0x20007465;
+pub const TIOCSCONS: ::c_uint = 0x20007463;
+pub const TIOCCONS: ::c_ulong = 0x80047462;
+pub const TIOCSCTTY: ::c_uint = 0x20007461;
+pub const TIOCEXT: ::c_ulong = 0x80047460;
+pub const TIOCSIG: ::c_uint = 0x2000745f;
+pub const TIOCDRAIN: ::c_uint = 0x2000745e;
+pub const TIOCMSDTRWAIT: ::c_ulong = 0x8004745b;
+pub const TIOCMGDTRWAIT: ::c_ulong = 0x4004745a;
+pub const TIOCSDRAINWAIT: ::c_ulong = 0x80047457;
+pub const TIOCGDRAINWAIT: ::c_ulong = 0x40047456;
+pub const TIOCDSIMICROCODE: ::c_uint = 0x20007455;
+pub const TIOCPTYGRANT: ::c_uint = 0x20007454;
+pub const TIOCPTYGNAME: ::c_uint = 0x40807453;
+pub const TIOCPTYUNLK: ::c_uint = 0x20007452;
+
+pub const BIOCGRSIG: ::c_ulong = 0x40044272;
+pub const BIOCSRSIG: ::c_ulong = 0x80044273;
+pub const BIOCSDLT: ::c_ulong = 0x80044278;
+pub const BIOCGSEESENT: ::c_ulong = 0x40044276;
+pub const BIOCSSEESENT: ::c_ulong = 0x80044277;
+pub const BIOCGDLTLIST: ::c_ulong = 0xc00c4279;
+
+pub const FIODTYPE: ::c_ulong = 0x4004667a;
+
+pub const B0: speed_t = 0;
+pub const B50: speed_t = 50;
+pub const B75: speed_t = 75;
+pub const B110: speed_t = 110;
+pub const B134: speed_t = 134;
+pub const B150: speed_t = 150;
+pub const B200: speed_t = 200;
+pub const B300: speed_t = 300;
+pub const B600: speed_t = 600;
+pub const B1200: speed_t = 1200;
+pub const B1800: speed_t = 1800;
+pub const B2400: speed_t = 2400;
+pub const B4800: speed_t = 4800;
+pub const B9600: speed_t = 9600;
+pub const B19200: speed_t = 19200;
+pub const B38400: speed_t = 38400;
+pub const B7200: speed_t = 7200;
+pub const B14400: speed_t = 14400;
+pub const B28800: speed_t = 28800;
+pub const B57600: speed_t = 57600;
+pub const B76800: speed_t = 76800;
+pub const B115200: speed_t = 115200;
+pub const B230400: speed_t = 230400;
+pub const EXTA: speed_t = 19200;
+pub const EXTB: speed_t = 38400;
+
+pub const SIGTRAP: ::c_int = 5;
+
+pub const GLOB_APPEND: ::c_int = 0x0001;
+pub const GLOB_DOOFFS: ::c_int = 0x0002;
+pub const GLOB_ERR: ::c_int = 0x0004;
+pub const GLOB_MARK: ::c_int = 0x0008;
+pub const GLOB_NOCHECK: ::c_int = 0x0010;
+pub const GLOB_NOSORT: ::c_int = 0x0020;
+pub const GLOB_NOESCAPE: ::c_int = 0x2000;
+
+pub const GLOB_NOSPACE: ::c_int = -1;
+pub const GLOB_ABORTED: ::c_int = -2;
+pub const GLOB_NOMATCH: ::c_int = -3;
+
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+
+pub const _SC_IOV_MAX: ::c_int = 56;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 70;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 71;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 73;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 75;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 82;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 83;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 85;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 86;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 87;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 88;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 89;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 90;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 91;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 93;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 94;
+pub const _SC_THREADS: ::c_int = 96;
+pub const _SC_TTY_NAME_MAX: ::c_int = 101;
+pub const _SC_ATEXIT_MAX: ::c_int = 107;
+pub const _SC_XOPEN_CRYPT: ::c_int = 108;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 109;
+pub const _SC_XOPEN_LEGACY: ::c_int = 110;
+pub const _SC_XOPEN_REALTIME: ::c_int = 111;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 112;
+pub const _SC_XOPEN_SHM: ::c_int = 113;
+pub const _SC_XOPEN_UNIX: ::c_int = 115;
+pub const _SC_XOPEN_VERSION: ::c_int = 116;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 121;
+pub const _SC_PHYS_PAGES: ::c_int = 200;
+
+pub const PTHREAD_PROCESS_PRIVATE: ::c_int = 2;
+pub const PTHREAD_PROCESS_SHARED: ::c_int = 1;
+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 1;
+pub const PTHREAD_CREATE_DETACHED: ::c_int = 2;
+#[cfg(target_arch = "aarch64")]
+pub const PTHREAD_STACK_MIN: ::size_t = 16384;
+#[cfg(not(target_arch = "aarch64"))]
+pub const PTHREAD_STACK_MIN: ::size_t = 8192;
+
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_AS: ::c_int = 5;
+pub const RLIMIT_RSS: ::c_int = RLIMIT_AS;
+pub const RLIMIT_MEMLOCK: ::c_int = 6;
+pub const RLIMIT_NPROC: ::c_int = 7;
+pub const RLIMIT_NOFILE: ::c_int = 8;
+#[deprecated(since = "0.2.64", note = "Not stable across OS versions")]
+pub const RLIM_NLIMITS: ::c_int = 9;
+pub const _RLIMIT_POSIX_FLAG: ::c_int = 0x1000;
+
+pub const RLIM_INFINITY: rlim_t = 0x7fff_ffff_ffff_ffff;
+
+pub const RUSAGE_SELF: ::c_int = 0;
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const MADV_NORMAL: ::c_int = 0;
+pub const MADV_RANDOM: ::c_int = 1;
+pub const MADV_SEQUENTIAL: ::c_int = 2;
+pub const MADV_WILLNEED: ::c_int = 3;
+pub const MADV_DONTNEED: ::c_int = 4;
+pub const MADV_FREE: ::c_int = 5;
+pub const MADV_ZERO_WIRED_PAGES: ::c_int = 6;
+pub const MADV_FREE_REUSABLE: ::c_int = 7;
+pub const MADV_FREE_REUSE: ::c_int = 8;
+pub const MADV_CAN_REUSE: ::c_int = 9;
+
+pub const MINCORE_INCORE: ::c_int = 0x1;
+pub const MINCORE_REFERENCED: ::c_int = 0x2;
+pub const MINCORE_MODIFIED: ::c_int = 0x4;
+pub const MINCORE_REFERENCED_OTHER: ::c_int = 0x8;
+pub const MINCORE_MODIFIED_OTHER: ::c_int = 0x10;
+
+//
+// sys/netinet/in.h
+// Protocols (RFC 1700)
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+// IPPROTO_IP defined in src/unix/mod.rs
+/// IP6 hop-by-hop options
+pub const IPPROTO_HOPOPTS: ::c_int = 0;
+// IPPROTO_ICMP defined in src/unix/mod.rs
+/// group mgmt protocol
+pub const IPPROTO_IGMP: ::c_int = 2;
+/// gateway<sup>2</sup> (deprecated)
+pub const IPPROTO_GGP: ::c_int = 3;
+/// for compatibility
+pub const IPPROTO_IPIP: ::c_int = 4;
+// IPPROTO_TCP defined in src/unix/mod.rs
+/// Stream protocol II.
+pub const IPPROTO_ST: ::c_int = 7;
+/// exterior gateway protocol
+pub const IPPROTO_EGP: ::c_int = 8;
+/// private interior gateway
+pub const IPPROTO_PIGP: ::c_int = 9;
+/// BBN RCC Monitoring
+pub const IPPROTO_RCCMON: ::c_int = 10;
+/// network voice protocol
+pub const IPPROTO_NVPII: ::c_int = 11;
+/// pup
+pub const IPPROTO_PUP: ::c_int = 12;
+/// Argus
+pub const IPPROTO_ARGUS: ::c_int = 13;
+/// EMCON
+pub const IPPROTO_EMCON: ::c_int = 14;
+/// Cross Net Debugger
+pub const IPPROTO_XNET: ::c_int = 15;
+/// Chaos
+pub const IPPROTO_CHAOS: ::c_int = 16;
+// IPPROTO_UDP defined in src/unix/mod.rs
+/// Multiplexing
+pub const IPPROTO_MUX: ::c_int = 18;
+/// DCN Measurement Subsystems
+pub const IPPROTO_MEAS: ::c_int = 19;
+/// Host Monitoring
+pub const IPPROTO_HMP: ::c_int = 20;
+/// Packet Radio Measurement
+pub const IPPROTO_PRM: ::c_int = 21;
+/// xns idp
+pub const IPPROTO_IDP: ::c_int = 22;
+/// Trunk-1
+pub const IPPROTO_TRUNK1: ::c_int = 23;
+/// Trunk-2
+pub const IPPROTO_TRUNK2: ::c_int = 24;
+/// Leaf-1
+pub const IPPROTO_LEAF1: ::c_int = 25;
+/// Leaf-2
+pub const IPPROTO_LEAF2: ::c_int = 26;
+/// Reliable Data
+pub const IPPROTO_RDP: ::c_int = 27;
+/// Reliable Transaction
+pub const IPPROTO_IRTP: ::c_int = 28;
+/// tp-4 w/ class negotiation
+pub const IPPROTO_TP: ::c_int = 29;
+/// Bulk Data Transfer
+pub const IPPROTO_BLT: ::c_int = 30;
+/// Network Services
+pub const IPPROTO_NSP: ::c_int = 31;
+/// Merit Internodal
+pub const IPPROTO_INP: ::c_int = 32;
+/// Sequential Exchange
+pub const IPPROTO_SEP: ::c_int = 33;
+/// Third Party Connect
+pub const IPPROTO_3PC: ::c_int = 34;
+/// InterDomain Policy Routing
+pub const IPPROTO_IDPR: ::c_int = 35;
+/// XTP
+pub const IPPROTO_XTP: ::c_int = 36;
+/// Datagram Delivery
+pub const IPPROTO_DDP: ::c_int = 37;
+/// Control Message Transport
+pub const IPPROTO_CMTP: ::c_int = 38;
+/// TP++ Transport
+pub const IPPROTO_TPXX: ::c_int = 39;
+/// IL transport protocol
+pub const IPPROTO_IL: ::c_int = 40;
+// IPPROTO_IPV6 defined in src/unix/mod.rs
+/// Source Demand Routing
+pub const IPPROTO_SDRP: ::c_int = 42;
+/// IP6 routing header
+pub const IPPROTO_ROUTING: ::c_int = 43;
+/// IP6 fragmentation header
+pub const IPPROTO_FRAGMENT: ::c_int = 44;
+/// InterDomain Routing
+pub const IPPROTO_IDRP: ::c_int = 45;
+/// resource reservation
+pub const IPPROTO_RSVP: ::c_int = 46;
+/// General Routing Encap.
+pub const IPPROTO_GRE: ::c_int = 47;
+/// Mobile Host Routing
+pub const IPPROTO_MHRP: ::c_int = 48;
+/// BHA
+pub const IPPROTO_BHA: ::c_int = 49;
+/// IP6 Encap Sec. Payload
+pub const IPPROTO_ESP: ::c_int = 50;
+/// IP6 Auth Header
+pub const IPPROTO_AH: ::c_int = 51;
+/// Integ. Net Layer Security
+pub const IPPROTO_INLSP: ::c_int = 52;
+/// IP with encryption
+pub const IPPROTO_SWIPE: ::c_int = 53;
+/// Next Hop Resolution
+pub const IPPROTO_NHRP: ::c_int = 54;
+/* 55-57: Unassigned */
+// IPPROTO_ICMPV6 defined in src/unix/mod.rs
+/// IP6 no next header
+pub const IPPROTO_NONE: ::c_int = 59;
+/// IP6 destination option
+pub const IPPROTO_DSTOPTS: ::c_int = 60;
+/// any host internal protocol
+pub const IPPROTO_AHIP: ::c_int = 61;
+/// CFTP
+pub const IPPROTO_CFTP: ::c_int = 62;
+/// "hello" routing protocol
+pub const IPPROTO_HELLO: ::c_int = 63;
+/// SATNET/Backroom EXPAK
+pub const IPPROTO_SATEXPAK: ::c_int = 64;
+/// Kryptolan
+pub const IPPROTO_KRYPTOLAN: ::c_int = 65;
+/// Remote Virtual Disk
+pub const IPPROTO_RVD: ::c_int = 66;
+/// Pluribus Packet Core
+pub const IPPROTO_IPPC: ::c_int = 67;
+/// Any distributed FS
+pub const IPPROTO_ADFS: ::c_int = 68;
+/// Satnet Monitoring
+pub const IPPROTO_SATMON: ::c_int = 69;
+/// VISA Protocol
+pub const IPPROTO_VISA: ::c_int = 70;
+/// Packet Core Utility
+pub const IPPROTO_IPCV: ::c_int = 71;
+/// Comp. Prot. Net. Executive
+pub const IPPROTO_CPNX: ::c_int = 72;
+/// Comp. Prot. HeartBeat
+pub const IPPROTO_CPHB: ::c_int = 73;
+/// Wang Span Network
+pub const IPPROTO_WSN: ::c_int = 74;
+/// Packet Video Protocol
+pub const IPPROTO_PVP: ::c_int = 75;
+/// BackRoom SATNET Monitoring
+pub const IPPROTO_BRSATMON: ::c_int = 76;
+/// Sun net disk proto (temp.)
+pub const IPPROTO_ND: ::c_int = 77;
+/// WIDEBAND Monitoring
+pub const IPPROTO_WBMON: ::c_int = 78;
+/// WIDEBAND EXPAK
+pub const IPPROTO_WBEXPAK: ::c_int = 79;
+/// ISO cnlp
+pub const IPPROTO_EON: ::c_int = 80;
+/// VMTP
+pub const IPPROTO_VMTP: ::c_int = 81;
+/// Secure VMTP
+pub const IPPROTO_SVMTP: ::c_int = 82;
+/// Banyon VINES
+pub const IPPROTO_VINES: ::c_int = 83;
+/// TTP
+pub const IPPROTO_TTP: ::c_int = 84;
+/// NSFNET-IGP
+pub const IPPROTO_IGP: ::c_int = 85;
+/// dissimilar gateway prot.
+pub const IPPROTO_DGP: ::c_int = 86;
+/// TCF
+pub const IPPROTO_TCF: ::c_int = 87;
+/// Cisco/GXS IGRP
+pub const IPPROTO_IGRP: ::c_int = 88;
+/// OSPFIGP
+pub const IPPROTO_OSPFIGP: ::c_int = 89;
+/// Strite RPC protocol
+pub const IPPROTO_SRPC: ::c_int = 90;
+/// Locus Address Resoloution
+pub const IPPROTO_LARP: ::c_int = 91;
+/// Multicast Transport
+pub const IPPROTO_MTP: ::c_int = 92;
+/// AX.25 Frames
+pub const IPPROTO_AX25: ::c_int = 93;
+/// IP encapsulated in IP
+pub const IPPROTO_IPEIP: ::c_int = 94;
+/// Mobile Int.ing control
+pub const IPPROTO_MICP: ::c_int = 95;
+/// Semaphore Comm. security
+pub const IPPROTO_SCCSP: ::c_int = 96;
+/// Ethernet IP encapsulation
+pub const IPPROTO_ETHERIP: ::c_int = 97;
+/// encapsulation header
+pub const IPPROTO_ENCAP: ::c_int = 98;
+/// any private encr. scheme
+pub const IPPROTO_APES: ::c_int = 99;
+/// GMTP
+pub const IPPROTO_GMTP: ::c_int = 100;
+
+/* 101-254: Partly Unassigned */
+/// Protocol Independent Mcast
+pub const IPPROTO_PIM: ::c_int = 103;
+/// payload compression (IPComp)
+pub const IPPROTO_IPCOMP: ::c_int = 108;
+/// PGM
+pub const IPPROTO_PGM: ::c_int = 113;
+/// SCTP
+pub const IPPROTO_SCTP: ::c_int = 132;
+
+/* 255: Reserved */
+/* BSD Private, local use, namespace incursion */
+/// divert pseudo-protocol
+pub const IPPROTO_DIVERT: ::c_int = 254;
+/// raw IP packet
+pub const IPPROTO_RAW: ::c_int = 255;
+pub const IPPROTO_MAX: ::c_int = 256;
+/// last return value of *_input(), meaning "all job for this pkt is done".
+pub const IPPROTO_DONE: ::c_int = 257;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_LOCAL: ::c_int = 1;
+pub const AF_UNIX: ::c_int = AF_LOCAL;
+pub const AF_INET: ::c_int = 2;
+pub const AF_IMPLINK: ::c_int = 3;
+pub const AF_PUP: ::c_int = 4;
+pub const AF_CHAOS: ::c_int = 5;
+pub const AF_NS: ::c_int = 6;
+pub const AF_ISO: ::c_int = 7;
+pub const AF_OSI: ::c_int = AF_ISO;
+pub const AF_ECMA: ::c_int = 8;
+pub const AF_DATAKIT: ::c_int = 9;
+pub const AF_CCITT: ::c_int = 10;
+pub const AF_SNA: ::c_int = 11;
+pub const AF_DECnet: ::c_int = 12;
+pub const AF_DLI: ::c_int = 13;
+pub const AF_LAT: ::c_int = 14;
+pub const AF_HYLINK: ::c_int = 15;
+pub const AF_APPLETALK: ::c_int = 16;
+pub const AF_ROUTE: ::c_int = 17;
+pub const AF_LINK: ::c_int = 18;
+pub const pseudo_AF_XTP: ::c_int = 19;
+pub const AF_COIP: ::c_int = 20;
+pub const AF_CNT: ::c_int = 21;
+pub const pseudo_AF_RTIP: ::c_int = 22;
+pub const AF_IPX: ::c_int = 23;
+pub const AF_SIP: ::c_int = 24;
+pub const pseudo_AF_PIP: ::c_int = 25;
+pub const AF_ISDN: ::c_int = 28;
+pub const AF_E164: ::c_int = AF_ISDN;
+pub const pseudo_AF_KEY: ::c_int = 29;
+pub const AF_INET6: ::c_int = 30;
+pub const AF_NATM: ::c_int = 31;
+pub const AF_SYSTEM: ::c_int = 32;
+pub const AF_NETBIOS: ::c_int = 33;
+pub const AF_PPP: ::c_int = 34;
+pub const pseudo_AF_HDRCMPLT: ::c_int = 35;
+pub const AF_SYS_CONTROL: ::c_int = 2;
+
+pub const SYSPROTO_EVENT: ::c_int = 1;
+pub const SYSPROTO_CONTROL: ::c_int = 2;
+
+pub const PF_UNSPEC: ::c_int = AF_UNSPEC;
+pub const PF_LOCAL: ::c_int = AF_LOCAL;
+pub const PF_UNIX: ::c_int = PF_LOCAL;
+pub const PF_INET: ::c_int = AF_INET;
+pub const PF_IMPLINK: ::c_int = AF_IMPLINK;
+pub const PF_PUP: ::c_int = AF_PUP;
+pub const PF_CHAOS: ::c_int = AF_CHAOS;
+pub const PF_NS: ::c_int = AF_NS;
+pub const PF_ISO: ::c_int = AF_ISO;
+pub const PF_OSI: ::c_int = AF_ISO;
+pub const PF_ECMA: ::c_int = AF_ECMA;
+pub const PF_DATAKIT: ::c_int = AF_DATAKIT;
+pub const PF_CCITT: ::c_int = AF_CCITT;
+pub const PF_SNA: ::c_int = AF_SNA;
+pub const PF_DECnet: ::c_int = AF_DECnet;
+pub const PF_DLI: ::c_int = AF_DLI;
+pub const PF_LAT: ::c_int = AF_LAT;
+pub const PF_HYLINK: ::c_int = AF_HYLINK;
+pub const PF_APPLETALK: ::c_int = AF_APPLETALK;
+pub const PF_ROUTE: ::c_int = AF_ROUTE;
+pub const PF_LINK: ::c_int = AF_LINK;
+pub const PF_XTP: ::c_int = pseudo_AF_XTP;
+pub const PF_COIP: ::c_int = AF_COIP;
+pub const PF_CNT: ::c_int = AF_CNT;
+pub const PF_SIP: ::c_int = AF_SIP;
+pub const PF_IPX: ::c_int = AF_IPX;
+pub const PF_RTIP: ::c_int = pseudo_AF_RTIP;
+pub const PF_PIP: ::c_int = pseudo_AF_PIP;
+pub const PF_ISDN: ::c_int = AF_ISDN;
+pub const PF_KEY: ::c_int = pseudo_AF_KEY;
+pub const PF_INET6: ::c_int = AF_INET6;
+pub const PF_NATM: ::c_int = AF_NATM;
+pub const PF_SYSTEM: ::c_int = AF_SYSTEM;
+pub const PF_NETBIOS: ::c_int = AF_NETBIOS;
+pub const PF_PPP: ::c_int = AF_PPP;
+
+pub const NET_RT_DUMP: ::c_int = 1;
+pub const NET_RT_FLAGS: ::c_int = 2;
+pub const NET_RT_IFLIST: ::c_int = 3;
+
+pub const SOMAXCONN: ::c_int = 128;
+
+pub const SOCK_MAXADDRLEN: ::c_int = 255;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_RAW: ::c_int = 3;
+pub const SOCK_RDM: ::c_int = 4;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const IP_TTL: ::c_int = 4;
+pub const IP_HDRINCL: ::c_int = 2;
+pub const IP_RECVDSTADDR: ::c_int = 7;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;
+pub const IP_RECVIF: ::c_int = 20;
+pub const IP_PKTINFO: ::c_int = 26;
+pub const IP_RECVTOS: ::c_int = 27;
+pub const IPV6_JOIN_GROUP: ::c_int = 12;
+pub const IPV6_LEAVE_GROUP: ::c_int = 13;
+pub const IPV6_CHECKSUM: ::c_int = 26;
+pub const IPV6_RECVTCLASS: ::c_int = 35;
+pub const IPV6_TCLASS: ::c_int = 36;
+pub const IPV6_PKTINFO: ::c_int = 46;
+pub const IPV6_HOPLIMIT: ::c_int = 47;
+pub const IPV6_RECVPKTINFO: ::c_int = 61;
+
+pub const TCP_NOPUSH: ::c_int = 4;
+pub const TCP_NOOPT: ::c_int = 8;
+pub const TCP_KEEPALIVE: ::c_int = 0x10;
+pub const TCP_KEEPINTVL: ::c_int = 0x101;
+pub const TCP_KEEPCNT: ::c_int = 0x102;
+/// Enable/Disable TCP Fastopen on this socket
+pub const TCP_FASTOPEN: ::c_int = 0x105;
+
+pub const SOL_LOCAL: ::c_int = 0;
+
+pub const LOCAL_PEERCRED: ::c_int = 0x001;
+pub const LOCAL_PEERPID: ::c_int = 0x002;
+pub const LOCAL_PEEREPID: ::c_int = 0x003;
+pub const LOCAL_PEERUUID: ::c_int = 0x004;
+pub const LOCAL_PEEREUUID: ::c_int = 0x005;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+
+pub const SO_DEBUG: ::c_int = 0x01;
+pub const SO_ACCEPTCONN: ::c_int = 0x0002;
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_USELOOPBACK: ::c_int = 0x0040;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_TIMESTAMP: ::c_int = 0x0400;
+pub const SO_TIMESTAMP_MONOTONIC: ::c_int = 0x0800;
+pub const SO_DONTTRUNC: ::c_int = 0x2000;
+pub const SO_WANTMORE: ::c_int = 0x4000;
+pub const SO_WANTOOBFLAG: ::c_int = 0x8000;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_LABEL: ::c_int = 0x1010;
+pub const SO_PEERLABEL: ::c_int = 0x1011;
+pub const SO_NREAD: ::c_int = 0x1020;
+pub const SO_NKE: ::c_int = 0x1021;
+pub const SO_NOSIGPIPE: ::c_int = 0x1022;
+pub const SO_NOADDRERR: ::c_int = 0x1023;
+pub const SO_NWRITE: ::c_int = 0x1024;
+pub const SO_REUSESHAREUID: ::c_int = 0x1025;
+pub const SO_NOTIFYCONFLICT: ::c_int = 0x1026;
+pub const SO_RANDOMPORT: ::c_int = 0x1082;
+pub const SO_NP_EXTENSIONS: ::c_int = 0x1083;
+
+pub const MSG_OOB: ::c_int = 0x1;
+pub const MSG_PEEK: ::c_int = 0x2;
+pub const MSG_DONTROUTE: ::c_int = 0x4;
+pub const MSG_EOR: ::c_int = 0x8;
+pub const MSG_TRUNC: ::c_int = 0x10;
+pub const MSG_CTRUNC: ::c_int = 0x20;
+pub const MSG_WAITALL: ::c_int = 0x40;
+pub const MSG_DONTWAIT: ::c_int = 0x80;
+pub const MSG_EOF: ::c_int = 0x100;
+pub const MSG_FLUSH: ::c_int = 0x400;
+pub const MSG_HOLD: ::c_int = 0x800;
+pub const MSG_SEND: ::c_int = 0x1000;
+pub const MSG_HAVEMORE: ::c_int = 0x2000;
+pub const MSG_RCVMORE: ::c_int = 0x4000;
+// pub const MSG_COMPAT: ::c_int = 0x8000;
+
+pub const SCM_TIMESTAMP: ::c_int = 0x02;
+pub const SCM_CREDS: ::c_int = 0x03;
+
+// https://github.com/aosm/xnu/blob/master/bsd/net/if.h#L140-L156
+pub const IFF_UP: ::c_int = 0x1; // interface is up
+pub const IFF_BROADCAST: ::c_int = 0x2; // broadcast address valid
+pub const IFF_DEBUG: ::c_int = 0x4; // turn on debugging
+pub const IFF_LOOPBACK: ::c_int = 0x8; // is a loopback net
+pub const IFF_POINTOPOINT: ::c_int = 0x10; // interface is point-to-point link
+pub const IFF_NOTRAILERS: ::c_int = 0x20; // obsolete: avoid use of trailers
+pub const IFF_RUNNING: ::c_int = 0x40; // resources allocated
+pub const IFF_NOARP: ::c_int = 0x80; // no address resolution protocol
+pub const IFF_PROMISC: ::c_int = 0x100; // receive all packets
+pub const IFF_ALLMULTI: ::c_int = 0x200; // receive all multicast packets
+pub const IFF_OACTIVE: ::c_int = 0x400; // transmission in progress
+pub const IFF_SIMPLEX: ::c_int = 0x800; // can't hear own transmissions
+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit
+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit
+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit
+pub const IFF_ALTPHYS: ::c_int = IFF_LINK2; // use alternate physical connection
+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const SAE_ASSOCID_ANY: ::sae_associd_t = 0;
+/// ((sae_associd_t)(-1ULL))
+pub const SAE_ASSOCID_ALL: ::sae_associd_t = 0xffffffff;
+
+pub const SAE_CONNID_ANY: ::sae_connid_t = 0;
+/// ((sae_connid_t)(-1ULL))
+pub const SAE_CONNID_ALL: ::sae_connid_t = 0xffffffff;
+
+// connectx() flag parameters
+
+/// resume connect() on read/write
+pub const CONNECT_RESUME_ON_READ_WRITE: ::c_uint = 0x1;
+/// data is idempotent
+pub const CONNECT_DATA_IDEMPOTENT: ::c_uint = 0x2;
+/// data includes security that replaces the TFO-cookie
+pub const CONNECT_DATA_AUTHENTICATED: ::c_uint = 0x4;
+
+pub const LOCK_SH: ::c_int = 1;
+pub const LOCK_EX: ::c_int = 2;
+pub const LOCK_NB: ::c_int = 4;
+pub const LOCK_UN: ::c_int = 8;
+
+pub const MAP_COPY: ::c_int = 0x0002;
+pub const MAP_RENAME: ::c_int = 0x0020;
+pub const MAP_NORESERVE: ::c_int = 0x0040;
+pub const MAP_NOEXTEND: ::c_int = 0x0100;
+pub const MAP_HASSEMAPHORE: ::c_int = 0x0200;
+pub const MAP_NOCACHE: ::c_int = 0x0400;
+pub const MAP_JIT: ::c_int = 0x0800;
+
+pub const _SC_ARG_MAX: ::c_int = 1;
+pub const _SC_CHILD_MAX: ::c_int = 2;
+pub const _SC_CLK_TCK: ::c_int = 3;
+pub const _SC_NGROUPS_MAX: ::c_int = 4;
+pub const _SC_OPEN_MAX: ::c_int = 5;
+pub const _SC_JOB_CONTROL: ::c_int = 6;
+pub const _SC_SAVED_IDS: ::c_int = 7;
+pub const _SC_VERSION: ::c_int = 8;
+pub const _SC_BC_BASE_MAX: ::c_int = 9;
+pub const _SC_BC_DIM_MAX: ::c_int = 10;
+pub const _SC_BC_SCALE_MAX: ::c_int = 11;
+pub const _SC_BC_STRING_MAX: ::c_int = 12;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 13;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 14;
+pub const _SC_LINE_MAX: ::c_int = 15;
+pub const _SC_RE_DUP_MAX: ::c_int = 16;
+pub const _SC_2_VERSION: ::c_int = 17;
+pub const _SC_2_C_BIND: ::c_int = 18;
+pub const _SC_2_C_DEV: ::c_int = 19;
+pub const _SC_2_CHAR_TERM: ::c_int = 20;
+pub const _SC_2_FORT_DEV: ::c_int = 21;
+pub const _SC_2_FORT_RUN: ::c_int = 22;
+pub const _SC_2_LOCALEDEF: ::c_int = 23;
+pub const _SC_2_SW_DEV: ::c_int = 24;
+pub const _SC_2_UPE: ::c_int = 25;
+pub const _SC_STREAM_MAX: ::c_int = 26;
+pub const _SC_TZNAME_MAX: ::c_int = 27;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 28;
+pub const _SC_PAGESIZE: ::c_int = 29;
+pub const _SC_MEMLOCK: ::c_int = 30;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 31;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 32;
+pub const _SC_MESSAGE_PASSING: ::c_int = 33;
+pub const _SC_PRIORITIZED_IO: ::c_int = 34;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 35;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 36;
+pub const _SC_SEMAPHORES: ::c_int = 37;
+pub const _SC_FSYNC: ::c_int = 38;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 39;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 40;
+pub const _SC_TIMERS: ::c_int = 41;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 42;
+pub const _SC_AIO_MAX: ::c_int = 43;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 44;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 45;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 46;
+pub const _SC_MAPPED_FILES: ::c_int = 47;
+pub const _SC_RTSIG_MAX: ::c_int = 48;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 49;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 50;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 51;
+pub const _SC_TIMER_MAX: ::c_int = 52;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 57;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 58;
+pub const _SC_2_PBS: ::c_int = 59;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 60;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 61;
+pub const _SC_2_PBS_LOCATE: ::c_int = 62;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 63;
+pub const _SC_2_PBS_TRACK: ::c_int = 64;
+pub const _SC_ADVISORY_INFO: ::c_int = 65;
+pub const _SC_BARRIERS: ::c_int = 66;
+pub const _SC_CLOCK_SELECTION: ::c_int = 67;
+pub const _SC_CPUTIME: ::c_int = 68;
+pub const _SC_FILE_LOCKING: ::c_int = 69;
+pub const _SC_HOST_NAME_MAX: ::c_int = 72;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 74;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 76;
+pub const _SC_REGEXP: ::c_int = 77;
+pub const _SC_SHELL: ::c_int = 78;
+pub const _SC_SPAWN: ::c_int = 79;
+pub const _SC_SPIN_LOCKS: ::c_int = 80;
+pub const _SC_SPORADIC_SERVER: ::c_int = 81;
+pub const _SC_THREAD_CPUTIME: ::c_int = 84;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 92;
+pub const _SC_TIMEOUTS: ::c_int = 95;
+pub const _SC_TRACE: ::c_int = 97;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 98;
+pub const _SC_TRACE_INHERIT: ::c_int = 99;
+pub const _SC_TRACE_LOG: ::c_int = 100;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 102;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 103;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 104;
+pub const _SC_V6_LP64_OFF64: ::c_int = 105;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 106;
+pub const _SC_IPV6: ::c_int = 118;
+pub const _SC_RAW_SOCKETS: ::c_int = 119;
+pub const _SC_SYMLOOP_MAX: ::c_int = 120;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_XOPEN_STREAMS: ::c_int = 114;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 122;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 123;
+pub const _SC_XBS5_LP64_OFF64: ::c_int = 124;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 125;
+pub const _SC_SS_REPL_MAX: ::c_int = 126;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 127;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 128;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 129;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 130;
+pub const _SC_PASS_MAX: ::c_int = 131;
+
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+pub const _PTHREAD_MUTEX_SIG_init: ::c_long = 0x32AAABA7;
+pub const _PTHREAD_COND_SIG_init: ::c_long = 0x3CB0B1BB;
+pub const _PTHREAD_RWLOCK_SIG_init: ::c_long = 0x2DA8B3B4;
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+    __sig: _PTHREAD_MUTEX_SIG_init,
+    __opaque: [0; __PTHREAD_MUTEX_SIZE__],
+};
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+    __sig: _PTHREAD_COND_SIG_init,
+    __opaque: [0; __PTHREAD_COND_SIZE__],
+};
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+    __sig: _PTHREAD_RWLOCK_SIG_init,
+    __opaque: [0; __PTHREAD_RWLOCK_SIZE__],
+};
+
+pub const MINSIGSTKSZ: ::size_t = 32768;
+pub const SIGSTKSZ: ::size_t = 131072;
+
+pub const FD_SETSIZE: usize = 1024;
+
+pub const ST_NOSUID: ::c_ulong = 2;
+
+pub const EVFILT_READ: i16 = -1;
+pub const EVFILT_WRITE: i16 = -2;
+pub const EVFILT_AIO: i16 = -3;
+pub const EVFILT_VNODE: i16 = -4;
+pub const EVFILT_PROC: i16 = -5;
+pub const EVFILT_SIGNAL: i16 = -6;
+pub const EVFILT_TIMER: i16 = -7;
+pub const EVFILT_MACHPORT: i16 = -8;
+pub const EVFILT_FS: i16 = -9;
+pub const EVFILT_USER: i16 = -10;
+pub const EVFILT_VM: i16 = -12;
+
+pub const EV_ADD: u16 = 0x1;
+pub const EV_DELETE: u16 = 0x2;
+pub const EV_ENABLE: u16 = 0x4;
+pub const EV_DISABLE: u16 = 0x8;
+pub const EV_ONESHOT: u16 = 0x10;
+pub const EV_CLEAR: u16 = 0x20;
+pub const EV_RECEIPT: u16 = 0x40;
+pub const EV_DISPATCH: u16 = 0x80;
+pub const EV_FLAG0: u16 = 0x1000;
+pub const EV_POLL: u16 = 0x1000;
+pub const EV_FLAG1: u16 = 0x2000;
+pub const EV_OOBAND: u16 = 0x2000;
+pub const EV_ERROR: u16 = 0x4000;
+pub const EV_EOF: u16 = 0x8000;
+pub const EV_SYSFLAGS: u16 = 0xf000;
+
+pub const NOTE_TRIGGER: u32 = 0x01000000;
+pub const NOTE_FFNOP: u32 = 0x00000000;
+pub const NOTE_FFAND: u32 = 0x40000000;
+pub const NOTE_FFOR: u32 = 0x80000000;
+pub const NOTE_FFCOPY: u32 = 0xc0000000;
+pub const NOTE_FFCTRLMASK: u32 = 0xc0000000;
+pub const NOTE_FFLAGSMASK: u32 = 0x00ffffff;
+pub const NOTE_LOWAT: u32 = 0x00000001;
+pub const NOTE_DELETE: u32 = 0x00000001;
+pub const NOTE_WRITE: u32 = 0x00000002;
+pub const NOTE_EXTEND: u32 = 0x00000004;
+pub const NOTE_ATTRIB: u32 = 0x00000008;
+pub const NOTE_LINK: u32 = 0x00000010;
+pub const NOTE_RENAME: u32 = 0x00000020;
+pub const NOTE_REVOKE: u32 = 0x00000040;
+pub const NOTE_NONE: u32 = 0x00000080;
+pub const NOTE_EXIT: u32 = 0x80000000;
+pub const NOTE_FORK: u32 = 0x40000000;
+pub const NOTE_EXEC: u32 = 0x20000000;
+#[doc(hidden)]
+#[deprecated(since = "0.2.49", note = "Deprecated since MacOSX 10.9")]
+pub const NOTE_REAP: u32 = 0x10000000;
+pub const NOTE_SIGNAL: u32 = 0x08000000;
+pub const NOTE_EXITSTATUS: u32 = 0x04000000;
+pub const NOTE_EXIT_DETAIL: u32 = 0x02000000;
+pub const NOTE_PDATAMASK: u32 = 0x000fffff;
+pub const NOTE_PCTRLMASK: u32 = 0xfff00000;
+#[doc(hidden)]
+#[deprecated(since = "0.2.49", note = "Deprecated since MacOSX 10.9")]
+pub const NOTE_EXIT_REPARENTED: u32 = 0x00080000;
+pub const NOTE_EXIT_DETAIL_MASK: u32 = 0x00070000;
+pub const NOTE_EXIT_DECRYPTFAIL: u32 = 0x00010000;
+pub const NOTE_EXIT_MEMORY: u32 = 0x00020000;
+pub const NOTE_EXIT_CSERROR: u32 = 0x00040000;
+pub const NOTE_VM_PRESSURE: u32 = 0x80000000;
+pub const NOTE_VM_PRESSURE_TERMINATE: u32 = 0x40000000;
+pub const NOTE_VM_PRESSURE_SUDDEN_TERMINATE: u32 = 0x20000000;
+pub const NOTE_VM_ERROR: u32 = 0x10000000;
+pub const NOTE_SECONDS: u32 = 0x00000001;
+pub const NOTE_USECONDS: u32 = 0x00000002;
+pub const NOTE_NSECONDS: u32 = 0x00000004;
+pub const NOTE_ABSOLUTE: u32 = 0x00000008;
+pub const NOTE_LEEWAY: u32 = 0x00000010;
+pub const NOTE_CRITICAL: u32 = 0x00000020;
+pub const NOTE_BACKGROUND: u32 = 0x00000040;
+pub const NOTE_TRACK: u32 = 0x00000001;
+pub const NOTE_TRACKERR: u32 = 0x00000002;
+pub const NOTE_CHILD: u32 = 0x00000004;
+
+pub const OCRNL: ::tcflag_t = 0x00000010;
+pub const ONOCR: ::tcflag_t = 0x00000020;
+pub const ONLRET: ::tcflag_t = 0x00000040;
+pub const OFILL: ::tcflag_t = 0x00000080;
+pub const NLDLY: ::tcflag_t = 0x00000300;
+pub const TABDLY: ::tcflag_t = 0x00000c04;
+pub const CRDLY: ::tcflag_t = 0x00003000;
+pub const FFDLY: ::tcflag_t = 0x00004000;
+pub const BSDLY: ::tcflag_t = 0x00008000;
+pub const VTDLY: ::tcflag_t = 0x00010000;
+pub const OFDEL: ::tcflag_t = 0x00020000;
+
+pub const NL0: ::tcflag_t = 0x00000000;
+pub const NL1: ::tcflag_t = 0x00000100;
+pub const TAB0: ::tcflag_t = 0x00000000;
+pub const TAB1: ::tcflag_t = 0x00000400;
+pub const TAB2: ::tcflag_t = 0x00000800;
+pub const CR0: ::tcflag_t = 0x00000000;
+pub const CR1: ::tcflag_t = 0x00001000;
+pub const CR2: ::tcflag_t = 0x00002000;
+pub const CR3: ::tcflag_t = 0x00003000;
+pub const FF0: ::tcflag_t = 0x00000000;
+pub const FF1: ::tcflag_t = 0x00004000;
+pub const BS0: ::tcflag_t = 0x00000000;
+pub const BS1: ::tcflag_t = 0x00008000;
+pub const TAB3: ::tcflag_t = 0x00000004;
+pub const VT0: ::tcflag_t = 0x00000000;
+pub const VT1: ::tcflag_t = 0x00010000;
+pub const IUTF8: ::tcflag_t = 0x00004000;
+pub const CRTSCTS: ::tcflag_t = 0x00030000;
+
+pub const NI_MAXHOST: ::socklen_t = 1025;
+pub const NI_MAXSERV: ::socklen_t = 32;
+pub const NI_NOFQDN: ::c_int = 0x00000001;
+pub const NI_NUMERICHOST: ::c_int = 0x00000002;
+pub const NI_NAMEREQD: ::c_int = 0x00000004;
+pub const NI_NUMERICSERV: ::c_int = 0x00000008;
+pub const NI_NUMERICSCOPE: ::c_int = 0x00000100;
+pub const NI_DGRAM: ::c_int = 0x00000010;
+
+pub const Q_GETQUOTA: ::c_int = 0x300;
+pub const Q_SETQUOTA: ::c_int = 0x400;
+
+pub const RENAME_SWAP: ::c_uint = 0x00000002;
+pub const RENAME_EXCL: ::c_uint = 0x00000004;
+
+pub const RTLD_LOCAL: ::c_int = 0x4;
+pub const RTLD_FIRST: ::c_int = 0x100;
+pub const RTLD_NODELETE: ::c_int = 0x80;
+pub const RTLD_NOLOAD: ::c_int = 0x10;
+pub const RTLD_GLOBAL: ::c_int = 0x8;
+
+pub const _WSTOPPED: ::c_int = 0o177;
+
+pub const LOG_NETINFO: ::c_int = 12 << 3;
+pub const LOG_REMOTEAUTH: ::c_int = 13 << 3;
+pub const LOG_INSTALL: ::c_int = 14 << 3;
+pub const LOG_RAS: ::c_int = 15 << 3;
+pub const LOG_LAUNCHD: ::c_int = 24 << 3;
+pub const LOG_NFACILITIES: ::c_int = 25;
+
+pub const CTLTYPE: ::c_int = 0xf;
+pub const CTLTYPE_NODE: ::c_int = 1;
+pub const CTLTYPE_INT: ::c_int = 2;
+pub const CTLTYPE_STRING: ::c_int = 3;
+pub const CTLTYPE_QUAD: ::c_int = 4;
+pub const CTLTYPE_OPAQUE: ::c_int = 5;
+pub const CTLTYPE_STRUCT: ::c_int = CTLTYPE_OPAQUE;
+pub const CTLFLAG_RD: ::c_int = 0x80000000;
+pub const CTLFLAG_WR: ::c_int = 0x40000000;
+pub const CTLFLAG_RW: ::c_int = CTLFLAG_RD | CTLFLAG_WR;
+pub const CTLFLAG_NOLOCK: ::c_int = 0x20000000;
+pub const CTLFLAG_ANYBODY: ::c_int = 0x10000000;
+pub const CTLFLAG_SECURE: ::c_int = 0x08000000;
+pub const CTLFLAG_MASKED: ::c_int = 0x04000000;
+pub const CTLFLAG_NOAUTO: ::c_int = 0x02000000;
+pub const CTLFLAG_KERN: ::c_int = 0x01000000;
+pub const CTLFLAG_LOCKED: ::c_int = 0x00800000;
+pub const CTLFLAG_OID2: ::c_int = 0x00400000;
+pub const CTL_UNSPEC: ::c_int = 0;
+pub const CTL_KERN: ::c_int = 1;
+pub const CTL_VM: ::c_int = 2;
+pub const CTL_VFS: ::c_int = 3;
+pub const CTL_NET: ::c_int = 4;
+pub const CTL_DEBUG: ::c_int = 5;
+pub const CTL_HW: ::c_int = 6;
+pub const CTL_MACHDEP: ::c_int = 7;
+pub const CTL_USER: ::c_int = 8;
+pub const CTL_MAXID: ::c_int = 9;
+pub const KERN_OSTYPE: ::c_int = 1;
+pub const KERN_OSRELEASE: ::c_int = 2;
+pub const KERN_OSREV: ::c_int = 3;
+pub const KERN_VERSION: ::c_int = 4;
+pub const KERN_MAXVNODES: ::c_int = 5;
+pub const KERN_MAXPROC: ::c_int = 6;
+pub const KERN_MAXFILES: ::c_int = 7;
+pub const KERN_ARGMAX: ::c_int = 8;
+pub const KERN_SECURELVL: ::c_int = 9;
+pub const KERN_HOSTNAME: ::c_int = 10;
+pub const KERN_HOSTID: ::c_int = 11;
+pub const KERN_CLOCKRATE: ::c_int = 12;
+pub const KERN_VNODE: ::c_int = 13;
+pub const KERN_PROC: ::c_int = 14;
+pub const KERN_FILE: ::c_int = 15;
+pub const KERN_PROF: ::c_int = 16;
+pub const KERN_POSIX1: ::c_int = 17;
+pub const KERN_NGROUPS: ::c_int = 18;
+pub const KERN_JOB_CONTROL: ::c_int = 19;
+pub const KERN_SAVED_IDS: ::c_int = 20;
+pub const KERN_BOOTTIME: ::c_int = 21;
+pub const KERN_NISDOMAINNAME: ::c_int = 22;
+pub const KERN_DOMAINNAME: ::c_int = KERN_NISDOMAINNAME;
+pub const KERN_MAXPARTITIONS: ::c_int = 23;
+pub const KERN_KDEBUG: ::c_int = 24;
+pub const KERN_UPDATEINTERVAL: ::c_int = 25;
+pub const KERN_OSRELDATE: ::c_int = 26;
+pub const KERN_NTP_PLL: ::c_int = 27;
+pub const KERN_BOOTFILE: ::c_int = 28;
+pub const KERN_MAXFILESPERPROC: ::c_int = 29;
+pub const KERN_MAXPROCPERUID: ::c_int = 30;
+pub const KERN_DUMPDEV: ::c_int = 31;
+pub const KERN_IPC: ::c_int = 32;
+pub const KERN_DUMMY: ::c_int = 33;
+pub const KERN_PS_STRINGS: ::c_int = 34;
+pub const KERN_USRSTACK32: ::c_int = 35;
+pub const KERN_LOGSIGEXIT: ::c_int = 36;
+pub const KERN_SYMFILE: ::c_int = 37;
+pub const KERN_PROCARGS: ::c_int = 38;
+pub const KERN_NETBOOT: ::c_int = 40;
+pub const KERN_SYSV: ::c_int = 42;
+pub const KERN_AFFINITY: ::c_int = 43;
+pub const KERN_TRANSLATE: ::c_int = 44;
+pub const KERN_CLASSIC: ::c_int = KERN_TRANSLATE;
+pub const KERN_EXEC: ::c_int = 45;
+pub const KERN_CLASSICHANDLER: ::c_int = KERN_EXEC;
+pub const KERN_AIOMAX: ::c_int = 46;
+pub const KERN_AIOPROCMAX: ::c_int = 47;
+pub const KERN_AIOTHREADS: ::c_int = 48;
+pub const KERN_COREFILE: ::c_int = 50;
+pub const KERN_COREDUMP: ::c_int = 51;
+pub const KERN_SUGID_COREDUMP: ::c_int = 52;
+pub const KERN_PROCDELAYTERM: ::c_int = 53;
+pub const KERN_SHREG_PRIVATIZABLE: ::c_int = 54;
+pub const KERN_LOW_PRI_WINDOW: ::c_int = 56;
+pub const KERN_LOW_PRI_DELAY: ::c_int = 57;
+pub const KERN_POSIX: ::c_int = 58;
+pub const KERN_USRSTACK64: ::c_int = 59;
+pub const KERN_NX_PROTECTION: ::c_int = 60;
+pub const KERN_TFP: ::c_int = 61;
+pub const KERN_PROCNAME: ::c_int = 62;
+pub const KERN_THALTSTACK: ::c_int = 63;
+pub const KERN_SPECULATIVE_READS: ::c_int = 64;
+pub const KERN_OSVERSION: ::c_int = 65;
+pub const KERN_SAFEBOOT: ::c_int = 66;
+pub const KERN_RAGEVNODE: ::c_int = 68;
+pub const KERN_TTY: ::c_int = 69;
+pub const KERN_CHECKOPENEVT: ::c_int = 70;
+pub const KERN_THREADNAME: ::c_int = 71;
+pub const KERN_MAXID: ::c_int = 72;
+pub const KERN_RAGE_PROC: ::c_int = 1;
+pub const KERN_RAGE_THREAD: ::c_int = 2;
+pub const KERN_UNRAGE_PROC: ::c_int = 3;
+pub const KERN_UNRAGE_THREAD: ::c_int = 4;
+pub const KERN_OPENEVT_PROC: ::c_int = 1;
+pub const KERN_UNOPENEVT_PROC: ::c_int = 2;
+pub const KERN_TFP_POLICY: ::c_int = 1;
+pub const KERN_TFP_POLICY_DENY: ::c_int = 0;
+pub const KERN_TFP_POLICY_DEFAULT: ::c_int = 2;
+pub const KERN_KDEFLAGS: ::c_int = 1;
+pub const KERN_KDDFLAGS: ::c_int = 2;
+pub const KERN_KDENABLE: ::c_int = 3;
+pub const KERN_KDSETBUF: ::c_int = 4;
+pub const KERN_KDGETBUF: ::c_int = 5;
+pub const KERN_KDSETUP: ::c_int = 6;
+pub const KERN_KDREMOVE: ::c_int = 7;
+pub const KERN_KDSETREG: ::c_int = 8;
+pub const KERN_KDGETREG: ::c_int = 9;
+pub const KERN_KDREADTR: ::c_int = 10;
+pub const KERN_KDPIDTR: ::c_int = 11;
+pub const KERN_KDTHRMAP: ::c_int = 12;
+pub const KERN_KDPIDEX: ::c_int = 14;
+pub const KERN_KDSETRTCDEC: ::c_int = 15;
+pub const KERN_KDGETENTROPY: ::c_int = 16;
+pub const KERN_KDWRITETR: ::c_int = 17;
+pub const KERN_KDWRITEMAP: ::c_int = 18;
+#[doc(hidden)]
+#[deprecated(since = "0.2.49", note = "Removed in MacOSX 10.12")]
+pub const KERN_KDENABLE_BG_TRACE: ::c_int = 19;
+#[doc(hidden)]
+#[deprecated(since = "0.2.49", note = "Removed in MacOSX 10.12")]
+pub const KERN_KDDISABLE_BG_TRACE: ::c_int = 20;
+pub const KERN_KDREADCURTHRMAP: ::c_int = 21;
+pub const KERN_KDSET_TYPEFILTER: ::c_int = 22;
+pub const KERN_KDBUFWAIT: ::c_int = 23;
+pub const KERN_KDCPUMAP: ::c_int = 24;
+pub const KERN_PROC_ALL: ::c_int = 0;
+pub const KERN_PROC_PID: ::c_int = 1;
+pub const KERN_PROC_PGRP: ::c_int = 2;
+pub const KERN_PROC_SESSION: ::c_int = 3;
+pub const KERN_PROC_TTY: ::c_int = 4;
+pub const KERN_PROC_UID: ::c_int = 5;
+pub const KERN_PROC_RUID: ::c_int = 6;
+pub const KERN_PROC_LCID: ::c_int = 7;
+pub const KIPC_MAXSOCKBUF: ::c_int = 1;
+pub const KIPC_SOCKBUF_WASTE: ::c_int = 2;
+pub const KIPC_SOMAXCONN: ::c_int = 3;
+pub const KIPC_MAX_LINKHDR: ::c_int = 4;
+pub const KIPC_MAX_PROTOHDR: ::c_int = 5;
+pub const KIPC_MAX_HDR: ::c_int = 6;
+pub const KIPC_MAX_DATALEN: ::c_int = 7;
+pub const KIPC_MBSTAT: ::c_int = 8;
+pub const KIPC_NMBCLUSTERS: ::c_int = 9;
+pub const KIPC_SOQLIMITCOMPAT: ::c_int = 10;
+pub const VM_METER: ::c_int = 1;
+pub const VM_LOADAVG: ::c_int = 2;
+pub const VM_MACHFACTOR: ::c_int = 4;
+pub const VM_SWAPUSAGE: ::c_int = 5;
+pub const VM_MAXID: ::c_int = 6;
+pub const HW_MACHINE: ::c_int = 1;
+pub const HW_MODEL: ::c_int = 2;
+pub const HW_NCPU: ::c_int = 3;
+pub const HW_BYTEORDER: ::c_int = 4;
+pub const HW_PHYSMEM: ::c_int = 5;
+pub const HW_USERMEM: ::c_int = 6;
+pub const HW_PAGESIZE: ::c_int = 7;
+pub const HW_DISKNAMES: ::c_int = 8;
+pub const HW_DISKSTATS: ::c_int = 9;
+pub const HW_EPOCH: ::c_int = 10;
+pub const HW_FLOATINGPT: ::c_int = 11;
+pub const HW_MACHINE_ARCH: ::c_int = 12;
+pub const HW_VECTORUNIT: ::c_int = 13;
+pub const HW_BUS_FREQ: ::c_int = 14;
+pub const HW_CPU_FREQ: ::c_int = 15;
+pub const HW_CACHELINE: ::c_int = 16;
+pub const HW_L1ICACHESIZE: ::c_int = 17;
+pub const HW_L1DCACHESIZE: ::c_int = 18;
+pub const HW_L2SETTINGS: ::c_int = 19;
+pub const HW_L2CACHESIZE: ::c_int = 20;
+pub const HW_L3SETTINGS: ::c_int = 21;
+pub const HW_L3CACHESIZE: ::c_int = 22;
+pub const HW_TB_FREQ: ::c_int = 23;
+pub const HW_MEMSIZE: ::c_int = 24;
+pub const HW_AVAILCPU: ::c_int = 25;
+pub const HW_TARGET: ::c_int = 26;
+pub const HW_PRODUCT: ::c_int = 27;
+pub const HW_MAXID: ::c_int = 28;
+pub const USER_CS_PATH: ::c_int = 1;
+pub const USER_BC_BASE_MAX: ::c_int = 2;
+pub const USER_BC_DIM_MAX: ::c_int = 3;
+pub const USER_BC_SCALE_MAX: ::c_int = 4;
+pub const USER_BC_STRING_MAX: ::c_int = 5;
+pub const USER_COLL_WEIGHTS_MAX: ::c_int = 6;
+pub const USER_EXPR_NEST_MAX: ::c_int = 7;
+pub const USER_LINE_MAX: ::c_int = 8;
+pub const USER_RE_DUP_MAX: ::c_int = 9;
+pub const USER_POSIX2_VERSION: ::c_int = 10;
+pub const USER_POSIX2_C_BIND: ::c_int = 11;
+pub const USER_POSIX2_C_DEV: ::c_int = 12;
+pub const USER_POSIX2_CHAR_TERM: ::c_int = 13;
+pub const USER_POSIX2_FORT_DEV: ::c_int = 14;
+pub const USER_POSIX2_FORT_RUN: ::c_int = 15;
+pub const USER_POSIX2_LOCALEDEF: ::c_int = 16;
+pub const USER_POSIX2_SW_DEV: ::c_int = 17;
+pub const USER_POSIX2_UPE: ::c_int = 18;
+pub const USER_STREAM_MAX: ::c_int = 19;
+pub const USER_TZNAME_MAX: ::c_int = 20;
+pub const USER_MAXID: ::c_int = 21;
+pub const CTL_DEBUG_NAME: ::c_int = 0;
+pub const CTL_DEBUG_VALUE: ::c_int = 1;
+pub const CTL_DEBUG_MAXID: ::c_int = 20;
+
+pub const PRIO_DARWIN_THREAD: ::c_int = 3;
+pub const PRIO_DARWIN_PROCESS: ::c_int = 4;
+pub const PRIO_DARWIN_BG: ::c_int = 0x1000;
+pub const PRIO_DARWIN_NONUI: ::c_int = 0x1001;
+
+pub const SEM_FAILED: *mut sem_t = -1isize as *mut ::sem_t;
+
+pub const AI_PASSIVE: ::c_int = 0x00000001;
+pub const AI_CANONNAME: ::c_int = 0x00000002;
+pub const AI_NUMERICHOST: ::c_int = 0x00000004;
+pub const AI_NUMERICSERV: ::c_int = 0x00001000;
+pub const AI_MASK: ::c_int = AI_PASSIVE
+    | AI_CANONNAME
+    | AI_NUMERICHOST
+    | AI_NUMERICSERV
+    | AI_ADDRCONFIG;
+pub const AI_ALL: ::c_int = 0x00000100;
+pub const AI_V4MAPPED_CFG: ::c_int = 0x00000200;
+pub const AI_ADDRCONFIG: ::c_int = 0x00000400;
+pub const AI_V4MAPPED: ::c_int = 0x00000800;
+pub const AI_DEFAULT: ::c_int = AI_V4MAPPED_CFG | AI_ADDRCONFIG;
+pub const AI_UNUSABLE: ::c_int = 0x10000000;
+
+pub const SIGEV_NONE: ::c_int = 0;
+pub const SIGEV_SIGNAL: ::c_int = 1;
+pub const SIGEV_THREAD: ::c_int = 3;
+
+pub const AIO_CANCELED: ::c_int = 2;
+pub const AIO_NOTCANCELED: ::c_int = 4;
+pub const AIO_ALLDONE: ::c_int = 1;
+#[deprecated(
+    since = "0.2.64",
+    note = "Can vary at runtime.  Use sysconf(3) instead"
+)]
+pub const AIO_LISTIO_MAX: ::c_int = 16;
+pub const LIO_NOP: ::c_int = 0;
+pub const LIO_WRITE: ::c_int = 2;
+pub const LIO_READ: ::c_int = 1;
+pub const LIO_WAIT: ::c_int = 2;
+pub const LIO_NOWAIT: ::c_int = 1;
+
+pub const WEXITED: ::c_int = 0x00000004;
+pub const WSTOPPED: ::c_int = 0x00000008;
+pub const WCONTINUED: ::c_int = 0x00000010;
+pub const WNOWAIT: ::c_int = 0x00000020;
+
+pub const P_ALL: idtype_t = 0;
+pub const P_PID: idtype_t = 1;
+pub const P_PGID: idtype_t = 2;
+
+pub const UTIME_OMIT: c_long = -2;
+pub const UTIME_NOW: c_long = -1;
+
+pub const XATTR_NOFOLLOW: ::c_int = 0x0001;
+pub const XATTR_CREATE: ::c_int = 0x0002;
+pub const XATTR_REPLACE: ::c_int = 0x0004;
+pub const XATTR_NOSECURITY: ::c_int = 0x0008;
+pub const XATTR_NODEFAULT: ::c_int = 0x0010;
+pub const XATTR_SHOWCOMPRESSION: ::c_int = 0x0020;
+
+pub const NET_RT_IFLIST2: ::c_int = 0x0006;
+
+// net/route.h
+pub const RTF_UP: ::c_int = 0x1;
+pub const RTF_GATEWAY: ::c_int = 0x2;
+pub const RTF_HOST: ::c_int = 0x4;
+pub const RTF_REJECT: ::c_int = 0x8;
+pub const RTF_DYNAMIC: ::c_int = 0x10;
+pub const RTF_MODIFIED: ::c_int = 0x20;
+pub const RTF_DONE: ::c_int = 0x40;
+pub const RTF_DELCLONE: ::c_int = 0x80;
+pub const RTF_CLONING: ::c_int = 0x100;
+pub const RTF_XRESOLVE: ::c_int = 0x200;
+pub const RTF_LLINFO: ::c_int = 0x400;
+pub const RTF_STATIC: ::c_int = 0x800;
+pub const RTF_BLACKHOLE: ::c_int = 0x1000;
+pub const RTF_NOIFREF: ::c_int = 0x2000;
+pub const RTF_PROTO2: ::c_int = 0x4000;
+pub const RTF_PROTO1: ::c_int = 0x8000;
+pub const RTF_PRCLONING: ::c_int = 0x10000;
+pub const RTF_WASCLONED: ::c_int = 0x20000;
+pub const RTF_PROTO3: ::c_int = 0x40000;
+pub const RTF_PINNED: ::c_int = 0x100000;
+pub const RTF_LOCAL: ::c_int = 0x200000;
+pub const RTF_BROADCAST: ::c_int = 0x400000;
+pub const RTF_MULTICAST: ::c_int = 0x800000;
+pub const RTF_IFSCOPE: ::c_int = 0x1000000;
+pub const RTF_CONDEMNED: ::c_int = 0x2000000;
+pub const RTF_IFREF: ::c_int = 0x4000000;
+pub const RTF_PROXY: ::c_int = 0x8000000;
+pub const RTF_ROUTER: ::c_int = 0x10000000;
+
+pub const RTM_VERSION: ::c_int = 5;
+
+// Message types
+pub const RTM_ADD: ::c_int = 0x1;
+pub const RTM_DELETE: ::c_int = 0x2;
+pub const RTM_CHANGE: ::c_int = 0x3;
+pub const RTM_GET: ::c_int = 0x4;
+pub const RTM_LOSING: ::c_int = 0x5;
+pub const RTM_REDIRECT: ::c_int = 0x6;
+pub const RTM_MISS: ::c_int = 0x7;
+pub const RTM_LOCK: ::c_int = 0x8;
+pub const RTM_OLDADD: ::c_int = 0x9;
+pub const RTM_OLDDEL: ::c_int = 0xa;
+pub const RTM_RESOLVE: ::c_int = 0xb;
+pub const RTM_NEWADDR: ::c_int = 0xc;
+pub const RTM_DELADDR: ::c_int = 0xd;
+pub const RTM_IFINFO: ::c_int = 0xe;
+pub const RTM_NEWMADDR: ::c_int = 0xf;
+pub const RTM_DELMADDR: ::c_int = 0x10;
+pub const RTM_IFINFO2: ::c_int = 0x12;
+pub const RTM_NEWMADDR2: ::c_int = 0x13;
+pub const RTM_GET2: ::c_int = 0x14;
+
+// Bitmask values for rtm_inits and rmx_locks.
+pub const RTV_MTU: ::c_int = 0x1;
+pub const RTV_HOPCOUNT: ::c_int = 0x2;
+pub const RTV_EXPIRE: ::c_int = 0x4;
+pub const RTV_RPIPE: ::c_int = 0x8;
+pub const RTV_SPIPE: ::c_int = 0x10;
+pub const RTV_SSTHRESH: ::c_int = 0x20;
+pub const RTV_RTT: ::c_int = 0x40;
+pub const RTV_RTTVAR: ::c_int = 0x80;
+
+// Bitmask values for rtm_addrs.
+pub const RTA_DST: ::c_int = 0x1;
+pub const RTA_GATEWAY: ::c_int = 0x2;
+pub const RTA_NETMASK: ::c_int = 0x4;
+pub const RTA_GENMASK: ::c_int = 0x8;
+pub const RTA_IFP: ::c_int = 0x10;
+pub const RTA_IFA: ::c_int = 0x20;
+pub const RTA_AUTHOR: ::c_int = 0x40;
+pub const RTA_BRD: ::c_int = 0x80;
+
+// Index offsets for sockaddr array for alternate internal encoding.
+pub const RTAX_DST: ::c_int = 0;
+pub const RTAX_GATEWAY: ::c_int = 1;
+pub const RTAX_NETMASK: ::c_int = 2;
+pub const RTAX_GENMASK: ::c_int = 3;
+pub const RTAX_IFP: ::c_int = 4;
+pub const RTAX_IFA: ::c_int = 5;
+pub const RTAX_AUTHOR: ::c_int = 6;
+pub const RTAX_BRD: ::c_int = 7;
+pub const RTAX_MAX: ::c_int = 8;
+
+pub const KERN_PROCARGS2: ::c_int = 49;
+
+pub const PROC_PIDTASKALLINFO: ::c_int = 2;
+pub const PROC_PIDTASKINFO: ::c_int = 4;
+pub const PROC_PIDTHREADINFO: ::c_int = 5;
+pub const MAXCOMLEN: usize = 16;
+pub const MAXTHREADNAMESIZE: usize = 64;
+
+pub const XUCRED_VERSION: ::c_uint = 0;
+
+pub const LC_SEGMENT: u32 = 0x1;
+pub const LC_SEGMENT_64: u32 = 0x19;
+
+pub const MH_MAGIC: u32 = 0xfeedface;
+pub const MH_MAGIC_64: u32 = 0xfeedfacf;
+
+// net/if_utun.h
+pub const UTUN_OPT_FLAGS: ::c_int = 1;
+pub const UTUN_OPT_IFNAME: ::c_int = 2;
+
+// net/bpf.h
+pub const DLT_NULL: ::c_uint = 0; // no link-layer encapsulation
+pub const DLT_EN10MB: ::c_uint = 1; // Ethernet (10Mb)
+pub const DLT_EN3MB: ::c_uint = 2; // Experimental Ethernet (3Mb)
+pub const DLT_AX25: ::c_uint = 3; // Amateur Radio AX.25
+pub const DLT_PRONET: ::c_uint = 4; // Proteon ProNET Token Ring
+pub const DLT_CHAOS: ::c_uint = 5; // Chaos
+pub const DLT_IEEE802: ::c_uint = 6; // IEEE 802 Networks
+pub const DLT_ARCNET: ::c_uint = 7; // ARCNET
+pub const DLT_SLIP: ::c_uint = 8; // Serial Line IP
+pub const DLT_PPP: ::c_uint = 9; // Point-to-point Protocol
+pub const DLT_FDDI: ::c_uint = 10; // FDDI
+pub const DLT_ATM_RFC1483: ::c_uint = 11; // LLC/SNAP encapsulated atm
+pub const DLT_RAW: ::c_uint = 12; // raw IP
+pub const DLT_LOOP: ::c_uint = 108;
+
+// https://github.com/apple/darwin-xnu/blob/master/bsd/net/bpf.h#L100
+// sizeof(i32)
+pub const BPF_ALIGNMENT: ::c_int = 4;
+
+// sys/mount.h
+pub const MNT_RDONLY: ::c_int = 0x00000001;
+pub const MNT_SYNCHRONOUS: ::c_int = 0x00000002;
+pub const MNT_NOEXEC: ::c_int = 0x00000004;
+pub const MNT_NOSUID: ::c_int = 0x00000008;
+pub const MNT_NODEV: ::c_int = 0x00000010;
+pub const MNT_UNION: ::c_int = 0x00000020;
+pub const MNT_ASYNC: ::c_int = 0x00000040;
+pub const MNT_CPROTECT: ::c_int = 0x00000080;
+
+// NFS export related mount flags.
+pub const MNT_EXPORTED: ::c_int = 0x00000100;
+
+// MAC labeled / "quarantined" flag
+pub const MNT_QUARANTINE: ::c_int = 0x00000400;
+
+// Flags set by internal operations.
+pub const MNT_LOCAL: ::c_int = 0x00001000;
+pub const MNT_QUOTA: ::c_int = 0x00002000;
+pub const MNT_ROOTFS: ::c_int = 0x00004000;
+pub const MNT_DOVOLFS: ::c_int = 0x00008000;
+
+pub const MNT_DONTBROWSE: ::c_int = 0x00100000;
+pub const MNT_IGNORE_OWNERSHIP: ::c_int = 0x00200000;
+pub const MNT_AUTOMOUNTED: ::c_int = 0x00400000;
+pub const MNT_JOURNALED: ::c_int = 0x00800000;
+pub const MNT_NOUSERXATTR: ::c_int = 0x01000000;
+pub const MNT_DEFWRITE: ::c_int = 0x02000000;
+pub const MNT_MULTILABEL: ::c_int = 0x04000000;
+pub const MNT_NOATIME: ::c_int = 0x10000000;
+pub const MNT_SNAPSHOT: ::c_int = 0x40000000;
+
+// External filesystem command modifier flags.
+pub const MNT_UPDATE: ::c_int = 0x00010000;
+pub const MNT_NOBLOCK: ::c_int = 0x00020000;
+pub const MNT_RELOAD: ::c_int = 0x00040000;
+
+// sys/spawn.h:
+pub const POSIX_SPAWN_RESETIDS: ::c_int = 0x01;
+pub const POSIX_SPAWN_SETPGROUP: ::c_int = 0x02;
+pub const POSIX_SPAWN_SETSIGDEF: ::c_int = 0x04;
+pub const POSIX_SPAWN_SETSIGMASK: ::c_int = 0x08;
+pub const POSIX_SPAWN_SETEXEC: ::c_int = 0x40;
+pub const POSIX_SPAWN_START_SUSPENDED: ::c_int = 0x80;
+pub const POSIX_SPAWN_CLOEXEC_DEFAULT: ::c_int = 0x4000;
+
+// sys/ipc.h:
+pub const IPC_CREAT: ::c_int = 0x200;
+pub const IPC_EXCL: ::c_int = 0x400;
+pub const IPC_NOWAIT: ::c_int = 0x800;
+pub const IPC_PRIVATE: key_t = 0;
+
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+
+pub const IPC_R: ::c_int = 0x100;
+pub const IPC_W: ::c_int = 0x80;
+pub const IPC_M: ::c_int = 0x1000;
+
+// sys/sem.h
+pub const SEM_UNDO: ::c_int = 0o10000;
+
+pub const GETNCNT: ::c_int = 3;
+pub const GETPID: ::c_int = 4;
+pub const GETVAL: ::c_int = 5;
+pub const GETALL: ::c_int = 6;
+pub const GETZCNT: ::c_int = 7;
+pub const SETVAL: ::c_int = 8;
+pub const SETALL: ::c_int = 9;
+
+// sys/shm.h
+pub const SHM_RDONLY: ::c_int = 0x1000;
+pub const SHM_RND: ::c_int = 0x2000;
+#[cfg(target_arch = "aarch64")]
+pub const SHMLBA: ::c_int = 16 * 1024;
+#[cfg(not(target_arch = "aarch64"))]
+pub const SHMLBA: ::c_int = 4096;
+pub const SHM_R: ::c_int = IPC_R;
+pub const SHM_W: ::c_int = IPC_W;
+
+// Flags for chflags(2)
+pub const UF_SETTABLE: ::c_uint = 0x0000ffff;
+pub const UF_NODUMP: ::c_uint = 0x00000001;
+pub const UF_IMMUTABLE: ::c_uint = 0x00000002;
+pub const UF_APPEND: ::c_uint = 0x00000004;
+pub const UF_OPAQUE: ::c_uint = 0x00000008;
+pub const UF_COMPRESSED: ::c_uint = 0x00000020;
+pub const UF_TRACKED: ::c_uint = 0x00000040;
+pub const SF_SETTABLE: ::c_uint = 0xffff0000;
+pub const SF_ARCHIVED: ::c_uint = 0x00010000;
+pub const SF_IMMUTABLE: ::c_uint = 0x00020000;
+pub const SF_APPEND: ::c_uint = 0x00040000;
+pub const UF_HIDDEN: ::c_uint = 0x00008000;
+
+//<sys/timex.h>
+pub const NTP_API: ::c_int = 4;
+pub const MAXPHASE: ::c_long = 500000000;
+pub const MAXFREQ: ::c_long = 500000;
+pub const MINSEC: ::c_int = 256;
+pub const MAXSEC: ::c_int = 2048;
+pub const NANOSECOND: ::c_long = 1000000000;
+pub const SCALE_PPM: ::c_int = 65;
+pub const MAXTC: ::c_int = 10;
+pub const MOD_OFFSET: ::c_uint = 0x0001;
+pub const MOD_FREQUENCY: ::c_uint = 0x0002;
+pub const MOD_MAXERROR: ::c_uint = 0x0004;
+pub const MOD_ESTERROR: ::c_uint = 0x0008;
+pub const MOD_STATUS: ::c_uint = 0x0010;
+pub const MOD_TIMECONST: ::c_uint = 0x0020;
+pub const MOD_PPSMAX: ::c_uint = 0x0040;
+pub const MOD_TAI: ::c_uint = 0x0080;
+pub const MOD_MICRO: ::c_uint = 0x1000;
+pub const MOD_NANO: ::c_uint = 0x2000;
+pub const MOD_CLKB: ::c_uint = 0x4000;
+pub const MOD_CLKA: ::c_uint = 0x8000;
+pub const STA_PLL: ::c_int = 0x0001;
+pub const STA_PPSFREQ: ::c_int = 0x0002;
+pub const STA_PPSTIME: ::c_int = 0x0004;
+pub const STA_FLL: ::c_int = 0x0008;
+pub const STA_INS: ::c_int = 0x0010;
+pub const STA_DEL: ::c_int = 0x0020;
+pub const STA_UNSYNC: ::c_int = 0x0040;
+pub const STA_FREQHOLD: ::c_int = 0x0080;
+pub const STA_PPSSIGNAL: ::c_int = 0x0100;
+pub const STA_PPSJITTER: ::c_int = 0x0200;
+pub const STA_PPSWANDER: ::c_int = 0x0400;
+pub const STA_PPSERROR: ::c_int = 0x0800;
+pub const STA_CLOCKERR: ::c_int = 0x1000;
+pub const STA_NANO: ::c_int = 0x2000;
+pub const STA_MODE: ::c_int = 0x4000;
+pub const STA_CLK: ::c_int = 0x8000;
+pub const STA_RONLY: ::c_int = STA_PPSSIGNAL
+    | STA_PPSJITTER
+    | STA_PPSWANDER
+    | STA_PPSERROR
+    | STA_CLOCKERR
+    | STA_NANO
+    | STA_MODE
+    | STA_CLK;
+pub const TIME_OK: ::c_int = 0;
+pub const TIME_INS: ::c_int = 1;
+pub const TIME_DEL: ::c_int = 2;
+pub const TIME_OOP: ::c_int = 3;
+pub const TIME_WAIT: ::c_int = 4;
+pub const TIME_ERROR: ::c_int = 5;
+
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        fn __DARWIN_ALIGN32(p: usize) -> usize {
+            const __DARWIN_ALIGNBYTES32: usize = ::mem::size_of::<u32>() - 1;
+            p + __DARWIN_ALIGNBYTES32 & !__DARWIN_ALIGNBYTES32
+        }
+    } else {
+        fn __DARWIN_ALIGN32(p: usize) -> usize {
+            let __DARWIN_ALIGNBYTES32: usize = ::mem::size_of::<u32>() - 1;
+            p + __DARWIN_ALIGNBYTES32 & !__DARWIN_ALIGNBYTES32
+        }
+    }
+}
+
+f! {
+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr,
+                       cmsg: *const ::cmsghdr) -> *mut ::cmsghdr {
+        if cmsg.is_null() {
+            return ::CMSG_FIRSTHDR(mhdr);
+        };
+        let cmsg_len = (*cmsg).cmsg_len as usize;
+        let next = cmsg as usize + __DARWIN_ALIGN32(cmsg_len as usize);
+        let max = (*mhdr).msg_control as usize
+                   + (*mhdr).msg_controllen as usize;
+        if next + __DARWIN_ALIGN32(::mem::size_of::<::cmsghdr>()) > max {
+            0 as *mut ::cmsghdr
+        } else {
+            next as *mut ::cmsghdr
+        }
+    }
+
+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {
+        (cmsg as *mut ::c_uchar)
+            .offset(__DARWIN_ALIGN32(::mem::size_of::<::cmsghdr>()) as isize)
+    }
+
+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        (__DARWIN_ALIGN32(::mem::size_of::<::cmsghdr>())
+            + __DARWIN_ALIGN32(length as usize))
+            as ::c_uint
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        (__DARWIN_ALIGN32(::mem::size_of::<::cmsghdr>()) + length as usize)
+            as ::c_uint
+    }
+}
+
+safe_f! {
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        status >> 8
+    }
+
+    pub {const} fn _WSTATUS(status: ::c_int) -> ::c_int {
+        status & 0x7f
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        _WSTATUS(status) == _WSTOPPED && WSTOPSIG(status) == 0x13
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        _WSTATUS(status) != _WSTOPPED && _WSTATUS(status) != 0
+    }
+
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        _WSTATUS(status) == _WSTOPPED && WSTOPSIG(status) != 0x13
+    }
+}
+
+extern "C" {
+    pub fn setgrent();
+    #[doc(hidden)]
+    #[deprecated(since = "0.2.49", note = "Deprecated in MacOSX 10.5")]
+    #[cfg_attr(not(target_arch = "aarch64"), link_name = "daemon$1050")]
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    #[doc(hidden)]
+    #[deprecated(since = "0.2.49", note = "Deprecated in MacOSX 10.10")]
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    #[doc(hidden)]
+    #[deprecated(since = "0.2.49", note = "Deprecated in MacOSX 10.10")]
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+    pub fn aio_read(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_write(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_fsync(op: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_error(aiocbp: *const aiocb) -> ::c_int;
+    pub fn aio_return(aiocbp: *mut aiocb) -> ::ssize_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "aio_suspend$UNIX2003"
+    )]
+    pub fn aio_suspend(
+        aiocb_list: *const *const aiocb,
+        nitems: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn aio_cancel(fd: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn chflags(path: *const ::c_char, flags: ::c_uint) -> ::c_int;
+    pub fn fchflags(fd: ::c_int, flags: ::c_uint) -> ::c_int;
+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn lio_listio(
+        mode: ::c_int,
+        aiocb_list: *const *mut aiocb,
+        nitems: ::c_int,
+        sevp: *mut sigevent,
+    ) -> ::c_int;
+
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+
+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn getutxent() -> *mut utmpx;
+    pub fn getutxid(ut: *const utmpx) -> *mut utmpx;
+    pub fn getutxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn pututxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn setutxent();
+    pub fn endutxent();
+    pub fn utmpxname(file: *const ::c_char) -> ::c_int;
+
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::socklen_t,
+        serv: *mut ::c_char,
+        sevlen: ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn mincore(
+        addr: *const ::c_void,
+        len: ::size_t,
+        vec: *mut ::c_char,
+    ) -> ::c_int;
+    pub fn sysctlnametomib(
+        name: *const ::c_char,
+        mibp: *mut ::c_int,
+        sizep: *mut ::size_t,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "mprotect$UNIX2003"
+    )]
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn semget(key: key_t, nsems: ::c_int, semflg: ::c_int) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "semctl$UNIX2003"
+    )]
+    pub fn semctl(
+        semid: ::c_int,
+        semnum: ::c_int,
+        cmd: ::c_int,
+        ...
+    ) -> ::c_int;
+    pub fn semop(
+        semid: ::c_int,
+        sops: *mut sembuf,
+        nsops: ::size_t,
+    ) -> ::c_int;
+    pub fn shm_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::c_int;
+    pub fn ftok(pathname: *const c_char, proj_id: ::c_int) -> key_t;
+    pub fn shmat(
+        shmid: ::c_int,
+        shmaddr: *const ::c_void,
+        shmflg: ::c_int,
+    ) -> *mut ::c_void;
+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "shmctl$UNIX2003"
+    )]
+    pub fn shmctl(
+        shmid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::shmid_ds,
+    ) -> ::c_int;
+    pub fn shmget(key: key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_uint,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    pub fn sysctlbyname(
+        name: *const ::c_char,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    #[deprecated(since = "0.2.55", note = "Use the mach crate")]
+    pub fn mach_absolute_time() -> u64;
+    #[deprecated(since = "0.2.55", note = "Use the mach crate")]
+    #[allow(deprecated)]
+    pub fn mach_timebase_info(info: *mut ::mach_timebase_info) -> ::c_int;
+    pub fn pthread_setname_np(name: *const ::c_char) -> ::c_int;
+    pub fn pthread_getname_np(
+        thread: ::pthread_t,
+        name: *mut ::c_char,
+        len: ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_from_mach_thread_np(port: ::mach_port_t) -> ::pthread_t;
+    pub fn pthread_get_stackaddr_np(thread: ::pthread_t) -> *mut ::c_void;
+    pub fn pthread_get_stacksize_np(thread: ::pthread_t) -> ::size_t;
+    pub fn pthread_condattr_setpshared(
+        attr: *mut pthread_condattr_t,
+        pshared: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getpshared(
+        attr: *const pthread_condattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_setpshared(
+        attr: *mut pthread_mutexattr_t,
+        pshared: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_getpshared(
+        attr: *const pthread_mutexattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_getpshared(
+        attr: *const pthread_rwlockattr_t,
+        val: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_setpshared(
+        attr: *mut pthread_rwlockattr_t,
+        val: ::c_int,
+    ) -> ::c_int;
+    pub fn __error() -> *mut ::c_int;
+    pub fn backtrace(buf: *mut *mut ::c_void, sz: ::c_int) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", not(target_arch = "aarch64")),
+        link_name = "statfs$INODE64"
+    )]
+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", not(target_arch = "aarch64")),
+        link_name = "fstatfs$INODE64"
+    )]
+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;
+    pub fn kevent(
+        kq: ::c_int,
+        changelist: *const ::kevent,
+        nchanges: ::c_int,
+        eventlist: *mut ::kevent,
+        nevents: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn kevent64(
+        kq: ::c_int,
+        changelist: *const ::kevent64_s,
+        nchanges: ::c_int,
+        eventlist: *mut ::kevent64_s,
+        nevents: ::c_int,
+        flags: ::c_uint,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn mount(
+        src: *const ::c_char,
+        target: *const ::c_char,
+        flags: ::c_int,
+        data: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn ptrace(
+        request: ::c_int,
+        pid: ::pid_t,
+        addr: *mut ::c_char,
+        data: ::c_int,
+    ) -> ::c_int;
+    pub fn quotactl(
+        special: *const ::c_char,
+        cmd: ::c_int,
+        id: ::c_int,
+        data: *mut ::c_char,
+    ) -> ::c_int;
+    pub fn sethostname(name: *const ::c_char, len: ::c_int) -> ::c_int;
+    pub fn sendfile(
+        fd: ::c_int,
+        s: ::c_int,
+        offset: ::off_t,
+        len: *mut ::off_t,
+        hdtr: *mut ::sf_hdtr,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn utimensat(
+        dirfd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn openpty(
+        amaster: *mut ::c_int,
+        aslave: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::c_int;
+    pub fn forkpty(
+        amaster: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::pid_t;
+    pub fn login_tty(fd: ::c_int) -> ::c_int;
+    pub fn duplocale(base: ::locale_t) -> ::locale_t;
+    pub fn freelocale(loc: ::locale_t) -> ::c_int;
+    pub fn localeconv_l(loc: ::locale_t) -> *mut lconv;
+    pub fn newlocale(
+        mask: ::c_int,
+        locale: *const ::c_char,
+        base: ::locale_t,
+    ) -> ::locale_t;
+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;
+    pub fn querylocale(mask: ::c_int, loc: ::locale_t) -> *const ::c_char;
+    pub fn getpriority(which: ::c_int, who: ::id_t) -> ::c_int;
+    pub fn setpriority(which: ::c_int, who: ::id_t, prio: ::c_int) -> ::c_int;
+    pub fn getdomainname(name: *mut ::c_char, len: ::c_int) -> ::c_int;
+    pub fn setdomainname(name: *const ::c_char, len: ::c_int) -> ::c_int;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn getxattr(
+        path: *const ::c_char,
+        name: *const ::c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+        position: u32,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn fgetxattr(
+        filedes: ::c_int,
+        name: *const ::c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+        position: u32,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn setxattr(
+        path: *const ::c_char,
+        name: *const ::c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        position: u32,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn fsetxattr(
+        filedes: ::c_int,
+        name: *const ::c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        position: u32,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn listxattr(
+        path: *const ::c_char,
+        list: *mut ::c_char,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn flistxattr(
+        filedes: ::c_int,
+        list: *mut ::c_char,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn removexattr(
+        path: *const ::c_char,
+        name: *const ::c_char,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn renamex_np(
+        from: *const ::c_char,
+        to: *const ::c_char,
+        flags: ::c_uint,
+    ) -> ::c_int;
+    pub fn renameatx_np(
+        fromfd: ::c_int,
+        from: *const ::c_char,
+        tofd: ::c_int,
+        to: *const ::c_char,
+        flags: ::c_uint,
+    ) -> ::c_int;
+    pub fn fremovexattr(
+        filedes: ::c_int,
+        name: *const ::c_char,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn getgrouplist(
+        name: *const ::c_char,
+        basegid: ::c_int,
+        groups: *mut ::c_int,
+        ngroups: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn initgroups(user: *const ::c_char, basegroup: ::c_int) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "waitid$UNIX2003"
+    )]
+    pub fn waitid(
+        idtype: idtype_t,
+        id: id_t,
+        infop: *mut ::siginfo_t,
+        options: ::c_int,
+    ) -> ::c_int;
+    pub fn brk(addr: *const ::c_void) -> *mut ::c_void;
+    pub fn sbrk(increment: ::c_int) -> *mut ::c_void;
+    pub fn settimeofday(
+        tv: *const ::timeval,
+        tz: *const ::timezone,
+    ) -> ::c_int;
+    #[deprecated(since = "0.2.55", note = "Use the mach crate")]
+    pub fn _dyld_image_count() -> u32;
+    #[deprecated(since = "0.2.55", note = "Use the mach crate")]
+    #[allow(deprecated)]
+    pub fn _dyld_get_image_header(image_index: u32) -> *const mach_header;
+    #[deprecated(since = "0.2.55", note = "Use the mach crate")]
+    pub fn _dyld_get_image_vmaddr_slide(image_index: u32) -> ::intptr_t;
+    #[deprecated(since = "0.2.55", note = "Use the mach crate")]
+    pub fn _dyld_get_image_name(image_index: u32) -> *const ::c_char;
+
+    pub fn posix_spawn(
+        pid: *mut ::pid_t,
+        path: *const ::c_char,
+        file_actions: *const ::posix_spawn_file_actions_t,
+        attrp: *const ::posix_spawnattr_t,
+        argv: *const *mut ::c_char,
+        envp: *const *mut ::c_char,
+    ) -> ::c_int;
+    pub fn posix_spawnp(
+        pid: *mut ::pid_t,
+        file: *const ::c_char,
+        file_actions: *const ::posix_spawn_file_actions_t,
+        attrp: *const ::posix_spawnattr_t,
+        argv: *const *mut ::c_char,
+        envp: *const *mut ::c_char,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_init(attr: *mut posix_spawnattr_t) -> ::c_int;
+    pub fn posix_spawnattr_destroy(attr: *mut posix_spawnattr_t) -> ::c_int;
+    pub fn posix_spawnattr_getsigdefault(
+        attr: *const posix_spawnattr_t,
+        default: *mut ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setsigdefault(
+        attr: *mut posix_spawnattr_t,
+        default: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getsigmask(
+        attr: *const posix_spawnattr_t,
+        default: *mut ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setsigmask(
+        attr: *mut posix_spawnattr_t,
+        default: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getflags(
+        attr: *const posix_spawnattr_t,
+        flags: *mut ::c_short,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setflags(
+        attr: *mut posix_spawnattr_t,
+        flags: ::c_short,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getpgroup(
+        attr: *const posix_spawnattr_t,
+        flags: *mut ::pid_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setpgroup(
+        attr: *mut posix_spawnattr_t,
+        flags: ::pid_t,
+    ) -> ::c_int;
+
+    pub fn posix_spawn_file_actions_init(
+        actions: *mut posix_spawn_file_actions_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_destroy(
+        actions: *mut posix_spawn_file_actions_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_addopen(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+        path: *const ::c_char,
+        oflag: ::c_int,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_addclose(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_adddup2(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+        newfd: ::c_int,
+    ) -> ::c_int;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+
+    pub fn connectx(
+        socket: ::c_int,
+        endpoints: *const sa_endpoints_t,
+        associd: sae_associd_t,
+        flags: ::c_uint,
+        iov: *const ::iovec,
+        iovcnt: ::c_uint,
+        len: *mut ::size_t,
+        connid: *mut sae_connid_t,
+    ) -> ::c_int;
+    pub fn disconnectx(
+        socket: ::c_int,
+        associd: sae_associd_t,
+        connid: sae_connid_t,
+    ) -> ::c_int;
+
+    pub fn ntp_adjtime(buf: *mut timex) -> ::c_int;
+    pub fn ntp_gettime(buf: *mut ntptimeval) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(any(target_arch = "arm", target_arch = "x86"))] {
+        mod b32;
+        pub use self::b32::*;
+    } else if #[cfg(any(target_arch = "x86_64", target_arch = "aarch64"))] {
+        mod b64;
+        pub use self::b64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/dragonfly/errno.rs b/library/libc/src/unix/bsd/freebsdlike/dragonfly/errno.rs
new file mode 100644
index 00000000..5fe6bb89
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/dragonfly/errno.rs
@@ -0,0 +1,13 @@
+// DragonFlyBSD's __error function is declared with "static inline", so it must
+// be implemented in the libc crate, as a pointer to a static thread_local.
+f! {
+    #[deprecated(since = "0.2.77", note = "Use `__errno_location()` instead")]
+    pub fn __error() -> *mut ::c_int {
+        &mut errno
+    }
+}
+
+extern "C" {
+    #[thread_local]
+    pub static mut errno: ::c_int;
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs b/library/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs
new file mode 100644
index 00000000..641fb892
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs
@@ -0,0 +1,1110 @@
+pub type dev_t = u32;
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type clock_t = u64;
+pub type ino_t = u64;
+pub type lwpid_t = i32;
+pub type nlink_t = u32;
+pub type blksize_t = i64;
+pub type clockid_t = ::c_ulong;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type time_t = i64;
+pub type suseconds_t = i64;
+
+pub type uuid_t = ::uuid;
+
+pub type fsblkcnt_t = u64;
+pub type fsfilcnt_t = u64;
+
+pub type mqd_t = ::c_int;
+pub type sem_t = *mut sem;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum sem {}
+impl ::Copy for sem {}
+impl ::Clone for sem {
+    fn clone(&self) -> sem {
+        *self
+    }
+}
+
+s! {
+    pub struct kevent {
+        pub ident: ::uintptr_t,
+        pub filter: ::c_short,
+        pub flags: ::c_ushort,
+        pub fflags: ::c_uint,
+        pub data: ::intptr_t,
+        pub udata: *mut ::c_void,
+    }
+
+    pub struct exit_status {
+        pub e_termination: u16,
+        pub e_exit: u16
+    }
+
+    pub struct aiocb {
+        pub aio_fildes: ::c_int,
+        pub aio_offset: ::off_t,
+        pub aio_buf: *mut ::c_void,
+        pub aio_nbytes: ::size_t,
+        pub aio_sigevent: sigevent,
+        pub aio_lio_opcode: ::c_int,
+        pub aio_reqprio: ::c_int,
+        _aio_val: ::c_int,
+        _aio_err: ::c_int
+    }
+
+    pub struct uuid {
+        pub time_low: u32,
+        pub time_mid: u16,
+        pub time_hi_and_version: u16,
+        pub clock_seq_hi_and_reserved: u8,
+        pub clock_seq_low: u8,
+        pub node: [u8; 6],
+    }
+
+    pub struct mq_attr {
+        pub mq_flags: ::c_long,
+        pub mq_maxmsg: ::c_long,
+        pub mq_msgsize: ::c_long,
+        pub mq_curmsgs: ::c_long,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        pub f_owner: ::uid_t,
+        pub f_type: ::c_uint,
+        pub f_syncreads: u64,
+        pub f_syncwrites: u64,
+        pub f_asyncreads: u64,
+        pub f_asyncwrites: u64,
+        pub f_fsid_uuid: ::uuid_t,
+        pub f_uid_uuid: ::uuid_t,
+    }
+
+    pub struct stat {
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_dev: ::dev_t,
+        pub st_mode: ::mode_t,
+        pub st_padding1: u16,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_size: ::off_t,
+        pub st_blocks: i64,
+        pub st_blksize: u32,
+        pub st_flags: u32,
+        pub st_gen: u32,
+        pub st_lspare: i32,
+        pub st_qspare1: i64,
+        pub st_qspare2: i64,
+    }
+
+    pub struct if_data {
+        pub ifi_type: ::c_uchar,
+        pub ifi_physical: ::c_uchar,
+        pub ifi_addrlen: ::c_uchar,
+        pub ifi_hdrlen: ::c_uchar,
+        pub ifi_recvquota: ::c_uchar,
+        pub ifi_xmitquota: ::c_uchar,
+        pub ifi_mtu: ::c_ulong,
+        pub ifi_metric: ::c_ulong,
+        pub ifi_link_state: ::c_ulong,
+        pub ifi_baudrate: u64,
+        pub ifi_ipackets: ::c_ulong,
+        pub ifi_ierrors: ::c_ulong,
+        pub ifi_opackets: ::c_ulong,
+        pub ifi_oerrors: ::c_ulong,
+        pub ifi_collisions: ::c_ulong,
+        pub ifi_ibytes: ::c_ulong,
+        pub ifi_obytes: ::c_ulong,
+        pub ifi_imcasts: ::c_ulong,
+        pub ifi_omcasts: ::c_ulong,
+        pub ifi_iqdrops: ::c_ulong,
+        pub ifi_noproto: ::c_ulong,
+        pub ifi_hwassist: ::c_ulong,
+        pub ifi_oqdrops: ::c_ulong,
+        pub ifi_lastchange: ::timeval,
+    }
+
+    pub struct if_msghdr {
+        pub ifm_msglen: ::c_ushort,
+        pub ifm_version: ::c_uchar,
+        pub ifm_type: ::c_uchar,
+        pub ifm_addrs: ::c_int,
+        pub ifm_flags: ::c_int,
+        pub ifm_index: ::c_ushort,
+        pub ifm_data: if_data,
+    }
+
+    pub struct sockaddr_dl {
+        pub sdl_len: ::c_uchar,
+        pub sdl_family: ::c_uchar,
+        pub sdl_index: ::c_ushort,
+        pub sdl_type: ::c_uchar,
+        pub sdl_nlen: ::c_uchar,
+        pub sdl_alen: ::c_uchar,
+        pub sdl_slen: ::c_uchar,
+        pub sdl_data: [::c_char; 12],
+        pub sdl_rcf: ::c_ushort,
+        pub sdl_route: [::c_ushort; 16],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_char,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct utmpx {
+        pub ut_name: [::c_char; 32],
+        pub ut_id: [::c_char; 4],
+
+        pub ut_line: [::c_char; 32],
+        pub ut_host: [::c_char; 256],
+
+        pub ut_unused: [u8; 16],
+        pub ut_session: u16,
+        pub ut_type: u16,
+        pub ut_pid: ::pid_t,
+        ut_exit: exit_status,
+        ut_ss: ::sockaddr_storage,
+        pub ut_tv: ::timeval,
+        pub ut_unused2: [u8; 16],
+    }
+
+    pub struct dirent {
+        pub d_fileno: ::ino_t,
+        pub d_namlen: u16,
+        pub d_type: u8,
+        __unused1: u8,
+        __unused2: u32,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct statfs {
+        pub f_bsize: ::c_long,
+        pub f_iosize: ::c_long,
+        pub f_blocks: ::c_long,
+        pub f_bfree: ::c_long,
+        pub f_bavail: ::c_long,
+        pub f_files: ::c_long,
+        pub f_ffree: ::c_long,
+        pub f_fsid: ::fsid_t,
+        pub f_owner: ::uid_t,
+        pub f_type: i32,
+        pub f_flags: i32,
+        pub f_syncwrites: ::c_long,
+        pub f_asyncwrites: ::c_long,
+        pub f_fstypename: [::c_char; 16],
+        pub f_mntonname: [::c_char; 90],
+        pub f_syncreads: ::c_long,
+        pub f_asyncreads: ::c_long,
+        pub f_mntfromname: [::c_char; 90],
+    }
+
+    pub struct sigevent {
+        pub sigev_notify: ::c_int,
+        // The union is 8-byte in size, so it is aligned at a 8-byte offset.
+        #[cfg(target_pointer_width = "64")]
+        __unused1: ::c_int,
+        pub sigev_signo: ::c_int,       //actually a union
+        // pad the union
+        #[cfg(target_pointer_width = "64")]
+        __unused2: ::c_int,
+        pub sigev_value: ::sigval,
+        __unused3: *mut ::c_void        //actually a function pointer
+    }
+
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for utmpx {
+            fn eq(&self, other: &utmpx) -> bool {
+                self.ut_name == other.ut_name
+                    && self.ut_id == other.ut_id
+                    && self.ut_line == other.ut_line
+                    && self
+                    .ut_host
+                    .iter()
+                    .zip(other.ut_host.iter())
+                    .all(|(a,b)| a == b)
+                    && self.ut_unused == other.ut_unused
+                    && self.ut_session == other.ut_session
+                    && self.ut_type == other.ut_type
+                    && self.ut_pid == other.ut_pid
+                    && self.ut_exit == other.ut_exit
+                    && self.ut_ss == other.ut_ss
+                    && self.ut_tv == other.ut_tv
+                    && self.ut_unused2 == other.ut_unused2
+            }
+        }
+        impl Eq for utmpx {}
+        impl ::fmt::Debug for utmpx {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmpx")
+                    .field("ut_name", &self.ut_name)
+                    .field("ut_id", &self.ut_id)
+                    .field("ut_line", &self.ut_line)
+                    // FIXME: .field("ut_host", &self.ut_host)
+                    .field("ut_unused", &self.ut_unused)
+                    .field("ut_session", &self.ut_session)
+                    .field("ut_type", &self.ut_type)
+                    .field("ut_pid", &self.ut_pid)
+                    .field("ut_exit", &self.ut_exit)
+                    .field("ut_ss", &self.ut_ss)
+                    .field("ut_tv", &self.ut_tv)
+                    .field("ut_unused2", &self.ut_unused2)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for utmpx {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_name.hash(state);
+                self.ut_id.hash(state);
+                self.ut_line.hash(state);
+                self.ut_host.hash(state);
+                self.ut_unused.hash(state);
+                self.ut_session.hash(state);
+                self.ut_type.hash(state);
+                self.ut_pid.hash(state);
+                self.ut_exit.hash(state);
+                self.ut_ss.hash(state);
+                self.ut_tv.hash(state);
+                self.ut_unused2.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_fileno == other.d_fileno
+                    && self.d_namlen == other.d_namlen
+                    && self.d_type == other.d_type
+                    // Ignore __unused1
+                    // Ignore __unused2
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_fileno", &self.d_fileno)
+                    .field("d_namlen", &self.d_namlen)
+                    .field("d_type", &self.d_type)
+                    // Ignore __unused1
+                    // Ignore __unused2
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_fileno.hash(state);
+                self.d_namlen.hash(state);
+                self.d_type.hash(state);
+                    // Ignore __unused1
+                    // Ignore __unused2
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for statfs {
+            fn eq(&self, other: &statfs) -> bool {
+                self.f_bsize == other.f_bsize
+                    && self.f_iosize == other.f_iosize
+                    && self.f_blocks == other.f_blocks
+                    && self.f_bfree == other.f_bfree
+                    && self.f_bavail == other.f_bavail
+                    && self.f_files == other.f_files
+                    && self.f_ffree == other.f_ffree
+                    && self.f_fsid == other.f_fsid
+                    && self.f_owner == other.f_owner
+                    && self.f_type == other.f_type
+                    && self.f_flags == other.f_flags
+                    && self.f_syncwrites == other.f_syncwrites
+                    && self.f_asyncwrites == other.f_asyncwrites
+                    && self.f_fstypename == other.f_fstypename
+                    && self
+                    .f_mntonname
+                    .iter()
+                    .zip(other.f_mntonname.iter())
+                    .all(|(a,b)| a == b)
+                    && self.f_syncreads == other.f_syncreads
+                    && self.f_asyncreads == other.f_asyncreads
+                    && self
+                    .f_mntfromname
+                    .iter()
+                    .zip(other.f_mntfromname.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for statfs {}
+        impl ::fmt::Debug for statfs {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("statfs")
+                    .field("f_bsize", &self.f_bsize)
+                    .field("f_iosize", &self.f_iosize)
+                    .field("f_blocks", &self.f_blocks)
+                    .field("f_bfree", &self.f_bfree)
+                    .field("f_bavail", &self.f_bavail)
+                    .field("f_files", &self.f_files)
+                    .field("f_ffree", &self.f_ffree)
+                    .field("f_fsid", &self.f_fsid)
+                    .field("f_owner", &self.f_owner)
+                    .field("f_type", &self.f_type)
+                    .field("f_flags", &self.f_flags)
+                    .field("f_syncwrites", &self.f_syncwrites)
+                    .field("f_asyncwrites", &self.f_asyncwrites)
+                    // FIXME: .field("f_mntonname", &self.f_mntonname)
+                    .field("f_syncreads", &self.f_syncreads)
+                    .field("f_asyncreads", &self.f_asyncreads)
+                    // FIXME: .field("f_mntfromname", &self.f_mntfromname)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for statfs {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.f_bsize.hash(state);
+                self.f_iosize.hash(state);
+                self.f_blocks.hash(state);
+                self.f_bfree.hash(state);
+                self.f_bavail.hash(state);
+                self.f_files.hash(state);
+                self.f_ffree.hash(state);
+                self.f_fsid.hash(state);
+                self.f_owner.hash(state);
+                self.f_type.hash(state);
+                self.f_flags.hash(state);
+                self.f_syncwrites.hash(state);
+                self.f_asyncwrites.hash(state);
+                self.f_fstypename.hash(state);
+                self.f_mntonname.hash(state);
+                self.f_syncreads.hash(state);
+                self.f_asyncreads.hash(state);
+                self.f_mntfromname.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_notify == other.sigev_notify
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_value == other.sigev_value
+            }
+        }
+        impl Eq for sigevent {}
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_value", &self.sigev_value)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_notify.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_value.hash(state);
+            }
+        }
+    }
+}
+
+pub const RAND_MAX: ::c_int = 0x7fff_ffff;
+pub const PTHREAD_STACK_MIN: ::size_t = 16384;
+pub const SIGSTKSZ: ::size_t = 40960;
+pub const MADV_INVAL: ::c_int = 10;
+pub const MADV_SETMAP: ::c_int = 11;
+pub const O_CLOEXEC: ::c_int = 0x00020000;
+pub const O_DIRECTORY: ::c_int = 0x08000000;
+pub const F_GETLK: ::c_int = 7;
+pub const F_SETLK: ::c_int = 8;
+pub const F_SETLKW: ::c_int = 9;
+pub const ENOMEDIUM: ::c_int = 93;
+pub const EASYNC: ::c_int = 99;
+pub const ELAST: ::c_int = 99;
+pub const RLIMIT_POSIXLOCKS: ::c_int = 11;
+#[deprecated(since = "0.2.64", note = "Not stable across OS versions")]
+pub const RLIM_NLIMITS: ::rlim_t = 12;
+
+pub const Q_GETQUOTA: ::c_int = 0x300;
+pub const Q_SETQUOTA: ::c_int = 0x400;
+
+pub const CTL_UNSPEC: ::c_int = 0;
+pub const CTL_KERN: ::c_int = 1;
+pub const CTL_VM: ::c_int = 2;
+pub const CTL_VFS: ::c_int = 3;
+pub const CTL_NET: ::c_int = 4;
+pub const CTL_DEBUG: ::c_int = 5;
+pub const CTL_HW: ::c_int = 6;
+pub const CTL_MACHDEP: ::c_int = 7;
+pub const CTL_USER: ::c_int = 8;
+pub const CTL_P1003_1B: ::c_int = 9;
+pub const CTL_LWKT: ::c_int = 10;
+pub const CTL_MAXID: ::c_int = 11;
+pub const KERN_OSTYPE: ::c_int = 1;
+pub const KERN_OSRELEASE: ::c_int = 2;
+pub const KERN_OSREV: ::c_int = 3;
+pub const KERN_VERSION: ::c_int = 4;
+pub const KERN_MAXVNODES: ::c_int = 5;
+pub const KERN_MAXPROC: ::c_int = 6;
+pub const KERN_MAXFILES: ::c_int = 7;
+pub const KERN_ARGMAX: ::c_int = 8;
+pub const KERN_SECURELVL: ::c_int = 9;
+pub const KERN_HOSTNAME: ::c_int = 10;
+pub const KERN_HOSTID: ::c_int = 11;
+pub const KERN_CLOCKRATE: ::c_int = 12;
+pub const KERN_VNODE: ::c_int = 13;
+pub const KERN_PROC: ::c_int = 14;
+pub const KERN_FILE: ::c_int = 15;
+pub const KERN_PROF: ::c_int = 16;
+pub const KERN_POSIX1: ::c_int = 17;
+pub const KERN_NGROUPS: ::c_int = 18;
+pub const KERN_JOB_CONTROL: ::c_int = 19;
+pub const KERN_SAVED_IDS: ::c_int = 20;
+pub const KERN_BOOTTIME: ::c_int = 21;
+pub const KERN_NISDOMAINNAME: ::c_int = 22;
+pub const KERN_UPDATEINTERVAL: ::c_int = 23;
+pub const KERN_OSRELDATE: ::c_int = 24;
+pub const KERN_NTP_PLL: ::c_int = 25;
+pub const KERN_BOOTFILE: ::c_int = 26;
+pub const KERN_MAXFILESPERPROC: ::c_int = 27;
+pub const KERN_MAXPROCPERUID: ::c_int = 28;
+pub const KERN_DUMPDEV: ::c_int = 29;
+pub const KERN_IPC: ::c_int = 30;
+pub const KERN_DUMMY: ::c_int = 31;
+pub const KERN_PS_STRINGS: ::c_int = 32;
+pub const KERN_USRSTACK: ::c_int = 33;
+pub const KERN_LOGSIGEXIT: ::c_int = 34;
+pub const KERN_IOV_MAX: ::c_int = 35;
+pub const KERN_MAXPOSIXLOCKSPERUID: ::c_int = 36;
+pub const KERN_MAXID: ::c_int = 37;
+pub const KERN_PROC_ALL: ::c_int = 0;
+pub const KERN_PROC_PID: ::c_int = 1;
+pub const KERN_PROC_PGRP: ::c_int = 2;
+pub const KERN_PROC_SESSION: ::c_int = 3;
+pub const KERN_PROC_TTY: ::c_int = 4;
+pub const KERN_PROC_UID: ::c_int = 5;
+pub const KERN_PROC_RUID: ::c_int = 6;
+pub const KERN_PROC_ARGS: ::c_int = 7;
+pub const KERN_PROC_CWD: ::c_int = 8;
+pub const KERN_PROC_PATHNAME: ::c_int = 9;
+pub const KERN_PROC_FLAGMASK: ::c_int = 0x10;
+pub const KERN_PROC_FLAG_LWP: ::c_int = 0x10;
+pub const KIPC_MAXSOCKBUF: ::c_int = 1;
+pub const KIPC_SOCKBUF_WASTE: ::c_int = 2;
+pub const KIPC_SOMAXCONN: ::c_int = 3;
+pub const KIPC_MAX_LINKHDR: ::c_int = 4;
+pub const KIPC_MAX_PROTOHDR: ::c_int = 5;
+pub const KIPC_MAX_HDR: ::c_int = 6;
+pub const KIPC_MAX_DATALEN: ::c_int = 7;
+pub const KIPC_MBSTAT: ::c_int = 8;
+pub const KIPC_NMBCLUSTERS: ::c_int = 9;
+pub const HW_MACHINE: ::c_int = 1;
+pub const HW_MODEL: ::c_int = 2;
+pub const HW_NCPU: ::c_int = 3;
+pub const HW_BYTEORDER: ::c_int = 4;
+pub const HW_PHYSMEM: ::c_int = 5;
+pub const HW_USERMEM: ::c_int = 6;
+pub const HW_PAGESIZE: ::c_int = 7;
+pub const HW_DISKNAMES: ::c_int = 8;
+pub const HW_DISKSTATS: ::c_int = 9;
+pub const HW_FLOATINGPT: ::c_int = 10;
+pub const HW_MACHINE_ARCH: ::c_int = 11;
+pub const HW_MACHINE_PLATFORM: ::c_int = 12;
+pub const HW_SENSORS: ::c_int = 13;
+pub const HW_MAXID: ::c_int = 14;
+pub const USER_CS_PATH: ::c_int = 1;
+pub const USER_BC_BASE_MAX: ::c_int = 2;
+pub const USER_BC_DIM_MAX: ::c_int = 3;
+pub const USER_BC_SCALE_MAX: ::c_int = 4;
+pub const USER_BC_STRING_MAX: ::c_int = 5;
+pub const USER_COLL_WEIGHTS_MAX: ::c_int = 6;
+pub const USER_EXPR_NEST_MAX: ::c_int = 7;
+pub const USER_LINE_MAX: ::c_int = 8;
+pub const USER_RE_DUP_MAX: ::c_int = 9;
+pub const USER_POSIX2_VERSION: ::c_int = 10;
+pub const USER_POSIX2_C_BIND: ::c_int = 11;
+pub const USER_POSIX2_C_DEV: ::c_int = 12;
+pub const USER_POSIX2_CHAR_TERM: ::c_int = 13;
+pub const USER_POSIX2_FORT_DEV: ::c_int = 14;
+pub const USER_POSIX2_FORT_RUN: ::c_int = 15;
+pub const USER_POSIX2_LOCALEDEF: ::c_int = 16;
+pub const USER_POSIX2_SW_DEV: ::c_int = 17;
+pub const USER_POSIX2_UPE: ::c_int = 18;
+pub const USER_STREAM_MAX: ::c_int = 19;
+pub const USER_TZNAME_MAX: ::c_int = 20;
+pub const USER_MAXID: ::c_int = 21;
+pub const CTL_P1003_1B_ASYNCHRONOUS_IO: ::c_int = 1;
+pub const CTL_P1003_1B_MAPPED_FILES: ::c_int = 2;
+pub const CTL_P1003_1B_MEMLOCK: ::c_int = 3;
+pub const CTL_P1003_1B_MEMLOCK_RANGE: ::c_int = 4;
+pub const CTL_P1003_1B_MEMORY_PROTECTION: ::c_int = 5;
+pub const CTL_P1003_1B_MESSAGE_PASSING: ::c_int = 6;
+pub const CTL_P1003_1B_PRIORITIZED_IO: ::c_int = 7;
+pub const CTL_P1003_1B_PRIORITY_SCHEDULING: ::c_int = 8;
+pub const CTL_P1003_1B_REALTIME_SIGNALS: ::c_int = 9;
+pub const CTL_P1003_1B_SEMAPHORES: ::c_int = 10;
+pub const CTL_P1003_1B_FSYNC: ::c_int = 11;
+pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: ::c_int = 12;
+pub const CTL_P1003_1B_SYNCHRONIZED_IO: ::c_int = 13;
+pub const CTL_P1003_1B_TIMERS: ::c_int = 14;
+pub const CTL_P1003_1B_AIO_LISTIO_MAX: ::c_int = 15;
+pub const CTL_P1003_1B_AIO_MAX: ::c_int = 16;
+pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: ::c_int = 17;
+pub const CTL_P1003_1B_DELAYTIMER_MAX: ::c_int = 18;
+pub const CTL_P1003_1B_UNUSED1: ::c_int = 19;
+pub const CTL_P1003_1B_PAGESIZE: ::c_int = 20;
+pub const CTL_P1003_1B_RTSIG_MAX: ::c_int = 21;
+pub const CTL_P1003_1B_SEM_NSEMS_MAX: ::c_int = 22;
+pub const CTL_P1003_1B_SEM_VALUE_MAX: ::c_int = 23;
+pub const CTL_P1003_1B_SIGQUEUE_MAX: ::c_int = 24;
+pub const CTL_P1003_1B_TIMER_MAX: ::c_int = 25;
+pub const CTL_P1003_1B_MAXID: ::c_int = 26;
+
+pub const EVFILT_READ: i16 = -1;
+pub const EVFILT_WRITE: i16 = -2;
+pub const EVFILT_AIO: i16 = -3;
+pub const EVFILT_VNODE: i16 = -4;
+pub const EVFILT_PROC: i16 = -5;
+pub const EVFILT_SIGNAL: i16 = -6;
+pub const EVFILT_TIMER: i16 = -7;
+pub const EVFILT_EXCEPT: i16 = -8;
+pub const EVFILT_USER: i16 = -9;
+pub const EVFILT_FS: i16 = -10;
+
+pub const EV_ADD: u16 = 0x1;
+pub const EV_DELETE: u16 = 0x2;
+pub const EV_ENABLE: u16 = 0x4;
+pub const EV_DISABLE: u16 = 0x8;
+pub const EV_ONESHOT: u16 = 0x10;
+pub const EV_CLEAR: u16 = 0x20;
+pub const EV_RECEIPT: u16 = 0x40;
+pub const EV_DISPATCH: u16 = 0x80;
+pub const EV_NODATA: u16 = 0x1000;
+pub const EV_FLAG1: u16 = 0x2000;
+pub const EV_ERROR: u16 = 0x4000;
+pub const EV_EOF: u16 = 0x8000;
+pub const EV_SYSFLAGS: u16 = 0xf000;
+
+pub const NOTE_TRIGGER: u32 = 0x01000000;
+pub const NOTE_FFNOP: u32 = 0x00000000;
+pub const NOTE_FFAND: u32 = 0x40000000;
+pub const NOTE_FFOR: u32 = 0x80000000;
+pub const NOTE_FFCOPY: u32 = 0xc0000000;
+pub const NOTE_FFCTRLMASK: u32 = 0xc0000000;
+pub const NOTE_FFLAGSMASK: u32 = 0x00ffffff;
+pub const NOTE_LOWAT: u32 = 0x00000001;
+pub const NOTE_OOB: u32 = 0x00000002;
+pub const NOTE_DELETE: u32 = 0x00000001;
+pub const NOTE_WRITE: u32 = 0x00000002;
+pub const NOTE_EXTEND: u32 = 0x00000004;
+pub const NOTE_ATTRIB: u32 = 0x00000008;
+pub const NOTE_LINK: u32 = 0x00000010;
+pub const NOTE_RENAME: u32 = 0x00000020;
+pub const NOTE_REVOKE: u32 = 0x00000040;
+pub const NOTE_EXIT: u32 = 0x80000000;
+pub const NOTE_FORK: u32 = 0x40000000;
+pub const NOTE_EXEC: u32 = 0x20000000;
+pub const NOTE_PDATAMASK: u32 = 0x000fffff;
+pub const NOTE_PCTRLMASK: u32 = 0xf0000000;
+pub const NOTE_TRACK: u32 = 0x00000001;
+pub const NOTE_TRACKERR: u32 = 0x00000002;
+pub const NOTE_CHILD: u32 = 0x00000004;
+
+pub const SO_SNDSPACE: ::c_int = 0x100a;
+pub const SO_CPUHINT: ::c_int = 0x1030;
+
+pub const PT_FIRSTMACH: ::c_int = 32;
+
+// https://github.com/DragonFlyBSD/DragonFlyBSD/blob/master/sys/net/if.h#L101
+pub const IFF_UP: ::c_int = 0x1; // interface is up
+pub const IFF_BROADCAST: ::c_int = 0x2; // broadcast address valid
+pub const IFF_DEBUG: ::c_int = 0x4; // turn on debugging
+pub const IFF_LOOPBACK: ::c_int = 0x8; // is a loopback net
+pub const IFF_POINTOPOINT: ::c_int = 0x10; // interface is point-to-point link
+pub const IFF_SMART: ::c_int = 0x20; // interface manages own routes
+pub const IFF_RUNNING: ::c_int = 0x40; // resources allocated
+pub const IFF_NOARP: ::c_int = 0x80; // no address resolution protocol
+pub const IFF_PROMISC: ::c_int = 0x100; // receive all packets
+pub const IFF_ALLMULTI: ::c_int = 0x200; // receive all multicast packets
+pub const IFF_OACTIVE_COMPAT: ::c_int = 0x400; // was transmission in progress
+pub const IFF_SIMPLEX: ::c_int = 0x800; // can't hear own transmissions
+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit
+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit
+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit
+pub const IFF_ALTPHYS: ::c_int = IFF_LINK2; // use alternate physical connection
+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast
+                                           // was interface is in polling mode
+pub const IFF_POLLING_COMPAT: ::c_int = 0x10000;
+pub const IFF_PPROMISC: ::c_int = 0x20000; // user-requested promisc mode
+pub const IFF_MONITOR: ::c_int = 0x40000; // user-requested monitor mode
+pub const IFF_STATICARP: ::c_int = 0x80000; // static ARP
+pub const IFF_NPOLLING: ::c_int = 0x100000; // interface is in polling mode
+pub const IFF_IDIRECT: ::c_int = 0x200000; // direct input
+
+//
+// sys/netinet/in.h
+// Protocols (RFC 1700)
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+// IPPROTO_IP defined in src/unix/mod.rs
+/// IP6 hop-by-hop options
+pub const IPPROTO_HOPOPTS: ::c_int = 0;
+// IPPROTO_ICMP defined in src/unix/mod.rs
+/// group mgmt protocol
+pub const IPPROTO_IGMP: ::c_int = 2;
+/// gateway^2 (deprecated)
+pub const IPPROTO_GGP: ::c_int = 3;
+/// for compatibility
+pub const IPPROTO_IPIP: ::c_int = 4;
+// IPPROTO_TCP defined in src/unix/mod.rs
+/// Stream protocol II.
+pub const IPPROTO_ST: ::c_int = 7;
+/// exterior gateway protocol
+pub const IPPROTO_EGP: ::c_int = 8;
+/// private interior gateway
+pub const IPPROTO_PIGP: ::c_int = 9;
+/// BBN RCC Monitoring
+pub const IPPROTO_RCCMON: ::c_int = 10;
+/// network voice protocol
+pub const IPPROTO_NVPII: ::c_int = 11;
+/// pup
+pub const IPPROTO_PUP: ::c_int = 12;
+/// Argus
+pub const IPPROTO_ARGUS: ::c_int = 13;
+/// EMCON
+pub const IPPROTO_EMCON: ::c_int = 14;
+/// Cross Net Debugger
+pub const IPPROTO_XNET: ::c_int = 15;
+/// Chaos
+pub const IPPROTO_CHAOS: ::c_int = 16;
+// IPPROTO_UDP defined in src/unix/mod.rs
+/// Multiplexing
+pub const IPPROTO_MUX: ::c_int = 18;
+/// DCN Measurement Subsystems
+pub const IPPROTO_MEAS: ::c_int = 19;
+/// Host Monitoring
+pub const IPPROTO_HMP: ::c_int = 20;
+/// Packet Radio Measurement
+pub const IPPROTO_PRM: ::c_int = 21;
+/// xns idp
+pub const IPPROTO_IDP: ::c_int = 22;
+/// Trunk-1
+pub const IPPROTO_TRUNK1: ::c_int = 23;
+/// Trunk-2
+pub const IPPROTO_TRUNK2: ::c_int = 24;
+/// Leaf-1
+pub const IPPROTO_LEAF1: ::c_int = 25;
+/// Leaf-2
+pub const IPPROTO_LEAF2: ::c_int = 26;
+/// Reliable Data
+pub const IPPROTO_RDP: ::c_int = 27;
+/// Reliable Transaction
+pub const IPPROTO_IRTP: ::c_int = 28;
+/// tp-4 w/ class negotiation
+pub const IPPROTO_TP: ::c_int = 29;
+/// Bulk Data Transfer
+pub const IPPROTO_BLT: ::c_int = 30;
+/// Network Services
+pub const IPPROTO_NSP: ::c_int = 31;
+/// Merit Internodal
+pub const IPPROTO_INP: ::c_int = 32;
+/// Sequential Exchange
+pub const IPPROTO_SEP: ::c_int = 33;
+/// Third Party Connect
+pub const IPPROTO_3PC: ::c_int = 34;
+/// InterDomain Policy Routing
+pub const IPPROTO_IDPR: ::c_int = 35;
+/// XTP
+pub const IPPROTO_XTP: ::c_int = 36;
+/// Datagram Delivery
+pub const IPPROTO_DDP: ::c_int = 37;
+/// Control Message Transport
+pub const IPPROTO_CMTP: ::c_int = 38;
+/// TP++ Transport
+pub const IPPROTO_TPXX: ::c_int = 39;
+/// IL transport protocol
+pub const IPPROTO_IL: ::c_int = 40;
+// IPPROTO_IPV6 defined in src/unix/mod.rs
+/// Source Demand Routing
+pub const IPPROTO_SDRP: ::c_int = 42;
+/// IP6 routing header
+pub const IPPROTO_ROUTING: ::c_int = 43;
+/// IP6 fragmentation header
+pub const IPPROTO_FRAGMENT: ::c_int = 44;
+/// InterDomain Routing
+pub const IPPROTO_IDRP: ::c_int = 45;
+/// resource reservation
+pub const IPPROTO_RSVP: ::c_int = 46;
+/// General Routing Encap.
+pub const IPPROTO_GRE: ::c_int = 47;
+/// Mobile Host Routing
+pub const IPPROTO_MHRP: ::c_int = 48;
+/// BHA
+pub const IPPROTO_BHA: ::c_int = 49;
+/// IP6 Encap Sec. Payload
+pub const IPPROTO_ESP: ::c_int = 50;
+/// IP6 Auth Header
+pub const IPPROTO_AH: ::c_int = 51;
+/// Integ. Net Layer Security
+pub const IPPROTO_INLSP: ::c_int = 52;
+/// IP with encryption
+pub const IPPROTO_SWIPE: ::c_int = 53;
+/// Next Hop Resolution
+pub const IPPROTO_NHRP: ::c_int = 54;
+/// IP Mobility
+pub const IPPROTO_MOBILE: ::c_int = 55;
+/// Transport Layer Security
+pub const IPPROTO_TLSP: ::c_int = 56;
+/// SKIP
+pub const IPPROTO_SKIP: ::c_int = 57;
+// IPPROTO_ICMPV6 defined in src/unix/mod.rs
+/// IP6 no next header
+pub const IPPROTO_NONE: ::c_int = 59;
+/// IP6 destination option
+pub const IPPROTO_DSTOPTS: ::c_int = 60;
+/// any host internal protocol
+pub const IPPROTO_AHIP: ::c_int = 61;
+/// CFTP
+pub const IPPROTO_CFTP: ::c_int = 62;
+/// "hello" routing protocol
+pub const IPPROTO_HELLO: ::c_int = 63;
+/// SATNET/Backroom EXPAK
+pub const IPPROTO_SATEXPAK: ::c_int = 64;
+/// Kryptolan
+pub const IPPROTO_KRYPTOLAN: ::c_int = 65;
+/// Remote Virtual Disk
+pub const IPPROTO_RVD: ::c_int = 66;
+/// Pluribus Packet Core
+pub const IPPROTO_IPPC: ::c_int = 67;
+/// Any distributed FS
+pub const IPPROTO_ADFS: ::c_int = 68;
+/// Satnet Monitoring
+pub const IPPROTO_SATMON: ::c_int = 69;
+/// VISA Protocol
+pub const IPPROTO_VISA: ::c_int = 70;
+/// Packet Core Utility
+pub const IPPROTO_IPCV: ::c_int = 71;
+/// Comp. Prot. Net. Executive
+pub const IPPROTO_CPNX: ::c_int = 72;
+/// Comp. Prot. HeartBeat
+pub const IPPROTO_CPHB: ::c_int = 73;
+/// Wang Span Network
+pub const IPPROTO_WSN: ::c_int = 74;
+/// Packet Video Protocol
+pub const IPPROTO_PVP: ::c_int = 75;
+/// BackRoom SATNET Monitoring
+pub const IPPROTO_BRSATMON: ::c_int = 76;
+/// Sun net disk proto (temp.)
+pub const IPPROTO_ND: ::c_int = 77;
+/// WIDEBAND Monitoring
+pub const IPPROTO_WBMON: ::c_int = 78;
+/// WIDEBAND EXPAK
+pub const IPPROTO_WBEXPAK: ::c_int = 79;
+/// ISO cnlp
+pub const IPPROTO_EON: ::c_int = 80;
+/// VMTP
+pub const IPPROTO_VMTP: ::c_int = 81;
+/// Secure VMTP
+pub const IPPROTO_SVMTP: ::c_int = 82;
+/// Banyon VINES
+pub const IPPROTO_VINES: ::c_int = 83;
+/// TTP
+pub const IPPROTO_TTP: ::c_int = 84;
+/// NSFNET-IGP
+pub const IPPROTO_IGP: ::c_int = 85;
+/// dissimilar gateway prot.
+pub const IPPROTO_DGP: ::c_int = 86;
+/// TCF
+pub const IPPROTO_TCF: ::c_int = 87;
+/// Cisco/GXS IGRP
+pub const IPPROTO_IGRP: ::c_int = 88;
+/// OSPFIGP
+pub const IPPROTO_OSPFIGP: ::c_int = 89;
+/// Strite RPC protocol
+pub const IPPROTO_SRPC: ::c_int = 90;
+/// Locus Address Resoloution
+pub const IPPROTO_LARP: ::c_int = 91;
+/// Multicast Transport
+pub const IPPROTO_MTP: ::c_int = 92;
+/// AX.25 Frames
+pub const IPPROTO_AX25: ::c_int = 93;
+/// IP encapsulated in IP
+pub const IPPROTO_IPEIP: ::c_int = 94;
+/// Mobile Int.ing control
+pub const IPPROTO_MICP: ::c_int = 95;
+/// Semaphore Comm. security
+pub const IPPROTO_SCCSP: ::c_int = 96;
+/// Ethernet IP encapsulation
+pub const IPPROTO_ETHERIP: ::c_int = 97;
+/// encapsulation header
+pub const IPPROTO_ENCAP: ::c_int = 98;
+/// any private encr. scheme
+pub const IPPROTO_APES: ::c_int = 99;
+/// GMTP
+pub const IPPROTO_GMTP: ::c_int = 100;
+/// payload compression (IPComp)
+pub const IPPROTO_IPCOMP: ::c_int = 108;
+
+/* 101-254: Partly Unassigned */
+/// Protocol Independent Mcast
+pub const IPPROTO_PIM: ::c_int = 103;
+/// CARP
+pub const IPPROTO_CARP: ::c_int = 112;
+/// PGM
+pub const IPPROTO_PGM: ::c_int = 113;
+/// PFSYNC
+pub const IPPROTO_PFSYNC: ::c_int = 240;
+
+/* 255: Reserved */
+/* BSD Private, local use, namespace incursion, no longer used */
+/// divert pseudo-protocol
+pub const IPPROTO_DIVERT: ::c_int = 254;
+pub const IPPROTO_MAX: ::c_int = 256;
+/// last return value of *_input(), meaning "all job for this pkt is done".
+pub const IPPROTO_DONE: ::c_int = 257;
+
+/// Used by RSS: the layer3 protocol is unknown
+pub const IPPROTO_UNKNOWN: ::c_int = 258;
+
+// sys/netinet/tcp.h
+pub const TCP_SIGNATURE_ENABLE: ::c_int = 16;
+pub const TCP_KEEPINIT: ::c_int = 32;
+pub const TCP_FASTKEEP: ::c_int = 128;
+
+pub const AF_BLUETOOTH: ::c_int = 33;
+pub const AF_MPLS: ::c_int = 34;
+pub const AF_IEEE80211: ::c_int = 35;
+
+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;
+
+pub const NET_RT_DUMP: ::c_int = 1;
+pub const NET_RT_FLAGS: ::c_int = 2;
+pub const NET_RT_IFLIST: ::c_int = 3;
+pub const NET_RT_MAXID: ::c_int = 4;
+
+pub const SOMAXOPT_SIZE: ::c_int = 65536;
+
+pub const MSG_UNUSED09: ::c_int = 0x00000200;
+pub const MSG_NOSIGNAL: ::c_int = 0x00000400;
+pub const MSG_SYNC: ::c_int = 0x00000800;
+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x00001000;
+pub const MSG_FBLOCKING: ::c_int = 0x00010000;
+pub const MSG_FNONBLOCKING: ::c_int = 0x00020000;
+pub const MSG_FMASK: ::c_int = 0xFFFF0000;
+
+// utmpx entry types
+pub const EMPTY: ::c_short = 0;
+pub const RUN_LVL: ::c_short = 1;
+pub const BOOT_TIME: ::c_short = 2;
+pub const OLD_TIME: ::c_short = 3;
+pub const NEW_TIME: ::c_short = 4;
+pub const INIT_PROCESS: ::c_short = 5;
+pub const LOGIN_PROCESS: ::c_short = 6;
+pub const USER_PROCESS: ::c_short = 7;
+pub const DEAD_PROCESS: ::c_short = 8;
+pub const ACCOUNTING: ::c_short = 9;
+pub const SIGNATURE: ::c_short = 10;
+pub const DOWNTIME: ::c_short = 11;
+// utmpx database types
+pub const UTX_DB_UTMPX: ::c_uint = 0;
+pub const UTX_DB_WTMPX: ::c_uint = 1;
+pub const UTX_DB_LASTLOG: ::c_uint = 2;
+
+pub const LC_COLLATE_MASK: ::c_int = 1 << 0;
+pub const LC_CTYPE_MASK: ::c_int = 1 << 1;
+pub const LC_MONETARY_MASK: ::c_int = 1 << 2;
+pub const LC_NUMERIC_MASK: ::c_int = 1 << 3;
+pub const LC_TIME_MASK: ::c_int = 1 << 4;
+pub const LC_MESSAGES_MASK: ::c_int = 1 << 5;
+pub const LC_ALL_MASK: ::c_int = LC_COLLATE_MASK
+    | LC_CTYPE_MASK
+    | LC_MESSAGES_MASK
+    | LC_MONETARY_MASK
+    | LC_NUMERIC_MASK
+    | LC_TIME_MASK;
+
+pub const TIOCSIG: ::c_uint = 0x2000745f;
+pub const BTUARTDISC: ::c_int = 0x7;
+pub const TIOCDCDTIMESTAMP: ::c_uint = 0x40107458;
+pub const TIOCISPTMASTER: ::c_uint = 0x20007455;
+pub const TIOCMODG: ::c_uint = 0x40047403;
+pub const TIOCMODS: ::c_ulong = 0x80047404;
+pub const TIOCREMOTE: ::c_ulong = 0x80047469;
+
+// Constants used by "at" family of system calls.
+pub const AT_FDCWD: ::c_int = 0xFFFAFDCD; // invalid file descriptor
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 1;
+pub const AT_REMOVEDIR: ::c_int = 2;
+pub const AT_EACCESS: ::c_int = 4;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 8;
+
+pub const VCHECKPT: usize = 19;
+
+pub const _PC_2_SYMLINKS: ::c_int = 22;
+pub const _PC_TIMESTAMP_RESOLUTION: ::c_int = 23;
+
+pub const _SC_V7_ILP32_OFF32: ::c_int = 122;
+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 123;
+pub const _SC_V7_LP64_OFF64: ::c_int = 124;
+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 125;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 126;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 127;
+
+pub const WCONTINUED: ::c_int = 4;
+pub const WSTOPPED: ::c_int = 0o177;
+
+// Values for struct rtprio (type_ field)
+pub const RTP_PRIO_REALTIME: ::c_ushort = 0;
+pub const RTP_PRIO_NORMAL: ::c_ushort = 1;
+pub const RTP_PRIO_IDLE: ::c_ushort = 2;
+pub const RTP_PRIO_THREAD: ::c_ushort = 3;
+
+// Flags for chflags(2)
+pub const UF_NOHISTORY: ::c_ulong = 0x00000040;
+pub const UF_CACHE: ::c_ulong = 0x00000080;
+pub const UF_XLINK: ::c_ulong = 0x00000100;
+pub const SF_NOHISTORY: ::c_ulong = 0x00400000;
+pub const SF_CACHE: ::c_ulong = 0x00800000;
+pub const SF_XLINK: ::c_ulong = 0x01000000;
+
+// timespec constants
+pub const UTIME_OMIT: c_long = -2;
+pub const UTIME_NOW: c_long = -1;
+
+fn _CMSG_ALIGN(n: usize) -> usize {
+    (n + 3) & !3
+}
+
+f! {
+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {
+        (cmsg as *mut ::c_uchar)
+            .offset(_CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        (_CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) + length as usize)
+            as ::c_uint
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)
+        -> *mut ::cmsghdr
+    {
+        let next = cmsg as usize + _CMSG_ALIGN((*cmsg).cmsg_len as usize)
+            + _CMSG_ALIGN(::mem::size_of::<::cmsghdr>());
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if next <= max {
+            (cmsg as usize + _CMSG_ALIGN((*cmsg).cmsg_len as usize))
+                as *mut ::cmsghdr
+        } else {
+            0 as *mut ::cmsghdr
+        }
+    }
+
+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        (_CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) +
+            _CMSG_ALIGN(length as usize)) as ::c_uint
+    }
+}
+
+safe_f! {
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        (status & 0o177) != 0o177 && (status & 0o177) != 0
+    }
+}
+
+extern "C" {
+    pub fn __errno_location() -> *mut ::c_int;
+    pub fn setgrent();
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+
+    pub fn setutxdb(_type: ::c_uint, file: *mut ::c_char) -> ::c_int;
+
+    pub fn aio_waitcomplete(
+        iocbp: *mut *mut aiocb,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+
+    pub fn freelocale(loc: ::locale_t);
+
+    pub fn lwp_rtprio(
+        function: ::c_int,
+        pid: ::pid_t,
+        lwpid: lwpid_t,
+        rtp: *mut super::rtprio,
+    ) -> ::c_int;
+
+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;
+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+    pub fn memmem(
+        haystack: *const ::c_void,
+        haystacklen: ::size_t,
+        needle: *const ::c_void,
+        needlelen: ::size_t,
+    ) -> *mut ::c_void;
+}
+
+#[link(name = "rt")]
+extern "C" {
+    pub fn aio_cancel(fd: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_error(aiocbp: *const aiocb) -> ::c_int;
+    pub fn aio_fsync(op: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_read(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_return(aiocbp: *mut aiocb) -> ::ssize_t;
+    pub fn aio_suspend(
+        aiocb_list: *const *const aiocb,
+        nitems: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn aio_write(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn lio_listio(
+        mode: ::c_int,
+        aiocb_list: *const *mut aiocb,
+        nitems: ::c_int,
+        sevp: *mut sigevent,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_thread_local)] {
+        mod errno;
+        pub use self::errno::*;
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/aarch64.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/aarch64.rs
new file mode 100644
index 00000000..db0093a5
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/aarch64.rs
@@ -0,0 +1,21 @@
+pub type c_char = u8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type wchar_t = u32;
+pub type time_t = i64;
+pub type suseconds_t = i64;
+pub type register_t = i64;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_longlong>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 8 - 1;
+    }
+}
+
+pub const MAP_32BIT: ::c_int = 0x00080000;
+pub const MINSIGSTKSZ: ::size_t = 4096; // 1024 * 4
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/arm.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/arm.rs
new file mode 100644
index 00000000..300b3dd4
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/arm.rs
@@ -0,0 +1,50 @@
+pub type c_char = u8;
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type wchar_t = u32;
+pub type time_t = i64;
+pub type suseconds_t = i32;
+pub type register_t = i32;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_atime_pad: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_mtime_pad: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ctime_pad: ::c_long,
+        pub st_size: ::off_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_blksize: ::blksize_t,
+        pub st_flags: ::fflags_t,
+        pub st_gen: u32,
+        pub st_lspare: i32,
+        pub st_birthtime: ::time_t,
+        pub st_birthtime_nsec: ::c_long,
+        pub st_birthtime_pad: ::c_long,
+    }
+}
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_int>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 4 - 1;
+    }
+}
+pub const MAP_32BIT: ::c_int = 0x00080000;
+pub const MINSIGSTKSZ: ::size_t = 4096; // 1024 * 4
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/b64.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/b64.rs
new file mode 100644
index 00000000..f32128f7
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/b64.rs
@@ -0,0 +1,32 @@
+#[repr(C)]
+#[cfg_attr(feature = "extra_traits", derive(Debug, Eq, Hash, PartialEq))]
+pub struct stat {
+    pub st_dev: ::dev_t,
+    pub st_ino: ::ino_t,
+    pub st_mode: ::mode_t,
+    pub st_nlink: ::nlink_t,
+    pub st_uid: ::uid_t,
+    pub st_gid: ::gid_t,
+    pub st_rdev: ::dev_t,
+    pub st_atime: ::time_t,
+    pub st_atime_nsec: ::c_long,
+    pub st_mtime: ::time_t,
+    pub st_mtime_nsec: ::c_long,
+    pub st_ctime: ::time_t,
+    pub st_ctime_nsec: ::c_long,
+    pub st_size: ::off_t,
+    pub st_blocks: ::blkcnt_t,
+    pub st_blksize: ::blksize_t,
+    pub st_flags: ::fflags_t,
+    pub st_gen: u32,
+    pub st_lspare: i32,
+    pub st_birthtime: ::time_t,
+    pub st_birthtime_nsec: ::c_long,
+}
+
+impl ::Copy for ::stat {}
+impl ::Clone for ::stat {
+    fn clone(&self) -> ::stat {
+        *self
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/mod.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/mod.rs
new file mode 100644
index 00000000..a88e56cc
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/mod.rs
@@ -0,0 +1,228 @@
+// APIs that were changed after FreeBSD 11
+
+// The type of `nlink_t` changed from `u16` to `u64` in FreeBSD 12:
+pub type nlink_t = u16;
+// Type of `dev_t` changed from `u32` to `u64` in FreeBSD 12:
+pub type dev_t = u32;
+// Type of `ino_t` changed from `unsigned int` to `unsigned long` in FreeBSD 12:
+pub type ino_t = u32;
+
+s! {
+    pub struct kevent {
+        pub ident: ::uintptr_t,
+        pub filter: ::c_short,
+        pub flags: ::c_ushort,
+        pub fflags: ::c_uint,
+        pub data: ::intptr_t,
+        pub udata: *mut ::c_void,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        // Type of shm_nattc changed from `int` to `shmatt_t` (aka `unsigned
+        // int`) in FreeBSD 12:
+        pub shm_nattch: ::c_int,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct dirent {
+        pub d_fileno: ::ino_t,
+        pub d_reclen: u16,
+        pub d_type: u8,
+        // Type of `d_namlen` changed from `char` to `u16` in FreeBSD 12:
+        pub d_namlen: u8,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct statfs {
+        pub f_version: u32,
+        pub f_type: u32,
+        pub f_flags: u64,
+        pub f_bsize: u64,
+        pub f_iosize: u64,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: i64,
+        pub f_files: u64,
+        pub f_ffree: i64,
+        pub f_syncwrites: u64,
+        pub f_asyncwrites: u64,
+        pub f_syncreads: u64,
+        pub f_asyncreads: u64,
+        f_spare: [u64; 10],
+        pub f_namemax: u32,
+        pub f_owner: ::uid_t,
+        pub f_fsid: ::fsid_t,
+        f_charspare: [::c_char; 80],
+        pub f_fstypename: [::c_char; 16],
+        // Array length changed from 88 to 1024 in FreeBSD 12:
+        pub f_mntfromname: [::c_char; 88],
+        // Array length changed from 88 to 1024 in FreeBSD 12:
+        pub f_mntonname: [::c_char; 88],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for statfs {
+            fn eq(&self, other: &statfs) -> bool {
+                self.f_version == other.f_version
+                    && self.f_type == other.f_type
+                    && self.f_flags == other.f_flags
+                    && self.f_bsize == other.f_bsize
+                    && self.f_iosize == other.f_iosize
+                    && self.f_blocks == other.f_blocks
+                    && self.f_bfree == other.f_bfree
+                    && self.f_bavail == other.f_bavail
+                    && self.f_files == other.f_files
+                    && self.f_ffree == other.f_ffree
+                    && self.f_syncwrites == other.f_syncwrites
+                    && self.f_asyncwrites == other.f_asyncwrites
+                    && self.f_syncreads == other.f_syncreads
+                    && self.f_asyncreads == other.f_asyncreads
+                    && self.f_namemax == other.f_namemax
+                    && self.f_owner == other.f_owner
+                    && self.f_fsid == other.f_fsid
+                    && self.f_fstypename == other.f_fstypename
+                    && self
+                    .f_mntfromname
+                    .iter()
+                    .zip(other.f_mntfromname.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .f_mntonname
+                    .iter()
+                    .zip(other.f_mntonname.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for statfs {}
+        impl ::fmt::Debug for statfs {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("statfs")
+                    .field("f_bsize", &self.f_bsize)
+                    .field("f_iosize", &self.f_iosize)
+                    .field("f_blocks", &self.f_blocks)
+                    .field("f_bfree", &self.f_bfree)
+                    .field("f_bavail", &self.f_bavail)
+                    .field("f_files", &self.f_files)
+                    .field("f_ffree", &self.f_ffree)
+                    .field("f_syncwrites", &self.f_syncwrites)
+                    .field("f_asyncwrites", &self.f_asyncwrites)
+                    .field("f_syncreads", &self.f_syncreads)
+                    .field("f_asyncreads", &self.f_asyncreads)
+                    .field("f_namemax", &self.f_namemax)
+                    .field("f_owner", &self.f_owner)
+                    .field("f_fsid", &self.f_fsid)
+                    .field("f_fstypename", &self.f_fstypename)
+                    .field("f_mntfromname", &&self.f_mntfromname[..])
+                    .field("f_mntonname", &&self.f_mntonname[..])
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for statfs {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.f_version.hash(state);
+                self.f_type.hash(state);
+                self.f_flags.hash(state);
+                self.f_bsize.hash(state);
+                self.f_iosize.hash(state);
+                self.f_blocks.hash(state);
+                self.f_bfree.hash(state);
+                self.f_bavail.hash(state);
+                self.f_files.hash(state);
+                self.f_ffree.hash(state);
+                self.f_syncwrites.hash(state);
+                self.f_asyncwrites.hash(state);
+                self.f_syncreads.hash(state);
+                self.f_asyncreads.hash(state);
+                self.f_namemax.hash(state);
+                self.f_owner.hash(state);
+                self.f_fsid.hash(state);
+                self.f_fstypename.hash(state);
+                self.f_mntfromname.hash(state);
+                self.f_mntonname.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_fileno == other.d_fileno
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self.d_namlen == other.d_namlen
+                    && self
+                    .d_name[..self.d_namlen as _]
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_fileno", &self.d_fileno)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                    .field("d_namlen", &self.d_namlen)
+                    .field("d_name", &&self.d_name[..self.d_namlen as _])
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_fileno.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_namlen.hash(state);
+                self.d_name[..self.d_namlen as _].hash(state);
+            }
+        }
+    }
+}
+
+pub const ELAST: ::c_int = 96;
+pub const RAND_MAX: ::c_int = 0x7fff_fffd;
+
+extern "C" {
+    // Return type ::c_int was removed in FreeBSD 12
+    pub fn setgrent() -> ::c_int;
+
+    // Type of `addr` argument changed from `const void*` to `void*`
+    // in FreeBSD 12
+    pub fn mprotect(
+        addr: *const ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+
+    // Return type ::c_int was removed in FreeBSD 12
+    pub fn freelocale(loc: ::locale_t) -> ::c_int;
+
+    // Return type ::c_int changed to ::ssize_t in FreeBSD 12:
+    pub fn msgrcv(
+        msqid: ::c_int,
+        msgp: *mut ::c_void,
+        msgsz: ::size_t,
+        msgtyp: ::c_long,
+        msgflg: ::c_int,
+    ) -> ::c_int;
+
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(any(target_arch = "x86_64",
+                 target_arch = "aarch64"))] {
+        mod b64;
+        pub use self::b64::*;
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/b64.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/b64.rs
new file mode 100644
index 00000000..80c6fa16
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/b64.rs
@@ -0,0 +1,34 @@
+#[repr(C)]
+#[cfg_attr(feature = "extra_traits", derive(Debug, Eq, Hash, PartialEq))]
+pub struct stat {
+    pub st_dev: ::dev_t,
+    pub st_ino: ::ino_t,
+    pub st_nlink: ::nlink_t,
+    pub st_mode: ::mode_t,
+    st_padding0: i16,
+    pub st_uid: ::uid_t,
+    pub st_gid: ::gid_t,
+    st_padding1: i32,
+    pub st_rdev: ::dev_t,
+    pub st_atime: ::time_t,
+    pub st_atime_nsec: ::c_long,
+    pub st_mtime: ::time_t,
+    pub st_mtime_nsec: ::c_long,
+    pub st_ctime: ::time_t,
+    pub st_ctime_nsec: ::c_long,
+    pub st_birthtime: ::time_t,
+    pub st_birthtime_nsec: ::c_long,
+    pub st_size: ::off_t,
+    pub st_blocks: ::blkcnt_t,
+    pub st_blksize: ::blksize_t,
+    pub st_flags: ::fflags_t,
+    pub st_gen: u64,
+    pub st_spare: [u64; 10],
+}
+
+impl ::Copy for ::stat {}
+impl ::Clone for ::stat {
+    fn clone(&self) -> ::stat {
+        *self
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/mod.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/mod.rs
new file mode 100644
index 00000000..647e11e6
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/mod.rs
@@ -0,0 +1,246 @@
+// APIs in FreeBSD 12 that have changed since 11.
+
+pub type nlink_t = u64;
+pub type dev_t = u64;
+pub type ino_t = ::c_ulong;
+pub type shmatt_t = ::c_uint;
+
+s! {
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+    }
+
+    pub struct kevent {
+        pub ident: ::uintptr_t,
+        pub filter: ::c_short,
+        pub flags: ::c_ushort,
+        pub fflags: ::c_uint,
+        pub data: ::intptr_t,
+        pub udata: *mut ::c_void,
+        pub ext: [u64; 4],
+    }
+}
+
+s_no_extra_traits! {
+    pub struct dirent {
+        pub d_fileno: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: u16,
+        pub d_type: u8,
+        d_pad0: u8,
+        pub d_namlen: u16,
+        d_pad1: u16,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct statfs {
+        pub f_version: u32,
+        pub f_type: u32,
+        pub f_flags: u64,
+        pub f_bsize: u64,
+        pub f_iosize: u64,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: i64,
+        pub f_files: u64,
+        pub f_ffree: i64,
+        pub f_syncwrites: u64,
+        pub f_asyncwrites: u64,
+        pub f_syncreads: u64,
+        pub f_asyncreads: u64,
+        f_spare: [u64; 10],
+        pub f_namemax: u32,
+        pub f_owner: ::uid_t,
+        pub f_fsid: ::fsid_t,
+        f_charspare: [::c_char; 80],
+        pub f_fstypename: [::c_char; 16],
+        pub f_mntfromname: [::c_char; 1024],
+        pub f_mntonname: [::c_char; 1024],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for statfs {
+            fn eq(&self, other: &statfs) -> bool {
+                self.f_version == other.f_version
+                    && self.f_type == other.f_type
+                    && self.f_flags == other.f_flags
+                    && self.f_bsize == other.f_bsize
+                    && self.f_iosize == other.f_iosize
+                    && self.f_blocks == other.f_blocks
+                    && self.f_bfree == other.f_bfree
+                    && self.f_bavail == other.f_bavail
+                    && self.f_files == other.f_files
+                    && self.f_ffree == other.f_ffree
+                    && self.f_syncwrites == other.f_syncwrites
+                    && self.f_asyncwrites == other.f_asyncwrites
+                    && self.f_syncreads == other.f_syncreads
+                    && self.f_asyncreads == other.f_asyncreads
+                    && self.f_namemax == other.f_namemax
+                    && self.f_owner == other.f_owner
+                    && self.f_fsid == other.f_fsid
+                    && self.f_fstypename == other.f_fstypename
+                    && self
+                    .f_mntfromname
+                    .iter()
+                    .zip(other.f_mntfromname.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .f_mntonname
+                    .iter()
+                    .zip(other.f_mntonname.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for statfs {}
+        impl ::fmt::Debug for statfs {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("statfs")
+                    .field("f_bsize", &self.f_bsize)
+                    .field("f_iosize", &self.f_iosize)
+                    .field("f_blocks", &self.f_blocks)
+                    .field("f_bfree", &self.f_bfree)
+                    .field("f_bavail", &self.f_bavail)
+                    .field("f_files", &self.f_files)
+                    .field("f_ffree", &self.f_ffree)
+                    .field("f_syncwrites", &self.f_syncwrites)
+                    .field("f_asyncwrites", &self.f_asyncwrites)
+                    .field("f_syncreads", &self.f_syncreads)
+                    .field("f_asyncreads", &self.f_asyncreads)
+                    .field("f_namemax", &self.f_namemax)
+                    .field("f_owner", &self.f_owner)
+                    .field("f_fsid", &self.f_fsid)
+                    .field("f_fstypename", &self.f_fstypename)
+                    .field("f_mntfromname", &&self.f_mntfromname[..])
+                    .field("f_mntonname", &&self.f_mntonname[..])
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for statfs {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.f_version.hash(state);
+                self.f_type.hash(state);
+                self.f_flags.hash(state);
+                self.f_bsize.hash(state);
+                self.f_iosize.hash(state);
+                self.f_blocks.hash(state);
+                self.f_bfree.hash(state);
+                self.f_bavail.hash(state);
+                self.f_files.hash(state);
+                self.f_ffree.hash(state);
+                self.f_syncwrites.hash(state);
+                self.f_asyncwrites.hash(state);
+                self.f_syncreads.hash(state);
+                self.f_asyncreads.hash(state);
+                self.f_namemax.hash(state);
+                self.f_owner.hash(state);
+                self.f_fsid.hash(state);
+                self.f_charspare.hash(state);
+                self.f_fstypename.hash(state);
+                self.f_mntfromname.hash(state);
+                self.f_mntonname.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_fileno == other.d_fileno
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self.d_namlen == other.d_namlen
+                    && self
+                    .d_name[..self.d_namlen as _]
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_fileno", &self.d_fileno)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                    .field("d_namlen", &self.d_namlen)
+                    .field("d_name", &&self.d_name[..self.d_namlen as _])
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_fileno.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_namlen.hash(state);
+                self.d_name[..self.d_namlen as _].hash(state);
+            }
+        }
+    }
+}
+
+pub const F_ADD_SEALS: ::c_int = 19;
+pub const F_GET_SEALS: ::c_int = 20;
+pub const F_SEAL_SEAL: ::c_int = 0x0001;
+pub const F_SEAL_SHRINK: ::c_int = 0x0002;
+pub const F_SEAL_GROW: ::c_int = 0x0004;
+pub const F_SEAL_WRITE: ::c_int = 0x0008;
+
+pub const GRND_NONBLOCK: ::c_uint = 0x1;
+pub const GRND_RANDOM: ::c_uint = 0x2;
+
+pub const RAND_MAX: ::c_int = 0x7fff_fffd;
+
+pub const SO_DOMAIN: ::c_int = 0x1019;
+
+pub const ELAST: ::c_int = 96;
+
+extern "C" {
+    pub fn setgrent();
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn freelocale(loc: ::locale_t);
+    pub fn msgrcv(
+        msqid: ::c_int,
+        msgp: *mut ::c_void,
+        msgsz: ::size_t,
+        msgtyp: ::c_long,
+        msgflg: ::c_int,
+    ) -> ::ssize_t;
+    pub fn clock_nanosleep(
+        clk_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+
+    pub fn getrandom(
+        buf: *mut ::c_void,
+        buflen: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+}
+
+cfg_if! {
+    if #[cfg(any(target_arch = "x86_64",
+                 target_arch = "aarch64"))] {
+        mod b64;
+        pub use self::b64::*;
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd13/b64.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd13/b64.rs
new file mode 100644
index 00000000..80c6fa16
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd13/b64.rs
@@ -0,0 +1,34 @@
+#[repr(C)]
+#[cfg_attr(feature = "extra_traits", derive(Debug, Eq, Hash, PartialEq))]
+pub struct stat {
+    pub st_dev: ::dev_t,
+    pub st_ino: ::ino_t,
+    pub st_nlink: ::nlink_t,
+    pub st_mode: ::mode_t,
+    st_padding0: i16,
+    pub st_uid: ::uid_t,
+    pub st_gid: ::gid_t,
+    st_padding1: i32,
+    pub st_rdev: ::dev_t,
+    pub st_atime: ::time_t,
+    pub st_atime_nsec: ::c_long,
+    pub st_mtime: ::time_t,
+    pub st_mtime_nsec: ::c_long,
+    pub st_ctime: ::time_t,
+    pub st_ctime_nsec: ::c_long,
+    pub st_birthtime: ::time_t,
+    pub st_birthtime_nsec: ::c_long,
+    pub st_size: ::off_t,
+    pub st_blocks: ::blkcnt_t,
+    pub st_blksize: ::blksize_t,
+    pub st_flags: ::fflags_t,
+    pub st_gen: u64,
+    pub st_spare: [u64; 10],
+}
+
+impl ::Copy for ::stat {}
+impl ::Clone for ::stat {
+    fn clone(&self) -> ::stat {
+        *self
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd13/mod.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd13/mod.rs
new file mode 100644
index 00000000..a974146d
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/freebsd13/mod.rs
@@ -0,0 +1,250 @@
+// APIs in FreeBSD 13 that have changed since 11.
+
+pub type nlink_t = u64;
+pub type dev_t = u64;
+pub type ino_t = ::c_ulong;
+pub type shmatt_t = ::c_uint;
+
+s! {
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+    }
+
+    pub struct kevent {
+        pub ident: ::uintptr_t,
+        pub filter: ::c_short,
+        pub flags: ::c_ushort,
+        pub fflags: ::c_uint,
+        pub data: ::intptr_t,
+        pub udata: *mut ::c_void,
+        pub ext: [u64; 4],
+    }
+}
+
+s_no_extra_traits! {
+    pub struct dirent {
+        pub d_fileno: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: u16,
+        pub d_type: u8,
+        d_pad0: u8,
+        pub d_namlen: u16,
+        d_pad1: u16,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct statfs {
+        pub f_version: u32,
+        pub f_type: u32,
+        pub f_flags: u64,
+        pub f_bsize: u64,
+        pub f_iosize: u64,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: i64,
+        pub f_files: u64,
+        pub f_ffree: i64,
+        pub f_syncwrites: u64,
+        pub f_asyncwrites: u64,
+        pub f_syncreads: u64,
+        pub f_asyncreads: u64,
+        f_spare: [u64; 10],
+        pub f_namemax: u32,
+        pub f_owner: ::uid_t,
+        pub f_fsid: ::fsid_t,
+        f_charspare: [::c_char; 80],
+        pub f_fstypename: [::c_char; 16],
+        pub f_mntfromname: [::c_char; 1024],
+        pub f_mntonname: [::c_char; 1024],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for statfs {
+            fn eq(&self, other: &statfs) -> bool {
+                self.f_version == other.f_version
+                    && self.f_type == other.f_type
+                    && self.f_flags == other.f_flags
+                    && self.f_bsize == other.f_bsize
+                    && self.f_iosize == other.f_iosize
+                    && self.f_blocks == other.f_blocks
+                    && self.f_bfree == other.f_bfree
+                    && self.f_bavail == other.f_bavail
+                    && self.f_files == other.f_files
+                    && self.f_ffree == other.f_ffree
+                    && self.f_syncwrites == other.f_syncwrites
+                    && self.f_asyncwrites == other.f_asyncwrites
+                    && self.f_syncreads == other.f_syncreads
+                    && self.f_asyncreads == other.f_asyncreads
+                    && self.f_namemax == other.f_namemax
+                    && self.f_owner == other.f_owner
+                    && self.f_fsid == other.f_fsid
+                    && self.f_fstypename == other.f_fstypename
+                    && self
+                    .f_mntfromname
+                    .iter()
+                    .zip(other.f_mntfromname.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .f_mntonname
+                    .iter()
+                    .zip(other.f_mntonname.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for statfs {}
+        impl ::fmt::Debug for statfs {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("statfs")
+                    .field("f_bsize", &self.f_bsize)
+                    .field("f_iosize", &self.f_iosize)
+                    .field("f_blocks", &self.f_blocks)
+                    .field("f_bfree", &self.f_bfree)
+                    .field("f_bavail", &self.f_bavail)
+                    .field("f_files", &self.f_files)
+                    .field("f_ffree", &self.f_ffree)
+                    .field("f_syncwrites", &self.f_syncwrites)
+                    .field("f_asyncwrites", &self.f_asyncwrites)
+                    .field("f_syncreads", &self.f_syncreads)
+                    .field("f_asyncreads", &self.f_asyncreads)
+                    .field("f_namemax", &self.f_namemax)
+                    .field("f_owner", &self.f_owner)
+                    .field("f_fsid", &self.f_fsid)
+                    .field("f_fstypename", &self.f_fstypename)
+                    .field("f_mntfromname", &&self.f_mntfromname[..])
+                    .field("f_mntonname", &&self.f_mntonname[..])
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for statfs {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.f_version.hash(state);
+                self.f_type.hash(state);
+                self.f_flags.hash(state);
+                self.f_bsize.hash(state);
+                self.f_iosize.hash(state);
+                self.f_blocks.hash(state);
+                self.f_bfree.hash(state);
+                self.f_bavail.hash(state);
+                self.f_files.hash(state);
+                self.f_ffree.hash(state);
+                self.f_syncwrites.hash(state);
+                self.f_asyncwrites.hash(state);
+                self.f_syncreads.hash(state);
+                self.f_asyncreads.hash(state);
+                self.f_namemax.hash(state);
+                self.f_owner.hash(state);
+                self.f_fsid.hash(state);
+                self.f_charspare.hash(state);
+                self.f_fstypename.hash(state);
+                self.f_mntfromname.hash(state);
+                self.f_mntonname.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_fileno == other.d_fileno
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self.d_namlen == other.d_namlen
+                    && self
+                    .d_name[..self.d_namlen as _]
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_fileno", &self.d_fileno)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                    .field("d_namlen", &self.d_namlen)
+                    .field("d_name", &&self.d_name[..self.d_namlen as _])
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_fileno.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_namlen.hash(state);
+                self.d_name[..self.d_namlen as _].hash(state);
+            }
+        }
+    }
+}
+
+pub const F_ADD_SEALS: ::c_int = 19;
+pub const F_GET_SEALS: ::c_int = 20;
+pub const F_SEAL_SEAL: ::c_int = 0x0001;
+pub const F_SEAL_SHRINK: ::c_int = 0x0002;
+pub const F_SEAL_GROW: ::c_int = 0x0004;
+pub const F_SEAL_WRITE: ::c_int = 0x0008;
+
+pub const GRND_NONBLOCK: ::c_uint = 0x1;
+pub const GRND_RANDOM: ::c_uint = 0x2;
+
+pub const RAND_MAX: ::c_int = 0x7fff_ffff;
+
+pub const SO_DOMAIN: ::c_int = 0x1019;
+
+pub const EINTEGRITY: ::c_int = 97;
+pub const ELAST: ::c_int = 97;
+pub const GRND_INSECURE: ::c_uint = 0x4;
+
+extern "C" {
+    pub fn aio_readv(aiocbp: *mut ::aiocb) -> ::c_int;
+    pub fn aio_writev(aiocbp: *mut ::aiocb) -> ::c_int;
+    pub fn setgrent();
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn freelocale(loc: ::locale_t);
+    pub fn msgrcv(
+        msqid: ::c_int,
+        msgp: *mut ::c_void,
+        msgsz: ::size_t,
+        msgtyp: ::c_long,
+        msgflg: ::c_int,
+    ) -> ::ssize_t;
+    pub fn clock_nanosleep(
+        clk_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+
+    pub fn getrandom(
+        buf: *mut ::c_void,
+        buflen: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+}
+
+cfg_if! {
+    if #[cfg(any(target_arch = "x86_64",
+                 target_arch = "aarch64"))] {
+        mod b64;
+        pub use self::b64::*;
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/mod.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/mod.rs
new file mode 100644
index 00000000..04bc48dc
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/mod.rs
@@ -0,0 +1,1567 @@
+pub type fflags_t = u32;
+pub type clock_t = i32;
+
+pub type lwpid_t = i32;
+pub type blksize_t = i32;
+pub type clockid_t = ::c_int;
+pub type sem_t = _sem;
+
+pub type fsblkcnt_t = u64;
+pub type fsfilcnt_t = u64;
+pub type idtype_t = ::c_uint;
+
+pub type key_t = ::c_long;
+pub type msglen_t = ::c_ulong;
+pub type msgqnum_t = ::c_ulong;
+
+pub type mqd_t = *mut ::c_void;
+pub type posix_spawnattr_t = *mut ::c_void;
+pub type posix_spawn_file_actions_t = *mut ::c_void;
+
+s! {
+    pub struct aiocb {
+        pub aio_fildes: ::c_int,
+        pub aio_offset: ::off_t,
+        pub aio_buf: *mut ::c_void,
+        pub aio_nbytes: ::size_t,
+        __unused1: [::c_int; 2],
+        __unused2: *mut ::c_void,
+        pub aio_lio_opcode: ::c_int,
+        pub aio_reqprio: ::c_int,
+        // unused 3 through 5 are the __aiocb_private structure
+        __unused3: ::c_long,
+        __unused4: ::c_long,
+        __unused5: *mut ::c_void,
+        pub aio_sigevent: sigevent
+    }
+
+    pub struct jail {
+        pub version: u32,
+        pub path: *mut ::c_char,
+        pub hostname: *mut ::c_char,
+        pub jailname: *mut ::c_char,
+        pub ip4s: ::c_uint,
+        pub ip6s: ::c_uint,
+        pub ip4: *mut ::in_addr,
+        pub ip6: *mut ::in6_addr,
+    }
+
+    pub struct statvfs {
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_bsize: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_fsid: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+    }
+
+    // internal structure has changed over time
+    pub struct _sem {
+        data: [u32; 4],
+    }
+
+    pub struct ipc_perm {
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub mode: ::mode_t,
+        pub seq: ::c_ushort,
+        pub key: ::key_t,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        pub msg_cbytes: ::msglen_t,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        pub msg_stime: ::time_t,
+        pub msg_rtime: ::time_t,
+        pub msg_ctime: ::time_t,
+    }
+
+    pub struct xucred {
+        pub cr_version: ::c_uint,
+        pub cr_uid: ::uid_t,
+        pub cr_ngroups: ::c_short,
+        pub cr_groups: [::gid_t;16],
+        __cr_unused1: *mut ::c_void,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct mmsghdr {
+        pub msg_hdr: ::msghdr,
+        pub msg_len: ::ssize_t,
+    }
+
+    pub struct sockcred {
+        pub sc_uid: ::uid_t,
+        pub sc_euid: ::uid_t,
+        pub sc_gid: ::gid_t,
+        pub sc_egid: ::gid_t,
+        pub sc_ngroups: ::c_int,
+        pub sc_groups: [::gid_t; 1],
+    }
+
+    pub struct ptrace_vm_entry {
+        pub pve_entry: ::c_int,
+        pub pve_timestamp: ::c_int,
+        pub pve_start: ::c_ulong,
+        pub pve_end: ::c_ulong,
+        pub pve_offset: ::c_ulong,
+        pub pve_prot: ::c_uint,
+        pub pve_pathlen: ::c_uint,
+        pub pve_fileid: ::c_long,
+        pub pve_fsid: u32,
+        pub pve_path: *mut ::c_char,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct utmpx {
+        pub ut_type: ::c_short,
+        pub ut_tv: ::timeval,
+        pub ut_id: [::c_char; 8],
+        pub ut_pid: ::pid_t,
+        pub ut_user: [::c_char; 32],
+        pub ut_line: [::c_char; 16],
+        pub ut_host: [::c_char; 128],
+        pub __ut_spare: [::c_char; 64],
+    }
+
+    pub struct sockaddr_dl {
+        pub sdl_len: ::c_uchar,
+        pub sdl_family: ::c_uchar,
+        pub sdl_index: ::c_ushort,
+        pub sdl_type: ::c_uchar,
+        pub sdl_nlen: ::c_uchar,
+        pub sdl_alen: ::c_uchar,
+        pub sdl_slen: ::c_uchar,
+        pub sdl_data: [::c_char; 46],
+    }
+
+    pub struct mq_attr {
+        pub mq_flags: ::c_long,
+        pub mq_maxmsg: ::c_long,
+        pub mq_msgsize: ::c_long,
+        pub mq_curmsgs: ::c_long,
+        __reserved: [::c_long; 4]
+    }
+
+    pub struct sigevent {
+        pub sigev_notify: ::c_int,
+        pub sigev_signo: ::c_int,
+        pub sigev_value: ::sigval,
+        //The rest of the structure is actually a union.  We expose only
+        //sigev_notify_thread_id because it's the most useful union member.
+        pub sigev_notify_thread_id: ::lwpid_t,
+        #[cfg(target_pointer_width = "64")]
+        __unused1: ::c_int,
+        __unused2: [::c_long; 7]
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for utmpx {
+            fn eq(&self, other: &utmpx) -> bool {
+                self.ut_type == other.ut_type
+                    && self.ut_tv == other.ut_tv
+                    && self.ut_id == other.ut_id
+                    && self.ut_pid == other.ut_pid
+                    && self.ut_user == other.ut_user
+                    && self.ut_line == other.ut_line
+                    && self
+                    .ut_host
+                    .iter()
+                    .zip(other.ut_host.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .__ut_spare
+                    .iter()
+                    .zip(other.__ut_spare.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for utmpx {}
+        impl ::fmt::Debug for utmpx {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmpx")
+                    .field("ut_type", &self.ut_type)
+                    .field("ut_tv", &self.ut_tv)
+                    .field("ut_id", &self.ut_id)
+                    .field("ut_pid", &self.ut_pid)
+                    .field("ut_user", &self.ut_user)
+                    .field("ut_line", &self.ut_line)
+                    // FIXME: .field("ut_host", &self.ut_host)
+                    // FIXME: .field("__ut_spare", &self.__ut_spare)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for utmpx {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_type.hash(state);
+                self.ut_tv.hash(state);
+                self.ut_id.hash(state);
+                self.ut_pid.hash(state);
+                self.ut_user.hash(state);
+                self.ut_line.hash(state);
+                self.ut_host.hash(state);
+                self.__ut_spare.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_dl {
+            fn eq(&self, other: &sockaddr_dl) -> bool {
+                self.sdl_len == other.sdl_len
+                    && self.sdl_family == other.sdl_family
+                    && self.sdl_index == other.sdl_index
+                    && self.sdl_type == other.sdl_type
+                    && self.sdl_nlen == other.sdl_nlen
+                    && self.sdl_alen == other.sdl_alen
+                    && self.sdl_slen == other.sdl_slen
+                    && self
+                    .sdl_data
+                    .iter()
+                    .zip(other.sdl_data.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_dl {}
+        impl ::fmt::Debug for sockaddr_dl {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_dl")
+                    .field("sdl_len", &self.sdl_len)
+                    .field("sdl_family", &self.sdl_family)
+                    .field("sdl_index", &self.sdl_index)
+                    .field("sdl_type", &self.sdl_type)
+                    .field("sdl_nlen", &self.sdl_nlen)
+                    .field("sdl_alen", &self.sdl_alen)
+                    .field("sdl_slen", &self.sdl_slen)
+                    // FIXME: .field("sdl_data", &self.sdl_data)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_dl {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sdl_len.hash(state);
+                self.sdl_family.hash(state);
+                self.sdl_index.hash(state);
+                self.sdl_type.hash(state);
+                self.sdl_nlen.hash(state);
+                self.sdl_alen.hash(state);
+                self.sdl_slen.hash(state);
+                self.sdl_data.hash(state);
+            }
+        }
+
+        impl PartialEq for mq_attr {
+            fn eq(&self, other: &mq_attr) -> bool {
+                self.mq_flags == other.mq_flags &&
+                self.mq_maxmsg == other.mq_maxmsg &&
+                self.mq_msgsize == other.mq_msgsize &&
+                self.mq_curmsgs == other.mq_curmsgs
+            }
+        }
+        impl Eq for mq_attr {}
+        impl ::fmt::Debug for mq_attr {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("mq_attr")
+                    .field("mq_flags", &self.mq_flags)
+                    .field("mq_maxmsg", &self.mq_maxmsg)
+                    .field("mq_msgsize", &self.mq_msgsize)
+                    .field("mq_curmsgs", &self.mq_curmsgs)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for mq_attr {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.mq_flags.hash(state);
+                self.mq_maxmsg.hash(state);
+                self.mq_msgsize.hash(state);
+                self.mq_curmsgs.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_notify == other.sigev_notify
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_value == other.sigev_value
+                    && self.sigev_notify_thread_id
+                        == other.sigev_notify_thread_id
+            }
+        }
+        impl Eq for sigevent {}
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_value", &self.sigev_value)
+                    .field("sigev_notify_thread_id",
+                           &self.sigev_notify_thread_id)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_notify.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_value.hash(state);
+                self.sigev_notify_thread_id.hash(state);
+            }
+        }
+    }
+}
+
+pub const SIGEV_THREAD_ID: ::c_int = 4;
+
+pub const EXTATTR_NAMESPACE_EMPTY: ::c_int = 0;
+pub const EXTATTR_NAMESPACE_USER: ::c_int = 1;
+pub const EXTATTR_NAMESPACE_SYSTEM: ::c_int = 2;
+
+pub const PTHREAD_STACK_MIN: ::size_t = MINSIGSTKSZ;
+pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::c_int = 4;
+pub const SIGSTKSZ: ::size_t = MINSIGSTKSZ + 32768;
+pub const SF_NODISKIO: ::c_int = 0x00000001;
+pub const SF_MNOWAIT: ::c_int = 0x00000002;
+pub const SF_SYNC: ::c_int = 0x00000004;
+pub const SF_USER_READAHEAD: ::c_int = 0x00000008;
+pub const SF_NOCACHE: ::c_int = 0x00000010;
+pub const O_CLOEXEC: ::c_int = 0x00100000;
+pub const O_DIRECTORY: ::c_int = 0x00020000;
+pub const O_EXEC: ::c_int = 0x00040000;
+pub const O_TTY_INIT: ::c_int = 0x00080000;
+pub const F_GETLK: ::c_int = 11;
+pub const F_SETLK: ::c_int = 12;
+pub const F_SETLKW: ::c_int = 13;
+pub const ENOTCAPABLE: ::c_int = 93;
+pub const ECAPMODE: ::c_int = 94;
+pub const ENOTRECOVERABLE: ::c_int = 95;
+pub const EOWNERDEAD: ::c_int = 96;
+pub const RLIMIT_NPTS: ::c_int = 11;
+pub const RLIMIT_SWAP: ::c_int = 12;
+pub const RLIMIT_KQUEUES: ::c_int = 13;
+pub const RLIMIT_UMTXP: ::c_int = 14;
+#[deprecated(since = "0.2.64", note = "Not stable across OS versions")]
+pub const RLIM_NLIMITS: ::rlim_t = 15;
+
+pub const NI_NOFQDN: ::c_int = 0x00000001;
+pub const NI_NUMERICHOST: ::c_int = 0x00000002;
+pub const NI_NAMEREQD: ::c_int = 0x00000004;
+pub const NI_NUMERICSERV: ::c_int = 0x00000008;
+pub const NI_DGRAM: ::c_int = 0x00000010;
+pub const NI_NUMERICSCOPE: ::c_int = 0x00000020;
+
+pub const Q_GETQUOTA: ::c_int = 0x700;
+pub const Q_SETQUOTA: ::c_int = 0x800;
+
+pub const POSIX_FADV_NORMAL: ::c_int = 0;
+pub const POSIX_FADV_RANDOM: ::c_int = 1;
+pub const POSIX_FADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_FADV_WILLNEED: ::c_int = 3;
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const POLLINIGNEOF: ::c_short = 0x2000;
+
+pub const EVFILT_READ: i16 = -1;
+pub const EVFILT_WRITE: i16 = -2;
+pub const EVFILT_AIO: i16 = -3;
+pub const EVFILT_VNODE: i16 = -4;
+pub const EVFILT_PROC: i16 = -5;
+pub const EVFILT_SIGNAL: i16 = -6;
+pub const EVFILT_TIMER: i16 = -7;
+pub const EVFILT_PROCDESC: i16 = -8;
+pub const EVFILT_FS: i16 = -9;
+pub const EVFILT_LIO: i16 = -10;
+pub const EVFILT_USER: i16 = -11;
+pub const EVFILT_SENDFILE: i16 = -12;
+pub const EVFILT_EMPTY: i16 = -13;
+
+pub const EV_ADD: u16 = 0x1;
+pub const EV_DELETE: u16 = 0x2;
+pub const EV_ENABLE: u16 = 0x4;
+pub const EV_DISABLE: u16 = 0x8;
+pub const EV_ONESHOT: u16 = 0x10;
+pub const EV_CLEAR: u16 = 0x20;
+pub const EV_RECEIPT: u16 = 0x40;
+pub const EV_DISPATCH: u16 = 0x80;
+pub const EV_DROP: u16 = 0x1000;
+pub const EV_FLAG1: u16 = 0x2000;
+pub const EV_ERROR: u16 = 0x4000;
+pub const EV_EOF: u16 = 0x8000;
+pub const EV_SYSFLAGS: u16 = 0xf000;
+
+pub const NOTE_TRIGGER: u32 = 0x01000000;
+pub const NOTE_FFNOP: u32 = 0x00000000;
+pub const NOTE_FFAND: u32 = 0x40000000;
+pub const NOTE_FFOR: u32 = 0x80000000;
+pub const NOTE_FFCOPY: u32 = 0xc0000000;
+pub const NOTE_FFCTRLMASK: u32 = 0xc0000000;
+pub const NOTE_FFLAGSMASK: u32 = 0x00ffffff;
+pub const NOTE_LOWAT: u32 = 0x00000001;
+pub const NOTE_DELETE: u32 = 0x00000001;
+pub const NOTE_WRITE: u32 = 0x00000002;
+pub const NOTE_EXTEND: u32 = 0x00000004;
+pub const NOTE_ATTRIB: u32 = 0x00000008;
+pub const NOTE_LINK: u32 = 0x00000010;
+pub const NOTE_RENAME: u32 = 0x00000020;
+pub const NOTE_REVOKE: u32 = 0x00000040;
+pub const NOTE_EXIT: u32 = 0x80000000;
+pub const NOTE_FORK: u32 = 0x40000000;
+pub const NOTE_EXEC: u32 = 0x20000000;
+pub const NOTE_PDATAMASK: u32 = 0x000fffff;
+pub const NOTE_PCTRLMASK: u32 = 0xf0000000;
+pub const NOTE_TRACK: u32 = 0x00000001;
+pub const NOTE_TRACKERR: u32 = 0x00000002;
+pub const NOTE_CHILD: u32 = 0x00000004;
+pub const NOTE_SECONDS: u32 = 0x00000001;
+pub const NOTE_MSECONDS: u32 = 0x00000002;
+pub const NOTE_USECONDS: u32 = 0x00000004;
+pub const NOTE_NSECONDS: u32 = 0x00000008;
+
+pub const MADV_PROTECT: ::c_int = 10;
+pub const RUSAGE_THREAD: ::c_int = 1;
+
+#[doc(hidden)]
+#[deprecated(
+    since = "0.2.72",
+    note = "CTL_UNSPEC is deprecated. Use CTL_SYSCTL instead"
+)]
+pub const CTL_UNSPEC: ::c_int = 0;
+pub const CTL_SYSCTL: ::c_int = 0;
+pub const CTL_KERN: ::c_int = 1;
+pub const CTL_VM: ::c_int = 2;
+pub const CTL_VFS: ::c_int = 3;
+pub const CTL_NET: ::c_int = 4;
+pub const CTL_DEBUG: ::c_int = 5;
+pub const CTL_HW: ::c_int = 6;
+pub const CTL_MACHDEP: ::c_int = 7;
+pub const CTL_USER: ::c_int = 8;
+pub const CTL_P1003_1B: ::c_int = 9;
+pub const CTL_SYSCTL_DEBUG: ::c_int = 0;
+pub const CTL_SYSCTL_NAME: ::c_int = 1;
+pub const CTL_SYSCTL_NEXT: ::c_int = 2;
+pub const CTL_SYSCTL_NAME2OID: ::c_int = 3;
+pub const CTL_SYSCTL_OIDFMT: ::c_int = 4;
+pub const CTL_SYSCTL_OIDDESCR: ::c_int = 5;
+pub const CTL_SYSCTL_OIDLABEL: ::c_int = 6;
+pub const KERN_OSTYPE: ::c_int = 1;
+pub const KERN_OSRELEASE: ::c_int = 2;
+pub const KERN_OSREV: ::c_int = 3;
+pub const KERN_VERSION: ::c_int = 4;
+pub const KERN_MAXVNODES: ::c_int = 5;
+pub const KERN_MAXPROC: ::c_int = 6;
+pub const KERN_MAXFILES: ::c_int = 7;
+pub const KERN_ARGMAX: ::c_int = 8;
+pub const KERN_SECURELVL: ::c_int = 9;
+pub const KERN_HOSTNAME: ::c_int = 10;
+pub const KERN_HOSTID: ::c_int = 11;
+pub const KERN_CLOCKRATE: ::c_int = 12;
+pub const KERN_VNODE: ::c_int = 13;
+pub const KERN_PROC: ::c_int = 14;
+pub const KERN_FILE: ::c_int = 15;
+pub const KERN_PROF: ::c_int = 16;
+pub const KERN_POSIX1: ::c_int = 17;
+pub const KERN_NGROUPS: ::c_int = 18;
+pub const KERN_JOB_CONTROL: ::c_int = 19;
+pub const KERN_SAVED_IDS: ::c_int = 20;
+pub const KERN_BOOTTIME: ::c_int = 21;
+pub const KERN_NISDOMAINNAME: ::c_int = 22;
+pub const KERN_UPDATEINTERVAL: ::c_int = 23;
+pub const KERN_OSRELDATE: ::c_int = 24;
+pub const KERN_NTP_PLL: ::c_int = 25;
+pub const KERN_BOOTFILE: ::c_int = 26;
+pub const KERN_MAXFILESPERPROC: ::c_int = 27;
+pub const KERN_MAXPROCPERUID: ::c_int = 28;
+pub const KERN_DUMPDEV: ::c_int = 29;
+pub const KERN_IPC: ::c_int = 30;
+pub const KERN_DUMMY: ::c_int = 31;
+pub const KERN_PS_STRINGS: ::c_int = 32;
+pub const KERN_USRSTACK: ::c_int = 33;
+pub const KERN_LOGSIGEXIT: ::c_int = 34;
+pub const KERN_IOV_MAX: ::c_int = 35;
+pub const KERN_HOSTUUID: ::c_int = 36;
+pub const KERN_ARND: ::c_int = 37;
+pub const KERN_PROC_ALL: ::c_int = 0;
+pub const KERN_PROC_PID: ::c_int = 1;
+pub const KERN_PROC_PGRP: ::c_int = 2;
+pub const KERN_PROC_SESSION: ::c_int = 3;
+pub const KERN_PROC_TTY: ::c_int = 4;
+pub const KERN_PROC_UID: ::c_int = 5;
+pub const KERN_PROC_RUID: ::c_int = 6;
+pub const KERN_PROC_ARGS: ::c_int = 7;
+pub const KERN_PROC_PROC: ::c_int = 8;
+pub const KERN_PROC_SV_NAME: ::c_int = 9;
+pub const KERN_PROC_RGID: ::c_int = 10;
+pub const KERN_PROC_GID: ::c_int = 11;
+pub const KERN_PROC_PATHNAME: ::c_int = 12;
+pub const KERN_PROC_OVMMAP: ::c_int = 13;
+pub const KERN_PROC_OFILEDESC: ::c_int = 14;
+pub const KERN_PROC_KSTACK: ::c_int = 15;
+pub const KERN_PROC_INC_THREAD: ::c_int = 0x10;
+pub const KERN_PROC_VMMAP: ::c_int = 32;
+pub const KERN_PROC_FILEDESC: ::c_int = 33;
+pub const KERN_PROC_GROUPS: ::c_int = 34;
+pub const KERN_PROC_ENV: ::c_int = 35;
+pub const KERN_PROC_AUXV: ::c_int = 36;
+pub const KERN_PROC_RLIMIT: ::c_int = 37;
+pub const KERN_PROC_PS_STRINGS: ::c_int = 38;
+pub const KERN_PROC_UMASK: ::c_int = 39;
+pub const KERN_PROC_OSREL: ::c_int = 40;
+pub const KERN_PROC_SIGTRAMP: ::c_int = 41;
+pub const KIPC_MAXSOCKBUF: ::c_int = 1;
+pub const KIPC_SOCKBUF_WASTE: ::c_int = 2;
+pub const KIPC_SOMAXCONN: ::c_int = 3;
+pub const KIPC_MAX_LINKHDR: ::c_int = 4;
+pub const KIPC_MAX_PROTOHDR: ::c_int = 5;
+pub const KIPC_MAX_HDR: ::c_int = 6;
+pub const KIPC_MAX_DATALEN: ::c_int = 7;
+pub const HW_MACHINE: ::c_int = 1;
+pub const HW_MODEL: ::c_int = 2;
+pub const HW_NCPU: ::c_int = 3;
+pub const HW_BYTEORDER: ::c_int = 4;
+pub const HW_PHYSMEM: ::c_int = 5;
+pub const HW_USERMEM: ::c_int = 6;
+pub const HW_PAGESIZE: ::c_int = 7;
+pub const HW_DISKNAMES: ::c_int = 8;
+pub const HW_DISKSTATS: ::c_int = 9;
+pub const HW_FLOATINGPT: ::c_int = 10;
+pub const HW_MACHINE_ARCH: ::c_int = 11;
+pub const HW_REALMEM: ::c_int = 12;
+pub const USER_CS_PATH: ::c_int = 1;
+pub const USER_BC_BASE_MAX: ::c_int = 2;
+pub const USER_BC_DIM_MAX: ::c_int = 3;
+pub const USER_BC_SCALE_MAX: ::c_int = 4;
+pub const USER_BC_STRING_MAX: ::c_int = 5;
+pub const USER_COLL_WEIGHTS_MAX: ::c_int = 6;
+pub const USER_EXPR_NEST_MAX: ::c_int = 7;
+pub const USER_LINE_MAX: ::c_int = 8;
+pub const USER_RE_DUP_MAX: ::c_int = 9;
+pub const USER_POSIX2_VERSION: ::c_int = 10;
+pub const USER_POSIX2_C_BIND: ::c_int = 11;
+pub const USER_POSIX2_C_DEV: ::c_int = 12;
+pub const USER_POSIX2_CHAR_TERM: ::c_int = 13;
+pub const USER_POSIX2_FORT_DEV: ::c_int = 14;
+pub const USER_POSIX2_FORT_RUN: ::c_int = 15;
+pub const USER_POSIX2_LOCALEDEF: ::c_int = 16;
+pub const USER_POSIX2_SW_DEV: ::c_int = 17;
+pub const USER_POSIX2_UPE: ::c_int = 18;
+pub const USER_STREAM_MAX: ::c_int = 19;
+pub const USER_TZNAME_MAX: ::c_int = 20;
+pub const CTL_P1003_1B_ASYNCHRONOUS_IO: ::c_int = 1;
+pub const CTL_P1003_1B_MAPPED_FILES: ::c_int = 2;
+pub const CTL_P1003_1B_MEMLOCK: ::c_int = 3;
+pub const CTL_P1003_1B_MEMLOCK_RANGE: ::c_int = 4;
+pub const CTL_P1003_1B_MEMORY_PROTECTION: ::c_int = 5;
+pub const CTL_P1003_1B_MESSAGE_PASSING: ::c_int = 6;
+pub const CTL_P1003_1B_PRIORITIZED_IO: ::c_int = 7;
+pub const CTL_P1003_1B_PRIORITY_SCHEDULING: ::c_int = 8;
+pub const CTL_P1003_1B_REALTIME_SIGNALS: ::c_int = 9;
+pub const CTL_P1003_1B_SEMAPHORES: ::c_int = 10;
+pub const CTL_P1003_1B_FSYNC: ::c_int = 11;
+pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: ::c_int = 12;
+pub const CTL_P1003_1B_SYNCHRONIZED_IO: ::c_int = 13;
+pub const CTL_P1003_1B_TIMERS: ::c_int = 14;
+pub const CTL_P1003_1B_AIO_LISTIO_MAX: ::c_int = 15;
+pub const CTL_P1003_1B_AIO_MAX: ::c_int = 16;
+pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: ::c_int = 17;
+pub const CTL_P1003_1B_DELAYTIMER_MAX: ::c_int = 18;
+pub const CTL_P1003_1B_MQ_OPEN_MAX: ::c_int = 19;
+pub const CTL_P1003_1B_PAGESIZE: ::c_int = 20;
+pub const CTL_P1003_1B_RTSIG_MAX: ::c_int = 21;
+pub const CTL_P1003_1B_SEM_NSEMS_MAX: ::c_int = 22;
+pub const CTL_P1003_1B_SEM_VALUE_MAX: ::c_int = 23;
+pub const CTL_P1003_1B_SIGQUEUE_MAX: ::c_int = 24;
+pub const CTL_P1003_1B_TIMER_MAX: ::c_int = 25;
+pub const TIOCGPTN: ::c_uint = 0x4004740f;
+pub const TIOCPTMASTER: ::c_uint = 0x2000741c;
+pub const TIOCSIG: ::c_uint = 0x2004745f;
+pub const TIOCM_DCD: ::c_int = 0x40;
+pub const H4DISC: ::c_int = 0x7;
+
+pub const BIOCSETFNR: ::c_ulong = 0x80104282;
+
+pub const FIONWRITE: ::c_ulong = 0x40046677;
+pub const FIONSPACE: ::c_ulong = 0x40046676;
+pub const FIOSEEKDATA: ::c_ulong = 0xc0086661;
+pub const FIOSEEKHOLE: ::c_ulong = 0xc0086662;
+
+pub const JAIL_API_VERSION: u32 = 2;
+pub const JAIL_CREATE: ::c_int = 0x01;
+pub const JAIL_UPDATE: ::c_int = 0x02;
+pub const JAIL_ATTACH: ::c_int = 0x04;
+pub const JAIL_DYING: ::c_int = 0x08;
+pub const JAIL_SET_MASK: ::c_int = 0x0f;
+pub const JAIL_GET_MASK: ::c_int = 0x08;
+pub const JAIL_SYS_DISABLE: ::c_int = 0;
+pub const JAIL_SYS_NEW: ::c_int = 1;
+pub const JAIL_SYS_INHERIT: ::c_int = 2;
+
+pub const SO_BINTIME: ::c_int = 0x2000;
+pub const SO_NO_OFFLOAD: ::c_int = 0x4000;
+pub const SO_NO_DDP: ::c_int = 0x8000;
+pub const SO_REUSEPORT_LB: ::c_int = 0x10000;
+pub const SO_LABEL: ::c_int = 0x1009;
+pub const SO_PEERLABEL: ::c_int = 0x1010;
+pub const SO_LISTENQLIMIT: ::c_int = 0x1011;
+pub const SO_LISTENQLEN: ::c_int = 0x1012;
+pub const SO_LISTENINCQLEN: ::c_int = 0x1013;
+pub const SO_SETFIB: ::c_int = 0x1014;
+pub const SO_USER_COOKIE: ::c_int = 0x1015;
+pub const SO_PROTOCOL: ::c_int = 0x1016;
+pub const SO_PROTOTYPE: ::c_int = SO_PROTOCOL;
+pub const SO_VENDOR: ::c_int = 0x80000000;
+
+pub const LOCAL_PEERCRED: ::c_int = 1;
+pub const LOCAL_CREDS: ::c_int = 2;
+pub const LOCAL_CONNWAIT: ::c_int = 4;
+pub const LOCAL_VENDOR: ::c_int = SO_VENDOR;
+
+pub const PT_LWPINFO: ::c_int = 13;
+pub const PT_GETNUMLWPS: ::c_int = 14;
+pub const PT_GETLWPLIST: ::c_int = 15;
+pub const PT_CLEARSTEP: ::c_int = 16;
+pub const PT_SETSTEP: ::c_int = 17;
+pub const PT_SUSPEND: ::c_int = 18;
+pub const PT_RESUME: ::c_int = 19;
+pub const PT_TO_SCE: ::c_int = 20;
+pub const PT_TO_SCX: ::c_int = 21;
+pub const PT_SYSCALL: ::c_int = 22;
+pub const PT_FOLLOW_FORK: ::c_int = 23;
+pub const PT_LWP_EVENTS: ::c_int = 24;
+pub const PT_GET_EVENT_MASK: ::c_int = 25;
+pub const PT_SET_EVENT_MASK: ::c_int = 26;
+pub const PT_GETREGS: ::c_int = 33;
+pub const PT_SETREGS: ::c_int = 34;
+pub const PT_GETFPREGS: ::c_int = 35;
+pub const PT_SETFPREGS: ::c_int = 36;
+pub const PT_GETDBREGS: ::c_int = 37;
+pub const PT_SETDBREGS: ::c_int = 38;
+pub const PT_VM_TIMESTAMP: ::c_int = 40;
+pub const PT_VM_ENTRY: ::c_int = 41;
+pub const PT_FIRSTMACH: ::c_int = 64;
+
+pub const PTRACE_EXEC: ::c_int = 0x0001;
+pub const PTRACE_SCE: ::c_int = 0x0002;
+pub const PTRACE_SCX: ::c_int = 0x0004;
+pub const PTRACE_SYSCALL: ::c_int = PTRACE_SCE | PTRACE_SCX;
+pub const PTRACE_FORK: ::c_int = 0x0008;
+pub const PTRACE_LWP: ::c_int = 0x0010;
+pub const PTRACE_VFORK: ::c_int = 0x0020;
+pub const PTRACE_DEFAULT: ::c_int = PTRACE_EXEC;
+
+pub const AF_SLOW: ::c_int = 33;
+pub const AF_SCLUSTER: ::c_int = 34;
+pub const AF_ARP: ::c_int = 35;
+pub const AF_BLUETOOTH: ::c_int = 36;
+pub const AF_IEEE80211: ::c_int = 37;
+pub const AF_INET_SDP: ::c_int = 40;
+pub const AF_INET6_SDP: ::c_int = 42;
+
+// https://github.com/freebsd/freebsd/blob/master/sys/net/if.h#L140
+pub const IFF_UP: ::c_int = 0x1; // (n) interface is up
+pub const IFF_BROADCAST: ::c_int = 0x2; // (i) broadcast address valid
+pub const IFF_DEBUG: ::c_int = 0x4; // (n) turn on debugging
+pub const IFF_LOOPBACK: ::c_int = 0x8; // (i) is a loopback net
+pub const IFF_POINTOPOINT: ::c_int = 0x10; // (i) is a point-to-point link
+                                           // 0x20           was IFF_SMART
+pub const IFF_RUNNING: ::c_int = 0x40; // (d) resources allocated
+#[doc(hidden)]
+#[deprecated(
+    since = "0.2.54",
+    note = "IFF_DRV_RUNNING is deprecated. Use the portable IFF_RUNNING instead"
+)]
+pub const IFF_DRV_RUNNING: ::c_int = 0x40;
+pub const IFF_NOARP: ::c_int = 0x80; // (n) no address resolution protocol
+pub const IFF_PROMISC: ::c_int = 0x100; // (n) receive all packets
+pub const IFF_ALLMULTI: ::c_int = 0x200; // (n) receive all multicast packets
+pub const IFF_OACTIVE: ::c_int = 0x400; // (d) tx hardware queue is full
+#[doc(hidden)]
+#[deprecated(
+    since = "0.2.54",
+    note = "Use the portable `IFF_OACTIVE` instead"
+)]
+pub const IFF_DRV_OACTIVE: ::c_int = 0x400;
+pub const IFF_SIMPLEX: ::c_int = 0x800; // (i) can't hear own transmissions
+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit
+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit
+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit
+pub const IFF_ALTPHYS: ::c_int = IFF_LINK2; // use alternate physical connection
+pub const IFF_MULTICAST: ::c_int = 0x8000; // (i) supports multicast
+                                           // (i) unconfigurable using ioctl(2)
+pub const IFF_CANTCONFIG: ::c_int = 0x10000;
+pub const IFF_PPROMISC: ::c_int = 0x20000; // (n) user-requested promisc mode
+pub const IFF_MONITOR: ::c_int = 0x40000; // (n) user-requested monitor mode
+pub const IFF_STATICARP: ::c_int = 0x80000; // (n) static ARP
+pub const IFF_DYING: ::c_int = 0x200000; // (n) interface is winding down
+pub const IFF_RENAMING: ::c_int = 0x400000; // (n) interface is being renamed
+
+// sys/netinet/in.h
+// Protocols (RFC 1700)
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+// IPPROTO_IP defined in src/unix/mod.rs
+/// IP6 hop-by-hop options
+pub const IPPROTO_HOPOPTS: ::c_int = 0;
+// IPPROTO_ICMP defined in src/unix/mod.rs
+/// group mgmt protocol
+pub const IPPROTO_IGMP: ::c_int = 2;
+/// gateway^2 (deprecated)
+pub const IPPROTO_GGP: ::c_int = 3;
+/// for compatibility
+pub const IPPROTO_IPIP: ::c_int = 4;
+// IPPROTO_TCP defined in src/unix/mod.rs
+/// Stream protocol II.
+pub const IPPROTO_ST: ::c_int = 7;
+/// exterior gateway protocol
+pub const IPPROTO_EGP: ::c_int = 8;
+/// private interior gateway
+pub const IPPROTO_PIGP: ::c_int = 9;
+/// BBN RCC Monitoring
+pub const IPPROTO_RCCMON: ::c_int = 10;
+/// network voice protocol
+pub const IPPROTO_NVPII: ::c_int = 11;
+/// pup
+pub const IPPROTO_PUP: ::c_int = 12;
+/// Argus
+pub const IPPROTO_ARGUS: ::c_int = 13;
+/// EMCON
+pub const IPPROTO_EMCON: ::c_int = 14;
+/// Cross Net Debugger
+pub const IPPROTO_XNET: ::c_int = 15;
+/// Chaos
+pub const IPPROTO_CHAOS: ::c_int = 16;
+// IPPROTO_UDP defined in src/unix/mod.rs
+/// Multiplexing
+pub const IPPROTO_MUX: ::c_int = 18;
+/// DCN Measurement Subsystems
+pub const IPPROTO_MEAS: ::c_int = 19;
+/// Host Monitoring
+pub const IPPROTO_HMP: ::c_int = 20;
+/// Packet Radio Measurement
+pub const IPPROTO_PRM: ::c_int = 21;
+/// xns idp
+pub const IPPROTO_IDP: ::c_int = 22;
+/// Trunk-1
+pub const IPPROTO_TRUNK1: ::c_int = 23;
+/// Trunk-2
+pub const IPPROTO_TRUNK2: ::c_int = 24;
+/// Leaf-1
+pub const IPPROTO_LEAF1: ::c_int = 25;
+/// Leaf-2
+pub const IPPROTO_LEAF2: ::c_int = 26;
+/// Reliable Data
+pub const IPPROTO_RDP: ::c_int = 27;
+/// Reliable Transaction
+pub const IPPROTO_IRTP: ::c_int = 28;
+/// tp-4 w/ class negotiation
+pub const IPPROTO_TP: ::c_int = 29;
+/// Bulk Data Transfer
+pub const IPPROTO_BLT: ::c_int = 30;
+/// Network Services
+pub const IPPROTO_NSP: ::c_int = 31;
+/// Merit Internodal
+pub const IPPROTO_INP: ::c_int = 32;
+#[doc(hidden)]
+#[deprecated(
+    since = "0.2.72",
+    note = "IPPROTO_SEP is deprecated. Use IPPROTO_DCCP instead"
+)]
+pub const IPPROTO_SEP: ::c_int = 33;
+/// Datagram Congestion Control Protocol
+pub const IPPROTO_DCCP: ::c_int = 33;
+/// Third Party Connect
+pub const IPPROTO_3PC: ::c_int = 34;
+/// InterDomain Policy Routing
+pub const IPPROTO_IDPR: ::c_int = 35;
+/// XTP
+pub const IPPROTO_XTP: ::c_int = 36;
+/// Datagram Delivery
+pub const IPPROTO_DDP: ::c_int = 37;
+/// Control Message Transport
+pub const IPPROTO_CMTP: ::c_int = 38;
+/// TP++ Transport
+pub const IPPROTO_TPXX: ::c_int = 39;
+/// IL transport protocol
+pub const IPPROTO_IL: ::c_int = 40;
+// IPPROTO_IPV6 defined in src/unix/mod.rs
+/// Source Demand Routing
+pub const IPPROTO_SDRP: ::c_int = 42;
+/// IP6 routing header
+pub const IPPROTO_ROUTING: ::c_int = 43;
+/// IP6 fragmentation header
+pub const IPPROTO_FRAGMENT: ::c_int = 44;
+/// InterDomain Routing
+pub const IPPROTO_IDRP: ::c_int = 45;
+/// resource reservation
+pub const IPPROTO_RSVP: ::c_int = 46;
+/// General Routing Encap.
+pub const IPPROTO_GRE: ::c_int = 47;
+/// Mobile Host Routing
+pub const IPPROTO_MHRP: ::c_int = 48;
+/// BHA
+pub const IPPROTO_BHA: ::c_int = 49;
+/// IP6 Encap Sec. Payload
+pub const IPPROTO_ESP: ::c_int = 50;
+/// IP6 Auth Header
+pub const IPPROTO_AH: ::c_int = 51;
+/// Integ. Net Layer Security
+pub const IPPROTO_INLSP: ::c_int = 52;
+/// IP with encryption
+pub const IPPROTO_SWIPE: ::c_int = 53;
+/// Next Hop Resolution
+pub const IPPROTO_NHRP: ::c_int = 54;
+/// IP Mobility
+pub const IPPROTO_MOBILE: ::c_int = 55;
+/// Transport Layer Security
+pub const IPPROTO_TLSP: ::c_int = 56;
+/// SKIP
+pub const IPPROTO_SKIP: ::c_int = 57;
+// IPPROTO_ICMPV6 defined in src/unix/mod.rs
+/// IP6 no next header
+pub const IPPROTO_NONE: ::c_int = 59;
+/// IP6 destination option
+pub const IPPROTO_DSTOPTS: ::c_int = 60;
+/// any host internal protocol
+pub const IPPROTO_AHIP: ::c_int = 61;
+/// CFTP
+pub const IPPROTO_CFTP: ::c_int = 62;
+/// "hello" routing protocol
+pub const IPPROTO_HELLO: ::c_int = 63;
+/// SATNET/Backroom EXPAK
+pub const IPPROTO_SATEXPAK: ::c_int = 64;
+/// Kryptolan
+pub const IPPROTO_KRYPTOLAN: ::c_int = 65;
+/// Remote Virtual Disk
+pub const IPPROTO_RVD: ::c_int = 66;
+/// Pluribus Packet Core
+pub const IPPROTO_IPPC: ::c_int = 67;
+/// Any distributed FS
+pub const IPPROTO_ADFS: ::c_int = 68;
+/// Satnet Monitoring
+pub const IPPROTO_SATMON: ::c_int = 69;
+/// VISA Protocol
+pub const IPPROTO_VISA: ::c_int = 70;
+/// Packet Core Utility
+pub const IPPROTO_IPCV: ::c_int = 71;
+/// Comp. Prot. Net. Executive
+pub const IPPROTO_CPNX: ::c_int = 72;
+/// Comp. Prot. HeartBeat
+pub const IPPROTO_CPHB: ::c_int = 73;
+/// Wang Span Network
+pub const IPPROTO_WSN: ::c_int = 74;
+/// Packet Video Protocol
+pub const IPPROTO_PVP: ::c_int = 75;
+/// BackRoom SATNET Monitoring
+pub const IPPROTO_BRSATMON: ::c_int = 76;
+/// Sun net disk proto (temp.)
+pub const IPPROTO_ND: ::c_int = 77;
+/// WIDEBAND Monitoring
+pub const IPPROTO_WBMON: ::c_int = 78;
+/// WIDEBAND EXPAK
+pub const IPPROTO_WBEXPAK: ::c_int = 79;
+/// ISO cnlp
+pub const IPPROTO_EON: ::c_int = 80;
+/// VMTP
+pub const IPPROTO_VMTP: ::c_int = 81;
+/// Secure VMTP
+pub const IPPROTO_SVMTP: ::c_int = 82;
+/// Banyon VINES
+pub const IPPROTO_VINES: ::c_int = 83;
+/// TTP
+pub const IPPROTO_TTP: ::c_int = 84;
+/// NSFNET-IGP
+pub const IPPROTO_IGP: ::c_int = 85;
+/// dissimilar gateway prot.
+pub const IPPROTO_DGP: ::c_int = 86;
+/// TCF
+pub const IPPROTO_TCF: ::c_int = 87;
+/// Cisco/GXS IGRP
+pub const IPPROTO_IGRP: ::c_int = 88;
+/// OSPFIGP
+pub const IPPROTO_OSPFIGP: ::c_int = 89;
+/// Strite RPC protocol
+pub const IPPROTO_SRPC: ::c_int = 90;
+/// Locus Address Resoloution
+pub const IPPROTO_LARP: ::c_int = 91;
+/// Multicast Transport
+pub const IPPROTO_MTP: ::c_int = 92;
+/// AX.25 Frames
+pub const IPPROTO_AX25: ::c_int = 93;
+/// IP encapsulated in IP
+pub const IPPROTO_IPEIP: ::c_int = 94;
+/// Mobile Int.ing control
+pub const IPPROTO_MICP: ::c_int = 95;
+/// Semaphore Comm. security
+pub const IPPROTO_SCCSP: ::c_int = 96;
+/// Ethernet IP encapsulation
+pub const IPPROTO_ETHERIP: ::c_int = 97;
+/// encapsulation header
+pub const IPPROTO_ENCAP: ::c_int = 98;
+/// any private encr. scheme
+pub const IPPROTO_APES: ::c_int = 99;
+/// GMTP
+pub const IPPROTO_GMTP: ::c_int = 100;
+/// payload compression (IPComp)
+pub const IPPROTO_IPCOMP: ::c_int = 108;
+/// SCTP
+pub const IPPROTO_SCTP: ::c_int = 132;
+/// IPv6 Mobility Header
+pub const IPPROTO_MH: ::c_int = 135;
+/// UDP-Lite
+pub const IPPROTO_UDPLITE: ::c_int = 136;
+/// IP6 Host Identity Protocol
+pub const IPPROTO_HIP: ::c_int = 139;
+/// IP6 Shim6 Protocol
+pub const IPPROTO_SHIM6: ::c_int = 140;
+
+/* 101-254: Partly Unassigned */
+/// Protocol Independent Mcast
+pub const IPPROTO_PIM: ::c_int = 103;
+/// CARP
+pub const IPPROTO_CARP: ::c_int = 112;
+/// PGM
+pub const IPPROTO_PGM: ::c_int = 113;
+/// MPLS-in-IP
+pub const IPPROTO_MPLS: ::c_int = 137;
+/// PFSYNC
+pub const IPPROTO_PFSYNC: ::c_int = 240;
+
+/* 255: Reserved */
+/* BSD Private, local use, namespace incursion, no longer used */
+/// OLD divert pseudo-proto
+pub const IPPROTO_OLD_DIVERT: ::c_int = 254;
+pub const IPPROTO_MAX: ::c_int = 256;
+/// last return value of *_input(), meaning "all job for this pkt is done".
+pub const IPPROTO_DONE: ::c_int = 257;
+
+/* Only used internally, so can be outside the range of valid IP protocols. */
+/// divert pseudo-protocol
+pub const IPPROTO_DIVERT: ::c_int = 258;
+/// SeND pseudo-protocol
+pub const IPPROTO_SEND: ::c_int = 259;
+
+// sys/netinet/TCP.h
+pub const TCP_MD5SIG: ::c_int = 16;
+pub const TCP_INFO: ::c_int = 32;
+pub const TCP_CONGESTION: ::c_int = 64;
+pub const TCP_CCALGOOPT: ::c_int = 65;
+pub const TCP_KEEPINIT: ::c_int = 128;
+pub const TCP_FASTOPEN: ::c_int = 1025;
+pub const TCP_PCAP_OUT: ::c_int = 2048;
+pub const TCP_PCAP_IN: ::c_int = 4096;
+
+pub const IP_BINDANY: ::c_int = 24;
+pub const IP_BINDMULTI: ::c_int = 25;
+pub const IP_RSS_LISTEN_BUCKET: ::c_int = 26;
+pub const IP_ORIGDSTADDR: ::c_int = 27;
+pub const IP_RECVORIGDSTADDR: ::c_int = IP_ORIGDSTADDR;
+
+pub const IP_RECVTOS: ::c_int = 68;
+
+pub const IPV6_BINDANY: ::c_int = 64;
+pub const IPV6_ORIGDSTADDR: ::c_int = 72;
+pub const IPV6_RECVORIGDSTADDR: ::c_int = IPV6_ORIGDSTADDR;
+
+pub const PF_SLOW: ::c_int = AF_SLOW;
+pub const PF_SCLUSTER: ::c_int = AF_SCLUSTER;
+pub const PF_ARP: ::c_int = AF_ARP;
+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;
+pub const PF_IEEE80211: ::c_int = AF_IEEE80211;
+pub const PF_INET_SDP: ::c_int = AF_INET_SDP;
+pub const PF_INET6_SDP: ::c_int = AF_INET6_SDP;
+
+pub const NET_RT_DUMP: ::c_int = 1;
+pub const NET_RT_FLAGS: ::c_int = 2;
+pub const NET_RT_IFLIST: ::c_int = 3;
+pub const NET_RT_IFMALIST: ::c_int = 4;
+pub const NET_RT_IFLISTL: ::c_int = 5;
+
+// System V IPC
+pub const IPC_PRIVATE: ::key_t = 0;
+pub const IPC_CREAT: ::c_int = 0o1000;
+pub const IPC_EXCL: ::c_int = 0o2000;
+pub const IPC_NOWAIT: ::c_int = 0o4000;
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+pub const IPC_INFO: ::c_int = 3;
+pub const IPC_R: ::c_int = 0o400;
+pub const IPC_W: ::c_int = 0o200;
+pub const IPC_M: ::c_int = 0o10000;
+pub const MSG_NOERROR: ::c_int = 0o10000;
+pub const SHM_RDONLY: ::c_int = 0o10000;
+pub const SHM_RND: ::c_int = 0o20000;
+pub const SHM_R: ::c_int = 0o400;
+pub const SHM_W: ::c_int = 0o200;
+pub const SHM_LOCK: ::c_int = 11;
+pub const SHM_UNLOCK: ::c_int = 12;
+pub const SHM_STAT: ::c_int = 13;
+pub const SHM_INFO: ::c_int = 14;
+pub const SHM_ANON: *mut ::c_char = 1 as *mut ::c_char;
+
+// The *_MAXID constants never should've been used outside of the
+// FreeBSD base system.  And with the exception of CTL_P1003_1B_MAXID,
+// they were all removed in svn r262489.  They remain here for backwards
+// compatibility only, and are scheduled to be removed in libc 1.0.0.
+#[doc(hidden)]
+#[deprecated(since = "0.2.54", note = "Removed in FreeBSD 11")]
+pub const CTL_MAXID: ::c_int = 10;
+#[doc(hidden)]
+#[deprecated(since = "0.2.54", note = "Removed in FreeBSD 11")]
+pub const KERN_MAXID: ::c_int = 38;
+#[doc(hidden)]
+#[deprecated(since = "0.2.54", note = "Removed in FreeBSD 11")]
+pub const HW_MAXID: ::c_int = 13;
+#[doc(hidden)]
+#[deprecated(since = "0.2.54", note = "Removed in FreeBSD 11")]
+pub const USER_MAXID: ::c_int = 21;
+#[doc(hidden)]
+#[deprecated(since = "0.2.74", note = "Removed in FreeBSD 13")]
+pub const CTL_P1003_1B_MAXID: ::c_int = 26;
+
+pub const MSG_NOTIFICATION: ::c_int = 0x00002000;
+pub const MSG_NBIO: ::c_int = 0x00004000;
+pub const MSG_COMPAT: ::c_int = 0x00008000;
+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x00040000;
+pub const MSG_NOSIGNAL: ::c_int = 0x20000;
+
+// utmpx entry types
+pub const EMPTY: ::c_short = 0;
+pub const BOOT_TIME: ::c_short = 1;
+pub const OLD_TIME: ::c_short = 2;
+pub const NEW_TIME: ::c_short = 3;
+pub const USER_PROCESS: ::c_short = 4;
+pub const INIT_PROCESS: ::c_short = 5;
+pub const LOGIN_PROCESS: ::c_short = 6;
+pub const DEAD_PROCESS: ::c_short = 7;
+pub const SHUTDOWN_TIME: ::c_short = 8;
+// utmp database types
+pub const UTXDB_ACTIVE: ::c_int = 0;
+pub const UTXDB_LASTLOGIN: ::c_int = 1;
+pub const UTXDB_LOG: ::c_int = 2;
+
+pub const LC_COLLATE_MASK: ::c_int = 1 << 0;
+pub const LC_CTYPE_MASK: ::c_int = 1 << 1;
+pub const LC_MONETARY_MASK: ::c_int = 1 << 2;
+pub const LC_NUMERIC_MASK: ::c_int = 1 << 3;
+pub const LC_TIME_MASK: ::c_int = 1 << 4;
+pub const LC_MESSAGES_MASK: ::c_int = 1 << 5;
+pub const LC_ALL_MASK: ::c_int = LC_COLLATE_MASK
+    | LC_CTYPE_MASK
+    | LC_MESSAGES_MASK
+    | LC_MONETARY_MASK
+    | LC_NUMERIC_MASK
+    | LC_TIME_MASK;
+
+pub const WSTOPPED: ::c_int = 2; // same as WUNTRACED
+pub const WCONTINUED: ::c_int = 4;
+pub const WNOWAIT: ::c_int = 8;
+pub const WEXITED: ::c_int = 16;
+pub const WTRAPPED: ::c_int = 32;
+
+// FreeBSD defines a great many more of these, we only expose the
+// standardized ones.
+pub const P_PID: idtype_t = 0;
+pub const P_PGID: idtype_t = 2;
+pub const P_ALL: idtype_t = 7;
+
+pub const UTIME_OMIT: c_long = -2;
+pub const UTIME_NOW: c_long = -1;
+
+pub const B460800: ::speed_t = 460800;
+pub const B921600: ::speed_t = 921600;
+
+pub const AT_FDCWD: ::c_int = -100;
+pub const AT_EACCESS: ::c_int = 0x100;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x200;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x400;
+pub const AT_REMOVEDIR: ::c_int = 0x800;
+
+pub const TABDLY: ::tcflag_t = 0x00000004;
+pub const TAB0: ::tcflag_t = 0x00000000;
+pub const TAB3: ::tcflag_t = 0x00000004;
+
+pub const _PC_ACL_NFS4: ::c_int = 64;
+
+pub const _SC_CPUSET_SIZE: ::c_int = 122;
+
+pub const XU_NGROUPS: ::c_int = 16;
+pub const XUCRED_VERSION: ::c_uint = 0;
+
+// Flags which can be passed to pdfork(2)
+pub const PD_DAEMON: ::c_int = 0x00000001;
+pub const PD_CLOEXEC: ::c_int = 0x00000002;
+pub const PD_ALLOWED_AT_FORK: ::c_int = PD_DAEMON | PD_CLOEXEC;
+
+// Values for struct rtprio (type_ field)
+pub const RTP_PRIO_REALTIME: ::c_ushort = 2;
+pub const RTP_PRIO_NORMAL: ::c_ushort = 3;
+pub const RTP_PRIO_IDLE: ::c_ushort = 4;
+
+pub const POSIX_SPAWN_RESETIDS: ::c_int = 0x01;
+pub const POSIX_SPAWN_SETPGROUP: ::c_int = 0x02;
+pub const POSIX_SPAWN_SETSCHEDPARAM: ::c_int = 0x04;
+pub const POSIX_SPAWN_SETSCHEDULER: ::c_int = 0x08;
+pub const POSIX_SPAWN_SETSIGDEF: ::c_int = 0x10;
+pub const POSIX_SPAWN_SETSIGMASK: ::c_int = 0x20;
+
+// Flags for chflags(2)
+pub const UF_SYSTEM: ::c_ulong = 0x00000080;
+pub const UF_SPARSE: ::c_ulong = 0x00000100;
+pub const UF_OFFLINE: ::c_ulong = 0x00000200;
+pub const UF_REPARSE: ::c_ulong = 0x00000400;
+pub const UF_ARCHIVE: ::c_ulong = 0x00000800;
+pub const UF_READONLY: ::c_ulong = 0x00001000;
+pub const UF_HIDDEN: ::c_ulong = 0x00008000;
+pub const SF_SNAPSHOT: ::c_ulong = 0x00200000;
+
+pub const F_OGETLK: ::c_int = 7;
+pub const F_OSETLK: ::c_int = 8;
+pub const F_OSETLKW: ::c_int = 9;
+pub const F_DUP2FD: ::c_int = 10;
+pub const F_SETLK_REMOTE: ::c_int = 14;
+pub const F_READAHEAD: ::c_int = 15;
+pub const F_RDAHEAD: ::c_int = 16;
+pub const F_DUP2FD_CLOEXEC: ::c_int = 18;
+
+fn _ALIGN(p: usize) -> usize {
+    (p + _ALIGNBYTES) & !_ALIGNBYTES
+}
+
+f! {
+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {
+        (cmsg as *mut ::c_uchar)
+            .offset(_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        _ALIGN(::mem::size_of::<::cmsghdr>()) as ::c_uint + length
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)
+        -> *mut ::cmsghdr
+    {
+        if cmsg.is_null() {
+            return ::CMSG_FIRSTHDR(mhdr);
+        };
+        let next = cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize)
+            + _ALIGN(::mem::size_of::<::cmsghdr>());
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if next > max {
+            0 as *mut ::cmsghdr
+        } else {
+            (cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize))
+                as *mut ::cmsghdr
+        }
+    }
+
+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        (_ALIGN(::mem::size_of::<::cmsghdr>()) + _ALIGN(length as usize))
+            as ::c_uint
+    }
+
+    pub fn SOCKCREDSIZE(ngrps: usize) -> usize {
+        let ngrps = if ngrps > 0 {
+            ngrps - 1
+        } else {
+            0
+        };
+        ::mem::size_of::<sockcred>() + ::mem::size_of::<::gid_t>() * ngrps
+    }
+
+    pub fn uname(buf: *mut ::utsname) -> ::c_int {
+        __xuname(256, buf as *mut ::c_void)
+    }
+}
+
+safe_f! {
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        (status & 0o177) != 0o177 && (status & 0o177) != 0 && status != 0x13
+    }
+}
+
+extern "C" {
+    pub fn __error() -> *mut ::c_int;
+
+    pub fn aio_cancel(fd: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_error(aiocbp: *const aiocb) -> ::c_int;
+    pub fn aio_fsync(op: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_read(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_return(aiocbp: *mut aiocb) -> ::ssize_t;
+    pub fn aio_suspend(
+        aiocb_list: *const *const aiocb,
+        nitems: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn aio_write(aiocbp: *mut aiocb) -> ::c_int;
+
+    pub fn extattr_delete_fd(
+        fd: ::c_int,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+    ) -> ::c_int;
+    pub fn extattr_delete_file(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+    ) -> ::c_int;
+    pub fn extattr_delete_link(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+    ) -> ::c_int;
+    pub fn extattr_get_fd(
+        fd: ::c_int,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_get_file(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_get_link(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_list_fd(
+        fd: ::c_int,
+        attrnamespace: ::c_int,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_list_file(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_list_link(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_set_fd(
+        fd: ::c_int,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *const ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_set_file(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *const ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_set_link(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *const ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+
+    pub fn jail(jail: *mut ::jail) -> ::c_int;
+    pub fn jail_attach(jid: ::c_int) -> ::c_int;
+    pub fn jail_remove(jid: ::c_int) -> ::c_int;
+    pub fn jail_get(
+        iov: *mut ::iovec,
+        niov: ::c_uint,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn jail_set(
+        iov: *mut ::iovec,
+        niov: ::c_uint,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn lio_listio(
+        mode: ::c_int,
+        aiocb_list: *const *mut aiocb,
+        nitems: ::c_int,
+        sevp: *mut sigevent,
+    ) -> ::c_int;
+
+    pub fn posix_fallocate(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+    pub fn posix_fadvise(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+        advise: ::c_int,
+    ) -> ::c_int;
+    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn mkostemps(
+        template: *mut ::c_char,
+        suffixlen: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn getutxuser(user: *const ::c_char) -> *mut utmpx;
+    pub fn setutxdb(_type: ::c_int, file: *const ::c_char) -> ::c_int;
+
+    pub fn aio_waitcomplete(
+        iocbp: *mut *mut aiocb,
+        timeout: *mut ::timespec,
+    ) -> ::ssize_t;
+    pub fn mq_getfd_np(mqd: ::mqd_t) -> ::c_int;
+
+    pub fn waitid(
+        idtype: idtype_t,
+        id: ::id_t,
+        infop: *mut ::siginfo_t,
+        options: ::c_int,
+    ) -> ::c_int;
+
+    pub fn ftok(pathname: *const ::c_char, proj_id: ::c_int) -> ::key_t;
+    pub fn shmget(key: ::key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;
+    pub fn shmat(
+        shmid: ::c_int,
+        shmaddr: *const ::c_void,
+        shmflg: ::c_int,
+    ) -> *mut ::c_void;
+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;
+    pub fn shmctl(
+        shmid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::shmid_ds,
+    ) -> ::c_int;
+    pub fn msgctl(
+        msqid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::msqid_ds,
+    ) -> ::c_int;
+    pub fn msgget(key: ::key_t, msgflg: ::c_int) -> ::c_int;
+    pub fn msgsnd(
+        msqid: ::c_int,
+        msgp: *const ::c_void,
+        msgsz: ::size_t,
+        msgflg: ::c_int,
+    ) -> ::c_int;
+    pub fn cfmakesane(termios: *mut ::termios);
+    pub fn fexecve(
+        fd: ::c_int,
+        argv: *const *const ::c_char,
+        envp: *const *const ::c_char,
+    ) -> ::c_int;
+
+    pub fn pdfork(fdp: *mut ::c_int, flags: ::c_int) -> ::pid_t;
+    pub fn pdgetpid(fd: ::c_int, pidp: *mut ::pid_t) -> ::c_int;
+    pub fn pdkill(fd: ::c_int, signum: ::c_int) -> ::c_int;
+
+    pub fn rtprio_thread(
+        function: ::c_int,
+        lwpid: ::lwpid_t,
+        rtp: *mut super::rtprio,
+    ) -> ::c_int;
+
+    pub fn posix_spawn(
+        pid: *mut ::pid_t,
+        path: *const ::c_char,
+        file_actions: *const ::posix_spawn_file_actions_t,
+        attrp: *const ::posix_spawnattr_t,
+        argv: *const *mut ::c_char,
+        envp: *const *mut ::c_char,
+    ) -> ::c_int;
+    pub fn posix_spawnp(
+        pid: *mut ::pid_t,
+        file: *const ::c_char,
+        file_actions: *const ::posix_spawn_file_actions_t,
+        attrp: *const ::posix_spawnattr_t,
+        argv: *const *mut ::c_char,
+        envp: *const *mut ::c_char,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_init(attr: *mut posix_spawnattr_t) -> ::c_int;
+    pub fn posix_spawnattr_destroy(attr: *mut posix_spawnattr_t) -> ::c_int;
+    pub fn posix_spawnattr_getsigdefault(
+        attr: *const posix_spawnattr_t,
+        default: *mut ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setsigdefault(
+        attr: *mut posix_spawnattr_t,
+        default: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getsigmask(
+        attr: *const posix_spawnattr_t,
+        default: *mut ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setsigmask(
+        attr: *mut posix_spawnattr_t,
+        default: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getflags(
+        attr: *const posix_spawnattr_t,
+        flags: *mut ::c_short,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setflags(
+        attr: *mut posix_spawnattr_t,
+        flags: ::c_short,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getpgroup(
+        attr: *const posix_spawnattr_t,
+        flags: *mut ::pid_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setpgroup(
+        attr: *mut posix_spawnattr_t,
+        flags: ::pid_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getschedpolicy(
+        attr: *const posix_spawnattr_t,
+        flags: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setschedpolicy(
+        attr: *mut posix_spawnattr_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getschedparam(
+        attr: *const posix_spawnattr_t,
+        param: *mut ::sched_param,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setschedparam(
+        attr: *mut posix_spawnattr_t,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+
+    pub fn posix_spawn_file_actions_init(
+        actions: *mut posix_spawn_file_actions_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_destroy(
+        actions: *mut posix_spawn_file_actions_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_addopen(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+        path: *const ::c_char,
+        oflag: ::c_int,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_addclose(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_adddup2(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+        newfd: ::c_int,
+    ) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "freebsd", freebsd11),
+        link_name = "statfs@FBSD_1.0"
+    )]
+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "freebsd", freebsd11),
+        link_name = "fstatfs@FBSD_1.0"
+    )]
+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;
+
+    pub fn dup3(src: ::c_int, dst: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn __xuname(nmln: ::c_int, buf: *mut ::c_void) -> ::c_int;
+
+    pub fn sendmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn recvmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::size_t,
+        flags: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::ssize_t;
+    pub fn memmem(
+        haystack: *const ::c_void,
+        haystacklen: ::size_t,
+        needle: *const ::c_void,
+        needlelen: ::size_t,
+    ) -> *mut ::c_void;
+
+    pub fn nmount(
+        iov: *mut ::iovec,
+        niov: ::c_uint,
+        flags: ::c_int,
+    ) -> ::c_int;
+}
+
+#[link(name = "util")]
+extern "C" {
+    pub fn extattr_namespace_to_string(
+        attrnamespace: ::c_int,
+        string: *mut *mut ::c_char,
+    ) -> ::c_int;
+    pub fn extattr_string_to_namespace(
+        string: *const ::c_char,
+        attrnamespace: *mut ::c_int,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(freebsd13)] {
+        mod freebsd13;
+        pub use self::freebsd13::*;
+    } else if #[cfg(freebsd12)] {
+        mod freebsd12;
+        pub use self::freebsd12::*;
+    } else if #[cfg(any(freebsd10, freebsd11))] {
+        mod freebsd11;
+        pub use self::freebsd11::*;
+    } else {
+        // Unknown freebsd version
+    }
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "x86")] {
+        mod x86;
+        pub use self::x86::*;
+    } else if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(target_arch = "arm")] {
+        mod arm;
+        pub use self::arm::*;
+    } else if #[cfg(target_arch = "powerpc64")] {
+        mod powerpc64;
+        pub use self::powerpc64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/powerpc64.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/powerpc64.rs
new file mode 100644
index 00000000..7f5b9752
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/powerpc64.rs
@@ -0,0 +1,47 @@
+pub type c_char = u8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type wchar_t = i32;
+pub type time_t = i64;
+pub type suseconds_t = i64;
+pub type register_t = i64;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_size: ::off_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_blksize: ::blksize_t,
+        pub st_flags: ::fflags_t,
+        pub st_gen: u32,
+        pub st_lspare: i32,
+        pub st_birthtime: ::time_t,
+        pub st_birthtime_nsec: ::c_long,
+    }
+}
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 8 - 1;
+    }
+}
+
+pub const MAP_32BIT: ::c_int = 0x00080000;
+pub const MINSIGSTKSZ: ::size_t = 2048; // 512 * 4
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/x86.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/x86.rs
new file mode 100644
index 00000000..d3a3f34b
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/x86.rs
@@ -0,0 +1,46 @@
+pub type c_char = i8;
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type wchar_t = i32;
+pub type time_t = i32;
+pub type suseconds_t = i32;
+pub type register_t = i32;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_size: ::off_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_blksize: ::blksize_t,
+        pub st_flags: ::fflags_t,
+        pub st_gen: u32,
+        pub st_lspare: i32,
+        pub st_birthtime: ::time_t,
+        pub st_birthtime_nsec: ::c_long,
+        __unused: [u8; 8],
+    }
+}
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 4 - 1;
+    }
+}
+pub const MINSIGSTKSZ: ::size_t = 2048; // 512 * 4
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/align.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/align.rs
new file mode 100644
index 00000000..3a016a05
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/align.rs
@@ -0,0 +1,197 @@
+use {c_long, register_t};
+
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 4]
+    }
+
+    #[repr(align(16))]
+    pub struct mcontext_t {
+        pub mc_onstack: register_t,
+        pub mc_rdi: register_t,
+        pub mc_rsi: register_t,
+        pub mc_rdx: register_t,
+        pub mc_rcx: register_t,
+        pub mc_r8: register_t,
+        pub mc_r9: register_t,
+        pub mc_rax: register_t,
+        pub mc_rbx: register_t,
+        pub mc_rbp: register_t,
+        pub mc_r10: register_t,
+        pub mc_r11: register_t,
+        pub mc_r12: register_t,
+        pub mc_r13: register_t,
+        pub mc_r14: register_t,
+        pub mc_r15: register_t,
+        pub mc_trapno: u32,
+        pub mc_fs: u16,
+        pub mc_gs: u16,
+        pub mc_addr: register_t,
+        pub mc_flags: u32,
+        pub mc_es: u16,
+        pub mc_ds: u16,
+        pub mc_err: register_t,
+        pub mc_rip: register_t,
+        pub mc_cs: register_t,
+        pub mc_rflags: register_t,
+        pub mc_rsp: register_t,
+        pub mc_ss: register_t,
+        pub mc_len: c_long,
+        pub mc_fpformat: c_long,
+        pub mc_ownedfp: c_long,
+        pub mc_fpstate: [c_long; 64],
+        pub mc_fsbase: register_t,
+        pub mc_gsbase: register_t,
+        pub mc_xfpustate: register_t,
+        pub mc_xfpustate_len: register_t,
+        pub mc_spare: [c_long; 4],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for mcontext_t {
+            fn eq(&self, other: &mcontext_t) -> bool {
+                self.mc_onstack == other.mc_onstack &&
+                self.mc_rdi == other.mc_rdi &&
+                self.mc_rsi == other.mc_rsi &&
+                self.mc_rdx == other.mc_rdx &&
+                self.mc_rcx == other.mc_rcx &&
+                self.mc_r8 == other.mc_r8 &&
+                self.mc_r9 == other.mc_r9 &&
+                self.mc_rax == other.mc_rax &&
+                self.mc_rbx == other.mc_rbx &&
+                self.mc_rbp == other.mc_rbp &&
+                self.mc_r10 == other.mc_r10 &&
+                self.mc_r11 == other.mc_r11 &&
+                self.mc_r12 == other.mc_r12 &&
+                self.mc_r13 == other.mc_r13 &&
+                self.mc_r14 == other.mc_r14 &&
+                self.mc_r15 == other.mc_r15 &&
+                self.mc_trapno == other.mc_trapno &&
+                self.mc_fs == other.mc_fs &&
+                self.mc_gs == other.mc_gs &&
+                self.mc_addr == other.mc_addr &&
+                self.mc_flags == other.mc_flags &&
+                self.mc_es == other.mc_es &&
+                self.mc_ds == other.mc_ds &&
+                self.mc_err == other.mc_err &&
+                self.mc_rip == other.mc_rip &&
+                self.mc_cs == other.mc_cs &&
+                self.mc_rflags == other.mc_rflags &&
+                self.mc_rsp == other.mc_rsp &&
+                self.mc_ss == other.mc_ss &&
+                self.mc_len == other.mc_len &&
+                self.mc_fpformat == other.mc_fpformat &&
+                self.mc_ownedfp == other.mc_ownedfp &&
+                self.mc_fpstate.iter().zip(other.mc_fpstate.iter())
+                .all(|(a, b)| a == b) &&
+                self.mc_fsbase == other.mc_fsbase &&
+                self.mc_gsbase == other.mc_gsbase &&
+                self.mc_xfpustate == other.mc_xfpustate &&
+                self.mc_xfpustate_len == other.mc_xfpustate_len &&
+                self.mc_spare == other.mc_spare
+            }
+        }
+        impl Eq for mcontext_t {}
+        impl ::fmt::Debug for mcontext_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("mcontext_t")
+                    .field("mc_onstack", &self.mc_onstack)
+                    .field("mc_rdi", &self.mc_rdi)
+                    .field("mc_rsi", &self.mc_rsi)
+                    .field("mc_rdx", &self.mc_rdx)
+                    .field("mc_rcx", &self.mc_rcx)
+                    .field("mc_r8", &self.mc_r8)
+                    .field("mc_r9", &self.mc_r9)
+                    .field("mc_rax", &self.mc_rax)
+                    .field("mc_rbx", &self.mc_rbx)
+                    .field("mc_rbp", &self.mc_rbp)
+                    .field("mc_r10", &self.mc_r10)
+                    .field("mc_r11", &self.mc_r11)
+                    .field("mc_r12", &self.mc_r12)
+                    .field("mc_r13", &self.mc_r13)
+                    .field("mc_r14", &self.mc_r14)
+                    .field("mc_r15", &self.mc_r15)
+                    .field("mc_trapno", &self.mc_trapno)
+                    .field("mc_fs", &self.mc_fs)
+                    .field("mc_gs", &self.mc_gs)
+                    .field("mc_addr", &self.mc_addr)
+                    .field("mc_flags", &self.mc_flags)
+                    .field("mc_es", &self.mc_es)
+                    .field("mc_ds", &self.mc_ds)
+                    .field("mc_err", &self.mc_err)
+                    .field("mc_rip", &self.mc_rip)
+                    .field("mc_cs", &self.mc_cs)
+                    .field("mc_rflags", &self.mc_rflags)
+                    .field("mc_rsp", &self.mc_rsp)
+                    .field("mc_ss", &self.mc_ss)
+                    .field("mc_len", &self.mc_len)
+                    .field("mc_fpformat", &self.mc_fpformat)
+                    .field("mc_ownedfp", &self.mc_ownedfp)
+                    // FIXME: .field("mc_fpstate", &self.mc_fpstate)
+                    .field("mc_fsbase", &self.mc_fsbase)
+                    .field("mc_gsbase", &self.mc_gsbase)
+                    .field("mc_xfpustate", &self.mc_xfpustate)
+                    .field("mc_xfpustate_len", &self.mc_xfpustate_len)
+                    .field("mc_spare", &self.mc_spare)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for mcontext_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.mc_onstack.hash(state);
+                self.mc_rdi.hash(state);
+                self.mc_rsi.hash(state);
+                self.mc_rdx.hash(state);
+                self.mc_rcx.hash(state);
+                self.mc_r8.hash(state);
+                self.mc_r9.hash(state);
+                self.mc_rax.hash(state);
+                self.mc_rbx.hash(state);
+                self.mc_rbp.hash(state);
+                self.mc_r10.hash(state);
+                self.mc_r11.hash(state);
+                self.mc_r12.hash(state);
+                self.mc_r13.hash(state);
+                self.mc_r14.hash(state);
+                self.mc_r15.hash(state);
+                self.mc_trapno.hash(state);
+                self.mc_fs.hash(state);
+                self.mc_gs.hash(state);
+                self.mc_addr.hash(state);
+                self.mc_flags.hash(state);
+                self.mc_es.hash(state);
+                self.mc_ds.hash(state);
+                self.mc_err.hash(state);
+                self.mc_rip.hash(state);
+                self.mc_cs.hash(state);
+                self.mc_rflags.hash(state);
+                self.mc_rsp.hash(state);
+                self.mc_ss.hash(state);
+                self.mc_len.hash(state);
+                self.mc_fpformat.hash(state);
+                self.mc_ownedfp.hash(state);
+                self.mc_fpstate.hash(state);
+                self.mc_fsbase.hash(state);
+                self.mc_gsbase.hash(state);
+                self.mc_xfpustate.hash(state);
+                self.mc_xfpustate_len.hash(state);
+                self.mc_spare.hash(state);
+            }
+        }
+    }
+}
+
+s! {
+    pub struct ucontext_t {
+        pub uc_sigmask: ::sigset_t,
+        pub uc_mcontext: ::mcontext_t,
+        pub uc_link: *mut ::ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_flags: ::c_int,
+        __spare__: [::c_int; 4],
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/mod.rs b/library/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/mod.rs
new file mode 100644
index 00000000..d3333c8b
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/mod.rs
@@ -0,0 +1,208 @@
+pub type c_char = i8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type wchar_t = i32;
+pub type time_t = i64;
+pub type suseconds_t = i64;
+pub type register_t = i64;
+
+s! {
+    pub struct reg32 {
+        pub r_fs: u32,
+        pub r_es: u32,
+        pub r_ds: u32,
+        pub r_edi: u32,
+        pub r_esi: u32,
+        pub r_ebp: u32,
+        pub r_isp: u32,
+        pub r_ebx: u32,
+        pub r_edx: u32,
+        pub r_ecx: u32,
+        pub r_eax: u32,
+        pub r_trapno: u32,
+        pub r_err: u32,
+        pub r_eip: u32,
+        pub r_cs: u32,
+        pub r_eflags: u32,
+        pub r_esp: u32,
+        pub r_ss: u32,
+        pub r_gs: u32,
+    }
+
+    pub struct reg {
+        pub r_r15: i64,
+        pub r_r14: i64,
+        pub r_r13: i64,
+        pub r_r12: i64,
+        pub r_r11: i64,
+        pub r_r10: i64,
+        pub r_r9: i64,
+        pub r_r8: i64,
+        pub r_rdi: i64,
+        pub r_rsi: i64,
+        pub r_rbp: i64,
+        pub r_rbx: i64,
+        pub r_rdx: i64,
+        pub r_rcx: i64,
+        pub r_rax: i64,
+        pub r_trapno: u32,
+        pub r_fs: u16,
+        pub r_gs: u16,
+        pub r_err: u32,
+        pub r_es: u16,
+        pub r_ds: u16,
+        pub r_rip: i64,
+        pub r_cs: i64,
+        pub r_rflags: i64,
+        pub r_rsp: i64,
+        pub r_ss: i64,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct fpreg32 {
+        pub fpr_env: [u32; 7],
+        pub fpr_acc: [[u8; 10]; 8],
+        pub fpr_ex_sw: u32,
+        pub fpr_pad: [u8; 64],
+    }
+
+    pub struct fpreg {
+        pub fpr_env: [u64; 4],
+        pub fpr_acc: [[u8; 16]; 8],
+        pub fpr_xacc: [[u8; 16]; 16],
+        pub fpr_spare: [u64; 12],
+    }
+
+    pub struct xmmreg {
+        pub xmm_env: [u32; 8],
+        pub xmm_acc: [[u8; 16]; 8],
+        pub xmm_reg: [[u8; 16]; 8],
+        pub xmm_pad: [u8; 224],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for fpreg32 {
+            fn eq(&self, other: &fpreg32) -> bool {
+                self.fpr_env == other.fpr_env &&
+                    self.fpr_acc == other.fpr_acc &&
+                    self.fpr_ex_sw == other.fpr_ex_sw &&
+                    self.fpr_pad
+                        .iter()
+                        .zip(other.fpr_pad.iter())
+                        .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for fpreg32 {}
+        impl ::fmt::Debug for fpreg32 {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("fpreg32")
+                    .field("fpr_env", &&self.fpr_env[..])
+                    .field("fpr_acc", &self.fpr_acc)
+                    .field("fpr_ex_sw", &self.fpr_ex_sw)
+                    .field("fpr_pad", &&self.fpr_pad[..])
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for fpreg32 {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.fpr_env.hash(state);
+                self.fpr_acc.hash(state);
+                self.fpr_ex_sw.hash(state);
+                self.fpr_pad.hash(state);
+            }
+        }
+
+        impl PartialEq for fpreg {
+            fn eq(&self, other: &fpreg) -> bool {
+                self.fpr_env == other.fpr_env &&
+                    self.fpr_acc == other.fpr_acc &&
+                    self.fpr_xacc == other.fpr_xacc &&
+                    self.fpr_spare == other.fpr_spare
+            }
+        }
+        impl Eq for fpreg {}
+        impl ::fmt::Debug for fpreg {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("fpreg")
+                    .field("fpr_env", &self.fpr_env)
+                    .field("fpr_acc", &self.fpr_acc)
+                    .field("fpr_xacc", &self.fpr_xacc)
+                    .field("fpr_spare", &self.fpr_spare)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for fpreg {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.fpr_env.hash(state);
+                self.fpr_acc.hash(state);
+                self.fpr_xacc.hash(state);
+                self.fpr_spare.hash(state);
+            }
+        }
+
+        impl PartialEq for xmmreg {
+            fn eq(&self, other: &xmmreg) -> bool {
+                self.xmm_env == other.xmm_env &&
+                    self.xmm_acc == other.xmm_acc &&
+                    self.xmm_reg == other.xmm_reg &&
+                    self.xmm_pad
+                        .iter()
+                        .zip(other.xmm_pad.iter())
+                        .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for xmmreg {}
+        impl ::fmt::Debug for xmmreg {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("xmmreg")
+                    .field("xmm_env", &self.xmm_env)
+                    .field("xmm_acc", &self.xmm_acc)
+                    .field("xmm_reg", &self.xmm_reg)
+                    .field("xmm_pad", &&self.xmm_pad[..])
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for xmmreg {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.xmm_env.hash(state);
+                self.xmm_acc.hash(state);
+                self.xmm_reg.hash(state);
+                self.xmm_pad.hash(state);
+            }
+        }
+    }
+}
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 8 - 1;
+    }
+}
+pub const MAP_32BIT: ::c_int = 0x00080000;
+pub const MINSIGSTKSZ: ::size_t = 2048; // 512 * 4
+
+pub const _MC_HASSEGS: u32 = 0x1;
+pub const _MC_HASBASES: u32 = 0x2;
+pub const _MC_HASFPXSTATE: u32 = 0x4;
+pub const _MC_FLAG_MASK: u32 = _MC_HASSEGS | _MC_HASBASES | _MC_HASFPXSTATE;
+
+pub const _MC_FPFMT_NODEV: c_long = 0x10000;
+pub const _MC_FPFMT_XMM: c_long = 0x10002;
+pub const _MC_FPOWNED_NONE: c_long = 0x20000;
+pub const _MC_FPOWNED_FPU: c_long = 0x20001;
+pub const _MC_FPOWNED_PCB: c_long = 0x20002;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/bsd/freebsdlike/mod.rs b/library/libc/src/unix/bsd/freebsdlike/mod.rs
new file mode 100644
index 00000000..d126391f
--- /dev/null
+++ b/library/libc/src/unix/bsd/freebsdlike/mod.rs
@@ -0,0 +1,1667 @@
+pub type mode_t = u16;
+pub type pthread_attr_t = *mut ::c_void;
+pub type rlim_t = i64;
+pub type pthread_mutex_t = *mut ::c_void;
+pub type pthread_mutexattr_t = *mut ::c_void;
+pub type pthread_cond_t = *mut ::c_void;
+pub type pthread_condattr_t = *mut ::c_void;
+pub type pthread_rwlock_t = *mut ::c_void;
+pub type pthread_rwlockattr_t = *mut ::c_void;
+pub type pthread_key_t = ::c_int;
+pub type tcflag_t = ::c_uint;
+pub type speed_t = ::c_uint;
+pub type nl_item = ::c_int;
+pub type id_t = i64;
+pub type vm_size_t = ::uintptr_t;
+
+// elf.h
+
+pub type Elf32_Addr = u32;
+pub type Elf32_Half = u16;
+pub type Elf32_Lword = u64;
+pub type Elf32_Off = u32;
+pub type Elf32_Sword = i32;
+pub type Elf32_Word = u32;
+
+pub type Elf64_Addr = u64;
+pub type Elf64_Half = u16;
+pub type Elf64_Lword = u64;
+pub type Elf64_Off = u64;
+pub type Elf64_Sword = i32;
+pub type Elf64_Sxword = i64;
+pub type Elf64_Word = u32;
+pub type Elf64_Xword = u64;
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "64")] {
+        type Elf_Addr = Elf64_Addr;
+        type Elf_Half = Elf64_Half;
+        type Elf_Phdr = Elf64_Phdr;
+    } else if #[cfg(target_pointer_width = "32")] {
+        type Elf_Addr = Elf32_Addr;
+        type Elf_Half = Elf32_Half;
+        type Elf_Phdr = Elf32_Phdr;
+    }
+}
+
+// link.h
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_addr(&self) -> *mut ::c_void {
+        self.si_addr
+    }
+
+    pub unsafe fn si_value(&self) -> ::sigval {
+        self.si_value
+    }
+
+    pub unsafe fn si_pid(&self) -> ::pid_t {
+        self.si_pid
+    }
+
+    pub unsafe fn si_uid(&self) -> ::uid_t {
+        self.si_uid
+    }
+
+    pub unsafe fn si_status(&self) -> ::c_int {
+        self.si_status
+    }
+}
+
+s! {
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct glob_t {
+        pub gl_pathc:  ::size_t,
+        pub gl_matchc: ::size_t,
+        pub gl_offs:   ::size_t,
+        pub gl_flags:  ::c_int,
+        pub gl_pathv:  *mut *mut ::c_char,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+        __unused6: *mut ::c_void,
+        __unused7: *mut ::c_void,
+        __unused8: *mut ::c_void,
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: ::socklen_t,
+        pub ai_canonname: *mut ::c_char,
+        pub ai_addr: *mut ::sockaddr,
+        pub ai_next: *mut addrinfo,
+    }
+
+    pub struct sigset_t {
+        bits: [u32; 4],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub si_pid: ::pid_t,
+        pub si_uid: ::uid_t,
+        pub si_status: ::c_int,
+        pub si_addr: *mut ::c_void,
+        pub si_value: ::sigval,
+        _pad1: ::c_long,
+        _pad2: [::c_int; 7],
+    }
+
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_flags: ::c_int,
+        pub sa_mask: sigset_t,
+    }
+
+    pub struct sched_param {
+        pub sched_priority: ::c_int,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct sockaddr_in {
+        pub sin_len: u8,
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [::c_char; 8],
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct flock {
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        #[cfg(not(target_os = "dragonfly"))]
+        pub l_sysid: ::c_int,
+    }
+
+    pub struct sf_hdtr {
+        pub headers: *mut ::iovec,
+        pub hdr_cnt: ::c_int,
+        pub trailers: *mut ::iovec,
+        pub trl_cnt: ::c_int,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct cmsgcred {
+        pub cmcred_pid: ::pid_t,
+        pub cmcred_uid: ::uid_t,
+        pub cmcred_euid: ::uid_t,
+        pub cmcred_gid: ::gid_t,
+        pub cmcred_ngroups: ::c_short,
+        pub cmcred_groups: [::gid_t; CMGROUP_MAX],
+    }
+
+    pub struct rtprio {
+        pub type_: ::c_ushort,
+        pub prio: ::c_ushort,
+    }
+
+    pub struct in6_pktinfo {
+        pub ipi6_addr: ::in6_addr,
+        pub ipi6_ifindex: ::c_uint,
+    }
+
+    pub struct arphdr {
+        pub ar_hrd: u16,
+        pub ar_pro: u16,
+        pub ar_hln: u8,
+        pub ar_pln: u8,
+        pub ar_op: u16,
+    }
+
+    pub struct timex {
+        pub modes: ::c_uint,
+        pub offset: ::c_long,
+        pub freq: ::c_long,
+        pub maxerror: ::c_long,
+        pub esterror: ::c_long,
+        pub status: ::c_int,
+        pub constant: ::c_long,
+        pub precision: ::c_long,
+        pub tolerance: ::c_long,
+        pub ppsfreq: ::c_long,
+        pub jitter: ::c_long,
+        pub shift: ::c_int,
+        pub stabil: ::c_long,
+        pub jitcnt: ::c_long,
+        pub calcnt: ::c_long,
+        pub errcnt: ::c_long,
+        pub stbcnt: ::c_long,
+    }
+
+    pub struct ntptimeval {
+        pub time: ::timespec,
+        pub maxerror: ::c_long,
+        pub esterror: ::c_long,
+        pub tai: ::c_long,
+        pub time_state: ::c_int,
+    }
+
+    pub struct ptrace_io_desc {
+        pub piod_op: ::c_int,
+        pub piod_offs: *mut ::c_void,
+        pub piod_addr: *mut ::c_void,
+        pub piod_len: ::size_t,
+    }
+
+    // elf.h
+
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    // link.h
+
+    pub struct dl_phdr_info {
+        pub dlpi_addr: Elf_Addr,
+        pub dlpi_name: *const ::c_char,
+        pub dlpi_phdr: *const Elf_Phdr,
+        pub dlpi_phnum: Elf_Half,
+        pub dlpi_adds: ::c_ulonglong,
+        pub dlpi_subs: ::c_ulonglong,
+        pub dlpi_tls_modid: usize,
+        pub dlpi_tls_data: *mut ::c_void,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct sockaddr_storage {
+        pub ss_len: u8,
+        pub ss_family: ::sa_family_t,
+        __ss_pad1: [u8; 6],
+        __ss_align: i64,
+        __ss_pad2: [u8; 112],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_len == other.ss_len
+                    && self.ss_family == other.ss_family
+                    && self.__ss_pad1 == other.__ss_pad1
+                    && self.__ss_align == other.__ss_align
+                    && self
+                    .__ss_pad2
+                    .iter()
+                    .zip(other.__ss_pad2.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_storage {}
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_len", &self.ss_len)
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_pad1", &self.__ss_pad1)
+                    .field("__ss_align", &self.__ss_align)
+                    // FIXME: .field("__ss_pad2", &self.__ss_pad2)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_len.hash(state);
+                self.ss_family.hash(state);
+                self.__ss_pad1.hash(state);
+                self.__ss_align.hash(state);
+                self.__ss_pad2.hash(state);
+            }
+        }
+    }
+}
+
+#[deprecated(
+    since = "0.2.64",
+    note = "Can vary at runtime.  Use sysconf(3) instead"
+)]
+pub const AIO_LISTIO_MAX: ::c_int = 16;
+pub const AIO_CANCELED: ::c_int = 1;
+pub const AIO_NOTCANCELED: ::c_int = 2;
+pub const AIO_ALLDONE: ::c_int = 3;
+pub const LIO_NOP: ::c_int = 0;
+pub const LIO_WRITE: ::c_int = 1;
+pub const LIO_READ: ::c_int = 2;
+pub const LIO_WAIT: ::c_int = 1;
+pub const LIO_NOWAIT: ::c_int = 0;
+
+pub const SIGEV_NONE: ::c_int = 0;
+pub const SIGEV_SIGNAL: ::c_int = 1;
+pub const SIGEV_THREAD: ::c_int = 2;
+pub const SIGEV_KEVENT: ::c_int = 3;
+
+pub const CODESET: ::nl_item = 0;
+pub const D_T_FMT: ::nl_item = 1;
+pub const D_FMT: ::nl_item = 2;
+pub const T_FMT: ::nl_item = 3;
+pub const T_FMT_AMPM: ::nl_item = 4;
+pub const AM_STR: ::nl_item = 5;
+pub const PM_STR: ::nl_item = 6;
+
+pub const DAY_1: ::nl_item = 7;
+pub const DAY_2: ::nl_item = 8;
+pub const DAY_3: ::nl_item = 9;
+pub const DAY_4: ::nl_item = 10;
+pub const DAY_5: ::nl_item = 11;
+pub const DAY_6: ::nl_item = 12;
+pub const DAY_7: ::nl_item = 13;
+
+pub const ABDAY_1: ::nl_item = 14;
+pub const ABDAY_2: ::nl_item = 15;
+pub const ABDAY_3: ::nl_item = 16;
+pub const ABDAY_4: ::nl_item = 17;
+pub const ABDAY_5: ::nl_item = 18;
+pub const ABDAY_6: ::nl_item = 19;
+pub const ABDAY_7: ::nl_item = 20;
+
+pub const MON_1: ::nl_item = 21;
+pub const MON_2: ::nl_item = 22;
+pub const MON_3: ::nl_item = 23;
+pub const MON_4: ::nl_item = 24;
+pub const MON_5: ::nl_item = 25;
+pub const MON_6: ::nl_item = 26;
+pub const MON_7: ::nl_item = 27;
+pub const MON_8: ::nl_item = 28;
+pub const MON_9: ::nl_item = 29;
+pub const MON_10: ::nl_item = 30;
+pub const MON_11: ::nl_item = 31;
+pub const MON_12: ::nl_item = 32;
+
+pub const ABMON_1: ::nl_item = 33;
+pub const ABMON_2: ::nl_item = 34;
+pub const ABMON_3: ::nl_item = 35;
+pub const ABMON_4: ::nl_item = 36;
+pub const ABMON_5: ::nl_item = 37;
+pub const ABMON_6: ::nl_item = 38;
+pub const ABMON_7: ::nl_item = 39;
+pub const ABMON_8: ::nl_item = 40;
+pub const ABMON_9: ::nl_item = 41;
+pub const ABMON_10: ::nl_item = 42;
+pub const ABMON_11: ::nl_item = 43;
+pub const ABMON_12: ::nl_item = 44;
+
+pub const ERA: ::nl_item = 45;
+pub const ERA_D_FMT: ::nl_item = 46;
+pub const ERA_D_T_FMT: ::nl_item = 47;
+pub const ERA_T_FMT: ::nl_item = 48;
+pub const ALT_DIGITS: ::nl_item = 49;
+
+pub const RADIXCHAR: ::nl_item = 50;
+pub const THOUSEP: ::nl_item = 51;
+
+pub const YESEXPR: ::nl_item = 52;
+pub const NOEXPR: ::nl_item = 53;
+
+pub const YESSTR: ::nl_item = 54;
+pub const NOSTR: ::nl_item = 55;
+
+pub const CRNCYSTR: ::nl_item = 56;
+
+pub const D_MD_ORDER: ::nl_item = 57;
+
+pub const ALTMON_1: ::nl_item = 58;
+pub const ALTMON_2: ::nl_item = 59;
+pub const ALTMON_3: ::nl_item = 60;
+pub const ALTMON_4: ::nl_item = 61;
+pub const ALTMON_5: ::nl_item = 62;
+pub const ALTMON_6: ::nl_item = 63;
+pub const ALTMON_7: ::nl_item = 64;
+pub const ALTMON_8: ::nl_item = 65;
+pub const ALTMON_9: ::nl_item = 66;
+pub const ALTMON_10: ::nl_item = 67;
+pub const ALTMON_11: ::nl_item = 68;
+pub const ALTMON_12: ::nl_item = 69;
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const SEEK_DATA: ::c_int = 3;
+pub const SEEK_HOLE: ::c_int = 4;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 2;
+pub const _IOLBF: ::c_int = 1;
+pub const BUFSIZ: ::c_uint = 1024;
+pub const FOPEN_MAX: ::c_uint = 20;
+pub const FILENAME_MAX: ::c_uint = 1024;
+pub const L_tmpnam: ::c_uint = 1024;
+pub const TMP_MAX: ::c_uint = 308915776;
+
+pub const O_NOCTTY: ::c_int = 32768;
+pub const O_DIRECT: ::c_int = 0x00010000;
+
+pub const S_IFIFO: mode_t = 4096;
+pub const S_IFCHR: mode_t = 8192;
+pub const S_IFBLK: mode_t = 24576;
+pub const S_IFDIR: mode_t = 16384;
+pub const S_IFREG: mode_t = 32768;
+pub const S_IFLNK: mode_t = 40960;
+pub const S_IFSOCK: mode_t = 49152;
+pub const S_IFMT: mode_t = 61440;
+pub const S_IEXEC: mode_t = 64;
+pub const S_IWRITE: mode_t = 128;
+pub const S_IREAD: mode_t = 256;
+pub const S_IRWXU: mode_t = 448;
+pub const S_IXUSR: mode_t = 64;
+pub const S_IWUSR: mode_t = 128;
+pub const S_IRUSR: mode_t = 256;
+pub const S_IRWXG: mode_t = 56;
+pub const S_IXGRP: mode_t = 8;
+pub const S_IWGRP: mode_t = 16;
+pub const S_IRGRP: mode_t = 32;
+pub const S_IRWXO: mode_t = 7;
+pub const S_IXOTH: mode_t = 1;
+pub const S_IWOTH: mode_t = 2;
+pub const S_IROTH: mode_t = 4;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+pub const F_DUPFD_CLOEXEC: ::c_int = 17;
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGEMT: ::c_int = 7;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+
+pub const PROT_NONE: ::c_int = 0;
+pub const PROT_READ: ::c_int = 1;
+pub const PROT_WRITE: ::c_int = 2;
+pub const PROT_EXEC: ::c_int = 4;
+
+pub const MAP_FILE: ::c_int = 0x0000;
+pub const MAP_SHARED: ::c_int = 0x0001;
+pub const MAP_PRIVATE: ::c_int = 0x0002;
+pub const MAP_FIXED: ::c_int = 0x0010;
+pub const MAP_ANON: ::c_int = 0x1000;
+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;
+
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const MS_SYNC: ::c_int = 0x0000;
+pub const MS_ASYNC: ::c_int = 0x0001;
+pub const MS_INVALIDATE: ::c_int = 0x0002;
+
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EDEADLK: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EAGAIN: ::c_int = 35;
+pub const EWOULDBLOCK: ::c_int = 35;
+pub const EINPROGRESS: ::c_int = 36;
+pub const EALREADY: ::c_int = 37;
+pub const ENOTSOCK: ::c_int = 38;
+pub const EDESTADDRREQ: ::c_int = 39;
+pub const EMSGSIZE: ::c_int = 40;
+pub const EPROTOTYPE: ::c_int = 41;
+pub const ENOPROTOOPT: ::c_int = 42;
+pub const EPROTONOSUPPORT: ::c_int = 43;
+pub const ESOCKTNOSUPPORT: ::c_int = 44;
+pub const EOPNOTSUPP: ::c_int = 45;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 46;
+pub const EAFNOSUPPORT: ::c_int = 47;
+pub const EADDRINUSE: ::c_int = 48;
+pub const EADDRNOTAVAIL: ::c_int = 49;
+pub const ENETDOWN: ::c_int = 50;
+pub const ENETUNREACH: ::c_int = 51;
+pub const ENETRESET: ::c_int = 52;
+pub const ECONNABORTED: ::c_int = 53;
+pub const ECONNRESET: ::c_int = 54;
+pub const ENOBUFS: ::c_int = 55;
+pub const EISCONN: ::c_int = 56;
+pub const ENOTCONN: ::c_int = 57;
+pub const ESHUTDOWN: ::c_int = 58;
+pub const ETOOMANYREFS: ::c_int = 59;
+pub const ETIMEDOUT: ::c_int = 60;
+pub const ECONNREFUSED: ::c_int = 61;
+pub const ELOOP: ::c_int = 62;
+pub const ENAMETOOLONG: ::c_int = 63;
+pub const EHOSTDOWN: ::c_int = 64;
+pub const EHOSTUNREACH: ::c_int = 65;
+pub const ENOTEMPTY: ::c_int = 66;
+pub const EPROCLIM: ::c_int = 67;
+pub const EUSERS: ::c_int = 68;
+pub const EDQUOT: ::c_int = 69;
+pub const ESTALE: ::c_int = 70;
+pub const EREMOTE: ::c_int = 71;
+pub const EBADRPC: ::c_int = 72;
+pub const ERPCMISMATCH: ::c_int = 73;
+pub const EPROGUNAVAIL: ::c_int = 74;
+pub const EPROGMISMATCH: ::c_int = 75;
+pub const EPROCUNAVAIL: ::c_int = 76;
+pub const ENOLCK: ::c_int = 77;
+pub const ENOSYS: ::c_int = 78;
+pub const EFTYPE: ::c_int = 79;
+pub const EAUTH: ::c_int = 80;
+pub const ENEEDAUTH: ::c_int = 81;
+pub const EIDRM: ::c_int = 82;
+pub const ENOMSG: ::c_int = 83;
+pub const EOVERFLOW: ::c_int = 84;
+pub const ECANCELED: ::c_int = 85;
+pub const EILSEQ: ::c_int = 86;
+pub const ENOATTR: ::c_int = 87;
+pub const EDOOFUS: ::c_int = 88;
+pub const EBADMSG: ::c_int = 89;
+pub const EMULTIHOP: ::c_int = 90;
+pub const ENOLINK: ::c_int = 91;
+pub const EPROTO: ::c_int = 92;
+
+pub const POLLSTANDARD: ::c_short = ::POLLIN
+    | ::POLLPRI
+    | ::POLLOUT
+    | ::POLLRDNORM
+    | ::POLLRDBAND
+    | ::POLLWRBAND
+    | ::POLLERR
+    | ::POLLHUP
+    | ::POLLNVAL;
+
+pub const EAI_AGAIN: ::c_int = 2;
+pub const EAI_BADFLAGS: ::c_int = 3;
+pub const EAI_FAIL: ::c_int = 4;
+pub const EAI_FAMILY: ::c_int = 5;
+pub const EAI_MEMORY: ::c_int = 6;
+pub const EAI_NONAME: ::c_int = 8;
+pub const EAI_SERVICE: ::c_int = 9;
+pub const EAI_SOCKTYPE: ::c_int = 10;
+pub const EAI_SYSTEM: ::c_int = 11;
+pub const EAI_OVERFLOW: ::c_int = 14;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+
+pub const SIGTRAP: ::c_int = 5;
+
+pub const GLOB_APPEND: ::c_int = 0x0001;
+pub const GLOB_DOOFFS: ::c_int = 0x0002;
+pub const GLOB_ERR: ::c_int = 0x0004;
+pub const GLOB_MARK: ::c_int = 0x0008;
+pub const GLOB_NOCHECK: ::c_int = 0x0010;
+pub const GLOB_NOSORT: ::c_int = 0x0020;
+pub const GLOB_NOESCAPE: ::c_int = 0x2000;
+
+pub const GLOB_NOSPACE: ::c_int = -1;
+pub const GLOB_ABORTED: ::c_int = -2;
+pub const GLOB_NOMATCH: ::c_int = -3;
+
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+
+pub const PTHREAD_PROCESS_PRIVATE: ::c_int = 0;
+pub const PTHREAD_PROCESS_SHARED: ::c_int = 1;
+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;
+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;
+
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_MEMLOCK: ::c_int = 6;
+pub const RLIMIT_NPROC: ::c_int = 7;
+pub const RLIMIT_NOFILE: ::c_int = 8;
+pub const RLIMIT_SBSIZE: ::c_int = 9;
+pub const RLIMIT_VMEM: ::c_int = 10;
+pub const RLIMIT_AS: ::c_int = RLIMIT_VMEM;
+pub const RLIM_INFINITY: rlim_t = 0x7fff_ffff_ffff_ffff;
+
+pub const RUSAGE_SELF: ::c_int = 0;
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const CLOCK_REALTIME: ::clockid_t = 0;
+pub const CLOCK_VIRTUAL: ::clockid_t = 1;
+pub const CLOCK_PROF: ::clockid_t = 2;
+pub const CLOCK_MONOTONIC: ::clockid_t = 4;
+pub const CLOCK_UPTIME: ::clockid_t = 5;
+pub const CLOCK_UPTIME_PRECISE: ::clockid_t = 7;
+pub const CLOCK_UPTIME_FAST: ::clockid_t = 8;
+pub const CLOCK_REALTIME_PRECISE: ::clockid_t = 9;
+pub const CLOCK_REALTIME_FAST: ::clockid_t = 10;
+pub const CLOCK_MONOTONIC_PRECISE: ::clockid_t = 11;
+pub const CLOCK_MONOTONIC_FAST: ::clockid_t = 12;
+pub const CLOCK_SECOND: ::clockid_t = 13;
+pub const CLOCK_THREAD_CPUTIME_ID: ::clockid_t = 14;
+pub const CLOCK_PROCESS_CPUTIME_ID: ::clockid_t = 15;
+
+pub const MADV_NORMAL: ::c_int = 0;
+pub const MADV_RANDOM: ::c_int = 1;
+pub const MADV_SEQUENTIAL: ::c_int = 2;
+pub const MADV_WILLNEED: ::c_int = 3;
+pub const MADV_DONTNEED: ::c_int = 4;
+pub const MADV_FREE: ::c_int = 5;
+pub const MADV_NOSYNC: ::c_int = 6;
+pub const MADV_AUTOSYNC: ::c_int = 7;
+pub const MADV_NOCORE: ::c_int = 8;
+pub const MADV_CORE: ::c_int = 9;
+
+pub const MINCORE_INCORE: ::c_int = 0x1;
+pub const MINCORE_REFERENCED: ::c_int = 0x2;
+pub const MINCORE_MODIFIED: ::c_int = 0x4;
+pub const MINCORE_REFERENCED_OTHER: ::c_int = 0x8;
+pub const MINCORE_MODIFIED_OTHER: ::c_int = 0x10;
+pub const MINCORE_SUPER: ::c_int = 0x20;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_LOCAL: ::c_int = 1;
+pub const AF_UNIX: ::c_int = AF_LOCAL;
+pub const AF_INET: ::c_int = 2;
+pub const AF_IMPLINK: ::c_int = 3;
+pub const AF_PUP: ::c_int = 4;
+pub const AF_CHAOS: ::c_int = 5;
+pub const AF_NETBIOS: ::c_int = 6;
+pub const AF_ISO: ::c_int = 7;
+pub const AF_OSI: ::c_int = AF_ISO;
+pub const AF_ECMA: ::c_int = 8;
+pub const AF_DATAKIT: ::c_int = 9;
+pub const AF_CCITT: ::c_int = 10;
+pub const AF_SNA: ::c_int = 11;
+pub const AF_DECnet: ::c_int = 12;
+pub const AF_DLI: ::c_int = 13;
+pub const AF_LAT: ::c_int = 14;
+pub const AF_HYLINK: ::c_int = 15;
+pub const AF_APPLETALK: ::c_int = 16;
+pub const AF_ROUTE: ::c_int = 17;
+pub const AF_LINK: ::c_int = 18;
+pub const pseudo_AF_XTP: ::c_int = 19;
+pub const AF_COIP: ::c_int = 20;
+pub const AF_CNT: ::c_int = 21;
+pub const pseudo_AF_RTIP: ::c_int = 22;
+pub const AF_IPX: ::c_int = 23;
+pub const AF_SIP: ::c_int = 24;
+pub const pseudo_AF_PIP: ::c_int = 25;
+pub const AF_ISDN: ::c_int = 26;
+pub const AF_E164: ::c_int = AF_ISDN;
+pub const pseudo_AF_KEY: ::c_int = 27;
+pub const AF_INET6: ::c_int = 28;
+pub const AF_NATM: ::c_int = 29;
+pub const AF_ATM: ::c_int = 30;
+pub const pseudo_AF_HDRCMPLT: ::c_int = 31;
+pub const AF_NETGRAPH: ::c_int = 32;
+
+pub const PF_UNSPEC: ::c_int = AF_UNSPEC;
+pub const PF_LOCAL: ::c_int = AF_LOCAL;
+pub const PF_UNIX: ::c_int = PF_LOCAL;
+pub const PF_INET: ::c_int = AF_INET;
+pub const PF_IMPLINK: ::c_int = AF_IMPLINK;
+pub const PF_PUP: ::c_int = AF_PUP;
+pub const PF_CHAOS: ::c_int = AF_CHAOS;
+pub const PF_NETBIOS: ::c_int = AF_NETBIOS;
+pub const PF_ISO: ::c_int = AF_ISO;
+pub const PF_OSI: ::c_int = AF_ISO;
+pub const PF_ECMA: ::c_int = AF_ECMA;
+pub const PF_DATAKIT: ::c_int = AF_DATAKIT;
+pub const PF_CCITT: ::c_int = AF_CCITT;
+pub const PF_SNA: ::c_int = AF_SNA;
+pub const PF_DECnet: ::c_int = AF_DECnet;
+pub const PF_DLI: ::c_int = AF_DLI;
+pub const PF_LAT: ::c_int = AF_LAT;
+pub const PF_HYLINK: ::c_int = AF_HYLINK;
+pub const PF_APPLETALK: ::c_int = AF_APPLETALK;
+pub const PF_ROUTE: ::c_int = AF_ROUTE;
+pub const PF_LINK: ::c_int = AF_LINK;
+pub const PF_XTP: ::c_int = pseudo_AF_XTP;
+pub const PF_COIP: ::c_int = AF_COIP;
+pub const PF_CNT: ::c_int = AF_CNT;
+pub const PF_SIP: ::c_int = AF_SIP;
+pub const PF_IPX: ::c_int = AF_IPX;
+pub const PF_RTIP: ::c_int = pseudo_AF_RTIP;
+pub const PF_PIP: ::c_int = pseudo_AF_PIP;
+pub const PF_ISDN: ::c_int = AF_ISDN;
+pub const PF_KEY: ::c_int = pseudo_AF_KEY;
+pub const PF_INET6: ::c_int = AF_INET6;
+pub const PF_NATM: ::c_int = AF_NATM;
+pub const PF_ATM: ::c_int = AF_ATM;
+pub const PF_NETGRAPH: ::c_int = AF_NETGRAPH;
+
+pub const PIOD_READ_D: ::c_int = 1;
+pub const PIOD_WRITE_D: ::c_int = 2;
+pub const PIOD_READ_I: ::c_int = 3;
+pub const PIOD_WRITE_I: ::c_int = 4;
+
+pub const PT_TRACE_ME: ::c_int = 0;
+pub const PT_READ_I: ::c_int = 1;
+pub const PT_READ_D: ::c_int = 2;
+pub const PT_WRITE_I: ::c_int = 4;
+pub const PT_WRITE_D: ::c_int = 5;
+pub const PT_CONTINUE: ::c_int = 7;
+pub const PT_KILL: ::c_int = 8;
+pub const PT_STEP: ::c_int = 9;
+pub const PT_ATTACH: ::c_int = 10;
+pub const PT_DETACH: ::c_int = 11;
+pub const PT_IO: ::c_int = 12;
+
+pub const SOMAXCONN: ::c_int = 128;
+
+pub const MSG_OOB: ::c_int = 0x00000001;
+pub const MSG_PEEK: ::c_int = 0x00000002;
+pub const MSG_DONTROUTE: ::c_int = 0x00000004;
+pub const MSG_EOR: ::c_int = 0x00000008;
+pub const MSG_TRUNC: ::c_int = 0x00000010;
+pub const MSG_CTRUNC: ::c_int = 0x00000020;
+pub const MSG_WAITALL: ::c_int = 0x00000040;
+pub const MSG_DONTWAIT: ::c_int = 0x00000080;
+pub const MSG_EOF: ::c_int = 0x00000100;
+
+pub const SCM_TIMESTAMP: ::c_int = 0x02;
+pub const SCM_CREDS: ::c_int = 0x03;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_RAW: ::c_int = 3;
+pub const SOCK_RDM: ::c_int = 4;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const SOCK_CLOEXEC: ::c_int = 0x10000000;
+pub const SOCK_NONBLOCK: ::c_int = 0x20000000;
+pub const SOCK_MAXADDRLEN: ::c_int = 255;
+pub const IP_TTL: ::c_int = 4;
+pub const IP_HDRINCL: ::c_int = 2;
+pub const IP_RECVDSTADDR: ::c_int = 7;
+pub const IP_SENDSRCADDR: ::c_int = IP_RECVDSTADDR;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;
+pub const IP_RECVIF: ::c_int = 20;
+pub const IPV6_JOIN_GROUP: ::c_int = 12;
+pub const IPV6_LEAVE_GROUP: ::c_int = 13;
+pub const IPV6_CHECKSUM: ::c_int = 26;
+pub const IPV6_RECVPKTINFO: ::c_int = 36;
+pub const IPV6_PKTINFO: ::c_int = 46;
+pub const IPV6_HOPLIMIT: ::c_int = 47;
+pub const IPV6_RECVTCLASS: ::c_int = 57;
+pub const IPV6_TCLASS: ::c_int = 61;
+
+pub const TCP_NOPUSH: ::c_int = 4;
+pub const TCP_NOOPT: ::c_int = 8;
+pub const TCP_KEEPIDLE: ::c_int = 256;
+pub const TCP_KEEPINTVL: ::c_int = 512;
+pub const TCP_KEEPCNT: ::c_int = 1024;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+pub const SO_DEBUG: ::c_int = 0x01;
+pub const SO_ACCEPTCONN: ::c_int = 0x0002;
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_USELOOPBACK: ::c_int = 0x0040;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_TIMESTAMP: ::c_int = 0x0400;
+pub const SO_NOSIGPIPE: ::c_int = 0x0800;
+pub const SO_ACCEPTFILTER: ::c_int = 0x1000;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_TYPE: ::c_int = 0x1008;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const LOCK_SH: ::c_int = 1;
+pub const LOCK_EX: ::c_int = 2;
+pub const LOCK_NB: ::c_int = 4;
+pub const LOCK_UN: ::c_int = 8;
+
+pub const MAP_COPY: ::c_int = 0x0002;
+#[doc(hidden)]
+#[deprecated(since = "0.2.54", note = "Removed in FreeBSD 11")]
+pub const MAP_RENAME: ::c_int = 0x0020;
+#[doc(hidden)]
+#[deprecated(since = "0.2.54", note = "Removed in FreeBSD 11")]
+pub const MAP_NORESERVE: ::c_int = 0x0040;
+pub const MAP_HASSEMAPHORE: ::c_int = 0x0200;
+pub const MAP_STACK: ::c_int = 0x0400;
+pub const MAP_NOSYNC: ::c_int = 0x0800;
+pub const MAP_NOCORE: ::c_int = 0x020000;
+
+pub const IPPROTO_RAW: ::c_int = 255;
+
+pub const _PC_LINK_MAX: ::c_int = 1;
+pub const _PC_MAX_CANON: ::c_int = 2;
+pub const _PC_MAX_INPUT: ::c_int = 3;
+pub const _PC_NAME_MAX: ::c_int = 4;
+pub const _PC_PATH_MAX: ::c_int = 5;
+pub const _PC_PIPE_BUF: ::c_int = 6;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 7;
+pub const _PC_NO_TRUNC: ::c_int = 8;
+pub const _PC_VDISABLE: ::c_int = 9;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 10;
+pub const _PC_FILESIZEBITS: ::c_int = 12;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 17;
+pub const _PC_SYMLINK_MAX: ::c_int = 18;
+pub const _PC_MIN_HOLE_SIZE: ::c_int = 21;
+pub const _PC_ASYNC_IO: ::c_int = 53;
+pub const _PC_PRIO_IO: ::c_int = 54;
+pub const _PC_SYNC_IO: ::c_int = 55;
+pub const _PC_ACL_EXTENDED: ::c_int = 59;
+pub const _PC_ACL_PATH_MAX: ::c_int = 60;
+pub const _PC_CAP_PRESENT: ::c_int = 61;
+pub const _PC_INF_PRESENT: ::c_int = 62;
+pub const _PC_MAC_PRESENT: ::c_int = 63;
+
+pub const _SC_ARG_MAX: ::c_int = 1;
+pub const _SC_CHILD_MAX: ::c_int = 2;
+pub const _SC_CLK_TCK: ::c_int = 3;
+pub const _SC_NGROUPS_MAX: ::c_int = 4;
+pub const _SC_OPEN_MAX: ::c_int = 5;
+pub const _SC_JOB_CONTROL: ::c_int = 6;
+pub const _SC_SAVED_IDS: ::c_int = 7;
+pub const _SC_VERSION: ::c_int = 8;
+pub const _SC_BC_BASE_MAX: ::c_int = 9;
+pub const _SC_BC_DIM_MAX: ::c_int = 10;
+pub const _SC_BC_SCALE_MAX: ::c_int = 11;
+pub const _SC_BC_STRING_MAX: ::c_int = 12;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 13;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 14;
+pub const _SC_LINE_MAX: ::c_int = 15;
+pub const _SC_RE_DUP_MAX: ::c_int = 16;
+pub const _SC_2_VERSION: ::c_int = 17;
+pub const _SC_2_C_BIND: ::c_int = 18;
+pub const _SC_2_C_DEV: ::c_int = 19;
+pub const _SC_2_CHAR_TERM: ::c_int = 20;
+pub const _SC_2_FORT_DEV: ::c_int = 21;
+pub const _SC_2_FORT_RUN: ::c_int = 22;
+pub const _SC_2_LOCALEDEF: ::c_int = 23;
+pub const _SC_2_SW_DEV: ::c_int = 24;
+pub const _SC_2_UPE: ::c_int = 25;
+pub const _SC_STREAM_MAX: ::c_int = 26;
+pub const _SC_TZNAME_MAX: ::c_int = 27;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 28;
+pub const _SC_MAPPED_FILES: ::c_int = 29;
+pub const _SC_MEMLOCK: ::c_int = 30;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 31;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 32;
+pub const _SC_MESSAGE_PASSING: ::c_int = 33;
+pub const _SC_PRIORITIZED_IO: ::c_int = 34;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 35;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 36;
+pub const _SC_SEMAPHORES: ::c_int = 37;
+pub const _SC_FSYNC: ::c_int = 38;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 39;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 40;
+pub const _SC_TIMERS: ::c_int = 41;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 42;
+pub const _SC_AIO_MAX: ::c_int = 43;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 44;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 45;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 46;
+pub const _SC_PAGESIZE: ::c_int = 47;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_RTSIG_MAX: ::c_int = 48;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 49;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 50;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 51;
+pub const _SC_TIMER_MAX: ::c_int = 52;
+pub const _SC_IOV_MAX: ::c_int = 56;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 57;
+pub const _SC_2_PBS: ::c_int = 59;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 60;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 61;
+pub const _SC_2_PBS_LOCATE: ::c_int = 62;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 63;
+pub const _SC_2_PBS_TRACK: ::c_int = 64;
+pub const _SC_ADVISORY_INFO: ::c_int = 65;
+pub const _SC_BARRIERS: ::c_int = 66;
+pub const _SC_CLOCK_SELECTION: ::c_int = 67;
+pub const _SC_CPUTIME: ::c_int = 68;
+pub const _SC_FILE_LOCKING: ::c_int = 69;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 58;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 70;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 71;
+pub const _SC_HOST_NAME_MAX: ::c_int = 72;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 73;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 74;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 75;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 76;
+pub const _SC_REGEXP: ::c_int = 77;
+pub const _SC_SHELL: ::c_int = 78;
+pub const _SC_SPAWN: ::c_int = 79;
+pub const _SC_SPIN_LOCKS: ::c_int = 80;
+pub const _SC_SPORADIC_SERVER: ::c_int = 81;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 82;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 83;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 85;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 86;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 87;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 88;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 89;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 90;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 91;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 92;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 93;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 94;
+pub const _SC_TIMEOUTS: ::c_int = 95;
+pub const _SC_THREADS: ::c_int = 96;
+pub const _SC_TRACE: ::c_int = 97;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 98;
+pub const _SC_TRACE_INHERIT: ::c_int = 99;
+pub const _SC_TRACE_LOG: ::c_int = 100;
+pub const _SC_TTY_NAME_MAX: ::c_int = 101;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 102;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 103;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 104;
+pub const _SC_V6_LP64_OFF64: ::c_int = 105;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 106;
+pub const _SC_ATEXIT_MAX: ::c_int = 107;
+pub const _SC_XOPEN_CRYPT: ::c_int = 108;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 109;
+pub const _SC_XOPEN_LEGACY: ::c_int = 110;
+pub const _SC_XOPEN_REALTIME: ::c_int = 111;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 112;
+pub const _SC_XOPEN_SHM: ::c_int = 113;
+pub const _SC_XOPEN_STREAMS: ::c_int = 114;
+pub const _SC_XOPEN_UNIX: ::c_int = 115;
+pub const _SC_XOPEN_VERSION: ::c_int = 116;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 117;
+pub const _SC_IPV6: ::c_int = 118;
+pub const _SC_RAW_SOCKETS: ::c_int = 119;
+pub const _SC_SYMLOOP_MAX: ::c_int = 120;
+pub const _SC_PHYS_PAGES: ::c_int = 121;
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = 0 as *mut _;
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = 0 as *mut _;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 3;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_ERRORCHECK;
+
+pub const SCHED_FIFO: ::c_int = 1;
+pub const SCHED_OTHER: ::c_int = 2;
+pub const SCHED_RR: ::c_int = 3;
+
+pub const FD_SETSIZE: usize = 1024;
+
+pub const ST_NOSUID: ::c_ulong = 2;
+
+pub const NI_MAXHOST: ::size_t = 1025;
+
+pub const RTLD_LOCAL: ::c_int = 0;
+pub const RTLD_NODELETE: ::c_int = 0x1000;
+pub const RTLD_NOLOAD: ::c_int = 0x2000;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+
+pub const LOG_NTP: ::c_int = 12 << 3;
+pub const LOG_SECURITY: ::c_int = 13 << 3;
+pub const LOG_CONSOLE: ::c_int = 14 << 3;
+pub const LOG_NFACILITIES: ::c_int = 24;
+
+pub const TIOCEXCL: ::c_uint = 0x2000740d;
+pub const TIOCNXCL: ::c_uint = 0x2000740e;
+pub const TIOCFLUSH: ::c_ulong = 0x80047410;
+pub const TIOCGETA: ::c_uint = 0x402c7413;
+pub const TIOCSETA: ::c_ulong = 0x802c7414;
+pub const TIOCSETAW: ::c_ulong = 0x802c7415;
+pub const TIOCSETAF: ::c_ulong = 0x802c7416;
+pub const TIOCGETD: ::c_uint = 0x4004741a;
+pub const TIOCSETD: ::c_ulong = 0x8004741b;
+pub const TIOCGDRAINWAIT: ::c_uint = 0x40047456;
+pub const TIOCSDRAINWAIT: ::c_ulong = 0x80047457;
+pub const TIOCTIMESTAMP: ::c_uint = 0x40107459;
+pub const TIOCMGDTRWAIT: ::c_uint = 0x4004745a;
+pub const TIOCMSDTRWAIT: ::c_ulong = 0x8004745b;
+pub const TIOCDRAIN: ::c_uint = 0x2000745e;
+pub const TIOCEXT: ::c_ulong = 0x80047460;
+pub const TIOCSCTTY: ::c_uint = 0x20007461;
+pub const TIOCCONS: ::c_ulong = 0x80047462;
+pub const TIOCGSID: ::c_uint = 0x40047463;
+pub const TIOCSTAT: ::c_uint = 0x20007465;
+pub const TIOCUCNTL: ::c_ulong = 0x80047466;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const TIOCGWINSZ: ::c_uint = 0x40087468;
+pub const TIOCMGET: ::c_uint = 0x4004746a;
+pub const TIOCM_LE: ::c_int = 0x1;
+pub const TIOCM_DTR: ::c_int = 0x2;
+pub const TIOCM_RTS: ::c_int = 0x4;
+pub const TIOCM_ST: ::c_int = 0x8;
+pub const TIOCM_SR: ::c_int = 0x10;
+pub const TIOCM_CTS: ::c_int = 0x20;
+pub const TIOCM_RI: ::c_int = 0x80;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = 0x40;
+pub const TIOCM_CAR: ::c_int = 0x40;
+pub const TIOCM_RNG: ::c_int = 0x80;
+pub const TIOCMBIC: ::c_ulong = 0x8004746b;
+pub const TIOCMBIS: ::c_ulong = 0x8004746c;
+pub const TIOCMSET: ::c_ulong = 0x8004746d;
+pub const TIOCSTART: ::c_uint = 0x2000746e;
+pub const TIOCSTOP: ::c_uint = 0x2000746f;
+pub const TIOCPKT: ::c_ulong = 0x80047470;
+pub const TIOCPKT_DATA: ::c_int = 0x0;
+pub const TIOCPKT_FLUSHREAD: ::c_int = 0x1;
+pub const TIOCPKT_FLUSHWRITE: ::c_int = 0x2;
+pub const TIOCPKT_STOP: ::c_int = 0x4;
+pub const TIOCPKT_START: ::c_int = 0x8;
+pub const TIOCPKT_NOSTOP: ::c_int = 0x10;
+pub const TIOCPKT_DOSTOP: ::c_int = 0x20;
+pub const TIOCPKT_IOCTL: ::c_int = 0x40;
+pub const TIOCNOTTY: ::c_uint = 0x20007471;
+pub const TIOCSTI: ::c_ulong = 0x80017472;
+pub const TIOCOUTQ: ::c_uint = 0x40047473;
+pub const TIOCSPGRP: ::c_ulong = 0x80047476;
+pub const TIOCGPGRP: ::c_uint = 0x40047477;
+pub const TIOCCDTR: ::c_uint = 0x20007478;
+pub const TIOCSDTR: ::c_uint = 0x20007479;
+pub const TTYDISC: ::c_int = 0x0;
+pub const SLIPDISC: ::c_int = 0x4;
+pub const PPPDISC: ::c_int = 0x5;
+pub const NETGRAPHDISC: ::c_int = 0x6;
+
+pub const BIOCGRSIG: ::c_ulong = 0x40044272;
+pub const BIOCSRSIG: ::c_ulong = 0x80044273;
+pub const BIOCSDLT: ::c_ulong = 0x80044278;
+pub const BIOCGSEESENT: ::c_ulong = 0x40044276;
+pub const BIOCSSEESENT: ::c_ulong = 0x80044277;
+pub const BIOCSETF: ::c_ulong = 0x80104267;
+pub const BIOCGDLTLIST: ::c_ulong = 0xc0104279;
+pub const BIOCSRTIMEOUT: ::c_ulong = 0x8010426d;
+pub const BIOCGRTIMEOUT: ::c_ulong = 0x4010426e;
+
+pub const FIODTYPE: ::c_ulong = 0x4004667a;
+pub const FIOGETLBA: ::c_ulong = 0x40046679;
+pub const FIODGNAME: ::c_ulong = 0x80106678;
+
+pub const B0: speed_t = 0;
+pub const B50: speed_t = 50;
+pub const B75: speed_t = 75;
+pub const B110: speed_t = 110;
+pub const B134: speed_t = 134;
+pub const B150: speed_t = 150;
+pub const B200: speed_t = 200;
+pub const B300: speed_t = 300;
+pub const B600: speed_t = 600;
+pub const B1200: speed_t = 1200;
+pub const B1800: speed_t = 1800;
+pub const B2400: speed_t = 2400;
+pub const B4800: speed_t = 4800;
+pub const B9600: speed_t = 9600;
+pub const B19200: speed_t = 19200;
+pub const B38400: speed_t = 38400;
+pub const B7200: speed_t = 7200;
+pub const B14400: speed_t = 14400;
+pub const B28800: speed_t = 28800;
+pub const B57600: speed_t = 57600;
+pub const B76800: speed_t = 76800;
+pub const B115200: speed_t = 115200;
+pub const B230400: speed_t = 230400;
+pub const EXTA: speed_t = 19200;
+pub const EXTB: speed_t = 38400;
+
+pub const SEM_FAILED: *mut sem_t = 0 as *mut sem_t;
+
+pub const CRTSCTS: ::tcflag_t = 0x00030000;
+pub const CCTS_OFLOW: ::tcflag_t = 0x00010000;
+pub const CRTS_IFLOW: ::tcflag_t = 0x00020000;
+pub const CDTR_IFLOW: ::tcflag_t = 0x00040000;
+pub const CDSR_OFLOW: ::tcflag_t = 0x00080000;
+pub const CCAR_OFLOW: ::tcflag_t = 0x00100000;
+pub const VERASE2: usize = 7;
+pub const OCRNL: ::tcflag_t = 0x10;
+pub const ONOCR: ::tcflag_t = 0x20;
+pub const ONLRET: ::tcflag_t = 0x40;
+
+pub const CMGROUP_MAX: usize = 16;
+
+// https://github.com/freebsd/freebsd/blob/master/sys/net/bpf.h
+// sizeof(long)
+pub const BPF_ALIGNMENT: ::c_int = 8;
+
+// Values for rtprio struct (prio field) and syscall (function argument)
+pub const RTP_PRIO_MIN: ::c_ushort = 0;
+pub const RTP_PRIO_MAX: ::c_ushort = 31;
+pub const RTP_LOOKUP: ::c_int = 0;
+pub const RTP_SET: ::c_int = 1;
+
+// Flags for chflags(2)
+pub const UF_SETTABLE: ::c_ulong = 0x0000ffff;
+pub const UF_NODUMP: ::c_ulong = 0x00000001;
+pub const UF_IMMUTABLE: ::c_ulong = 0x00000002;
+pub const UF_APPEND: ::c_ulong = 0x00000004;
+pub const UF_OPAQUE: ::c_ulong = 0x00000008;
+pub const UF_NOUNLINK: ::c_ulong = 0x00000010;
+pub const SF_SETTABLE: ::c_ulong = 0xffff0000;
+pub const SF_ARCHIVED: ::c_ulong = 0x00010000;
+pub const SF_IMMUTABLE: ::c_ulong = 0x00020000;
+pub const SF_APPEND: ::c_ulong = 0x00040000;
+pub const SF_NOUNLINK: ::c_ulong = 0x00100000;
+
+pub const TIMER_ABSTIME: ::c_int = 1;
+
+//<sys/timex.h>
+pub const NTP_API: ::c_int = 4;
+pub const MAXPHASE: ::c_long = 500000000;
+pub const MAXFREQ: ::c_long = 500000;
+pub const MINSEC: ::c_int = 256;
+pub const MAXSEC: ::c_int = 2048;
+pub const NANOSECOND: ::c_long = 1000000000;
+pub const SCALE_PPM: ::c_int = 65;
+pub const MAXTC: ::c_int = 10;
+pub const MOD_OFFSET: ::c_uint = 0x0001;
+pub const MOD_FREQUENCY: ::c_uint = 0x0002;
+pub const MOD_MAXERROR: ::c_uint = 0x0004;
+pub const MOD_ESTERROR: ::c_uint = 0x0008;
+pub const MOD_STATUS: ::c_uint = 0x0010;
+pub const MOD_TIMECONST: ::c_uint = 0x0020;
+pub const MOD_PPSMAX: ::c_uint = 0x0040;
+pub const MOD_TAI: ::c_uint = 0x0080;
+pub const MOD_MICRO: ::c_uint = 0x1000;
+pub const MOD_NANO: ::c_uint = 0x2000;
+pub const MOD_CLKB: ::c_uint = 0x4000;
+pub const MOD_CLKA: ::c_uint = 0x8000;
+pub const STA_PLL: ::c_int = 0x0001;
+pub const STA_PPSFREQ: ::c_int = 0x0002;
+pub const STA_PPSTIME: ::c_int = 0x0004;
+pub const STA_FLL: ::c_int = 0x0008;
+pub const STA_INS: ::c_int = 0x0010;
+pub const STA_DEL: ::c_int = 0x0020;
+pub const STA_UNSYNC: ::c_int = 0x0040;
+pub const STA_FREQHOLD: ::c_int = 0x0080;
+pub const STA_PPSSIGNAL: ::c_int = 0x0100;
+pub const STA_PPSJITTER: ::c_int = 0x0200;
+pub const STA_PPSWANDER: ::c_int = 0x0400;
+pub const STA_PPSERROR: ::c_int = 0x0800;
+pub const STA_CLOCKERR: ::c_int = 0x1000;
+pub const STA_NANO: ::c_int = 0x2000;
+pub const STA_MODE: ::c_int = 0x4000;
+pub const STA_CLK: ::c_int = 0x8000;
+pub const STA_RONLY: ::c_int = STA_PPSSIGNAL
+    | STA_PPSJITTER
+    | STA_PPSWANDER
+    | STA_PPSERROR
+    | STA_CLOCKERR
+    | STA_NANO
+    | STA_MODE
+    | STA_CLK;
+pub const TIME_OK: ::c_int = 0;
+pub const TIME_INS: ::c_int = 1;
+pub const TIME_DEL: ::c_int = 2;
+pub const TIME_OOP: ::c_int = 3;
+pub const TIME_WAIT: ::c_int = 4;
+pub const TIME_ERROR: ::c_int = 5;
+
+pub const REG_ENOSYS: ::c_int = -1;
+pub const REG_ILLSEQ: ::c_int = 17;
+
+safe_f! {
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        status == 0x13
+    }
+
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        status >> 8
+    }
+
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        (status & 0o177) == 0o177
+    }
+}
+
+extern "C" {
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;
+    pub fn accept4(
+        s: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn chflags(path: *const ::c_char, flags: ::c_ulong) -> ::c_int;
+    pub fn chflagsat(
+        fd: ::c_int,
+        path: *const ::c_char,
+        flags: ::c_ulong,
+        atflag: ::c_int,
+    ) -> ::c_int;
+
+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_settime(
+        clk_id: ::clockid_t,
+        tp: *const ::timespec,
+    ) -> ::c_int;
+    pub fn clock_getcpuclockid(
+        pid: ::pid_t,
+        clk_id: *mut ::clockid_t,
+    ) -> ::c_int;
+
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+    pub fn duplocale(base: ::locale_t) -> ::locale_t;
+    pub fn endutxent();
+    pub fn fchflags(fd: ::c_int, flags: ::c_ulong) -> ::c_int;
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn getdomainname(name: *mut ::c_char, len: ::c_int) -> ::c_int;
+    pub fn getgrent_r(
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn getpwent_r(
+        pwd: *mut ::passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::passwd,
+    ) -> ::c_int;
+    pub fn getgrouplist(
+        name: *const ::c_char,
+        basegid: ::gid_t,
+        groups: *mut ::gid_t,
+        ngroups: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::size_t,
+        serv: *mut ::c_char,
+        servlen: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn getpriority(which: ::c_int, who: ::c_int) -> ::c_int;
+    pub fn getutxent() -> *mut utmpx;
+    pub fn getutxid(ut: *const utmpx) -> *mut utmpx;
+    pub fn getutxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn initgroups(name: *const ::c_char, basegid: ::gid_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "kevent@FBSD_1.0"
+    )]
+    pub fn kevent(
+        kq: ::c_int,
+        changelist: *const ::kevent,
+        nchanges: ::c_int,
+        eventlist: *mut ::kevent,
+        nevents: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn lchflags(path: *const ::c_char, flags: ::c_ulong) -> ::c_int;
+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;
+    pub fn memrchr(
+        cx: *const ::c_void,
+        c: ::c_int,
+        n: ::size_t,
+    ) -> *mut ::c_void;
+    pub fn mkfifoat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "mknodat@FBSD_1.1"
+    )]
+    pub fn mknodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: dev_t,
+    ) -> ::c_int;
+    pub fn mincore(
+        addr: *const ::c_void,
+        len: ::size_t,
+        vec: *mut ::c_char,
+    ) -> ::c_int;
+    pub fn newlocale(
+        mask: ::c_int,
+        locale: *const ::c_char,
+        base: ::locale_t,
+    ) -> ::locale_t;
+    pub fn nl_langinfo_l(item: ::nl_item, locale: ::locale_t)
+        -> *mut ::c_char;
+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn ppoll(
+        fds: *mut ::pollfd,
+        nfds: ::nfds_t,
+        timeout: *const ::timespec,
+        sigmask: *const sigset_t,
+    ) -> ::c_int;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn pthread_attr_get_np(
+        tid: ::pthread_t,
+        attr: *mut ::pthread_attr_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const ::pthread_attr_t,
+        guardsize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstack(
+        attr: *const ::pthread_attr_t,
+        stackaddr: *mut *mut ::c_void,
+        stacksize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getclock(
+        attr: *const pthread_condattr_t,
+        clock_id: *mut clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getpshared(
+        attr: *const pthread_condattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setclock(
+        attr: *mut pthread_condattr_t,
+        clock_id: ::clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setpshared(
+        attr: *mut pthread_condattr_t,
+        pshared: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_main_np() -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_getpshared(
+        attr: *const pthread_mutexattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_setpshared(
+        attr: *mut pthread_mutexattr_t,
+        pshared: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_getpshared(
+        attr: *const pthread_rwlockattr_t,
+        val: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_setpshared(
+        attr: *mut pthread_rwlockattr_t,
+        val: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_set_name_np(tid: ::pthread_t, name: *const ::c_char);
+    pub fn ptrace(
+        request: ::c_int,
+        pid: ::pid_t,
+        addr: *mut ::c_char,
+        data: ::c_int,
+    ) -> ::c_int;
+    pub fn pututxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn querylocale(mask: ::c_int, loc: ::locale_t) -> *const ::c_char;
+    pub fn rtprio(
+        function: ::c_int,
+        pid: ::pid_t,
+        rtp: *mut rtprio,
+    ) -> ::c_int;
+    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;
+    pub fn sched_setscheduler(
+        pid: ::pid_t,
+        policy: ::c_int,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;
+    pub fn sem_timedwait(
+        sem: *mut sem_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sendfile(
+        fd: ::c_int,
+        s: ::c_int,
+        offset: ::off_t,
+        nbytes: ::size_t,
+        hdtr: *mut ::sf_hdtr,
+        sbytes: *mut ::off_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn setdomainname(name: *const ::c_char, len: ::c_int) -> ::c_int;
+    pub fn sethostname(name: *const ::c_char, len: ::c_int) -> ::c_int;
+    pub fn setpriority(which: ::c_int, who: ::c_int, prio: ::c_int)
+        -> ::c_int;
+    pub fn setresgid(rgid: ::gid_t, egid: ::gid_t, sgid: ::gid_t) -> ::c_int;
+    pub fn setresuid(ruid: ::uid_t, euid: ::uid_t, suid: ::uid_t) -> ::c_int;
+    pub fn settimeofday(
+        tv: *const ::timeval,
+        tz: *const ::timezone,
+    ) -> ::c_int;
+    pub fn setutxent();
+    pub fn shm_open(
+        name: *const ::c_char,
+        oflag: ::c_int,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn sigtimedwait(
+        set: *const sigset_t,
+        info: *mut siginfo_t,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> ::c_int;
+    pub fn sysctl(
+        name: *const ::c_int,
+        namelen: ::c_uint,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *const ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    pub fn sysctlbyname(
+        name: *const ::c_char,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *const ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    pub fn sysctlnametomib(
+        name: *const ::c_char,
+        mibp: *mut ::c_int,
+        sizep: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;
+    pub fn utimensat(
+        dirfd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+
+    pub fn ntp_adjtime(buf: *mut timex) -> ::c_int;
+    pub fn ntp_gettime(buf: *mut ntptimeval) -> ::c_int;
+
+    // #include <link.h>
+    pub fn dl_iterate_phdr(
+        callback: ::Option<
+            unsafe extern "C" fn(
+                info: *mut dl_phdr_info,
+                size: usize,
+                data: *mut ::c_void,
+            ) -> ::c_int,
+        >,
+        data: *mut ::c_void,
+    ) -> ::c_int;
+}
+
+#[link(name = "rt")]
+extern "C" {
+    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;
+    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;
+    pub fn mq_notify(mqd: ::mqd_t, notification: *const ::sigevent)
+        -> ::c_int;
+    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;
+    pub fn mq_receive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mq_send(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+    ) -> ::c_int;
+    pub fn mq_setattr(
+        mqd: ::mqd_t,
+        newattr: *const ::mq_attr,
+        oldattr: *mut ::mq_attr,
+    ) -> ::c_int;
+    pub fn mq_timedreceive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::ssize_t;
+    pub fn mq_timedsend(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;
+}
+
+#[link(name = "util")]
+extern "C" {
+    pub fn openpty(
+        amaster: *mut ::c_int,
+        aslave: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::c_int;
+    pub fn forkpty(
+        amaster: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::pid_t;
+    pub fn login_tty(fd: ::c_int) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_os = "freebsd")] {
+        mod freebsd;
+        pub use self::freebsd::*;
+    } else if #[cfg(target_os = "dragonfly")] {
+        mod dragonfly;
+        pub use self::dragonfly::*;
+    } else {
+        // ...
+    }
+}
diff --git a/library/libc/src/unix/bsd/mod.rs b/library/libc/src/unix/bsd/mod.rs
new file mode 100644
index 00000000..725f5cbf
--- /dev/null
+++ b/library/libc/src/unix/bsd/mod.rs
@@ -0,0 +1,920 @@
+pub type off_t = i64;
+pub type useconds_t = u32;
+pub type blkcnt_t = i64;
+pub type socklen_t = u32;
+pub type sa_family_t = u8;
+pub type pthread_t = ::uintptr_t;
+pub type nfds_t = ::c_uint;
+pub type regoff_t = off_t;
+
+s! {
+    pub struct sockaddr {
+        pub sa_len: u8,
+        pub sa_family: sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_len: u8,
+        pub sin6_family: sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_change: ::time_t,
+        pub pw_class: *mut ::c_char,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+        pub pw_expire: ::time_t,
+
+        #[cfg(not(any(target_os = "macos",
+                      target_os = "ios",
+                      target_os = "netbsd",
+                      target_os = "openbsd")))]
+        pub pw_fields: ::c_int,
+    }
+
+    pub struct ifaddrs {
+        pub ifa_next: *mut ifaddrs,
+        pub ifa_name: *mut ::c_char,
+        pub ifa_flags: ::c_uint,
+        pub ifa_addr: *mut ::sockaddr,
+        pub ifa_netmask: *mut ::sockaddr,
+        pub ifa_dstaddr: *mut ::sockaddr,
+        pub ifa_data: *mut ::c_void,
+        #[cfg(target_os = "netbsd")]
+        pub ifa_addrflags: ::c_uint
+    }
+
+    pub struct fd_set {
+        #[cfg(all(target_pointer_width = "64",
+                  any(target_os = "freebsd", target_os = "dragonfly")))]
+        fds_bits: [i64; FD_SETSIZE / 64],
+        #[cfg(not(all(target_pointer_width = "64",
+                      any(target_os = "freebsd", target_os = "dragonfly"))))]
+        fds_bits: [i32; FD_SETSIZE / 32],
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+        pub tm_gmtoff: ::c_long,
+        pub tm_zone: *mut ::c_char,
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::socklen_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct fsid_t {
+        __fsid_val: [i32; 2],
+    }
+
+    pub struct if_nameindex {
+        pub if_index: ::c_uint,
+        pub if_name: *mut ::c_char,
+    }
+
+    pub struct regex_t {
+        __re_magic: ::c_int,
+        __re_nsub: ::size_t,
+        __re_endp: *const ::c_char,
+        __re_g: *mut ::c_void,
+    }
+
+    pub struct regmatch_t {
+        pub rm_so: regoff_t,
+        pub rm_eo: regoff_t,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct sockaddr_un {
+        pub sun_len: u8,
+        pub sun_family: sa_family_t,
+        pub sun_path: [c_char; 104]
+    }
+
+    pub struct utsname {
+        #[cfg(not(target_os = "dragonfly"))]
+        pub sysname: [::c_char; 256],
+        #[cfg(target_os = "dragonfly")]
+        pub sysname: [::c_char; 32],
+        #[cfg(not(target_os = "dragonfly"))]
+        pub nodename: [::c_char; 256],
+        #[cfg(target_os = "dragonfly")]
+        pub nodename: [::c_char; 32],
+        #[cfg(not(target_os = "dragonfly"))]
+        pub release: [::c_char; 256],
+        #[cfg(target_os = "dragonfly")]
+        pub release: [::c_char; 32],
+        #[cfg(not(target_os = "dragonfly"))]
+        pub version: [::c_char; 256],
+        #[cfg(target_os = "dragonfly")]
+        pub version: [::c_char; 32],
+        #[cfg(not(target_os = "dragonfly"))]
+        pub machine: [::c_char; 256],
+        #[cfg(target_os = "dragonfly")]
+        pub machine: [::c_char; 32],
+    }
+
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for sockaddr_un {
+            fn eq(&self, other: &sockaddr_un) -> bool {
+                self.sun_len == other.sun_len
+                    && self.sun_family == other.sun_family
+                    && self
+                    .sun_path
+                    .iter()
+                    .zip(other.sun_path.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for sockaddr_un {}
+
+        impl ::fmt::Debug for sockaddr_un {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_un")
+                    .field("sun_len", &self.sun_len)
+                    .field("sun_family", &self.sun_family)
+                // FIXME: .field("sun_path", &self.sun_path)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sockaddr_un {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sun_len.hash(state);
+                self.sun_family.hash(state);
+                self.sun_path.hash(state);
+            }
+        }
+
+        impl PartialEq for utsname {
+            fn eq(&self, other: &utsname) -> bool {
+                self.sysname
+                    .iter()
+                    .zip(other.sysname.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .nodename
+                    .iter()
+                    .zip(other.nodename.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .release
+                    .iter()
+                    .zip(other.release.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .version
+                    .iter()
+                    .zip(other.version.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .machine
+                    .iter()
+                    .zip(other.machine.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for utsname {}
+
+        impl ::fmt::Debug for utsname {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utsname")
+                // FIXME: .field("sysname", &self.sysname)
+                // FIXME: .field("nodename", &self.nodename)
+                // FIXME: .field("release", &self.release)
+                // FIXME: .field("version", &self.version)
+                // FIXME: .field("machine", &self.machine)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utsname {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sysname.hash(state);
+                self.nodename.hash(state);
+                self.release.hash(state);
+                self.version.hash(state);
+                self.machine.hash(state);
+            }
+        }
+    }
+}
+
+pub const LC_ALL: ::c_int = 0;
+pub const LC_COLLATE: ::c_int = 1;
+pub const LC_CTYPE: ::c_int = 2;
+pub const LC_MONETARY: ::c_int = 3;
+pub const LC_NUMERIC: ::c_int = 4;
+pub const LC_TIME: ::c_int = 5;
+pub const LC_MESSAGES: ::c_int = 6;
+
+pub const FIOCLEX: ::c_ulong = 0x20006601;
+pub const FIONCLEX: ::c_ulong = 0x20006602;
+pub const FIONREAD: ::c_ulong = 0x4004667f;
+pub const FIONBIO: ::c_ulong = 0x8004667e;
+pub const FIOASYNC: ::c_ulong = 0x8004667d;
+pub const FIOSETOWN: ::c_ulong = 0x8004667c;
+pub const FIOGETOWN: ::c_ulong = 0x4004667b;
+
+pub const PATH_MAX: ::c_int = 1024;
+
+pub const IOV_MAX: ::c_int = 1024;
+
+pub const SA_ONSTACK: ::c_int = 0x0001;
+pub const SA_SIGINFO: ::c_int = 0x0040;
+pub const SA_RESTART: ::c_int = 0x0002;
+pub const SA_RESETHAND: ::c_int = 0x0004;
+pub const SA_NOCLDSTOP: ::c_int = 0x0008;
+pub const SA_NODEFER: ::c_int = 0x0010;
+pub const SA_NOCLDWAIT: ::c_int = 0x0020;
+
+pub const SS_ONSTACK: ::c_int = 1;
+pub const SS_DISABLE: ::c_int = 4;
+
+pub const SIGCHLD: ::c_int = 20;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGUSR1: ::c_int = 30;
+pub const SIGUSR2: ::c_int = 31;
+pub const SIGCONT: ::c_int = 19;
+pub const SIGSTOP: ::c_int = 17;
+pub const SIGTSTP: ::c_int = 18;
+pub const SIGURG: ::c_int = 16;
+pub const SIGIO: ::c_int = 23;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGINFO: ::c_int = 29;
+
+pub const SIG_SETMASK: ::c_int = 3;
+pub const SIG_BLOCK: ::c_int = 0x1;
+pub const SIG_UNBLOCK: ::c_int = 0x2;
+
+pub const IP_TOS: ::c_int = 3;
+pub const IP_MULTICAST_IF: ::c_int = 9;
+pub const IP_MULTICAST_TTL: ::c_int = 10;
+pub const IP_MULTICAST_LOOP: ::c_int = 11;
+
+pub const IPV6_UNICAST_HOPS: ::c_int = 4;
+pub const IPV6_MULTICAST_IF: ::c_int = 9;
+pub const IPV6_MULTICAST_HOPS: ::c_int = 10;
+pub const IPV6_MULTICAST_LOOP: ::c_int = 11;
+pub const IPV6_V6ONLY: ::c_int = 27;
+
+pub const IPTOS_ECN_NOTECT: u8 = 0x00;
+pub const IPTOS_ECN_MASK: u8 = 0x03;
+pub const IPTOS_ECN_ECT1: u8 = 0x01;
+pub const IPTOS_ECN_ECT0: u8 = 0x02;
+pub const IPTOS_ECN_CE: u8 = 0x03;
+
+pub const ST_RDONLY: ::c_ulong = 1;
+
+pub const SCM_RIGHTS: ::c_int = 0x01;
+
+pub const NCCS: usize = 20;
+
+pub const O_ACCMODE: ::c_int = 0x3;
+pub const O_RDONLY: ::c_int = 0;
+pub const O_WRONLY: ::c_int = 1;
+pub const O_RDWR: ::c_int = 2;
+pub const O_APPEND: ::c_int = 8;
+pub const O_CREAT: ::c_int = 512;
+pub const O_TRUNC: ::c_int = 1024;
+pub const O_EXCL: ::c_int = 2048;
+pub const O_ASYNC: ::c_int = 0x40;
+pub const O_SYNC: ::c_int = 0x80;
+pub const O_NONBLOCK: ::c_int = 0x4;
+pub const O_NOFOLLOW: ::c_int = 0x100;
+pub const O_SHLOCK: ::c_int = 0x10;
+pub const O_EXLOCK: ::c_int = 0x20;
+pub const O_FSYNC: ::c_int = O_SYNC;
+pub const O_NDELAY: ::c_int = O_NONBLOCK;
+
+pub const F_GETOWN: ::c_int = 5;
+pub const F_SETOWN: ::c_int = 6;
+
+pub const F_RDLCK: ::c_short = 1;
+pub const F_UNLCK: ::c_short = 2;
+pub const F_WRLCK: ::c_short = 3;
+
+pub const MNT_FORCE: ::c_int = 0x80000;
+
+pub const Q_SYNC: ::c_int = 0x600;
+pub const Q_QUOTAON: ::c_int = 0x100;
+pub const Q_QUOTAOFF: ::c_int = 0x200;
+
+pub const TCIOFF: ::c_int = 3;
+pub const TCION: ::c_int = 4;
+pub const TCOOFF: ::c_int = 1;
+pub const TCOON: ::c_int = 2;
+pub const TCIFLUSH: ::c_int = 1;
+pub const TCOFLUSH: ::c_int = 2;
+pub const TCIOFLUSH: ::c_int = 3;
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+pub const VEOF: usize = 0;
+pub const VEOL: usize = 1;
+pub const VEOL2: usize = 2;
+pub const VERASE: usize = 3;
+pub const VWERASE: usize = 4;
+pub const VKILL: usize = 5;
+pub const VREPRINT: usize = 6;
+pub const VINTR: usize = 8;
+pub const VQUIT: usize = 9;
+pub const VSUSP: usize = 10;
+pub const VDSUSP: usize = 11;
+pub const VSTART: usize = 12;
+pub const VSTOP: usize = 13;
+pub const VLNEXT: usize = 14;
+pub const VDISCARD: usize = 15;
+pub const VMIN: usize = 16;
+pub const VTIME: usize = 17;
+pub const VSTATUS: usize = 18;
+pub const _POSIX_VDISABLE: ::cc_t = 0xff;
+pub const IGNBRK: ::tcflag_t = 0x00000001;
+pub const BRKINT: ::tcflag_t = 0x00000002;
+pub const IGNPAR: ::tcflag_t = 0x00000004;
+pub const PARMRK: ::tcflag_t = 0x00000008;
+pub const INPCK: ::tcflag_t = 0x00000010;
+pub const ISTRIP: ::tcflag_t = 0x00000020;
+pub const INLCR: ::tcflag_t = 0x00000040;
+pub const IGNCR: ::tcflag_t = 0x00000080;
+pub const ICRNL: ::tcflag_t = 0x00000100;
+pub const IXON: ::tcflag_t = 0x00000200;
+pub const IXOFF: ::tcflag_t = 0x00000400;
+pub const IXANY: ::tcflag_t = 0x00000800;
+pub const IMAXBEL: ::tcflag_t = 0x00002000;
+pub const OPOST: ::tcflag_t = 0x1;
+pub const ONLCR: ::tcflag_t = 0x2;
+pub const OXTABS: ::tcflag_t = 0x4;
+pub const ONOEOT: ::tcflag_t = 0x8;
+pub const CIGNORE: ::tcflag_t = 0x00000001;
+pub const CSIZE: ::tcflag_t = 0x00000300;
+pub const CS5: ::tcflag_t = 0x00000000;
+pub const CS6: ::tcflag_t = 0x00000100;
+pub const CS7: ::tcflag_t = 0x00000200;
+pub const CS8: ::tcflag_t = 0x00000300;
+pub const CSTOPB: ::tcflag_t = 0x00000400;
+pub const CREAD: ::tcflag_t = 0x00000800;
+pub const PARENB: ::tcflag_t = 0x00001000;
+pub const PARODD: ::tcflag_t = 0x00002000;
+pub const HUPCL: ::tcflag_t = 0x00004000;
+pub const CLOCAL: ::tcflag_t = 0x00008000;
+pub const ECHOKE: ::tcflag_t = 0x00000001;
+pub const ECHOE: ::tcflag_t = 0x00000002;
+pub const ECHOK: ::tcflag_t = 0x00000004;
+pub const ECHO: ::tcflag_t = 0x00000008;
+pub const ECHONL: ::tcflag_t = 0x00000010;
+pub const ECHOPRT: ::tcflag_t = 0x00000020;
+pub const ECHOCTL: ::tcflag_t = 0x00000040;
+pub const ISIG: ::tcflag_t = 0x00000080;
+pub const ICANON: ::tcflag_t = 0x00000100;
+pub const ALTWERASE: ::tcflag_t = 0x00000200;
+pub const IEXTEN: ::tcflag_t = 0x00000400;
+pub const EXTPROC: ::tcflag_t = 0x00000800;
+pub const TOSTOP: ::tcflag_t = 0x00400000;
+pub const FLUSHO: ::tcflag_t = 0x00800000;
+pub const NOKERNINFO: ::tcflag_t = 0x02000000;
+pub const PENDIN: ::tcflag_t = 0x20000000;
+pub const NOFLSH: ::tcflag_t = 0x80000000;
+pub const MDMBUF: ::tcflag_t = 0x00100000;
+
+pub const WNOHANG: ::c_int = 0x00000001;
+pub const WUNTRACED: ::c_int = 0x00000002;
+
+pub const RTLD_LAZY: ::c_int = 0x1;
+pub const RTLD_NOW: ::c_int = 0x2;
+pub const RTLD_NEXT: *mut ::c_void = -1isize as *mut ::c_void;
+pub const RTLD_DEFAULT: *mut ::c_void = -2isize as *mut ::c_void;
+pub const RTLD_SELF: *mut ::c_void = -3isize as *mut ::c_void;
+
+pub const LOG_CRON: ::c_int = 9 << 3;
+pub const LOG_AUTHPRIV: ::c_int = 10 << 3;
+pub const LOG_FTP: ::c_int = 11 << 3;
+pub const LOG_PERROR: ::c_int = 0x20;
+
+pub const TCP_NODELAY: ::c_int = 1;
+pub const TCP_MAXSEG: ::c_int = 2;
+
+pub const PIPE_BUF: usize = 512;
+
+pub const CLD_EXITED: ::c_int = 1;
+pub const CLD_KILLED: ::c_int = 2;
+pub const CLD_DUMPED: ::c_int = 3;
+pub const CLD_TRAPPED: ::c_int = 4;
+pub const CLD_STOPPED: ::c_int = 5;
+pub const CLD_CONTINUED: ::c_int = 6;
+
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLPRI: ::c_short = 0x2;
+pub const POLLOUT: ::c_short = 0x4;
+pub const POLLERR: ::c_short = 0x8;
+pub const POLLHUP: ::c_short = 0x10;
+pub const POLLNVAL: ::c_short = 0x20;
+pub const POLLRDNORM: ::c_short = 0x040;
+pub const POLLWRNORM: ::c_short = 0x004;
+pub const POLLRDBAND: ::c_short = 0x080;
+pub const POLLWRBAND: ::c_short = 0x100;
+
+pub const BIOCGBLEN: ::c_ulong = 0x40044266;
+pub const BIOCSBLEN: ::c_ulong = 0xc0044266;
+pub const BIOCFLUSH: ::c_uint = 0x20004268;
+pub const BIOCPROMISC: ::c_uint = 0x20004269;
+pub const BIOCGDLT: ::c_ulong = 0x4004426a;
+pub const BIOCGETIF: ::c_ulong = 0x4020426b;
+pub const BIOCSETIF: ::c_ulong = 0x8020426c;
+pub const BIOCGSTATS: ::c_ulong = 0x4008426f;
+pub const BIOCIMMEDIATE: ::c_ulong = 0x80044270;
+pub const BIOCVERSION: ::c_ulong = 0x40044271;
+pub const BIOCGHDRCMPLT: ::c_ulong = 0x40044274;
+pub const BIOCSHDRCMPLT: ::c_ulong = 0x80044275;
+pub const SIOCGIFADDR: ::c_ulong = 0xc0206921;
+
+pub const REG_BASIC: ::c_int = 0o0000;
+pub const REG_EXTENDED: ::c_int = 0o0001;
+pub const REG_ICASE: ::c_int = 0o0002;
+pub const REG_NOSUB: ::c_int = 0o0004;
+pub const REG_NEWLINE: ::c_int = 0o0010;
+pub const REG_NOSPEC: ::c_int = 0o0020;
+pub const REG_PEND: ::c_int = 0o0040;
+pub const REG_DUMP: ::c_int = 0o0200;
+
+pub const REG_NOMATCH: ::c_int = 1;
+pub const REG_BADPAT: ::c_int = 2;
+pub const REG_ECOLLATE: ::c_int = 3;
+pub const REG_ECTYPE: ::c_int = 4;
+pub const REG_EESCAPE: ::c_int = 5;
+pub const REG_ESUBREG: ::c_int = 6;
+pub const REG_EBRACK: ::c_int = 7;
+pub const REG_EPAREN: ::c_int = 8;
+pub const REG_EBRACE: ::c_int = 9;
+pub const REG_BADBR: ::c_int = 10;
+pub const REG_ERANGE: ::c_int = 11;
+pub const REG_ESPACE: ::c_int = 12;
+pub const REG_BADRPT: ::c_int = 13;
+pub const REG_EMPTY: ::c_int = 14;
+pub const REG_ASSERT: ::c_int = 15;
+pub const REG_INVARG: ::c_int = 16;
+pub const REG_ATOI: ::c_int = 255;
+pub const REG_ITOA: ::c_int = 0o0400;
+
+pub const REG_NOTBOL: ::c_int = 0o00001;
+pub const REG_NOTEOL: ::c_int = 0o00002;
+pub const REG_STARTEND: ::c_int = 0o00004;
+pub const REG_TRACE: ::c_int = 0o00400;
+pub const REG_LARGE: ::c_int = 0o01000;
+pub const REG_BACKR: ::c_int = 0o02000;
+
+pub const TIOCCBRK: ::c_uint = 0x2000747a;
+pub const TIOCSBRK: ::c_uint = 0x2000747b;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+pub const ITIMER_REAL: ::c_int = 0;
+pub const ITIMER_VIRTUAL: ::c_int = 1;
+pub const ITIMER_PROF: ::c_int = 2;
+
+f! {
+    pub fn CMSG_FIRSTHDR(mhdr: *const ::msghdr) -> *mut ::cmsghdr {
+        if (*mhdr).msg_controllen as usize >= ::mem::size_of::<::cmsghdr>() {
+            (*mhdr).msg_control as *mut ::cmsghdr
+        } else {
+            0 as *mut ::cmsghdr
+        }
+    }
+
+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        (*set).fds_bits[fd / bits] &= !(1 << (fd % bits));
+        return
+    }
+
+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        return ((*set).fds_bits[fd / bits] & (1 << (fd % bits))) != 0
+    }
+
+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        (*set).fds_bits[fd / bits] |= 1 << (fd % bits);
+        return
+    }
+
+    pub fn FD_ZERO(set: *mut fd_set) -> () {
+        for slot in (*set).fds_bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+}
+
+safe_f! {
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        status & 0o177
+    }
+
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & 0o177) == 0
+    }
+
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        status >> 8
+    }
+
+    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {
+        (status & 0o200) != 0
+    }
+
+    pub {const} fn QCMD(cmd: ::c_int, type_: ::c_int) -> ::c_int {
+        (cmd << 8) | (type_ & 0x00ff)
+    }
+}
+
+extern "C" {
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "getrlimit$UNIX2003"
+    )]
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "setrlimit$UNIX2003"
+    )]
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+    pub fn abs(i: ::c_int) -> ::c_int;
+    pub fn atof(s: *const ::c_char) -> ::c_double;
+    pub fn labs(i: ::c_long) -> ::c_long;
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd12, freebsd11, freebsd10)),
+        link_name = "rand@FBSD_1.0"
+    )]
+    pub fn rand() -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd12, freebsd11, freebsd10)),
+        link_name = "srand@FBSD_1.0"
+    )]
+    pub fn srand(seed: ::c_uint);
+
+    pub fn getifaddrs(ifap: *mut *mut ::ifaddrs) -> ::c_int;
+    pub fn freeifaddrs(ifa: *mut ::ifaddrs);
+    pub fn setgroups(ngroups: ::c_int, ptr: *const ::gid_t) -> ::c_int;
+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;
+    pub fn kqueue() -> ::c_int;
+    pub fn unmount(target: *const ::c_char, arg: ::c_int) -> ::c_int;
+    pub fn syscall(num: ::c_int, ...) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__getpwent50")]
+    pub fn getpwent() -> *mut passwd;
+    pub fn setpwent();
+    pub fn endpwent();
+    pub fn endgrent();
+    pub fn getgrent() -> *mut ::group;
+
+    pub fn getprogname() -> *const ::c_char;
+    pub fn setprogname(name: *const ::c_char);
+    pub fn getloadavg(loadavg: *mut ::c_double, nelem: ::c_int) -> ::c_int;
+    pub fn if_nameindex() -> *mut if_nameindex;
+    pub fn if_freenameindex(ptr: *mut if_nameindex);
+
+    pub fn getpeereid(
+        socket: ::c_int,
+        euid: *mut ::uid_t,
+        egid: *mut ::gid_t,
+    ) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", not(target_arch = "aarch64")),
+        link_name = "glob$INODE64"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__glob30")]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "glob@FBSD_1.0"
+    )]
+    pub fn glob(
+        pattern: *const ::c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut ::glob_t,
+    ) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__globfree30")]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "globfree@FBSD_1.0"
+    )]
+    pub fn globfree(pglob: *mut ::glob_t);
+
+    pub fn posix_madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86_64"),
+        link_name = "seekdir$INODE64"
+    )]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "seekdir$INODE64$UNIX2003"
+    )]
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86_64"),
+        link_name = "telldir$INODE64"
+    )]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "telldir$INODE64$UNIX2003"
+    )]
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+    pub fn madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "msync$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__msync13")]
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "recvfrom$UNIX2003"
+    )]
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__futimes50")]
+    pub fn futimes(fd: ::c_int, times: *const ::timeval) -> ::c_int;
+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "bind$UNIX2003"
+    )]
+    pub fn bind(
+        socket: ::c_int,
+        address: *const ::sockaddr,
+        address_len: ::socklen_t,
+    ) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "writev$UNIX2003"
+    )]
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "readv$UNIX2003"
+    )]
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "sendmsg$UNIX2003"
+    )]
+    pub fn sendmsg(
+        fd: ::c_int,
+        msg: *const ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "recvmsg$UNIX2003"
+    )]
+    pub fn recvmsg(
+        fd: ::c_int,
+        msg: *mut ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+
+    pub fn sync();
+    pub fn getgrgid_r(
+        gid: ::gid_t,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "sigaltstack$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigaltstack14")]
+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;
+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;
+    pub fn getdtablesize() -> ::c_int;
+    pub fn getgrnam_r(
+        name: *const ::c_char,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_sigmask$UNIX2003"
+    )]
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;
+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_cancel$UNIX2003"
+    )]
+    pub fn pthread_cancel(thread: ::pthread_t) -> ::c_int;
+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;
+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__getpwnam_r50")]
+    pub fn getpwnam_r(
+        name: *const ::c_char,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__getpwuid_r50")]
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "sigwait$UNIX2003"
+    )]
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "popen$UNIX2003"
+    )]
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+    pub fn faccessat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_create(
+        native: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        f: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn acct(filename: *const ::c_char) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "wait4$UNIX2003"
+    )]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd12, freebsd11, freebsd10)),
+        link_name = "wait4@FBSD_1.0"
+    )]
+    pub fn wait4(
+        pid: ::pid_t,
+        status: *mut ::c_int,
+        options: ::c_int,
+        rusage: *mut ::rusage,
+    ) -> ::pid_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "getitimer$UNIX2003"
+    )]
+    pub fn getitimer(which: ::c_int, curr_value: *mut ::itimerval) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "setitimer$UNIX2003"
+    )]
+    pub fn setitimer(
+        which: ::c_int,
+        new_value: *const ::itimerval,
+        old_value: *mut ::itimerval,
+    ) -> ::c_int;
+
+    pub fn regcomp(
+        preg: *mut regex_t,
+        pattern: *const ::c_char,
+        cflags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn regexec(
+        preg: *const regex_t,
+        input: *const ::c_char,
+        nmatch: ::size_t,
+        pmatch: *mut regmatch_t,
+        eflags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn regerror(
+        errcode: ::c_int,
+        preg: *const regex_t,
+        errbuf: *mut ::c_char,
+        errbuf_size: ::size_t,
+    ) -> ::size_t;
+
+    pub fn regfree(preg: *mut regex_t);
+}
+
+cfg_if! {
+    if #[cfg(any(target_os = "macos", target_os = "ios"))] {
+        mod apple;
+        pub use self::apple::*;
+    } else if #[cfg(any(target_os = "openbsd", target_os = "netbsd"))] {
+        mod netbsdlike;
+        pub use self::netbsdlike::*;
+    } else if #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))] {
+        mod freebsdlike;
+        pub use self::freebsdlike::*;
+    } else {
+        // Unknown target_os
+    }
+}
diff --git a/library/libc/src/unix/bsd/netbsdlike/mod.rs b/library/libc/src/unix/bsd/netbsdlike/mod.rs
new file mode 100644
index 00000000..720f10be
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/mod.rs
@@ -0,0 +1,785 @@
+pub type wchar_t = i32;
+pub type time_t = i64;
+pub type mode_t = u32;
+pub type nlink_t = u32;
+pub type ino_t = u64;
+pub type pthread_key_t = ::c_int;
+pub type rlim_t = u64;
+pub type speed_t = ::c_uint;
+pub type tcflag_t = ::c_uint;
+pub type nl_item = c_long;
+pub type clockid_t = ::c_int;
+pub type id_t = u32;
+pub type sem_t = *mut sem;
+pub type key_t = c_long;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum sem {}
+impl ::Copy for sem {}
+impl ::Clone for sem {
+    fn clone(&self) -> sem {
+        *self
+    }
+}
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct in6_pktinfo {
+        pub ipi6_addr: ::in6_addr,
+        pub ipi6_ifindex: ::c_uint,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        pub c_ispeed: ::c_int,
+        pub c_ospeed: ::c_int,
+    }
+
+    pub struct flock {
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+    }
+
+    pub struct ipc_perm {
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub mode: ::mode_t,
+        pub seq: ::c_ushort,
+        pub key: ::key_t,
+    }
+
+    pub struct ptrace_io_desc {
+        pub piod_op: ::c_int,
+        pub piod_offs: *mut ::c_void,
+        pub piod_addr: *mut ::c_void,
+        pub piod_len: ::size_t,
+    }
+}
+
+pub const D_T_FMT: ::nl_item = 0;
+pub const D_FMT: ::nl_item = 1;
+pub const T_FMT: ::nl_item = 2;
+pub const T_FMT_AMPM: ::nl_item = 3;
+pub const AM_STR: ::nl_item = 4;
+pub const PM_STR: ::nl_item = 5;
+
+pub const DAY_1: ::nl_item = 6;
+pub const DAY_2: ::nl_item = 7;
+pub const DAY_3: ::nl_item = 8;
+pub const DAY_4: ::nl_item = 9;
+pub const DAY_5: ::nl_item = 10;
+pub const DAY_6: ::nl_item = 11;
+pub const DAY_7: ::nl_item = 12;
+
+pub const ABDAY_1: ::nl_item = 13;
+pub const ABDAY_2: ::nl_item = 14;
+pub const ABDAY_3: ::nl_item = 15;
+pub const ABDAY_4: ::nl_item = 16;
+pub const ABDAY_5: ::nl_item = 17;
+pub const ABDAY_6: ::nl_item = 18;
+pub const ABDAY_7: ::nl_item = 19;
+
+pub const MON_1: ::nl_item = 20;
+pub const MON_2: ::nl_item = 21;
+pub const MON_3: ::nl_item = 22;
+pub const MON_4: ::nl_item = 23;
+pub const MON_5: ::nl_item = 24;
+pub const MON_6: ::nl_item = 25;
+pub const MON_7: ::nl_item = 26;
+pub const MON_8: ::nl_item = 27;
+pub const MON_9: ::nl_item = 28;
+pub const MON_10: ::nl_item = 29;
+pub const MON_11: ::nl_item = 30;
+pub const MON_12: ::nl_item = 31;
+
+pub const ABMON_1: ::nl_item = 32;
+pub const ABMON_2: ::nl_item = 33;
+pub const ABMON_3: ::nl_item = 34;
+pub const ABMON_4: ::nl_item = 35;
+pub const ABMON_5: ::nl_item = 36;
+pub const ABMON_6: ::nl_item = 37;
+pub const ABMON_7: ::nl_item = 38;
+pub const ABMON_8: ::nl_item = 39;
+pub const ABMON_9: ::nl_item = 40;
+pub const ABMON_10: ::nl_item = 41;
+pub const ABMON_11: ::nl_item = 42;
+pub const ABMON_12: ::nl_item = 43;
+
+pub const RADIXCHAR: ::nl_item = 44;
+pub const THOUSEP: ::nl_item = 45;
+pub const YESSTR: ::nl_item = 46;
+pub const YESEXPR: ::nl_item = 47;
+pub const NOSTR: ::nl_item = 48;
+pub const NOEXPR: ::nl_item = 49;
+pub const CRNCYSTR: ::nl_item = 50;
+
+pub const CODESET: ::nl_item = 51;
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const RAND_MAX: ::c_int = 2147483647;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 2;
+pub const _IOLBF: ::c_int = 1;
+pub const BUFSIZ: ::c_uint = 1024;
+pub const FOPEN_MAX: ::c_uint = 20;
+pub const FILENAME_MAX: ::c_uint = 1024;
+pub const L_tmpnam: ::c_uint = 1024;
+pub const O_NOCTTY: ::c_int = 32768;
+pub const S_IFIFO: mode_t = 4096;
+pub const S_IFCHR: mode_t = 8192;
+pub const S_IFBLK: mode_t = 24576;
+pub const S_IFDIR: mode_t = 16384;
+pub const S_IFREG: mode_t = 32768;
+pub const S_IFLNK: mode_t = 40960;
+pub const S_IFSOCK: mode_t = 49152;
+pub const S_IFMT: mode_t = 61440;
+pub const S_IEXEC: mode_t = 64;
+pub const S_IWRITE: mode_t = 128;
+pub const S_IREAD: mode_t = 256;
+pub const S_IRWXU: mode_t = 448;
+pub const S_IXUSR: mode_t = 64;
+pub const S_IWUSR: mode_t = 128;
+pub const S_IRUSR: mode_t = 256;
+pub const S_IRWXG: mode_t = 56;
+pub const S_IXGRP: mode_t = 8;
+pub const S_IWGRP: mode_t = 16;
+pub const S_IRGRP: mode_t = 32;
+pub const S_IRWXO: mode_t = 7;
+pub const S_IXOTH: mode_t = 1;
+pub const S_IWOTH: mode_t = 2;
+pub const S_IROTH: mode_t = 4;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+pub const F_GETLK: ::c_int = 7;
+pub const F_SETLK: ::c_int = 8;
+pub const F_SETLKW: ::c_int = 9;
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGEMT: ::c_int = 7;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+
+pub const PROT_NONE: ::c_int = 0;
+pub const PROT_READ: ::c_int = 1;
+pub const PROT_WRITE: ::c_int = 2;
+pub const PROT_EXEC: ::c_int = 4;
+
+pub const MAP_FILE: ::c_int = 0x0000;
+pub const MAP_SHARED: ::c_int = 0x0001;
+pub const MAP_PRIVATE: ::c_int = 0x0002;
+pub const MAP_FIXED: ::c_int = 0x0010;
+pub const MAP_ANON: ::c_int = 0x1000;
+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;
+
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+pub const IPC_CREAT: ::c_int = 0o001000;
+pub const IPC_EXCL: ::c_int = 0o002000;
+pub const IPC_NOWAIT: ::c_int = 0o004000;
+
+pub const IPC_PRIVATE: ::key_t = 0;
+
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const MS_ASYNC: ::c_int = 0x0001;
+
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EDEADLK: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EAGAIN: ::c_int = 35;
+pub const EWOULDBLOCK: ::c_int = 35;
+pub const EINPROGRESS: ::c_int = 36;
+pub const EALREADY: ::c_int = 37;
+pub const ENOTSOCK: ::c_int = 38;
+pub const EDESTADDRREQ: ::c_int = 39;
+pub const EMSGSIZE: ::c_int = 40;
+pub const EPROTOTYPE: ::c_int = 41;
+pub const ENOPROTOOPT: ::c_int = 42;
+pub const EPROTONOSUPPORT: ::c_int = 43;
+pub const ESOCKTNOSUPPORT: ::c_int = 44;
+pub const EOPNOTSUPP: ::c_int = 45;
+pub const EPFNOSUPPORT: ::c_int = 46;
+pub const EAFNOSUPPORT: ::c_int = 47;
+pub const EADDRINUSE: ::c_int = 48;
+pub const EADDRNOTAVAIL: ::c_int = 49;
+pub const ENETDOWN: ::c_int = 50;
+pub const ENETUNREACH: ::c_int = 51;
+pub const ENETRESET: ::c_int = 52;
+pub const ECONNABORTED: ::c_int = 53;
+pub const ECONNRESET: ::c_int = 54;
+pub const ENOBUFS: ::c_int = 55;
+pub const EISCONN: ::c_int = 56;
+pub const ENOTCONN: ::c_int = 57;
+pub const ESHUTDOWN: ::c_int = 58;
+pub const ETOOMANYREFS: ::c_int = 59;
+pub const ETIMEDOUT: ::c_int = 60;
+pub const ECONNREFUSED: ::c_int = 61;
+pub const ELOOP: ::c_int = 62;
+pub const ENAMETOOLONG: ::c_int = 63;
+pub const EHOSTDOWN: ::c_int = 64;
+pub const EHOSTUNREACH: ::c_int = 65;
+pub const ENOTEMPTY: ::c_int = 66;
+pub const EPROCLIM: ::c_int = 67;
+pub const EUSERS: ::c_int = 68;
+pub const EDQUOT: ::c_int = 69;
+pub const ESTALE: ::c_int = 70;
+pub const EREMOTE: ::c_int = 71;
+pub const EBADRPC: ::c_int = 72;
+pub const ERPCMISMATCH: ::c_int = 73;
+pub const EPROGUNAVAIL: ::c_int = 74;
+pub const EPROGMISMATCH: ::c_int = 75;
+pub const EPROCUNAVAIL: ::c_int = 76;
+pub const ENOLCK: ::c_int = 77;
+pub const ENOSYS: ::c_int = 78;
+pub const EFTYPE: ::c_int = 79;
+pub const EAUTH: ::c_int = 80;
+pub const ENEEDAUTH: ::c_int = 81;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+
+pub const SIGTRAP: ::c_int = 5;
+
+pub const GLOB_APPEND: ::c_int = 0x0001;
+pub const GLOB_DOOFFS: ::c_int = 0x0002;
+pub const GLOB_ERR: ::c_int = 0x0004;
+pub const GLOB_MARK: ::c_int = 0x0008;
+pub const GLOB_NOCHECK: ::c_int = 0x0010;
+pub const GLOB_NOSORT: ::c_int = 0x0020;
+pub const GLOB_NOESCAPE: ::c_int = 0x1000;
+
+pub const GLOB_NOSPACE: ::c_int = -1;
+pub const GLOB_ABORTED: ::c_int = -2;
+pub const GLOB_NOMATCH: ::c_int = -3;
+pub const GLOB_NOSYS: ::c_int = -4;
+
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+
+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;
+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;
+
+pub const PIOD_READ_D: ::c_int = 1;
+pub const PIOD_WRITE_D: ::c_int = 2;
+pub const PIOD_READ_I: ::c_int = 3;
+pub const PIOD_WRITE_I: ::c_int = 4;
+pub const PIOD_READ_AUXV: ::c_int = 5;
+
+pub const PT_TRACE_ME: ::c_int = 0;
+pub const PT_READ_I: ::c_int = 1;
+pub const PT_READ_D: ::c_int = 2;
+pub const PT_WRITE_I: ::c_int = 4;
+pub const PT_WRITE_D: ::c_int = 5;
+pub const PT_CONTINUE: ::c_int = 7;
+pub const PT_KILL: ::c_int = 8;
+pub const PT_ATTACH: ::c_int = 9;
+pub const PT_DETACH: ::c_int = 10;
+pub const PT_IO: ::c_int = 11;
+
+// http://man.openbsd.org/OpenBSD-current/man2/clock_getres.2
+// The man page says clock_gettime(3) can accept various values as clockid_t but
+// http://fxr.watson.org/fxr/source/kern/kern_time.c?v=OPENBSD;im=excerpts#L161
+// the implementation rejects anything other than the below two
+//
+// http://netbsd.gw.com/cgi-bin/man-cgi?clock_gettime
+// https://github.com/jsonn/src/blob/HEAD/sys/kern/subr_time.c#L222
+// Basically the same goes for NetBSD
+pub const CLOCK_REALTIME: ::clockid_t = 0;
+pub const CLOCK_MONOTONIC: ::clockid_t = 3;
+
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_MEMLOCK: ::c_int = 6;
+pub const RLIMIT_NPROC: ::c_int = 7;
+pub const RLIMIT_NOFILE: ::c_int = 8;
+
+pub const RLIM_INFINITY: rlim_t = 0x7fff_ffff_ffff_ffff;
+pub const RLIM_SAVED_MAX: rlim_t = RLIM_INFINITY;
+pub const RLIM_SAVED_CUR: rlim_t = RLIM_INFINITY;
+
+pub const RUSAGE_SELF: ::c_int = 0;
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const MADV_NORMAL: ::c_int = 0;
+pub const MADV_RANDOM: ::c_int = 1;
+pub const MADV_SEQUENTIAL: ::c_int = 2;
+pub const MADV_WILLNEED: ::c_int = 3;
+pub const MADV_DONTNEED: ::c_int = 4;
+pub const MADV_FREE: ::c_int = 6;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_LOCAL: ::c_int = 1;
+pub const AF_UNIX: ::c_int = AF_LOCAL;
+pub const AF_INET: ::c_int = 2;
+pub const AF_IMPLINK: ::c_int = 3;
+pub const AF_PUP: ::c_int = 4;
+pub const AF_CHAOS: ::c_int = 5;
+pub const AF_NS: ::c_int = 6;
+pub const AF_ISO: ::c_int = 7;
+pub const AF_OSI: ::c_int = AF_ISO;
+pub const AF_DATAKIT: ::c_int = 9;
+pub const AF_CCITT: ::c_int = 10;
+pub const AF_SNA: ::c_int = 11;
+pub const AF_DECnet: ::c_int = 12;
+pub const AF_DLI: ::c_int = 13;
+pub const AF_LAT: ::c_int = 14;
+pub const AF_HYLINK: ::c_int = 15;
+pub const AF_APPLETALK: ::c_int = 16;
+pub const AF_LINK: ::c_int = 18;
+pub const pseudo_AF_XTP: ::c_int = 19;
+pub const AF_COIP: ::c_int = 20;
+pub const AF_CNT: ::c_int = 21;
+pub const pseudo_AF_RTIP: ::c_int = 22;
+pub const AF_IPX: ::c_int = 23;
+pub const AF_INET6: ::c_int = 24;
+pub const pseudo_AF_PIP: ::c_int = 25;
+pub const AF_ISDN: ::c_int = 26;
+pub const AF_E164: ::c_int = AF_ISDN;
+pub const AF_NATM: ::c_int = 27;
+
+pub const PF_UNSPEC: ::c_int = AF_UNSPEC;
+pub const PF_LOCAL: ::c_int = AF_LOCAL;
+pub const PF_UNIX: ::c_int = PF_LOCAL;
+pub const PF_INET: ::c_int = AF_INET;
+pub const PF_IMPLINK: ::c_int = AF_IMPLINK;
+pub const PF_PUP: ::c_int = AF_PUP;
+pub const PF_CHAOS: ::c_int = AF_CHAOS;
+pub const PF_NS: ::c_int = AF_NS;
+pub const PF_ISO: ::c_int = AF_ISO;
+pub const PF_OSI: ::c_int = AF_ISO;
+pub const PF_DATAKIT: ::c_int = AF_DATAKIT;
+pub const PF_CCITT: ::c_int = AF_CCITT;
+pub const PF_SNA: ::c_int = AF_SNA;
+pub const PF_DECnet: ::c_int = AF_DECnet;
+pub const PF_DLI: ::c_int = AF_DLI;
+pub const PF_LAT: ::c_int = AF_LAT;
+pub const PF_HYLINK: ::c_int = AF_HYLINK;
+pub const PF_APPLETALK: ::c_int = AF_APPLETALK;
+pub const PF_LINK: ::c_int = AF_LINK;
+pub const PF_XTP: ::c_int = pseudo_AF_XTP;
+pub const PF_COIP: ::c_int = AF_COIP;
+pub const PF_CNT: ::c_int = AF_CNT;
+pub const PF_IPX: ::c_int = AF_IPX;
+pub const PF_INET6: ::c_int = AF_INET6;
+pub const PF_RTIP: ::c_int = pseudo_AF_RTIP;
+pub const PF_PIP: ::c_int = pseudo_AF_PIP;
+pub const PF_ISDN: ::c_int = AF_ISDN;
+pub const PF_NATM: ::c_int = AF_NATM;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_RAW: ::c_int = 3;
+pub const SOCK_RDM: ::c_int = 4;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const IP_TTL: ::c_int = 4;
+pub const IP_HDRINCL: ::c_int = 2;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;
+pub const IPV6_RECVPKTINFO: ::c_int = 36;
+pub const IPV6_PKTINFO: ::c_int = 46;
+pub const IPV6_RECVTCLASS: ::c_int = 57;
+pub const IPV6_TCLASS: ::c_int = 61;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+pub const SO_DEBUG: ::c_int = 0x01;
+pub const SO_ACCEPTCONN: ::c_int = 0x0002;
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_USELOOPBACK: ::c_int = 0x0040;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_TYPE: ::c_int = 0x1008;
+
+pub const SOMAXCONN: ::c_int = 128;
+
+pub const MSG_OOB: ::c_int = 0x1;
+pub const MSG_PEEK: ::c_int = 0x2;
+pub const MSG_DONTROUTE: ::c_int = 0x4;
+pub const MSG_EOR: ::c_int = 0x8;
+pub const MSG_TRUNC: ::c_int = 0x10;
+pub const MSG_CTRUNC: ::c_int = 0x20;
+pub const MSG_WAITALL: ::c_int = 0x40;
+pub const MSG_DONTWAIT: ::c_int = 0x80;
+pub const MSG_BCAST: ::c_int = 0x100;
+pub const MSG_MCAST: ::c_int = 0x200;
+pub const MSG_NOSIGNAL: ::c_int = 0x400;
+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x800;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const LOCK_SH: ::c_int = 1;
+pub const LOCK_EX: ::c_int = 2;
+pub const LOCK_NB: ::c_int = 4;
+pub const LOCK_UN: ::c_int = 8;
+
+pub const IPPROTO_RAW: ::c_int = 255;
+
+pub const _SC_ARG_MAX: ::c_int = 1;
+pub const _SC_CHILD_MAX: ::c_int = 2;
+pub const _SC_NGROUPS_MAX: ::c_int = 4;
+pub const _SC_OPEN_MAX: ::c_int = 5;
+pub const _SC_JOB_CONTROL: ::c_int = 6;
+pub const _SC_SAVED_IDS: ::c_int = 7;
+pub const _SC_VERSION: ::c_int = 8;
+pub const _SC_BC_BASE_MAX: ::c_int = 9;
+pub const _SC_BC_DIM_MAX: ::c_int = 10;
+pub const _SC_BC_SCALE_MAX: ::c_int = 11;
+pub const _SC_BC_STRING_MAX: ::c_int = 12;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 13;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 14;
+pub const _SC_LINE_MAX: ::c_int = 15;
+pub const _SC_RE_DUP_MAX: ::c_int = 16;
+pub const _SC_2_VERSION: ::c_int = 17;
+pub const _SC_2_C_BIND: ::c_int = 18;
+pub const _SC_2_C_DEV: ::c_int = 19;
+pub const _SC_2_CHAR_TERM: ::c_int = 20;
+pub const _SC_2_FORT_DEV: ::c_int = 21;
+pub const _SC_2_FORT_RUN: ::c_int = 22;
+pub const _SC_2_LOCALEDEF: ::c_int = 23;
+pub const _SC_2_SW_DEV: ::c_int = 24;
+pub const _SC_2_UPE: ::c_int = 25;
+pub const _SC_STREAM_MAX: ::c_int = 26;
+pub const _SC_TZNAME_MAX: ::c_int = 27;
+pub const _SC_PAGESIZE: ::c_int = 28;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_FSYNC: ::c_int = 29;
+pub const _SC_XOPEN_SHM: ::c_int = 30;
+
+pub const Q_GETQUOTA: ::c_int = 0x300;
+pub const Q_SETQUOTA: ::c_int = 0x400;
+
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+
+pub const LOG_NFACILITIES: ::c_int = 24;
+
+pub const HW_NCPU: ::c_int = 3;
+
+pub const B0: speed_t = 0;
+pub const B50: speed_t = 50;
+pub const B75: speed_t = 75;
+pub const B110: speed_t = 110;
+pub const B134: speed_t = 134;
+pub const B150: speed_t = 150;
+pub const B200: speed_t = 200;
+pub const B300: speed_t = 300;
+pub const B600: speed_t = 600;
+pub const B1200: speed_t = 1200;
+pub const B1800: speed_t = 1800;
+pub const B2400: speed_t = 2400;
+pub const B4800: speed_t = 4800;
+pub const B9600: speed_t = 9600;
+pub const B19200: speed_t = 19200;
+pub const B38400: speed_t = 38400;
+pub const B7200: speed_t = 7200;
+pub const B14400: speed_t = 14400;
+pub const B28800: speed_t = 28800;
+pub const B57600: speed_t = 57600;
+pub const B76800: speed_t = 76800;
+pub const B115200: speed_t = 115200;
+pub const B230400: speed_t = 230400;
+pub const EXTA: speed_t = 19200;
+pub const EXTB: speed_t = 38400;
+
+pub const SEM_FAILED: *mut sem_t = 0 as *mut sem_t;
+
+pub const CRTSCTS: ::tcflag_t = 0x00010000;
+pub const CRTS_IFLOW: ::tcflag_t = CRTSCTS;
+pub const CCTS_OFLOW: ::tcflag_t = CRTSCTS;
+pub const OCRNL: ::tcflag_t = 0x10;
+
+pub const TIOCEXCL: ::c_ulong = 0x2000740d;
+pub const TIOCNXCL: ::c_ulong = 0x2000740e;
+pub const TIOCFLUSH: ::c_ulong = 0x80047410;
+pub const TIOCGETA: ::c_ulong = 0x402c7413;
+pub const TIOCSETA: ::c_ulong = 0x802c7414;
+pub const TIOCSETAW: ::c_ulong = 0x802c7415;
+pub const TIOCSETAF: ::c_ulong = 0x802c7416;
+pub const TIOCGETD: ::c_ulong = 0x4004741a;
+pub const TIOCSETD: ::c_ulong = 0x8004741b;
+pub const TIOCMGET: ::c_ulong = 0x4004746a;
+pub const TIOCMBIC: ::c_ulong = 0x8004746b;
+pub const TIOCMBIS: ::c_ulong = 0x8004746c;
+pub const TIOCMSET: ::c_ulong = 0x8004746d;
+pub const TIOCSTART: ::c_ulong = 0x2000746e;
+pub const TIOCSTOP: ::c_ulong = 0x2000746f;
+pub const TIOCSCTTY: ::c_ulong = 0x20007461;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const TIOCM_LE: ::c_int = 0o0001;
+pub const TIOCM_DTR: ::c_int = 0o0002;
+pub const TIOCM_RTS: ::c_int = 0o0004;
+pub const TIOCM_ST: ::c_int = 0o0010;
+pub const TIOCM_SR: ::c_int = 0o0020;
+pub const TIOCM_CTS: ::c_int = 0o0040;
+pub const TIOCM_CAR: ::c_int = 0o0100;
+pub const TIOCM_RNG: ::c_int = 0o0200;
+pub const TIOCM_DSR: ::c_int = 0o0400;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+// Flags for chflags(2)
+pub const UF_SETTABLE: ::c_ulong = 0x0000ffff;
+pub const UF_NODUMP: ::c_ulong = 0x00000001;
+pub const UF_IMMUTABLE: ::c_ulong = 0x00000002;
+pub const UF_APPEND: ::c_ulong = 0x00000004;
+pub const UF_OPAQUE: ::c_ulong = 0x00000008;
+pub const SF_SETTABLE: ::c_ulong = 0xffff0000;
+pub const SF_ARCHIVED: ::c_ulong = 0x00010000;
+pub const SF_IMMUTABLE: ::c_ulong = 0x00020000;
+pub const SF_APPEND: ::c_ulong = 0x00040000;
+
+pub const TIMER_ABSTIME: ::c_int = 1;
+
+#[link(name = "util")]
+extern "C" {
+    pub fn setgrent();
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    pub fn accept4(
+        s: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn mincore(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        vec: *mut ::c_char,
+    ) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__clock_getres50")]
+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__clock_gettime50")]
+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__clock_settime50")]
+    pub fn clock_settime(
+        clk_id: ::clockid_t,
+        tp: *const ::timespec,
+    ) -> ::c_int;
+    pub fn __errno() -> *mut ::c_int;
+    pub fn shm_open(
+        name: *const ::c_char,
+        oflag: ::c_int,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn memrchr(
+        cx: *const ::c_void,
+        c: ::c_int,
+        n: ::size_t,
+    ) -> *mut ::c_void;
+    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn mkostemps(
+        template: *mut ::c_char,
+        suffixlen: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn utimensat(
+        dirfd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+    pub fn openpty(
+        amaster: *mut ::c_int,
+        aslave: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::c_int;
+    pub fn forkpty(
+        amaster: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::pid_t;
+    pub fn login_tty(fd: ::c_int) -> ::c_int;
+    pub fn getpriority(which: ::c_int, who: ::id_t) -> ::c_int;
+    pub fn setpriority(which: ::c_int, who: ::id_t, prio: ::c_int) -> ::c_int;
+
+    pub fn mknodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: dev_t,
+    ) -> ::c_int;
+    pub fn mkfifoat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn sem_timedwait(
+        sem: *mut sem_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;
+    pub fn pthread_condattr_setclock(
+        attr: *mut pthread_condattr_t,
+        clock_id: ::clockid_t,
+    ) -> ::c_int;
+    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;
+
+    pub fn getgrouplist(
+        name: *const ::c_char,
+        basegid: ::gid_t,
+        groups: *mut ::gid_t,
+        ngroups: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn initgroups(name: *const ::c_char, basegid: ::gid_t) -> ::c_int;
+    pub fn getdomainname(name: *mut ::c_char, len: ::size_t) -> ::c_int;
+    pub fn setdomainname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+
+    pub fn shmget(key: ::key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;
+    pub fn shmat(
+        shmid: ::c_int,
+        shmaddr: *const ::c_void,
+        shmflg: ::c_int,
+    ) -> *mut ::c_void;
+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;
+    pub fn shmctl(
+        shmid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::shmid_ds,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_os = "netbsd")] {
+        mod netbsd;
+        pub use self::netbsd::*;
+    } else if #[cfg(target_os = "openbsd")] {
+        mod openbsd;
+        pub use self::openbsd::*;
+    } else {
+        // Unknown target_os
+    }
+}
diff --git a/library/libc/src/unix/bsd/netbsdlike/netbsd/aarch64.rs b/library/libc/src/unix/bsd/netbsdlike/netbsd/aarch64.rs
new file mode 100644
index 00000000..58c4cf7c
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/netbsd/aarch64.rs
@@ -0,0 +1,22 @@
+use PT_FIRSTMACH;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type c_char = u8;
+pub type __cpu_simple_lock_nv_t = ::c_uchar;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_int>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 4 - 1;
+    }
+}
+
+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 0;
+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 1;
+pub const PT_GETFPREGS: ::c_int = PT_FIRSTMACH + 2;
+pub const PT_SETFPREGS: ::c_int = PT_FIRSTMACH + 3;
diff --git a/library/libc/src/unix/bsd/netbsdlike/netbsd/arm.rs b/library/libc/src/unix/bsd/netbsdlike/netbsd/arm.rs
new file mode 100644
index 00000000..4bf3ccd0
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/netbsd/arm.rs
@@ -0,0 +1,22 @@
+use PT_FIRSTMACH;
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type c_char = u8;
+pub type __cpu_simple_lock_nv_t = ::c_int;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_longlong>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 8 - 1;
+    }
+}
+
+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 1;
+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 2;
+pub const PT_GETFPREGS: ::c_int = PT_FIRSTMACH + 3;
+pub const PT_SETFPREGS: ::c_int = PT_FIRSTMACH + 4;
diff --git a/library/libc/src/unix/bsd/netbsdlike/netbsd/mod.rs b/library/libc/src/unix/bsd/netbsdlike/netbsd/mod.rs
new file mode 100644
index 00000000..4b7dbafc
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/netbsd/mod.rs
@@ -0,0 +1,2152 @@
+pub type clock_t = ::c_uint;
+pub type suseconds_t = ::c_int;
+pub type dev_t = u64;
+pub type blksize_t = i32;
+pub type fsblkcnt_t = u64;
+pub type fsfilcnt_t = u64;
+pub type idtype_t = ::c_int;
+pub type mqd_t = ::c_int;
+type __pthread_spin_t = __cpu_simple_lock_nv_t;
+pub type vm_size_t = ::uintptr_t;
+pub type lwpid_t = ::c_uint;
+pub type shmatt_t = ::c_uint;
+
+// elf.h
+
+pub type Elf32_Addr = u32;
+pub type Elf32_Half = u16;
+pub type Elf32_Lword = u64;
+pub type Elf32_Off = u32;
+pub type Elf32_Sword = i32;
+pub type Elf32_Word = u32;
+
+pub type Elf64_Addr = u64;
+pub type Elf64_Half = u16;
+pub type Elf64_Lword = u64;
+pub type Elf64_Off = u64;
+pub type Elf64_Sword = i32;
+pub type Elf64_Sxword = i64;
+pub type Elf64_Word = u32;
+pub type Elf64_Xword = u64;
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "64")] {
+        type Elf_Addr = Elf64_Addr;
+        type Elf_Half = Elf64_Half;
+        type Elf_Phdr = Elf64_Phdr;
+    } else if #[cfg(target_pointer_width = "32")] {
+        type Elf_Addr = Elf32_Addr;
+        type Elf_Half = Elf32_Half;
+        type Elf_Phdr = Elf32_Phdr;
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_value(&self) -> ::sigval {
+        #[repr(C)]
+        struct siginfo_timer {
+            _si_signo: ::c_int,
+            _si_errno: ::c_int,
+            _si_code: ::c_int,
+            __pad1: ::c_int,
+            _pid: ::pid_t,
+            _uid: ::uid_t,
+            value: ::sigval,
+        }
+        (*(self as *const siginfo_t as *const siginfo_timer)).value
+    }
+}
+
+s! {
+    pub struct aiocb {
+        pub aio_offset: ::off_t,
+        pub aio_buf: *mut ::c_void,
+        pub aio_nbytes: ::size_t,
+        pub aio_fildes: ::c_int,
+        pub aio_lio_opcode: ::c_int,
+        pub aio_reqprio: ::c_int,
+        pub aio_sigevent: ::sigevent,
+        _state: ::c_int,
+        _errno: ::c_int,
+        _retval: ::ssize_t
+    }
+
+    pub struct glob_t {
+        pub gl_pathc:   ::size_t,
+        pub gl_matchc:  ::size_t,
+        pub gl_offs:    ::size_t,
+        pub gl_flags:   ::c_int,
+        pub gl_pathv:   *mut *mut ::c_char,
+
+        __unused3: *mut ::c_void,
+
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+        __unused6: *mut ::c_void,
+        __unused7: *mut ::c_void,
+        __unused8: *mut ::c_void,
+    }
+
+    pub struct mq_attr {
+        pub mq_flags: ::c_long,
+        pub mq_maxmsg: ::c_long,
+        pub mq_msgsize: ::c_long,
+        pub mq_curmsgs: ::c_long,
+    }
+
+    pub struct sigset_t {
+        __bits: [u32; 4],
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_mode: ::mode_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_atime: ::time_t,
+        pub st_atimensec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtimensec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctimensec: ::c_long,
+        pub st_birthtime: ::time_t,
+        pub st_birthtimensec: ::c_long,
+        pub st_size: ::off_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_blksize: ::blksize_t,
+        pub st_flags: u32,
+        pub st_gen: u32,
+        pub st_spare: [u32; 2],
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: ::socklen_t,
+        pub ai_canonname: *mut ::c_char,
+        pub ai_addr: *mut ::sockaddr,
+        pub ai_next: *mut ::addrinfo,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        __pad1: ::c_int,
+        pub si_addr: *mut ::c_void,
+        __pad2: [u64; 13],
+    }
+
+    pub struct pthread_attr_t {
+        pta_magic: ::c_uint,
+        pta_flags: ::c_int,
+        pta_private: *mut ::c_void,
+    }
+
+    pub struct pthread_mutex_t {
+        ptm_magic: ::c_uint,
+        ptm_errorcheck: __pthread_spin_t,
+        #[cfg(any(target_arch = "sparc", target_arch = "sparc64",
+                  target_arch = "x86", target_arch = "x86_64"))]
+        ptm_pad1: [u8; 3],
+        // actually a union with a non-unused, 0-initialized field
+        ptm_unused: __pthread_spin_t,
+        #[cfg(any(target_arch = "sparc", target_arch = "sparc64",
+                  target_arch = "x86", target_arch = "x86_64"))]
+        ptm_pad2: [u8; 3],
+        ptm_owner: ::pthread_t,
+        ptm_waiters: *mut u8,
+        ptm_recursed: ::c_uint,
+        ptm_spare2: *mut ::c_void,
+    }
+
+    pub struct pthread_mutexattr_t {
+        ptma_magic: ::c_uint,
+        ptma_private: *mut ::c_void,
+    }
+
+    pub struct pthread_rwlockattr_t {
+        ptra_magic: ::c_uint,
+        ptra_private: *mut ::c_void,
+    }
+
+    pub struct pthread_cond_t {
+        ptc_magic: ::c_uint,
+        ptc_lock: __pthread_spin_t,
+        ptc_waiters_first: *mut u8,
+        ptc_waiters_last: *mut u8,
+        ptc_mutex: *mut ::pthread_mutex_t,
+        ptc_private: *mut ::c_void,
+    }
+
+    pub struct pthread_condattr_t {
+        ptca_magic: ::c_uint,
+        ptca_private: *mut ::c_void,
+    }
+
+    pub struct pthread_rwlock_t {
+        ptr_magic: ::c_uint,
+        ptr_interlock: __pthread_spin_t,
+        ptr_rblocked_first: *mut u8,
+        ptr_rblocked_last: *mut u8,
+        ptr_wblocked_first: *mut u8,
+        ptr_wblocked_last: *mut u8,
+        ptr_nreaders: ::c_uint,
+        ptr_owner: ::pthread_t,
+        ptr_private: *mut ::c_void,
+    }
+
+    pub struct kevent {
+        pub ident: ::uintptr_t,
+        pub filter: u32,
+        pub flags: u32,
+        pub fflags: u32,
+        pub data: i64,
+        pub udata: ::intptr_t,
+    }
+
+    pub struct dqblk {
+        pub dqb_bhardlimit: u32,
+        pub dqb_bsoftlimit: u32,
+        pub dqb_curblocks: u32,
+        pub dqb_ihardlimit: u32,
+        pub dqb_isoftlimit: u32,
+        pub dqb_curinodes: u32,
+        pub dqb_btime: i32,
+        pub dqb_itime: i32,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *const ::c_void,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct if_data {
+        pub ifi_type: ::c_uchar,
+        pub ifi_addrlen: ::c_uchar,
+        pub ifi_hdrlen: ::c_uchar,
+        pub ifi_link_state: ::c_int,
+        pub ifi_mtu: u64,
+        pub ifi_metric: u64,
+        pub ifi_baudrate: u64,
+        pub ifi_ipackets: u64,
+        pub ifi_ierrors: u64,
+        pub ifi_opackets: u64,
+        pub ifi_oerrors: u64,
+        pub ifi_collisions: u64,
+        pub ifi_ibytes: u64,
+        pub ifi_obytes: u64,
+        pub ifi_imcasts: u64,
+        pub ifi_omcasts: u64,
+        pub ifi_iqdrops: u64,
+        pub ifi_noproto: u64,
+        pub ifi_lastchange: ::timespec,
+    }
+
+    pub struct if_msghdr {
+        pub ifm_msglen: ::c_ushort,
+        pub ifm_version: ::c_uchar,
+        pub ifm_type: ::c_uchar,
+        pub ifm_addrs: ::c_int,
+        pub ifm_flags: ::c_int,
+        pub ifm_index: ::c_ushort,
+        pub ifm_data: if_data,
+    }
+
+    pub struct sockcred {
+        pub sc_pid: ::pid_t,
+        pub sc_uid: ::uid_t,
+        pub sc_euid: ::uid_t,
+        pub sc_gid: ::gid_t,
+        pub sc_egid: ::gid_t,
+        pub sc_ngroups: ::c_int,
+        pub sc_groups: [::gid_t; 1],
+    }
+
+    pub struct sockaddr_dl {
+        pub sdl_len: ::c_uchar,
+        pub sdl_family: ::c_uchar,
+        pub sdl_index: ::c_ushort,
+        pub sdl_type: u8,
+        pub sdl_nlen: u8,
+        pub sdl_alen: u8,
+        pub sdl_slen: u8,
+        pub sdl_data: [::c_char; 12],
+    }
+
+    pub struct mmsghdr {
+        pub msg_hdr: ::msghdr,
+        pub msg_len: ::c_uint,
+    }
+
+    pub struct __exit_status {
+        pub e_termination: u16,
+        pub e_exit: u16,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        _shm_internal: *mut ::c_void,
+    }
+
+    pub struct utmp {
+        pub ut_line: [::c_char; UT_LINESIZE],
+        pub ut_name: [::c_char; UT_NAMESIZE],
+        pub ut_host: [::c_char; UT_HOSTSIZE],
+        pub ut_time: ::time_t
+    }
+
+    pub struct lastlog {
+        pub ll_line: [::c_char; UT_LINESIZE],
+        pub ll_host: [::c_char; UT_HOSTSIZE],
+        pub ll_time: ::time_t
+    }
+
+    pub struct timex {
+        pub modes: ::c_uint,
+        pub offset: ::c_long,
+        pub freq: ::c_long,
+        pub maxerror: ::c_long,
+        pub esterror: ::c_long,
+        pub status: ::c_int,
+        pub constant: ::c_long,
+        pub precision: ::c_long,
+        pub tolerance: ::c_long,
+        pub ppsfreq: ::c_long,
+        pub jitter: ::c_long,
+        pub shift: ::c_int,
+        pub stabil: ::c_long,
+        pub jitcnt: ::c_long,
+        pub calcnt: ::c_long,
+        pub errcnt: ::c_long,
+        pub stbcnt: ::c_long,
+    }
+
+    pub struct ntptimeval {
+        pub time: ::timespec,
+        pub maxerror: ::c_long,
+        pub esterror: ::c_long,
+        pub tai: ::c_long,
+        pub time_state: ::c_int,
+    }
+
+    // elf.h
+
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    // link.h
+
+    pub struct dl_phdr_info {
+        pub dlpi_addr: Elf_Addr,
+        pub dlpi_name: *const ::c_char,
+        pub dlpi_phdr: *const Elf_Phdr,
+        pub dlpi_phnum: Elf_Half,
+        pub dlpi_adds: ::c_ulonglong,
+        pub dlpi_subs: ::c_ulonglong,
+        pub dlpi_tls_modid: usize,
+        pub dlpi_tls_data: *mut ::c_void,
+    }
+}
+
+s_no_extra_traits! {
+
+    pub struct utmpx {
+        pub ut_name: [::c_char; _UTX_USERSIZE],
+        pub ut_id: [::c_char; _UTX_IDSIZE],
+        pub ut_line: [::c_char; _UTX_LINESIZE],
+        pub ut_host: [::c_char; _UTX_HOSTSIZE],
+        pub ut_session: u16,
+        pub ut_type: u16,
+        pub ut_pid: ::pid_t,
+        pub ut_exit: __exit_status,
+        pub ut_ss: sockaddr_storage,
+        pub ut_tv: ::timeval,
+        pub ut_pad: [u8; _UTX_PADSIZE],
+    }
+
+    pub struct lastlogx {
+        pub ll_tv: ::timeval,
+        pub ll_line: [::c_char; _UTX_LINESIZE],
+        pub ll_host: [::c_char; _UTX_HOSTSIZE],
+        pub ll_ss: sockaddr_storage,
+    }
+
+    pub struct in_pktinfo {
+        pub ipi_addr: ::in_addr,
+        pub ipi_ifindex: ::c_uint,
+    }
+
+    #[repr(packed)]
+    pub struct arphdr {
+        pub ar_hrd: u16,
+        pub ar_pro: u16,
+        pub ar_hln: u8,
+        pub ar_pln: u8,
+        pub ar_op: u16,
+    }
+
+    #[repr(packed)]
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct sockaddr_in {
+        pub sin_len: u8,
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [i8; 8],
+    }
+
+    pub struct dirent {
+        pub d_fileno: ::ino_t,
+        pub d_reclen: u16,
+        pub d_namlen: u16,
+        pub d_type: u8,
+        pub d_name: [::c_char; 512],
+    }
+
+    pub struct statvfs {
+        pub f_flag: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_iosize: ::c_ulong,
+
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_bresvd: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fresvd: ::fsfilcnt_t,
+
+        pub f_syncreads: u64,
+        pub f_syncwrites: u64,
+
+        pub f_asyncreads: u64,
+        pub f_asyncwrites: u64,
+
+        pub f_fsidx: ::fsid_t,
+        pub f_fsid: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        pub f_owner: ::uid_t,
+
+        pub f_spare: [u32; 4],
+
+        pub f_fstypename: [::c_char; 32],
+        pub f_mntonname: [::c_char; 1024],
+        pub f_mntfromname: [::c_char; 1024],
+    }
+
+    pub struct sockaddr_storage {
+        pub ss_len: u8,
+        pub ss_family: ::sa_family_t,
+        __ss_pad1: [u8; 6],
+        __ss_pad2: i64,
+        __ss_pad3: [u8; 112],
+    }
+
+    pub struct sigevent {
+        pub sigev_notify: ::c_int,
+        pub sigev_signo: ::c_int,
+        pub sigev_value: ::sigval,
+        __unused1: *mut ::c_void,       //actually a function pointer
+        pub sigev_notify_attributes: *mut ::c_void
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for utmpx {
+            fn eq(&self, other: &utmpx) -> bool {
+                self.ut_type == other.ut_type
+                    && self.ut_pid == other.ut_pid
+                    && self.ut_name == other.ut_name
+                    && self.ut_line == other.ut_line
+                    && self.ut_id == other.ut_id
+                    && self.ut_exit == other.ut_exit
+                    && self.ut_session == other.ut_session
+                    && self.ut_tv == other.ut_tv
+                    && self.ut_ss == other.ut_ss
+                    && self
+                    .ut_pad
+                    .iter()
+                    .zip(other.ut_pad.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .ut_host
+                    .iter()
+                    .zip(other.ut_host.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for utmpx {}
+
+        impl ::fmt::Debug for utmpx {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmpx")
+                    .field("ut_name", &self.ut_name)
+                    .field("ut_id", &self.ut_id)
+                    .field("ut_line", &self.ut_line)
+                // FIXME .field("ut_host", &self.ut_host)
+                    .field("ut_session", &self.ut_session)
+                    .field("ut_type", &self.ut_type)
+                    .field("ut_pid", &self.ut_pid)
+                    .field("ut_exit", &self.ut_exit)
+                    .field("ut_ss", &self.ut_ss)
+                    .field("ut_tv", &self.ut_tv)
+                // FIXME .field("ut_pad", &self.ut_pad)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utmpx {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_name.hash(state);
+                self.ut_type.hash(state);
+                self.ut_pid.hash(state);
+                self.ut_line.hash(state);
+                self.ut_id.hash(state);
+                self.ut_host.hash(state);
+                self.ut_exit.hash(state);
+                self.ut_session.hash(state);
+                self.ut_tv.hash(state);
+                self.ut_ss.hash(state);
+                self.ut_pad.hash(state);
+            }
+        }
+
+        impl PartialEq for lastlogx {
+            fn eq(&self, other: &lastlogx) -> bool {
+                self.ll_tv == other.ll_tv
+                    && self.ll_line == other.ll_line
+                    && self.ll_ss == other.ll_ss
+                    && self
+                    .ll_host
+                    .iter()
+                    .zip(other.ll_host.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for lastlogx {}
+
+        impl ::fmt::Debug for lastlogx {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("lastlogx")
+                    .field("ll_tv", &self.ll_tv)
+                    .field("ll_line", &self.ll_line)
+                // FIXME.field("ll_host", &self.ll_host)
+                    .field("ll_ss", &self.ll_ss)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for lastlogx {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ll_tv.hash(state);
+                self.ll_line.hash(state);
+                self.ll_host.hash(state);
+                self.ll_ss.hash(state);
+            }
+        }
+
+        impl PartialEq for in_pktinfo {
+            fn eq(&self, other: &in_pktinfo) -> bool {
+                self.ipi_addr == other.ipi_addr
+                    && self.ipi_ifindex == other.ipi_ifindex
+            }
+        }
+        impl Eq for in_pktinfo {}
+        impl ::fmt::Debug for in_pktinfo {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("in_pktinfo")
+                    .field("ipi_addr", &self.ipi_addr)
+                    .field("ipi_ifindex", &self.ipi_ifindex)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for in_pktinfo {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ipi_addr.hash(state);
+                self.ipi_ifindex.hash(state);
+            }
+        }
+
+        impl PartialEq for arphdr {
+            fn eq(&self, other: &arphdr) -> bool {
+                self.ar_hrd == other.ar_hrd
+                    && self.ar_pro == other.ar_pro
+                    && self.ar_hln == other.ar_hln
+                    && self.ar_pln == other.ar_pln
+                    && self.ar_op == other.ar_op
+            }
+        }
+        impl Eq for arphdr {}
+        impl ::fmt::Debug for arphdr {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                let ar_hrd = self.ar_hrd;
+                let ar_pro = self.ar_pro;
+                let ar_op = self.ar_op;
+                f.debug_struct("arphdr")
+                    .field("ar_hrd", &ar_hrd)
+                    .field("ar_pro", &ar_pro)
+                    .field("ar_hln", &self.ar_hln)
+                    .field("ar_pln", &self.ar_pln)
+                    .field("ar_op", &ar_op)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for arphdr {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                let ar_hrd = self.ar_hrd;
+                let ar_pro = self.ar_pro;
+                let ar_op = self.ar_op;
+                ar_hrd.hash(state);
+                ar_pro.hash(state);
+                self.ar_hln.hash(state);
+                self.ar_pln.hash(state);
+                ar_op.hash(state);
+            }
+        }
+
+        impl PartialEq for in_addr {
+            fn eq(&self, other: &in_addr) -> bool {
+                self.s_addr == other.s_addr
+            }
+        }
+        impl Eq for in_addr {}
+        impl ::fmt::Debug for in_addr {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                let s_addr = self.s_addr;
+                f.debug_struct("in_addr")
+                    .field("s_addr", &s_addr)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for in_addr {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                let s_addr = self.s_addr;
+                s_addr.hash(state);
+            }
+        }
+
+        impl PartialEq for ip_mreq {
+            fn eq(&self, other: &ip_mreq) -> bool {
+                self.imr_multiaddr == other.imr_multiaddr
+                    && self.imr_interface == other.imr_interface
+            }
+        }
+        impl Eq for ip_mreq {}
+        impl ::fmt::Debug for ip_mreq {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("ip_mreq")
+                    .field("imr_multiaddr", &self.imr_multiaddr)
+                    .field("imr_interface", &self.imr_interface)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for ip_mreq {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.imr_multiaddr.hash(state);
+                self.imr_interface.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_in {
+            fn eq(&self, other: &sockaddr_in) -> bool {
+                self.sin_len == other.sin_len
+                    && self.sin_family == other.sin_family
+                    && self.sin_port == other.sin_port
+                    && self.sin_addr == other.sin_addr
+                    && self.sin_zero == other.sin_zero
+            }
+        }
+        impl Eq for sockaddr_in {}
+        impl ::fmt::Debug for sockaddr_in {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_in")
+                    .field("sin_len", &self.sin_len)
+                    .field("sin_family", &self.sin_family)
+                    .field("sin_port", &self.sin_port)
+                    .field("sin_addr", &self.sin_addr)
+                    .field("sin_zero", &self.sin_zero)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_in {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sin_len.hash(state);
+                self.sin_family.hash(state);
+                self.sin_port.hash(state);
+                self.sin_addr.hash(state);
+                self.sin_zero.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_fileno == other.d_fileno
+                    && self.d_reclen == other.d_reclen
+                    && self.d_namlen == other.d_namlen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_fileno", &self.d_fileno)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_namlen", &self.d_namlen)
+                    .field("d_type", &self.d_type)
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_fileno.hash(state);
+                self.d_reclen.hash(state);
+                self.d_namlen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for statvfs {
+            fn eq(&self, other: &statvfs) -> bool {
+                self.f_flag == other.f_flag
+                    && self.f_bsize == other.f_bsize
+                    && self.f_frsize == other.f_frsize
+                    && self.f_iosize == other.f_iosize
+                    && self.f_blocks == other.f_blocks
+                    && self.f_bfree == other.f_bfree
+                    && self.f_bavail == other.f_bavail
+                    && self.f_bresvd == other.f_bresvd
+                    && self.f_files == other.f_files
+                    && self.f_ffree == other.f_ffree
+                    && self.f_favail == other.f_favail
+                    && self.f_fresvd == other.f_fresvd
+                    && self.f_syncreads == other.f_syncreads
+                    && self.f_syncwrites == other.f_syncwrites
+                    && self.f_asyncreads == other.f_asyncreads
+                    && self.f_asyncwrites == other.f_asyncwrites
+                    && self.f_fsidx == other.f_fsidx
+                    && self.f_fsid == other.f_fsid
+                    && self.f_namemax == other.f_namemax
+                    && self.f_owner == other.f_owner
+                    && self.f_spare == other.f_spare
+                    && self.f_fstypename == other.f_fstypename
+                    && self
+                    .f_mntonname
+                    .iter()
+                    .zip(other.f_mntonname.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .f_mntfromname
+                    .iter()
+                    .zip(other.f_mntfromname.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for statvfs {}
+        impl ::fmt::Debug for statvfs {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("statvfs")
+                    .field("f_flag", &self.f_flag)
+                    .field("f_bsize", &self.f_bsize)
+                    .field("f_frsize", &self.f_frsize)
+                    .field("f_iosize", &self.f_iosize)
+                    .field("f_blocks", &self.f_blocks)
+                    .field("f_bfree", &self.f_bfree)
+                    .field("f_bavail", &self.f_bavail)
+                    .field("f_bresvd", &self.f_bresvd)
+                    .field("f_files", &self.f_files)
+                    .field("f_ffree", &self.f_ffree)
+                    .field("f_favail", &self.f_favail)
+                    .field("f_fresvd", &self.f_fresvd)
+                    .field("f_syncreads", &self.f_syncreads)
+                    .field("f_syncwrites", &self.f_syncwrites)
+                    .field("f_asyncreads", &self.f_asyncreads)
+                    .field("f_asyncwrites", &self.f_asyncwrites)
+                    .field("f_fsidx", &self.f_fsidx)
+                    .field("f_fsid", &self.f_fsid)
+                    .field("f_namemax", &self.f_namemax)
+                    .field("f_owner", &self.f_owner)
+                    .field("f_spare", &self.f_spare)
+                    .field("f_fstypename", &self.f_fstypename)
+                    // FIXME: .field("f_mntonname", &self.f_mntonname)
+                    // FIXME: .field("f_mntfromname", &self.f_mntfromname)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for statvfs {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.f_flag.hash(state);
+                self.f_bsize.hash(state);
+                self.f_frsize.hash(state);
+                self.f_iosize.hash(state);
+                self.f_blocks.hash(state);
+                self.f_bfree.hash(state);
+                self.f_bavail.hash(state);
+                self.f_bresvd.hash(state);
+                self.f_files.hash(state);
+                self.f_ffree.hash(state);
+                self.f_favail.hash(state);
+                self.f_fresvd.hash(state);
+                self.f_syncreads.hash(state);
+                self.f_syncwrites.hash(state);
+                self.f_asyncreads.hash(state);
+                self.f_asyncwrites.hash(state);
+                self.f_fsidx.hash(state);
+                self.f_fsid.hash(state);
+                self.f_namemax.hash(state);
+                self.f_owner.hash(state);
+                self.f_spare.hash(state);
+                self.f_fstypename.hash(state);
+                self.f_mntonname.hash(state);
+                self.f_mntfromname.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_len == other.ss_len
+                    && self.ss_family == other.ss_family
+                    && self.__ss_pad1 == other.__ss_pad1
+                    && self.__ss_pad2 == other.__ss_pad2
+                    && self
+                    .__ss_pad3
+                    .iter()
+                    .zip(other.__ss_pad3.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_storage {}
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_len", &self.ss_len)
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_pad1", &self.__ss_pad1)
+                    .field("__ss_pad2", &self.__ss_pad2)
+                    // FIXME: .field("__ss_pad3", &self.__ss_pad3)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_len.hash(state);
+                self.ss_family.hash(state);
+                self.__ss_pad1.hash(state);
+                self.__ss_pad2.hash(state);
+                self.__ss_pad3.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_notify == other.sigev_notify
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_value == other.sigev_value
+                    && self.sigev_notify_attributes
+                        == other.sigev_notify_attributes
+            }
+        }
+        impl Eq for sigevent {}
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_value", &self.sigev_value)
+                    .field("sigev_notify_attributes",
+                           &self.sigev_notify_attributes)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_notify.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_value.hash(state);
+                self.sigev_notify_attributes.hash(state);
+            }
+        }
+    }
+}
+
+pub const AT_FDCWD: ::c_int = -100;
+pub const AT_EACCESS: ::c_int = 0x100;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x200;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x400;
+pub const AT_REMOVEDIR: ::c_int = 0x800;
+
+pub const EXTATTR_NAMESPACE_USER: ::c_int = 1;
+pub const EXTATTR_NAMESPACE_SYSTEM: ::c_int = 2;
+
+pub const LC_COLLATE_MASK: ::c_int = 1 << ::LC_COLLATE;
+pub const LC_CTYPE_MASK: ::c_int = 1 << ::LC_CTYPE;
+pub const LC_MONETARY_MASK: ::c_int = 1 << ::LC_MONETARY;
+pub const LC_NUMERIC_MASK: ::c_int = 1 << ::LC_NUMERIC;
+pub const LC_TIME_MASK: ::c_int = 1 << ::LC_TIME;
+pub const LC_MESSAGES_MASK: ::c_int = 1 << ::LC_MESSAGES;
+pub const LC_ALL_MASK: ::c_int = !0;
+
+pub const ERA: ::nl_item = 52;
+pub const ERA_D_FMT: ::nl_item = 53;
+pub const ERA_D_T_FMT: ::nl_item = 54;
+pub const ERA_T_FMT: ::nl_item = 55;
+pub const ALT_DIGITS: ::nl_item = 56;
+
+pub const O_CLOEXEC: ::c_int = 0x400000;
+pub const O_ALT_IO: ::c_int = 0x40000;
+pub const O_NOSIGPIPE: ::c_int = 0x1000000;
+pub const O_SEARCH: ::c_int = 0x800000;
+pub const O_DIRECTORY: ::c_int = 0x200000;
+pub const O_DIRECT: ::c_int = 0x00080000;
+pub const O_RSYNC: ::c_int = 0x00020000;
+
+pub const MS_SYNC: ::c_int = 0x4;
+pub const MS_INVALIDATE: ::c_int = 0x2;
+
+// Here because they are not present on OpenBSD
+// (https://github.com/openbsd/src/blob/master/sys/sys/resource.h)
+pub const RLIMIT_SBSIZE: ::c_int = 9;
+pub const RLIMIT_AS: ::c_int = 10;
+pub const RLIMIT_NTHR: ::c_int = 11;
+
+#[deprecated(since = "0.2.64", note = "Not stable across OS versions")]
+pub const RLIM_NLIMITS: ::c_int = 12;
+
+pub const EIDRM: ::c_int = 82;
+pub const ENOMSG: ::c_int = 83;
+pub const EOVERFLOW: ::c_int = 84;
+pub const EILSEQ: ::c_int = 85;
+pub const ENOTSUP: ::c_int = 86;
+pub const ECANCELED: ::c_int = 87;
+pub const EBADMSG: ::c_int = 88;
+pub const ENODATA: ::c_int = 89;
+pub const ENOSR: ::c_int = 90;
+pub const ENOSTR: ::c_int = 91;
+pub const ETIME: ::c_int = 92;
+pub const ENOATTR: ::c_int = 93;
+pub const EMULTIHOP: ::c_int = 94;
+pub const ENOLINK: ::c_int = 95;
+pub const EPROTO: ::c_int = 96;
+pub const ELAST: ::c_int = 96;
+
+pub const F_DUPFD_CLOEXEC: ::c_int = 12;
+pub const F_CLOSEM: ::c_int = 10;
+pub const F_GETNOSIGPIPE: ::c_int = 13;
+pub const F_SETNOSIGPIPE: ::c_int = 14;
+pub const F_MAXFD: ::c_int = 11;
+
+pub const IP_RECVDSTADDR: ::c_int = 7;
+pub const IP_SENDSRCADDR: ::c_int = IP_RECVDSTADDR;
+pub const IP_RECVIF: ::c_int = 20;
+pub const IP_PKTINFO: ::c_int = 25;
+pub const IP_RECVPKTINFO: ::c_int = 26;
+pub const IPV6_JOIN_GROUP: ::c_int = 12;
+pub const IPV6_LEAVE_GROUP: ::c_int = 13;
+
+pub const TCP_KEEPIDLE: ::c_int = 3;
+pub const TCP_KEEPINTVL: ::c_int = 5;
+pub const TCP_KEEPCNT: ::c_int = 6;
+pub const TCP_KEEPINIT: ::c_int = 7;
+pub const TCP_INFO: ::c_int = 9;
+pub const TCP_MD5SIG: ::c_int = 0x10;
+pub const TCP_CONGCTL: ::c_int = 0x20;
+
+pub const SOCK_CONN_DGRAM: ::c_int = 6;
+pub const SOCK_DCCP: ::c_int = SOCK_CONN_DGRAM;
+pub const SOCK_NOSIGPIPE: ::c_int = 0x40000000;
+pub const SOCK_FLAGS_MASK: ::c_int = 0xf0000000;
+
+pub const SO_SNDTIMEO: ::c_int = 0x100b;
+pub const SO_RCVTIMEO: ::c_int = 0x100c;
+pub const SO_ACCEPTFILTER: ::c_int = 0x1000;
+pub const SO_TIMESTAMP: ::c_int = 0x2000;
+pub const SO_OVERFLOWED: ::c_int = 0x1009;
+pub const SO_NOHEADER: ::c_int = 0x100a;
+
+// https://github.com/NetBSD/src/blob/trunk/sys/net/if.h#L373
+pub const IFF_UP: ::c_int = 0x0001; // interface is up
+pub const IFF_BROADCAST: ::c_int = 0x0002; // broadcast address valid
+pub const IFF_DEBUG: ::c_int = 0x0004; // turn on debugging
+pub const IFF_LOOPBACK: ::c_int = 0x0008; // is a loopback net
+pub const IFF_POINTOPOINT: ::c_int = 0x0010; // interface is point-to-point link
+pub const IFF_NOTRAILERS: ::c_int = 0x0020; // avoid use of trailers
+pub const IFF_RUNNING: ::c_int = 0x0040; // resources allocated
+pub const IFF_NOARP: ::c_int = 0x0080; // no address resolution protocol
+pub const IFF_PROMISC: ::c_int = 0x0100; // receive all packets
+pub const IFF_ALLMULTI: ::c_int = 0x0200; // receive all multicast packets
+pub const IFF_OACTIVE: ::c_int = 0x0400; // transmission in progress
+pub const IFF_SIMPLEX: ::c_int = 0x0800; // can't hear own transmissions
+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit
+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit
+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit
+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast
+
+// sys/netinet/in.h
+// Protocols (RFC 1700)
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+// IPPROTO_IP defined in src/unix/mod.rs
+/// Hop-by-hop option header
+pub const IPPROTO_HOPOPTS: ::c_int = 0;
+// IPPROTO_ICMP defined in src/unix/mod.rs
+/// group mgmt protocol
+pub const IPPROTO_IGMP: ::c_int = 2;
+/// gateway^2 (deprecated)
+pub const IPPROTO_GGP: ::c_int = 3;
+/// for compatibility
+pub const IPPROTO_IPIP: ::c_int = 4;
+// IPPROTO_TCP defined in src/unix/mod.rs
+/// exterior gateway protocol
+pub const IPPROTO_EGP: ::c_int = 8;
+/// pup
+pub const IPPROTO_PUP: ::c_int = 12;
+// IPPROTO_UDP defined in src/unix/mod.rs
+/// xns idp
+pub const IPPROTO_IDP: ::c_int = 22;
+/// tp-4 w/ class negotiation
+pub const IPPROTO_TP: ::c_int = 29;
+/// DCCP
+pub const IPPROTO_DCCP: ::c_int = 33;
+// IPPROTO_IPV6 defined in src/unix/mod.rs
+/// IP6 routing header
+pub const IPPROTO_ROUTING: ::c_int = 43;
+/// IP6 fragmentation header
+pub const IPPROTO_FRAGMENT: ::c_int = 44;
+/// resource reservation
+pub const IPPROTO_RSVP: ::c_int = 46;
+/// General Routing Encap.
+pub const IPPROTO_GRE: ::c_int = 47;
+/// IP6 Encap Sec. Payload
+pub const IPPROTO_ESP: ::c_int = 50;
+/// IP6 Auth Header
+pub const IPPROTO_AH: ::c_int = 51;
+/// IP Mobility RFC 2004
+pub const IPPROTO_MOBILE: ::c_int = 55;
+/// IPv6 ICMP
+pub const IPPROTO_IPV6_ICMP: ::c_int = 58;
+// IPPROTO_ICMPV6 defined in src/unix/mod.rs
+/// IP6 no next header
+pub const IPPROTO_NONE: ::c_int = 59;
+/// IP6 destination option
+pub const IPPROTO_DSTOPTS: ::c_int = 60;
+/// ISO cnlp
+pub const IPPROTO_EON: ::c_int = 80;
+/// Ethernet-in-IP
+pub const IPPROTO_ETHERIP: ::c_int = 97;
+/// encapsulation header
+pub const IPPROTO_ENCAP: ::c_int = 98;
+/// Protocol indep. multicast
+pub const IPPROTO_PIM: ::c_int = 103;
+/// IP Payload Comp. Protocol
+pub const IPPROTO_IPCOMP: ::c_int = 108;
+/// VRRP RFC 2338
+pub const IPPROTO_VRRP: ::c_int = 112;
+/// Common Address Resolution Protocol
+pub const IPPROTO_CARP: ::c_int = 112;
+/// L2TPv3
+// TEMP: Disabled for now; this constant was added to NetBSD on 2017-02-16,
+// but isn't yet supported by the NetBSD rumprun kernel image used for
+// libc testing.
+//pub const IPPROTO_L2TP: ::c_int = 115;
+/// SCTP
+pub const IPPROTO_SCTP: ::c_int = 132;
+/// PFSYNC
+pub const IPPROTO_PFSYNC: ::c_int = 240;
+pub const IPPROTO_MAX: ::c_int = 256;
+
+/// last return value of *_input(), meaning "all job for this pkt is done".
+pub const IPPROTO_DONE: ::c_int = 257;
+
+/// sysctl placeholder for (FAST_)IPSEC
+pub const CTL_IPPROTO_IPSEC: ::c_int = 258;
+
+pub const AF_OROUTE: ::c_int = 17;
+pub const AF_ARP: ::c_int = 28;
+pub const pseudo_AF_KEY: ::c_int = 29;
+pub const pseudo_AF_HDRCMPLT: ::c_int = 30;
+pub const AF_BLUETOOTH: ::c_int = 31;
+pub const AF_IEEE80211: ::c_int = 32;
+pub const AF_MPLS: ::c_int = 33;
+pub const AF_ROUTE: ::c_int = 34;
+pub const NET_RT_DUMP: ::c_int = 1;
+pub const NET_RT_FLAGS: ::c_int = 2;
+pub const NET_RT_OOOIFLIST: ::c_int = 3;
+pub const NET_RT_OOIFLIST: ::c_int = 4;
+pub const NET_RT_OIFLIST: ::c_int = 5;
+pub const NET_RT_IFLIST: ::c_int = 6;
+pub const NET_RT_MAXID: ::c_int = 7;
+
+pub const PF_OROUTE: ::c_int = AF_OROUTE;
+pub const PF_ARP: ::c_int = AF_ARP;
+pub const PF_KEY: ::c_int = pseudo_AF_KEY;
+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;
+pub const PF_MPLS: ::c_int = AF_MPLS;
+pub const PF_ROUTE: ::c_int = AF_ROUTE;
+
+pub const MSG_NBIO: ::c_int = 0x1000;
+pub const MSG_WAITFORONE: ::c_int = 0x2000;
+pub const MSG_NOTIFICATION: ::c_int = 0x4000;
+
+pub const SCM_TIMESTAMP: ::c_int = 0x08;
+pub const SCM_CREDS: ::c_int = 0x10;
+
+pub const O_DSYNC: ::c_int = 0x10000;
+
+pub const MAP_RENAME: ::c_int = 0x20;
+pub const MAP_NORESERVE: ::c_int = 0x40;
+pub const MAP_HASSEMAPHORE: ::c_int = 0x200;
+pub const MAP_WIRED: ::c_int = 0x800;
+
+pub const DCCP_TYPE_REQUEST: ::c_int = 0;
+pub const DCCP_TYPE_RESPONSE: ::c_int = 1;
+pub const DCCP_TYPE_DATA: ::c_int = 2;
+pub const DCCP_TYPE_ACK: ::c_int = 3;
+pub const DCCP_TYPE_DATAACK: ::c_int = 4;
+pub const DCCP_TYPE_CLOSEREQ: ::c_int = 5;
+pub const DCCP_TYPE_CLOSE: ::c_int = 6;
+pub const DCCP_TYPE_RESET: ::c_int = 7;
+pub const DCCP_TYPE_MOVE: ::c_int = 8;
+
+pub const DCCP_FEATURE_CC: ::c_int = 1;
+pub const DCCP_FEATURE_ECN: ::c_int = 2;
+pub const DCCP_FEATURE_ACKRATIO: ::c_int = 3;
+pub const DCCP_FEATURE_ACKVECTOR: ::c_int = 4;
+pub const DCCP_FEATURE_MOBILITY: ::c_int = 5;
+pub const DCCP_FEATURE_LOSSWINDOW: ::c_int = 6;
+pub const DCCP_FEATURE_CONN_NONCE: ::c_int = 8;
+pub const DCCP_FEATURE_IDENTREG: ::c_int = 7;
+
+pub const DCCP_OPT_PADDING: ::c_int = 0;
+pub const DCCP_OPT_DATA_DISCARD: ::c_int = 1;
+pub const DCCP_OPT_SLOW_RECV: ::c_int = 2;
+pub const DCCP_OPT_BUF_CLOSED: ::c_int = 3;
+pub const DCCP_OPT_CHANGE_L: ::c_int = 32;
+pub const DCCP_OPT_CONFIRM_L: ::c_int = 33;
+pub const DCCP_OPT_CHANGE_R: ::c_int = 34;
+pub const DCCP_OPT_CONFIRM_R: ::c_int = 35;
+pub const DCCP_OPT_INIT_COOKIE: ::c_int = 36;
+pub const DCCP_OPT_NDP_COUNT: ::c_int = 37;
+pub const DCCP_OPT_ACK_VECTOR0: ::c_int = 38;
+pub const DCCP_OPT_ACK_VECTOR1: ::c_int = 39;
+pub const DCCP_OPT_RECV_BUF_DROPS: ::c_int = 40;
+pub const DCCP_OPT_TIMESTAMP: ::c_int = 41;
+pub const DCCP_OPT_TIMESTAMP_ECHO: ::c_int = 42;
+pub const DCCP_OPT_ELAPSEDTIME: ::c_int = 43;
+pub const DCCP_OPT_DATACHECKSUM: ::c_int = 44;
+
+pub const DCCP_REASON_UNSPEC: ::c_int = 0;
+pub const DCCP_REASON_CLOSED: ::c_int = 1;
+pub const DCCP_REASON_INVALID: ::c_int = 2;
+pub const DCCP_REASON_OPTION_ERR: ::c_int = 3;
+pub const DCCP_REASON_FEA_ERR: ::c_int = 4;
+pub const DCCP_REASON_CONN_REF: ::c_int = 5;
+pub const DCCP_REASON_BAD_SNAME: ::c_int = 6;
+pub const DCCP_REASON_BAD_COOKIE: ::c_int = 7;
+pub const DCCP_REASON_INV_MOVE: ::c_int = 8;
+pub const DCCP_REASON_UNANSW_CH: ::c_int = 10;
+pub const DCCP_REASON_FRUITLESS_NEG: ::c_int = 11;
+
+pub const DCCP_CCID: ::c_int = 1;
+pub const DCCP_CSLEN: ::c_int = 2;
+pub const DCCP_MAXSEG: ::c_int = 4;
+pub const DCCP_SERVICE: ::c_int = 8;
+
+pub const DCCP_NDP_LIMIT: ::c_int = 16;
+pub const DCCP_SEQ_NUM_LIMIT: ::c_int = 16777216;
+pub const DCCP_MAX_OPTIONS: ::c_int = 32;
+pub const DCCP_MAX_PKTS: ::c_int = 100;
+
+pub const _PC_LINK_MAX: ::c_int = 1;
+pub const _PC_MAX_CANON: ::c_int = 2;
+pub const _PC_MAX_INPUT: ::c_int = 3;
+pub const _PC_NAME_MAX: ::c_int = 4;
+pub const _PC_PATH_MAX: ::c_int = 5;
+pub const _PC_PIPE_BUF: ::c_int = 6;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 7;
+pub const _PC_NO_TRUNC: ::c_int = 8;
+pub const _PC_VDISABLE: ::c_int = 9;
+pub const _PC_SYNC_IO: ::c_int = 10;
+pub const _PC_FILESIZEBITS: ::c_int = 11;
+pub const _PC_SYMLINK_MAX: ::c_int = 12;
+pub const _PC_2_SYMLINKS: ::c_int = 13;
+pub const _PC_ACL_EXTENDED: ::c_int = 14;
+pub const _PC_MIN_HOLE_SIZE: ::c_int = 15;
+
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 31;
+pub const _SC_IOV_MAX: ::c_int = 32;
+pub const _SC_MAPPED_FILES: ::c_int = 33;
+pub const _SC_MEMLOCK: ::c_int = 34;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 35;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 36;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 37;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 38;
+pub const _SC_CLK_TCK: ::c_int = 39;
+pub const _SC_ATEXIT_MAX: ::c_int = 40;
+pub const _SC_THREADS: ::c_int = 41;
+pub const _SC_SEMAPHORES: ::c_int = 42;
+pub const _SC_BARRIERS: ::c_int = 43;
+pub const _SC_TIMERS: ::c_int = 44;
+pub const _SC_SPIN_LOCKS: ::c_int = 45;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 46;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 47;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 48;
+pub const _SC_CLOCK_SELECTION: ::c_int = 49;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 50;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 51;
+pub const _SC_AIO_MAX: ::c_int = 52;
+pub const _SC_MESSAGE_PASSING: ::c_int = 53;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 54;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 55;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 56;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 57;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 58;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 59;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 60;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 61;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 62;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 63;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 64;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 65;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 66;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 67;
+pub const _SC_TTY_NAME_MAX: ::c_int = 68;
+pub const _SC_HOST_NAME_MAX: ::c_int = 69;
+pub const _SC_PASS_MAX: ::c_int = 70;
+pub const _SC_REGEXP: ::c_int = 71;
+pub const _SC_SHELL: ::c_int = 72;
+pub const _SC_SYMLOOP_MAX: ::c_int = 73;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 74;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 75;
+pub const _SC_V6_LP64_OFF64: ::c_int = 76;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 77;
+pub const _SC_2_PBS: ::c_int = 80;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 81;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 82;
+pub const _SC_2_PBS_LOCATE: ::c_int = 83;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 84;
+pub const _SC_2_PBS_TRACK: ::c_int = 85;
+pub const _SC_SPAWN: ::c_int = 86;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 87;
+pub const _SC_TIMER_MAX: ::c_int = 88;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 89;
+pub const _SC_CPUTIME: ::c_int = 90;
+pub const _SC_THREAD_CPUTIME: ::c_int = 91;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 92;
+// These two variables will be supported in NetBSD 8.0
+// pub const _SC_SIGQUEUE_MAX : ::c_int = 93;
+// pub const _SC_REALTIME_SIGNALS : ::c_int = 94;
+pub const _SC_PHYS_PAGES: ::c_int = 121;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 1001;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 1002;
+pub const _SC_SCHED_RT_TS: ::c_int = 2001;
+pub const _SC_SCHED_PRI_MIN: ::c_int = 2002;
+pub const _SC_SCHED_PRI_MAX: ::c_int = 2003;
+
+pub const FD_SETSIZE: usize = 0x100;
+
+pub const ST_NOSUID: ::c_ulong = 8;
+
+pub const BIOCGRSIG: ::c_ulong = 0x40044272;
+pub const BIOCSRSIG: ::c_ulong = 0x80044273;
+pub const BIOCSDLT: ::c_ulong = 0x80044278;
+pub const BIOCGSEESENT: ::c_ulong = 0x40044276;
+pub const BIOCSSEESENT: ::c_ulong = 0x80044277;
+
+//<sys/timex.h>
+pub const NTP_API: ::c_int = 4;
+pub const MAXPHASE: ::c_long = 500000000;
+pub const MAXFREQ: ::c_long = 500000;
+pub const MINSEC: ::c_int = 256;
+pub const MAXSEC: ::c_int = 2048;
+pub const NANOSECOND: ::c_long = 1000000000;
+pub const SCALE_PPM: ::c_int = 65;
+pub const MAXTC: ::c_int = 10;
+pub const MOD_OFFSET: ::c_uint = 0x0001;
+pub const MOD_FREQUENCY: ::c_uint = 0x0002;
+pub const MOD_MAXERROR: ::c_uint = 0x0004;
+pub const MOD_ESTERROR: ::c_uint = 0x0008;
+pub const MOD_STATUS: ::c_uint = 0x0010;
+pub const MOD_TIMECONST: ::c_uint = 0x0020;
+pub const MOD_PPSMAX: ::c_uint = 0x0040;
+pub const MOD_TAI: ::c_uint = 0x0080;
+pub const MOD_MICRO: ::c_uint = 0x1000;
+pub const MOD_NANO: ::c_uint = 0x2000;
+pub const MOD_CLKB: ::c_uint = 0x4000;
+pub const MOD_CLKA: ::c_uint = 0x8000;
+pub const STA_PLL: ::c_int = 0x0001;
+pub const STA_PPSFREQ: ::c_int = 0x0002;
+pub const STA_PPSTIME: ::c_int = 0x0004;
+pub const STA_FLL: ::c_int = 0x0008;
+pub const STA_INS: ::c_int = 0x0010;
+pub const STA_DEL: ::c_int = 0x0020;
+pub const STA_UNSYNC: ::c_int = 0x0040;
+pub const STA_FREQHOLD: ::c_int = 0x0080;
+pub const STA_PPSSIGNAL: ::c_int = 0x0100;
+pub const STA_PPSJITTER: ::c_int = 0x0200;
+pub const STA_PPSWANDER: ::c_int = 0x0400;
+pub const STA_PPSERROR: ::c_int = 0x0800;
+pub const STA_CLOCKERR: ::c_int = 0x1000;
+pub const STA_NANO: ::c_int = 0x2000;
+pub const STA_MODE: ::c_int = 0x4000;
+pub const STA_CLK: ::c_int = 0x8000;
+pub const STA_RONLY: ::c_int = STA_PPSSIGNAL
+    | STA_PPSJITTER
+    | STA_PPSWANDER
+    | STA_PPSERROR
+    | STA_CLOCKERR
+    | STA_NANO
+    | STA_MODE
+    | STA_CLK;
+pub const TIME_OK: ::c_int = 0;
+pub const TIME_INS: ::c_int = 1;
+pub const TIME_DEL: ::c_int = 2;
+pub const TIME_OOP: ::c_int = 3;
+pub const TIME_WAIT: ::c_int = 4;
+pub const TIME_ERROR: ::c_int = 5;
+
+cfg_if! {
+    if #[cfg(any(target_arch = "sparc", target_arch = "sparc64",
+                 target_arch = "x86", target_arch = "x86_64"))] {
+        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t
+          = pthread_mutex_t {
+            ptm_magic: 0x33330003,
+            ptm_errorcheck: 0,
+            ptm_pad1: [0; 3],
+            ptm_unused: 0,
+            ptm_pad2: [0; 3],
+            ptm_waiters: 0 as *mut _,
+            ptm_owner: 0,
+            ptm_recursed: 0,
+            ptm_spare2: 0 as *mut _,
+        };
+    } else {
+        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t
+          = pthread_mutex_t {
+            ptm_magic: 0x33330003,
+            ptm_errorcheck: 0,
+            ptm_unused: 0,
+            ptm_waiters: 0 as *mut _,
+            ptm_owner: 0,
+            ptm_recursed: 0,
+            ptm_spare2: 0 as *mut _,
+        };
+    }
+}
+
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+    ptc_magic: 0x55550005,
+    ptc_lock: 0,
+    ptc_waiters_first: 0 as *mut _,
+    ptc_waiters_last: 0 as *mut _,
+    ptc_mutex: 0 as *mut _,
+    ptc_private: 0 as *mut _,
+};
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+    ptr_magic: 0x99990009,
+    ptr_interlock: 0,
+    ptr_rblocked_first: 0 as *mut _,
+    ptr_rblocked_last: 0 as *mut _,
+    ptr_wblocked_first: 0 as *mut _,
+    ptr_wblocked_last: 0 as *mut _,
+    ptr_nreaders: 0,
+    ptr_owner: 0,
+    ptr_private: 0 as *mut _,
+};
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+
+pub const EVFILT_AIO: u32 = 2;
+pub const EVFILT_PROC: u32 = 4;
+pub const EVFILT_READ: u32 = 0;
+pub const EVFILT_SIGNAL: u32 = 5;
+pub const EVFILT_TIMER: u32 = 6;
+pub const EVFILT_VNODE: u32 = 3;
+pub const EVFILT_WRITE: u32 = 1;
+
+pub const EV_ADD: u32 = 0x1;
+pub const EV_DELETE: u32 = 0x2;
+pub const EV_ENABLE: u32 = 0x4;
+pub const EV_DISABLE: u32 = 0x8;
+pub const EV_ONESHOT: u32 = 0x10;
+pub const EV_CLEAR: u32 = 0x20;
+pub const EV_RECEIPT: u32 = 0x40;
+pub const EV_DISPATCH: u32 = 0x80;
+pub const EV_FLAG1: u32 = 0x2000;
+pub const EV_ERROR: u32 = 0x4000;
+pub const EV_EOF: u32 = 0x8000;
+pub const EV_SYSFLAGS: u32 = 0xf000;
+
+pub const NOTE_LOWAT: u32 = 0x00000001;
+pub const NOTE_DELETE: u32 = 0x00000001;
+pub const NOTE_WRITE: u32 = 0x00000002;
+pub const NOTE_EXTEND: u32 = 0x00000004;
+pub const NOTE_ATTRIB: u32 = 0x00000008;
+pub const NOTE_LINK: u32 = 0x00000010;
+pub const NOTE_RENAME: u32 = 0x00000020;
+pub const NOTE_REVOKE: u32 = 0x00000040;
+pub const NOTE_EXIT: u32 = 0x80000000;
+pub const NOTE_FORK: u32 = 0x40000000;
+pub const NOTE_EXEC: u32 = 0x20000000;
+pub const NOTE_PDATAMASK: u32 = 0x000fffff;
+pub const NOTE_PCTRLMASK: u32 = 0xf0000000;
+pub const NOTE_TRACK: u32 = 0x00000001;
+pub const NOTE_TRACKERR: u32 = 0x00000002;
+pub const NOTE_CHILD: u32 = 0x00000004;
+
+pub const TMP_MAX: ::c_uint = 308915776;
+
+pub const NI_MAXHOST: ::socklen_t = 1025;
+
+pub const RTLD_NOLOAD: ::c_int = 0x2000;
+pub const RTLD_LOCAL: ::c_int = 0x200;
+
+pub const CTL_MAXNAME: ::c_int = 12;
+pub const SYSCTL_NAMELEN: ::c_int = 32;
+pub const SYSCTL_DEFSIZE: ::c_int = 8;
+pub const CTLTYPE_NODE: ::c_int = 1;
+pub const CTLTYPE_INT: ::c_int = 2;
+pub const CTLTYPE_STRING: ::c_int = 3;
+pub const CTLTYPE_QUAD: ::c_int = 4;
+pub const CTLTYPE_STRUCT: ::c_int = 5;
+pub const CTLTYPE_BOOL: ::c_int = 6;
+pub const CTLFLAG_READONLY: ::c_int = 0x00000000;
+pub const CTLFLAG_READWRITE: ::c_int = 0x00000070;
+pub const CTLFLAG_ANYWRITE: ::c_int = 0x00000080;
+pub const CTLFLAG_PRIVATE: ::c_int = 0x00000100;
+pub const CTLFLAG_PERMANENT: ::c_int = 0x00000200;
+pub const CTLFLAG_OWNDATA: ::c_int = 0x00000400;
+pub const CTLFLAG_IMMEDIATE: ::c_int = 0x00000800;
+pub const CTLFLAG_HEX: ::c_int = 0x00001000;
+pub const CTLFLAG_ROOT: ::c_int = 0x00002000;
+pub const CTLFLAG_ANYNUMBER: ::c_int = 0x00004000;
+pub const CTLFLAG_HIDDEN: ::c_int = 0x00008000;
+pub const CTLFLAG_ALIAS: ::c_int = 0x00010000;
+pub const CTLFLAG_MMAP: ::c_int = 0x00020000;
+pub const CTLFLAG_OWNDESC: ::c_int = 0x00040000;
+pub const CTLFLAG_UNSIGNED: ::c_int = 0x00080000;
+pub const SYSCTL_VERS_MASK: ::c_int = 0xff000000;
+pub const SYSCTL_VERS_0: ::c_int = 0x00000000;
+pub const SYSCTL_VERS_1: ::c_int = 0x01000000;
+pub const SYSCTL_VERSION: ::c_int = SYSCTL_VERS_1;
+pub const CTL_EOL: ::c_int = -1;
+pub const CTL_QUERY: ::c_int = -2;
+pub const CTL_CREATE: ::c_int = -3;
+pub const CTL_CREATESYM: ::c_int = -4;
+pub const CTL_DESTROY: ::c_int = -5;
+pub const CTL_MMAP: ::c_int = -6;
+pub const CTL_DESCRIBE: ::c_int = -7;
+pub const CTL_UNSPEC: ::c_int = 0;
+pub const CTL_KERN: ::c_int = 1;
+pub const CTL_VM: ::c_int = 2;
+pub const CTL_VFS: ::c_int = 3;
+pub const CTL_NET: ::c_int = 4;
+pub const CTL_DEBUG: ::c_int = 5;
+pub const CTL_HW: ::c_int = 6;
+pub const CTL_MACHDEP: ::c_int = 7;
+pub const CTL_USER: ::c_int = 8;
+pub const CTL_DDB: ::c_int = 9;
+pub const CTL_PROC: ::c_int = 10;
+pub const CTL_VENDOR: ::c_int = 11;
+pub const CTL_EMUL: ::c_int = 12;
+pub const CTL_SECURITY: ::c_int = 13;
+pub const CTL_MAXID: ::c_int = 14;
+pub const KERN_OSTYPE: ::c_int = 1;
+pub const KERN_OSRELEASE: ::c_int = 2;
+pub const KERN_OSREV: ::c_int = 3;
+pub const KERN_VERSION: ::c_int = 4;
+pub const KERN_MAXVNODES: ::c_int = 5;
+pub const KERN_MAXPROC: ::c_int = 6;
+pub const KERN_MAXFILES: ::c_int = 7;
+pub const KERN_ARGMAX: ::c_int = 8;
+pub const KERN_SECURELVL: ::c_int = 9;
+pub const KERN_HOSTNAME: ::c_int = 10;
+pub const KERN_HOSTID: ::c_int = 11;
+pub const KERN_CLOCKRATE: ::c_int = 12;
+pub const KERN_VNODE: ::c_int = 13;
+pub const KERN_PROC: ::c_int = 14;
+pub const KERN_FILE: ::c_int = 15;
+pub const KERN_PROF: ::c_int = 16;
+pub const KERN_POSIX1: ::c_int = 17;
+pub const KERN_NGROUPS: ::c_int = 18;
+pub const KERN_JOB_CONTROL: ::c_int = 19;
+pub const KERN_SAVED_IDS: ::c_int = 20;
+pub const KERN_OBOOTTIME: ::c_int = 21;
+pub const KERN_DOMAINNAME: ::c_int = 22;
+pub const KERN_MAXPARTITIONS: ::c_int = 23;
+pub const KERN_RAWPARTITION: ::c_int = 24;
+pub const KERN_NTPTIME: ::c_int = 25;
+pub const KERN_TIMEX: ::c_int = 26;
+pub const KERN_AUTONICETIME: ::c_int = 27;
+pub const KERN_AUTONICEVAL: ::c_int = 28;
+pub const KERN_RTC_OFFSET: ::c_int = 29;
+pub const KERN_ROOT_DEVICE: ::c_int = 30;
+pub const KERN_MSGBUFSIZE: ::c_int = 31;
+pub const KERN_FSYNC: ::c_int = 32;
+pub const KERN_OLDSYSVMSG: ::c_int = 33;
+pub const KERN_OLDSYSVSEM: ::c_int = 34;
+pub const KERN_OLDSYSVSHM: ::c_int = 35;
+pub const KERN_OLDSHORTCORENAME: ::c_int = 36;
+pub const KERN_SYNCHRONIZED_IO: ::c_int = 37;
+pub const KERN_IOV_MAX: ::c_int = 38;
+pub const KERN_MBUF: ::c_int = 39;
+pub const KERN_MAPPED_FILES: ::c_int = 40;
+pub const KERN_MEMLOCK: ::c_int = 41;
+pub const KERN_MEMLOCK_RANGE: ::c_int = 42;
+pub const KERN_MEMORY_PROTECTION: ::c_int = 43;
+pub const KERN_LOGIN_NAME_MAX: ::c_int = 44;
+pub const KERN_DEFCORENAME: ::c_int = 45;
+pub const KERN_LOGSIGEXIT: ::c_int = 46;
+pub const KERN_PROC2: ::c_int = 47;
+pub const KERN_PROC_ARGS: ::c_int = 48;
+pub const KERN_FSCALE: ::c_int = 49;
+pub const KERN_CCPU: ::c_int = 50;
+pub const KERN_CP_TIME: ::c_int = 51;
+pub const KERN_OLDSYSVIPC_INFO: ::c_int = 52;
+pub const KERN_MSGBUF: ::c_int = 53;
+pub const KERN_CONSDEV: ::c_int = 54;
+pub const KERN_MAXPTYS: ::c_int = 55;
+pub const KERN_PIPE: ::c_int = 56;
+pub const KERN_MAXPHYS: ::c_int = 57;
+pub const KERN_SBMAX: ::c_int = 58;
+pub const KERN_TKSTAT: ::c_int = 59;
+pub const KERN_MONOTONIC_CLOCK: ::c_int = 60;
+pub const KERN_URND: ::c_int = 61;
+pub const KERN_LABELSECTOR: ::c_int = 62;
+pub const KERN_LABELOFFSET: ::c_int = 63;
+pub const KERN_LWP: ::c_int = 64;
+pub const KERN_FORKFSLEEP: ::c_int = 65;
+pub const KERN_POSIX_THREADS: ::c_int = 66;
+pub const KERN_POSIX_SEMAPHORES: ::c_int = 67;
+pub const KERN_POSIX_BARRIERS: ::c_int = 68;
+pub const KERN_POSIX_TIMERS: ::c_int = 69;
+pub const KERN_POSIX_SPIN_LOCKS: ::c_int = 70;
+pub const KERN_POSIX_READER_WRITER_LOCKS: ::c_int = 71;
+pub const KERN_DUMP_ON_PANIC: ::c_int = 72;
+pub const KERN_SOMAXKVA: ::c_int = 73;
+pub const KERN_ROOT_PARTITION: ::c_int = 74;
+pub const KERN_DRIVERS: ::c_int = 75;
+pub const KERN_BUF: ::c_int = 76;
+pub const KERN_FILE2: ::c_int = 77;
+pub const KERN_VERIEXEC: ::c_int = 78;
+pub const KERN_CP_ID: ::c_int = 79;
+pub const KERN_HARDCLOCK_TICKS: ::c_int = 80;
+pub const KERN_ARND: ::c_int = 81;
+pub const KERN_SYSVIPC: ::c_int = 82;
+pub const KERN_BOOTTIME: ::c_int = 83;
+pub const KERN_EVCNT: ::c_int = 84;
+pub const KERN_MAXID: ::c_int = 85;
+pub const KERN_PROC_ALL: ::c_int = 0;
+pub const KERN_PROC_PID: ::c_int = 1;
+pub const KERN_PROC_PGRP: ::c_int = 2;
+pub const KERN_PROC_SESSION: ::c_int = 3;
+pub const KERN_PROC_TTY: ::c_int = 4;
+pub const KERN_PROC_UID: ::c_int = 5;
+pub const KERN_PROC_RUID: ::c_int = 6;
+pub const KERN_PROC_GID: ::c_int = 7;
+pub const KERN_PROC_RGID: ::c_int = 8;
+pub const KERN_PROC_ARGV: ::c_int = 1;
+pub const KERN_PROC_NARGV: ::c_int = 2;
+pub const KERN_PROC_ENV: ::c_int = 3;
+pub const KERN_PROC_NENV: ::c_int = 4;
+pub const KERN_PROC_PATHNAME: ::c_int = 5;
+
+pub const EAI_AGAIN: ::c_int = 2;
+pub const EAI_BADFLAGS: ::c_int = 3;
+pub const EAI_FAIL: ::c_int = 4;
+pub const EAI_FAMILY: ::c_int = 5;
+pub const EAI_MEMORY: ::c_int = 6;
+pub const EAI_NODATA: ::c_int = 7;
+pub const EAI_NONAME: ::c_int = 8;
+pub const EAI_SERVICE: ::c_int = 9;
+pub const EAI_SOCKTYPE: ::c_int = 10;
+pub const EAI_SYSTEM: ::c_int = 11;
+pub const EAI_OVERFLOW: ::c_int = 14;
+
+pub const AIO_CANCELED: ::c_int = 1;
+pub const AIO_NOTCANCELED: ::c_int = 2;
+pub const AIO_ALLDONE: ::c_int = 3;
+pub const LIO_NOP: ::c_int = 0;
+pub const LIO_WRITE: ::c_int = 1;
+pub const LIO_READ: ::c_int = 2;
+pub const LIO_WAIT: ::c_int = 1;
+pub const LIO_NOWAIT: ::c_int = 0;
+
+pub const SIGEV_NONE: ::c_int = 0;
+pub const SIGEV_SIGNAL: ::c_int = 1;
+pub const SIGEV_THREAD: ::c_int = 2;
+
+pub const WSTOPPED: ::c_int = 0x00000002; // same as WUNTRACED
+pub const WCONTINUED: ::c_int = 0x00000010;
+pub const WEXITED: ::c_int = 0x000000020;
+pub const WNOWAIT: ::c_int = 0x00010000;
+
+pub const P_ALL: idtype_t = 0;
+pub const P_PID: idtype_t = 1;
+pub const P_PGID: idtype_t = 4;
+
+pub const UTIME_OMIT: c_long = 1073741822;
+pub const UTIME_NOW: c_long = 1073741823;
+
+pub const B460800: ::speed_t = 460800;
+pub const B921600: ::speed_t = 921600;
+
+pub const ONOCR: ::tcflag_t = 0x20;
+pub const ONLRET: ::tcflag_t = 0x40;
+pub const CDTRCTS: ::tcflag_t = 0x00020000;
+pub const CHWFLOW: ::tcflag_t = ::MDMBUF | ::CRTSCTS | ::CDTRCTS;
+
+// pub const _PATH_UTMPX: &[::c_char; 14] = b"/var/run/utmpx";
+// pub const _PATH_WTMPX: &[::c_char; 14] = b"/var/log/wtmpx";
+// pub const _PATH_LASTLOGX: &[::c_char; 17] = b"/var/log/lastlogx";
+// pub const _PATH_UTMP_UPDATE: &[::c_char; 24] = b"/usr/libexec/utmp_update";
+pub const UT_NAMESIZE: usize = 8;
+pub const UT_LINESIZE: usize = 8;
+pub const UT_HOSTSIZE: usize = 16;
+pub const _UTX_USERSIZE: usize = 32;
+pub const _UTX_LINESIZE: usize = 32;
+pub const _UTX_PADSIZE: usize = 40;
+pub const _UTX_IDSIZE: usize = 4;
+pub const _UTX_HOSTSIZE: usize = 256;
+pub const EMPTY: u16 = 0;
+pub const RUN_LVL: u16 = 1;
+pub const BOOT_TIME: u16 = 2;
+pub const OLD_TIME: u16 = 3;
+pub const NEW_TIME: u16 = 4;
+pub const INIT_PROCESS: u16 = 5;
+pub const LOGIN_PROCESS: u16 = 6;
+pub const USER_PROCESS: u16 = 7;
+pub const DEAD_PROCESS: u16 = 8;
+pub const ACCOUNTING: u16 = 9;
+pub const SIGNATURE: u16 = 10;
+pub const DOWN_TIME: u16 = 11;
+
+pub const SOCK_CLOEXEC: ::c_int = 0x10000000;
+pub const SOCK_NONBLOCK: ::c_int = 0x20000000;
+
+// Uncomment on next NetBSD release
+// pub const FIOSEEKDATA: ::c_ulong = 0xc0086661;
+// pub const FIOSEEKHOLE: ::c_ulong = 0xc0086662;
+pub const OFIOGETBMAP: ::c_ulong = 0xc004667a;
+pub const FIOGETBMAP: ::c_ulong = 0xc008667a;
+pub const FIONWRITE: ::c_ulong = 0x40046679;
+pub const FIONSPACE: ::c_ulong = 0x40046678;
+pub const FIBMAP: ::c_ulong = 0xc008667a;
+
+pub const SIGSTKSZ: ::size_t = 40960;
+
+pub const REG_ENOSYS: ::c_int = 17;
+
+pub const PT_DUMPCORE: ::c_int = 12;
+pub const PT_LWPINFO: ::c_int = 13;
+pub const PT_SYSCALL: ::c_int = 14;
+pub const PT_SYSCALLEMU: ::c_int = 15;
+pub const PT_SET_EVENT_MASK: ::c_int = 16;
+pub const PT_GET_EVENT_MASK: ::c_int = 17;
+pub const PT_GET_PROCESS_STATE: ::c_int = 18;
+pub const PT_FIRSTMACH: ::c_int = 32;
+
+// Flags for chflags(2)
+pub const SF_SNAPSHOT: ::c_ulong = 0x00200000;
+pub const SF_LOG: ::c_ulong = 0x00400000;
+pub const SF_SNAPINVAL: ::c_ulong = 0x00800000;
+
+fn _ALIGN(p: usize) -> usize {
+    (p + _ALIGNBYTES) & !_ALIGNBYTES
+}
+
+f! {
+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {
+        (cmsg as *mut ::c_uchar)
+            .offset(_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        _ALIGN(::mem::size_of::<::cmsghdr>()) as ::c_uint + length
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)
+        -> *mut ::cmsghdr
+    {
+        if cmsg.is_null() {
+            return ::CMSG_FIRSTHDR(mhdr);
+        };
+        let next = cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize)
+            + _ALIGN(::mem::size_of::<::cmsghdr>());
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if next > max {
+            0 as *mut ::cmsghdr
+        } else {
+            (cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize))
+                as *mut ::cmsghdr
+        }
+    }
+
+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        (_ALIGN(::mem::size_of::<::cmsghdr>()) + _ALIGN(length as usize))
+            as ::c_uint
+    }
+
+    // dirfd() is a macro on netbsd to access
+    // the first field of the struct where dirp points to:
+    // http://cvsweb.netbsd.org/bsdweb.cgi/src/include/dirent.h?rev=1.36
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int {
+        *(dirp as *const ::c_int)
+    }
+
+    pub fn SOCKCREDSIZE(ngrps: usize) -> usize {
+        let ngrps = if ngrps > 0 {
+            ngrps - 1
+        } else {
+            0
+        };
+        ::mem::size_of::<sockcred>() + ::mem::size_of::<::gid_t>() * ngrps
+    }
+}
+
+safe_f! {
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        status >> 8
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        (status & 0o177) != 0o177 && (status & 0o177) != 0
+    }
+
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        (status & 0o177) == 0o177
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        status == 0xffff
+    }
+}
+
+extern "C" {
+    pub fn ntp_adjtime(buf: *mut timex) -> ::c_int;
+    pub fn ntp_gettime(buf: *mut ntptimeval) -> ::c_int;
+    pub fn clock_nanosleep(
+        clk_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+}
+
+#[link(name = "rt")]
+extern "C" {
+    pub fn aio_read(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_write(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_fsync(op: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_error(aiocbp: *const aiocb) -> ::c_int;
+    pub fn aio_return(aiocbp: *mut aiocb) -> ::ssize_t;
+    #[link_name = "__aio_suspend50"]
+    pub fn aio_suspend(
+        aiocb_list: *const *const aiocb,
+        nitems: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn aio_cancel(fd: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn lio_listio(
+        mode: ::c_int,
+        aiocb_list: *const *mut aiocb,
+        nitems: ::c_int,
+        sevp: *mut sigevent,
+    ) -> ::c_int;
+}
+
+extern "C" {
+    pub fn chflags(path: *const ::c_char, flags: ::c_ulong) -> ::c_int;
+    pub fn fchflags(fd: ::c_int, flags: ::c_ulong) -> ::c_int;
+    pub fn lchflags(path: *const ::c_char, flags: ::c_ulong) -> ::c_int;
+
+    pub fn extattr_delete_fd(
+        fd: ::c_int,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+    ) -> ::c_int;
+    pub fn extattr_delete_file(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+    ) -> ::c_int;
+    pub fn extattr_delete_link(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+    ) -> ::c_int;
+    pub fn extattr_get_fd(
+        fd: ::c_int,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_get_file(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_get_link(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *mut ::c_void,
+        nbytes: ::size_t,
+    ) -> ::ssize_t;
+    pub fn extattr_namespace_to_string(
+        attrnamespace: ::c_int,
+        string: *mut *mut ::c_char,
+    ) -> ::c_int;
+    pub fn extattr_set_fd(
+        fd: ::c_int,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *const ::c_void,
+        nbytes: ::size_t,
+    ) -> ::c_int;
+    pub fn extattr_set_file(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *const ::c_void,
+        nbytes: ::size_t,
+    ) -> ::c_int;
+    pub fn extattr_set_link(
+        path: *const ::c_char,
+        attrnamespace: ::c_int,
+        attrname: *const ::c_char,
+        data: *const ::c_void,
+        nbytes: ::size_t,
+    ) -> ::c_int;
+    pub fn extattr_string_to_namespace(
+        string: *const ::c_char,
+        attrnamespace: *mut ::c_int,
+    ) -> ::c_int;
+
+    #[link_name = "__lutimes50"]
+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;
+    #[link_name = "__gettimeofday50"]
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::socklen_t,
+        serv: *mut ::c_char,
+        sevlen: ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn sysctl(
+        name: *const ::c_int,
+        namelen: ::c_uint,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *const ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    pub fn sysctlbyname(
+        name: *const ::c_char,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *const ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    #[link_name = "__kevent50"]
+    pub fn kevent(
+        kq: ::c_int,
+        changelist: *const ::kevent,
+        nchanges: ::size_t,
+        eventlist: *mut ::kevent,
+        nevents: ::size_t,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    #[link_name = "__mount50"]
+    pub fn mount(
+        src: *const ::c_char,
+        target: *const ::c_char,
+        flags: ::c_int,
+        data: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::c_int;
+    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;
+    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;
+    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;
+    pub fn mq_notify(mqd: ::mqd_t, notification: *const ::sigevent)
+        -> ::c_int;
+    pub fn mq_receive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mq_send(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+    ) -> ::c_int;
+    pub fn mq_setattr(
+        mqd: ::mqd_t,
+        newattr: *const ::mq_attr,
+        oldattr: *mut ::mq_attr,
+    ) -> ::c_int;
+    #[link_name = "__mq_timedreceive50"]
+    pub fn mq_timedreceive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::ssize_t;
+    #[link_name = "__mq_timedsend50"]
+    pub fn mq_timedsend(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn ptrace(
+        request: ::c_int,
+        pid: ::pid_t,
+        addr: *mut ::c_void,
+        data: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_setname_np(
+        t: ::pthread_t,
+        name: *const ::c_char,
+        arg: *const ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_attr_get_np(
+        thread: ::pthread_t,
+        attr: *mut ::pthread_attr_t,
+    ) -> ::c_int;
+    pub fn pthread_getattr_np(
+        native: ::pthread_t,
+        attr: *mut ::pthread_attr_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const ::pthread_attr_t,
+        guardsize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstack(
+        attr: *const ::pthread_attr_t,
+        stackaddr: *mut *mut ::c_void,
+        stacksize: *mut ::size_t,
+    ) -> ::c_int;
+    #[link_name = "__sigtimedwait50"]
+    pub fn sigtimedwait(
+        set: *const sigset_t,
+        info: *mut siginfo_t,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> ::c_int;
+    pub fn duplocale(base: ::locale_t) -> ::locale_t;
+    pub fn freelocale(loc: ::locale_t);
+    pub fn localeconv_l(loc: ::locale_t) -> *mut lconv;
+    pub fn newlocale(
+        mask: ::c_int,
+        locale: *const ::c_char,
+        base: ::locale_t,
+    ) -> ::locale_t;
+    #[link_name = "__settimeofday50"]
+    pub fn settimeofday(tv: *const ::timeval, tz: *const ::c_void) -> ::c_int;
+
+    pub fn dup3(src: ::c_int, dst: ::c_int, flags: ::c_int) -> ::c_int;
+
+    pub fn sendmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn recvmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+
+    pub fn _lwp_self() -> lwpid_t;
+    pub fn memmem(
+        haystack: *const ::c_void,
+        haystacklen: ::size_t,
+        needle: *const ::c_void,
+        needlelen: ::size_t,
+    ) -> *mut ::c_void;
+
+    // link.h
+
+    pub fn dl_iterate_phdr(
+        callback: ::Option<
+            unsafe extern "C" fn(
+                info: *mut dl_phdr_info,
+                size: usize,
+                data: *mut ::c_void,
+            ) -> ::c_int,
+        >,
+        data: *mut ::c_void,
+    ) -> ::c_int;
+}
+
+#[link(name = "util")]
+extern "C" {
+    #[cfg_attr(target_os = "netbsd", link_name = "__getpwent_r50")]
+    pub fn getpwent_r(
+        pwd: *mut ::passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::passwd,
+    ) -> ::c_int;
+    pub fn getgrent_r(
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+
+    pub fn updwtmpx(file: *const ::c_char, ut: *const utmpx) -> ::c_int;
+    pub fn getlastlogx(
+        fname: *const ::c_char,
+        uid: ::uid_t,
+        ll: *mut lastlogx,
+    ) -> *mut lastlogx;
+    pub fn updlastlogx(
+        fname: *const ::c_char,
+        uid: ::uid_t,
+        ll: *mut lastlogx,
+    ) -> ::c_int;
+    pub fn utmpxname(file: *const ::c_char) -> ::c_int;
+    pub fn getutxent() -> *mut utmpx;
+    pub fn getutxid(ut: *const utmpx) -> *mut utmpx;
+    pub fn getutxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn pututxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn setutxent();
+    pub fn endutxent();
+
+    pub fn getutmp(ux: *const utmpx, u: *mut utmp);
+    pub fn getutmpx(u: *const utmp, ux: *mut utmpx);
+
+    pub fn utpname(file: *const ::c_char) -> ::c_int;
+    pub fn setutent();
+    pub fn endutent();
+    pub fn getutent() -> *mut utmp;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(target_arch = "arm")] {
+        mod arm;
+        pub use self::arm::*;
+    } else if #[cfg(target_arch = "powerpc")] {
+        mod powerpc;
+        pub use self::powerpc::*;
+    } else if #[cfg(target_arch = "sparc64")] {
+        mod sparc64;
+        pub use self::sparc64::*;
+    } else if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(target_arch = "x86")] {
+        mod x86;
+        pub use self::x86::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/bsd/netbsdlike/netbsd/powerpc.rs b/library/libc/src/unix/bsd/netbsdlike/netbsd/powerpc.rs
new file mode 100644
index 00000000..e12fd5e1
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/netbsd/powerpc.rs
@@ -0,0 +1,21 @@
+use PT_FIRSTMACH;
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type c_char = u8;
+pub type __cpu_simple_lock_nv_t = ::c_int;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_double>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 8 - 1;
+    }
+}
+
+pub const PT_STEP: ::c_int = PT_FIRSTMACH + 0;
+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 1;
+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 2;
diff --git a/library/libc/src/unix/bsd/netbsdlike/netbsd/sparc64.rs b/library/libc/src/unix/bsd/netbsdlike/netbsd/sparc64.rs
new file mode 100644
index 00000000..6a86759e
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/netbsd/sparc64.rs
@@ -0,0 +1,8 @@
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type c_char = i8;
+pub type __cpu_simple_lock_nv_t = ::c_uchar;
+
+// should be pub(crate), but that requires Rust 1.18.0
+#[doc(hidden)]
+pub const _ALIGNBYTES: usize = 0xf;
diff --git a/library/libc/src/unix/bsd/netbsdlike/netbsd/x86.rs b/library/libc/src/unix/bsd/netbsdlike/netbsd/x86.rs
new file mode 100644
index 00000000..daa89a11
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/netbsd/x86.rs
@@ -0,0 +1,15 @@
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type c_char = i8;
+pub type __cpu_simple_lock_nv_t = ::c_uchar;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_int>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 4 - 1;
+    }
+}
diff --git a/library/libc/src/unix/bsd/netbsdlike/netbsd/x86_64.rs b/library/libc/src/unix/bsd/netbsdlike/netbsd/x86_64.rs
new file mode 100644
index 00000000..0860d4f6
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/netbsd/x86_64.rs
@@ -0,0 +1,23 @@
+use PT_FIRSTMACH;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type c_char = i8;
+pub type __cpu_simple_lock_nv_t = ::c_uchar;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 8 - 1;
+    }
+}
+
+pub const PT_STEP: ::c_int = PT_FIRSTMACH + 0;
+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 1;
+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 2;
+pub const PT_GETFPREGS: ::c_int = PT_FIRSTMACH + 3;
+pub const PT_SETFPREGS: ::c_int = PT_FIRSTMACH + 4;
diff --git a/library/libc/src/unix/bsd/netbsdlike/openbsd/aarch64.rs b/library/libc/src/unix/bsd/netbsdlike/openbsd/aarch64.rs
new file mode 100644
index 00000000..99350ec8
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/openbsd/aarch64.rs
@@ -0,0 +1,16 @@
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type c_char = u8;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 8 - 1;
+    }
+}
+
+pub const _MAX_PAGE_SHIFT: u32 = 12;
diff --git a/library/libc/src/unix/bsd/netbsdlike/openbsd/mod.rs b/library/libc/src/unix/bsd/netbsdlike/openbsd/mod.rs
new file mode 100644
index 00000000..06068115
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/openbsd/mod.rs
@@ -0,0 +1,1586 @@
+use unix::bsd::O_SYNC;
+
+pub type clock_t = i64;
+pub type suseconds_t = ::c_long;
+pub type dev_t = i32;
+pub type sigset_t = ::c_uint;
+pub type blksize_t = i32;
+pub type fsblkcnt_t = u64;
+pub type fsfilcnt_t = u64;
+pub type pthread_attr_t = *mut ::c_void;
+pub type pthread_mutex_t = *mut ::c_void;
+pub type pthread_mutexattr_t = *mut ::c_void;
+pub type pthread_cond_t = *mut ::c_void;
+pub type pthread_condattr_t = *mut ::c_void;
+pub type pthread_rwlock_t = *mut ::c_void;
+pub type pthread_rwlockattr_t = *mut ::c_void;
+pub type caddr_t = *mut ::c_char;
+
+// elf.h
+
+pub type Elf32_Addr = u32;
+pub type Elf32_Half = u16;
+pub type Elf32_Lword = u64;
+pub type Elf32_Off = u32;
+pub type Elf32_Sword = i32;
+pub type Elf32_Word = u32;
+
+pub type Elf64_Addr = u64;
+pub type Elf64_Half = u16;
+pub type Elf64_Lword = u64;
+pub type Elf64_Off = u64;
+pub type Elf64_Sword = i32;
+pub type Elf64_Sxword = i64;
+pub type Elf64_Word = u32;
+pub type Elf64_Xword = u64;
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "64")] {
+        type Elf_Addr = Elf64_Addr;
+        type Elf_Half = Elf64_Half;
+        type Elf_Phdr = Elf64_Phdr;
+    } else if #[cfg(target_pointer_width = "32")] {
+        type Elf_Addr = Elf32_Addr;
+        type Elf_Half = Elf32_Half;
+        type Elf_Phdr = Elf32_Phdr;
+    }
+}
+
+s! {
+    pub struct glob_t {
+        pub gl_pathc:   ::size_t,
+        pub gl_matchc:  ::size_t,
+        pub gl_offs:    ::size_t,
+        pub gl_flags:   ::c_int,
+        pub gl_pathv:   *mut *mut ::c_char,
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+        __unused6: *mut ::c_void,
+        __unused7: *mut ::c_void,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct ufs_args {
+        pub fspec: *mut ::c_char,
+        pub export_info: export_args,
+    }
+
+    pub struct mfs_args {
+        pub fspec: *mut ::c_char,
+        pub export_info: export_args,
+        // https://github.com/openbsd/src/blob/master/sys/sys/types.h#L134
+        pub base: *mut ::c_char,
+        pub size: ::c_ulong,
+    }
+
+    pub struct iso_args {
+        pub fspec: *mut ::c_char,
+        pub export_info: export_args,
+        pub flags: ::c_int,
+        pub sess: ::c_int,
+    }
+
+    pub struct nfs_args {
+        pub version: ::c_int,
+        pub addr: *mut ::sockaddr,
+        pub addrlen: ::c_int,
+        pub sotype: ::c_int,
+        pub proto: ::c_int,
+        pub fh: *mut ::c_uchar,
+        pub fhsize: ::c_int,
+        pub flags: ::c_int,
+        pub wsize: ::c_int,
+        pub rsize: ::c_int,
+        pub readdirsize: ::c_int,
+        pub timeo: ::c_int,
+        pub retrans: ::c_int,
+        pub maxgrouplist: ::c_int,
+        pub readahead: ::c_int,
+        pub leaseterm: ::c_int,
+        pub deadthresh: ::c_int,
+        pub hostname: *mut ::c_char,
+        pub acregmin: ::c_int,
+        pub acregmax: ::c_int,
+        pub acdirmin: ::c_int,
+        pub acdirmax: ::c_int,
+    }
+
+    pub struct msdosfs_args {
+        pub fspec: *mut ::c_char,
+        pub export_info: export_args,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub mask: ::mode_t,
+        pub flags: ::c_int,
+    }
+
+    pub struct ntfs_args {
+        pub fspec: *mut ::c_char,
+        pub export_info: export_args,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub mode: ::mode_t,
+        pub flag: ::c_ulong,
+    }
+
+    pub struct udf_args {
+        pub fspec: *mut ::c_char,
+        pub lastblock: u32,
+    }
+
+    pub struct tmpfs_args {
+        pub ta_version: ::c_int,
+        pub ta_nodes_max: ::ino_t,
+        pub ta_size_max: ::off_t,
+        pub ta_root_uid: ::uid_t,
+        pub ta_root_gid: ::gid_t,
+        pub ta_root_mode: ::mode_t,
+    }
+
+    pub struct fusefs_args {
+        pub name: *mut ::c_char,
+        pub fd: ::c_int,
+        pub max_read: ::c_int,
+        pub allow_other: ::c_int,
+    }
+
+    pub struct xucred {
+        pub cr_uid: ::uid_t,
+        pub cr_gid: ::gid_t,
+        pub cr_ngroups: ::c_short,
+        //https://github.com/openbsd/src/blob/master/sys/sys/syslimits.h#L44
+        pub cr_groups: [::gid_t; 16],
+    }
+
+    pub struct export_args {
+        pub ex_flags: ::c_int,
+        pub ex_root: ::uid_t,
+        pub ex_anon: xucred,
+        pub ex_addr: *mut ::sockaddr,
+        pub ex_addrlen: ::c_int,
+        pub ex_mask: *mut ::sockaddr,
+        pub ex_masklen: ::c_int,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct sockaddr_in {
+        pub sin_len: u8,
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [i8; 8],
+    }
+
+    pub struct kevent {
+        pub ident: ::uintptr_t,
+        pub filter: ::c_short,
+        pub flags: ::c_ushort,
+        pub fflags: ::c_uint,
+        pub data: i64,
+        pub udata: *mut ::c_void,
+    }
+
+    pub struct stat {
+        pub st_mode: ::mode_t,
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_size: ::off_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_blksize: ::blksize_t,
+        pub st_flags: u32,
+        pub st_gen: u32,
+        pub st_birthtime: ::time_t,
+        pub st_birthtime_nsec: ::c_long,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: ::socklen_t,
+        pub ai_addr: *mut ::sockaddr,
+        pub ai_canonname: *mut ::c_char,
+        pub ai_next: *mut ::addrinfo,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct if_data {
+        pub ifi_type: ::c_uchar,
+        pub ifi_addrlen: ::c_uchar,
+        pub ifi_hdrlen: ::c_uchar,
+        pub ifi_link_state: ::c_uchar,
+        pub ifi_mtu: u32,
+        pub ifi_metric: u32,
+        pub ifi_rdomain: u32,
+        pub ifi_baudrate: u64,
+        pub ifi_ipackets: u64,
+        pub ifi_ierrors: u64,
+        pub ifi_opackets: u64,
+        pub ifi_oerrors: u64,
+        pub ifi_collisions: u64,
+        pub ifi_ibytes: u64,
+        pub ifi_obytes: u64,
+        pub ifi_imcasts: u64,
+        pub ifi_omcasts: u64,
+        pub ifi_iqdrops: u64,
+        pub ifi_oqdrops: u64,
+        pub ifi_noproto: u64,
+        pub ifi_capabilities: u32,
+        pub ifi_lastchange: ::timeval,
+    }
+
+    pub struct if_msghdr {
+        pub ifm_msglen: ::c_ushort,
+        pub ifm_version: ::c_uchar,
+        pub ifm_type: ::c_uchar,
+        pub ifm_hdrlen: ::c_ushort,
+        pub ifm_index: ::c_ushort,
+        pub ifm_tableid: ::c_ushort,
+        pub ifm_pad1: ::c_uchar,
+        pub ifm_pad2: ::c_uchar,
+        pub ifm_addrs: ::c_int,
+        pub ifm_flags: ::c_int,
+        pub ifm_xflags: ::c_int,
+        pub ifm_data: if_data,
+    }
+
+    pub struct sockaddr_dl {
+        pub sdl_len: ::c_uchar,
+        pub sdl_family: ::c_uchar,
+        pub sdl_index: ::c_ushort,
+        pub sdl_type: ::c_uchar,
+        pub sdl_nlen: ::c_uchar,
+        pub sdl_alen: ::c_uchar,
+        pub sdl_slen: ::c_uchar,
+        pub sdl_data: [::c_char; 24],
+    }
+
+    pub struct sockpeercred {
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub pid: ::pid_t,
+    }
+
+    pub struct arphdr {
+        pub ar_hrd: u16,
+        pub ar_pro: u16,
+        pub ar_hln: u8,
+        pub ar_pln: u8,
+        pub ar_op: u16,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::c_int,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_nattch: ::c_short,
+        pub shm_atime: ::time_t,
+        __shm_atimensec: c_long,
+        pub shm_dtime: ::time_t,
+        __shm_dtimensec: c_long,
+        pub shm_ctime: ::time_t,
+        __shm_ctimensec: c_long,
+        pub shm_internal: *mut ::c_void,
+    }
+
+    // elf.h
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    // link.h
+
+    pub struct dl_phdr_info {
+        pub dlpi_addr: Elf_Addr,
+        pub dlpi_name: *const ::c_char,
+        pub dlpi_phdr: *const Elf_Phdr,
+        pub dlpi_phnum: Elf_Half,
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_value(&self) -> ::sigval {
+        #[repr(C)]
+        struct siginfo_timer {
+            _si_signo: ::c_int,
+            _si_errno: ::c_int,
+            _si_code: ::c_int,
+            _pid: ::pid_t,
+            _uid: ::uid_t,
+            value: ::sigval,
+        }
+        (*(self as *const siginfo_t as *const siginfo_timer)).value
+    }
+}
+
+s_no_extra_traits! {
+    pub struct dirent {
+        pub d_fileno: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: u16,
+        pub d_type: u8,
+        pub d_namlen: u8,
+        __d_padding: [u8; 4],
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct sockaddr_storage {
+        pub ss_len: u8,
+        pub ss_family: ::sa_family_t,
+        __ss_pad1: [u8; 6],
+        __ss_pad2: i64,
+        __ss_pad3: [u8; 240],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_addr: *mut ::c_char,
+        #[cfg(target_pointer_width = "32")]
+        __pad: [u8; 112],
+        #[cfg(target_pointer_width = "64")]
+        __pad: [u8; 108],
+    }
+
+    pub struct lastlog {
+        ll_time: ::time_t,
+        ll_line: [::c_char; UT_LINESIZE],
+        ll_host: [::c_char; UT_HOSTSIZE],
+    }
+
+    pub struct utmp {
+        pub ut_line: [::c_char; UT_LINESIZE],
+        pub ut_name: [::c_char; UT_NAMESIZE],
+        pub ut_host: [::c_char; UT_HOSTSIZE],
+        pub ut_time: ::time_t,
+    }
+
+    pub union mount_info {
+        pub ufs_args: ufs_args,
+        pub mfs_args: mfs_args,
+        pub nfs_args: nfs_args,
+        pub iso_args: iso_args,
+        pub msdosfs_args: msdosfs_args,
+        pub ntfs_args: ntfs_args,
+        pub tmpfs_args: tmpfs_args,
+        align: [::c_char; 160],
+    }
+
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_fileno == other.d_fileno
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self.d_namlen == other.d_namlen
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for dirent {}
+
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_fileno", &self.d_fileno)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                    .field("d_namlen", &self.d_namlen)
+                // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_fileno.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_namlen.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_len == other.ss_len
+                    && self.ss_family == other.ss_family
+            }
+        }
+
+        impl Eq for sockaddr_storage {}
+
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_len", &self.ss_len)
+                    .field("ss_family", &self.ss_family)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_len.hash(state);
+                self.ss_family.hash(state);
+            }
+        }
+
+        impl PartialEq for siginfo_t {
+            fn eq(&self, other: &siginfo_t) -> bool {
+                self.si_signo == other.si_signo
+                    && self.si_code == other.si_code
+                    && self.si_errno == other.si_errno
+                    && self.si_addr == other.si_addr
+            }
+        }
+
+        impl Eq for siginfo_t {}
+
+        impl ::fmt::Debug for siginfo_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("siginfo_t")
+                    .field("si_signo", &self.si_signo)
+                    .field("si_code", &self.si_code)
+                    .field("si_errno", &self.si_errno)
+                    .field("si_addr", &self.si_addr)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for siginfo_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.si_signo.hash(state);
+                self.si_code.hash(state);
+                self.si_errno.hash(state);
+                self.si_addr.hash(state);
+            }
+        }
+
+        impl PartialEq for lastlog {
+            fn eq(&self, other: &lastlog) -> bool {
+                self.ll_time == other.ll_time
+                    && self
+                    .ll_line
+                    .iter()
+                    .zip(other.ll_line.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .ll_host
+                    .iter()
+                    .zip(other.ll_host.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for lastlog {}
+
+        impl ::fmt::Debug for lastlog {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("lastlog")
+                    .field("ll_time", &self.ll_time)
+                // FIXME: .field("ll_line", &self.ll_line)
+                // FIXME: .field("ll_host", &self.ll_host)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for lastlog {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ll_time.hash(state);
+                self.ll_line.hash(state);
+                self.ll_host.hash(state);
+            }
+        }
+
+        impl PartialEq for utmp {
+            fn eq(&self, other: &utmp) -> bool {
+                self.ut_time == other.ut_time
+                    && self
+                    .ut_line
+                    .iter()
+                    .zip(other.ut_line.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .ut_name
+                    .iter()
+                    .zip(other.ut_name.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .ut_host
+                    .iter()
+                    .zip(other.ut_host.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for utmp {}
+
+        impl ::fmt::Debug for utmp {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmp")
+                // FIXME: .field("ut_line", &self.ut_line)
+                // FIXME: .field("ut_name", &self.ut_name)
+                // FIXME: .field("ut_host", &self.ut_host)
+                    .field("ut_time", &self.ut_time)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utmp {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_line.hash(state);
+                self.ut_name.hash(state);
+                self.ut_host.hash(state);
+                self.ut_time.hash(state);
+            }
+        }
+
+        impl PartialEq for mount_info {
+            fn eq(&self, other: &mount_info) -> bool {
+                unsafe {
+                    self.align
+                        .iter()
+                        .zip(other.align.iter())
+                        .all(|(a,b)| a == b)
+                }
+            }
+        }
+
+        impl Eq for mount_info { }
+
+        impl ::fmt::Debug for mount_info {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("mount_info")
+                // FIXME: .field("align", &self.align)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for mount_info {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                unsafe { self.align.hash(state) };
+            }
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        s_no_extra_traits! {
+            // This type uses the union mount_info:
+            pub struct statfs {
+                pub f_flags: u32,
+                pub f_bsize: u32,
+                pub f_iosize: u32,
+                pub f_blocks: u64,
+                pub f_bfree: u64,
+                pub f_bavail: i64,
+                pub f_files: u64,
+                pub f_ffree: u64,
+                pub f_favail: i64,
+                pub f_syncwrites: u64,
+                pub f_syncreads: u64,
+                pub f_asyncwrites: u64,
+                pub f_asyncreads: u64,
+                pub f_fsid: ::fsid_t,
+                pub f_namemax: u32,
+                pub f_owner: ::uid_t,
+                pub f_ctime: u64,
+                pub f_fstypename: [::c_char; 16],
+                pub f_mntonname: [::c_char; 90],
+                pub f_mntfromname: [::c_char; 90],
+                pub f_mntfromspec: [::c_char; 90],
+                pub mount_info: mount_info,
+            }
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for statfs {
+                    fn eq(&self, other: &statfs) -> bool {
+                        self.f_flags == other.f_flags
+                            && self.f_bsize == other.f_bsize
+                            && self.f_iosize == other.f_iosize
+                            && self.f_blocks == other.f_blocks
+                            && self.f_bfree == other.f_bfree
+                            && self.f_bavail == other.f_bavail
+                            && self.f_files == other.f_files
+                            && self.f_ffree == other.f_ffree
+                            && self.f_favail == other.f_favail
+                            && self.f_syncwrites == other.f_syncwrites
+                            && self.f_syncreads == other.f_syncreads
+                            && self.f_asyncwrites == other.f_asyncwrites
+                            && self.f_asyncreads == other.f_asyncreads
+                            && self.f_fsid == other.f_fsid
+                            && self.f_namemax == other.f_namemax
+                            && self.f_owner == other.f_owner
+                            && self.f_ctime == other.f_ctime
+                            && self.f_fstypename
+                            .iter()
+                            .zip(other.f_fstypename.iter())
+                            .all(|(a,b)| a == b)
+                            && self.f_mntonname
+                            .iter()
+                            .zip(other.f_mntonname.iter())
+                            .all(|(a,b)| a == b)
+                            && self.f_mntfromname
+                            .iter()
+                            .zip(other.f_mntfromname.iter())
+                            .all(|(a,b)| a == b)
+                            && self.f_mntfromspec
+                            .iter()
+                            .zip(other.f_mntfromspec.iter())
+                            .all(|(a,b)| a == b)
+                            && self.mount_info == other.mount_info
+                    }
+                }
+
+                impl Eq for statfs { }
+
+                impl ::fmt::Debug for statfs {
+                    fn fmt(&self, f: &mut ::fmt::Formatter)
+                           -> ::fmt::Result {
+                        f.debug_struct("statfs")
+                            .field("f_flags", &self.f_flags)
+                            .field("f_bsize", &self.f_bsize)
+                            .field("f_iosize", &self.f_iosize)
+                            .field("f_blocks", &self.f_blocks)
+                            .field("f_bfree", &self.f_bfree)
+                            .field("f_bavail", &self.f_bavail)
+                            .field("f_files", &self.f_files)
+                            .field("f_ffree", &self.f_ffree)
+                            .field("f_favail", &self.f_favail)
+                            .field("f_syncwrites", &self.f_syncwrites)
+                            .field("f_syncreads", &self.f_syncreads)
+                            .field("f_asyncwrites", &self.f_asyncwrites)
+                            .field("f_asyncreads", &self.f_asyncreads)
+                            .field("f_fsid", &self.f_fsid)
+                            .field("f_namemax", &self.f_namemax)
+                            .field("f_owner", &self.f_owner)
+                            .field("f_ctime", &self.f_ctime)
+                        // FIXME: .field("f_fstypename", &self.f_fstypename)
+                        // FIXME: .field("f_mntonname", &self.f_mntonname)
+                        // FIXME: .field("f_mntfromname", &self.f_mntfromname)
+                        // FIXME: .field("f_mntfromspec", &self.f_mntfromspec)
+                            .field("mount_info", &self.mount_info)
+                            .finish()
+                    }
+                }
+
+                impl ::hash::Hash for statfs {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.f_flags.hash(state);
+                        self.f_bsize.hash(state);
+                        self.f_iosize.hash(state);
+                        self.f_blocks.hash(state);
+                        self.f_bfree.hash(state);
+                        self.f_bavail.hash(state);
+                        self.f_files.hash(state);
+                        self.f_ffree.hash(state);
+                        self.f_favail.hash(state);
+                        self.f_syncwrites.hash(state);
+                        self.f_syncreads.hash(state);
+                        self.f_asyncwrites.hash(state);
+                        self.f_asyncreads.hash(state);
+                        self.f_fsid.hash(state);
+                        self.f_namemax.hash(state);
+                        self.f_owner.hash(state);
+                        self.f_ctime.hash(state);
+                        self.f_fstypename.hash(state);
+                        self.f_mntonname.hash(state);
+                        self.f_mntfromname.hash(state);
+                        self.f_mntfromspec.hash(state);
+                        self.mount_info.hash(state);
+                    }
+                }
+            }
+        }
+    }
+}
+
+pub const UT_NAMESIZE: usize = 32;
+pub const UT_LINESIZE: usize = 8;
+pub const UT_HOSTSIZE: usize = 256;
+
+pub const O_CLOEXEC: ::c_int = 0x10000;
+pub const O_DIRECTORY: ::c_int = 0x20000;
+pub const O_RSYNC: ::c_int = O_SYNC;
+
+pub const MS_SYNC: ::c_int = 0x0002;
+pub const MS_INVALIDATE: ::c_int = 0x0004;
+
+pub const POLLNORM: ::c_short = ::POLLRDNORM;
+
+pub const ENOATTR: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const EOVERFLOW: ::c_int = 87;
+pub const ECANCELED: ::c_int = 88;
+pub const EIDRM: ::c_int = 89;
+pub const ENOMSG: ::c_int = 90;
+pub const ENOTSUP: ::c_int = 91;
+pub const EBADMSG: ::c_int = 92;
+pub const ENOTRECOVERABLE: ::c_int = 93;
+pub const EOWNERDEAD: ::c_int = 94;
+pub const EPROTO: ::c_int = 95;
+pub const ELAST: ::c_int = 95;
+
+pub const F_DUPFD_CLOEXEC: ::c_int = 10;
+
+pub const UTIME_OMIT: c_long = -1;
+pub const UTIME_NOW: c_long = -2;
+
+pub const AT_FDCWD: ::c_int = -100;
+pub const AT_EACCESS: ::c_int = 0x01;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x02;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x04;
+pub const AT_REMOVEDIR: ::c_int = 0x08;
+
+#[deprecated(since = "0.2.64", note = "Not stable across OS versions")]
+pub const RLIM_NLIMITS: ::c_int = 9;
+
+pub const SO_TIMESTAMP: ::c_int = 0x0800;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_BINDANY: ::c_int = 0x1000;
+pub const SO_NETPROC: ::c_int = 0x1020;
+pub const SO_RTABLE: ::c_int = 0x1021;
+pub const SO_PEERCRED: ::c_int = 0x1022;
+pub const SO_SPLICE: ::c_int = 0x1023;
+
+// sys/netinet/in.h
+// Protocols (RFC 1700)
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+// IPPROTO_IP defined in src/unix/mod.rs
+/// Hop-by-hop option header
+pub const IPPROTO_HOPOPTS: ::c_int = 0;
+// IPPROTO_ICMP defined in src/unix/mod.rs
+/// group mgmt protocol
+pub const IPPROTO_IGMP: ::c_int = 2;
+/// gateway^2 (deprecated)
+pub const IPPROTO_GGP: ::c_int = 3;
+/// for compatibility
+pub const IPPROTO_IPIP: ::c_int = 4;
+// IPPROTO_TCP defined in src/unix/mod.rs
+/// exterior gateway protocol
+pub const IPPROTO_EGP: ::c_int = 8;
+/// pup
+pub const IPPROTO_PUP: ::c_int = 12;
+// IPPROTO_UDP defined in src/unix/mod.rs
+/// xns idp
+pub const IPPROTO_IDP: ::c_int = 22;
+/// tp-4 w/ class negotiation
+pub const IPPROTO_TP: ::c_int = 29;
+// IPPROTO_IPV6 defined in src/unix/mod.rs
+/// IP6 routing header
+pub const IPPROTO_ROUTING: ::c_int = 43;
+/// IP6 fragmentation header
+pub const IPPROTO_FRAGMENT: ::c_int = 44;
+/// resource reservation
+pub const IPPROTO_RSVP: ::c_int = 46;
+/// General Routing Encap.
+pub const IPPROTO_GRE: ::c_int = 47;
+/// IP6 Encap Sec. Payload
+pub const IPPROTO_ESP: ::c_int = 50;
+/// IP6 Auth Header
+pub const IPPROTO_AH: ::c_int = 51;
+/// IP Mobility RFC 2004
+pub const IPPROTO_MOBILE: ::c_int = 55;
+// IPPROTO_ICMPV6 defined in src/unix/mod.rs
+/// IP6 no next header
+pub const IPPROTO_NONE: ::c_int = 59;
+/// IP6 destination option
+pub const IPPROTO_DSTOPTS: ::c_int = 60;
+/// ISO cnlp
+pub const IPPROTO_EON: ::c_int = 80;
+/// Ethernet-in-IP
+pub const IPPROTO_ETHERIP: ::c_int = 97;
+/// encapsulation header
+pub const IPPROTO_ENCAP: ::c_int = 98;
+/// Protocol indep. multicast
+pub const IPPROTO_PIM: ::c_int = 103;
+/// IP Payload Comp. Protocol
+pub const IPPROTO_IPCOMP: ::c_int = 108;
+/// CARP
+pub const IPPROTO_CARP: ::c_int = 112;
+/// unicast MPLS packet
+pub const IPPROTO_MPLS: ::c_int = 137;
+/// PFSYNC
+pub const IPPROTO_PFSYNC: ::c_int = 240;
+pub const IPPROTO_MAX: ::c_int = 256;
+
+// Only used internally, so it can be outside the range of valid IP protocols
+pub const IPPROTO_DIVERT: ::c_int = 258;
+
+pub const IP_RECVDSTADDR: ::c_int = 7;
+pub const IP_SENDSRCADDR: ::c_int = IP_RECVDSTADDR;
+pub const IP_RECVIF: ::c_int = 30;
+
+// sys/netinet/in.h
+pub const TCP_MD5SIG: ::c_int = 0x04;
+pub const TCP_NOPUSH: ::c_int = 0x10;
+
+pub const AF_ECMA: ::c_int = 8;
+pub const AF_ROUTE: ::c_int = 17;
+pub const AF_ENCAP: ::c_int = 28;
+pub const AF_SIP: ::c_int = 29;
+pub const AF_KEY: ::c_int = 30;
+pub const pseudo_AF_HDRCMPLT: ::c_int = 31;
+pub const AF_BLUETOOTH: ::c_int = 32;
+pub const AF_MPLS: ::c_int = 33;
+pub const pseudo_AF_PFLOW: ::c_int = 34;
+pub const pseudo_AF_PIPEX: ::c_int = 35;
+pub const NET_RT_DUMP: ::c_int = 1;
+pub const NET_RT_FLAGS: ::c_int = 2;
+pub const NET_RT_IFLIST: ::c_int = 3;
+pub const NET_RT_STATS: ::c_int = 4;
+pub const NET_RT_TABLE: ::c_int = 5;
+pub const NET_RT_IFNAMES: ::c_int = 6;
+#[doc(hidden)]
+pub const NET_RT_MAXID: ::c_int = 7;
+
+pub const IPV6_JOIN_GROUP: ::c_int = 12;
+pub const IPV6_LEAVE_GROUP: ::c_int = 13;
+
+pub const PF_ROUTE: ::c_int = AF_ROUTE;
+pub const PF_ECMA: ::c_int = AF_ECMA;
+pub const PF_ENCAP: ::c_int = AF_ENCAP;
+pub const PF_SIP: ::c_int = AF_SIP;
+pub const PF_KEY: ::c_int = AF_KEY;
+pub const PF_BPF: ::c_int = pseudo_AF_HDRCMPLT;
+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;
+pub const PF_MPLS: ::c_int = AF_MPLS;
+pub const PF_PFLOW: ::c_int = pseudo_AF_PFLOW;
+pub const PF_PIPEX: ::c_int = pseudo_AF_PIPEX;
+
+pub const SCM_TIMESTAMP: ::c_int = 0x04;
+
+pub const O_DSYNC: ::c_int = 128;
+
+pub const MAP_RENAME: ::c_int = 0x0000;
+pub const MAP_NORESERVE: ::c_int = 0x0000;
+pub const MAP_HASSEMAPHORE: ::c_int = 0x0000;
+
+pub const EIPSEC: ::c_int = 82;
+pub const ENOMEDIUM: ::c_int = 85;
+pub const EMEDIUMTYPE: ::c_int = 86;
+
+pub const EAI_BADFLAGS: ::c_int = -1;
+pub const EAI_NONAME: ::c_int = -2;
+pub const EAI_AGAIN: ::c_int = -3;
+pub const EAI_FAIL: ::c_int = -4;
+pub const EAI_NODATA: ::c_int = -5;
+pub const EAI_FAMILY: ::c_int = -6;
+pub const EAI_SOCKTYPE: ::c_int = -7;
+pub const EAI_SERVICE: ::c_int = -8;
+pub const EAI_MEMORY: ::c_int = -10;
+pub const EAI_SYSTEM: ::c_int = -11;
+pub const EAI_OVERFLOW: ::c_int = -14;
+
+pub const RUSAGE_THREAD: ::c_int = 1;
+
+pub const MAP_COPY: ::c_int = 0x0002;
+pub const MAP_NOEXTEND: ::c_int = 0x0000;
+
+pub const _PC_LINK_MAX: ::c_int = 1;
+pub const _PC_MAX_CANON: ::c_int = 2;
+pub const _PC_MAX_INPUT: ::c_int = 3;
+pub const _PC_NAME_MAX: ::c_int = 4;
+pub const _PC_PATH_MAX: ::c_int = 5;
+pub const _PC_PIPE_BUF: ::c_int = 6;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 7;
+pub const _PC_NO_TRUNC: ::c_int = 8;
+pub const _PC_VDISABLE: ::c_int = 9;
+pub const _PC_2_SYMLINKS: ::c_int = 10;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 11;
+pub const _PC_ASYNC_IO: ::c_int = 12;
+pub const _PC_FILESIZEBITS: ::c_int = 13;
+pub const _PC_PRIO_IO: ::c_int = 14;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 15;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 16;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 17;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 18;
+pub const _PC_SYMLINK_MAX: ::c_int = 19;
+pub const _PC_SYNC_IO: ::c_int = 20;
+pub const _PC_TIMESTAMP_RESOLUTION: ::c_int = 21;
+
+pub const _SC_CLK_TCK: ::c_int = 3;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 31;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 32;
+pub const _SC_HOST_NAME_MAX: ::c_int = 33;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 34;
+pub const _SC_2_PBS: ::c_int = 35;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 36;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 37;
+pub const _SC_2_PBS_LOCATE: ::c_int = 38;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 39;
+pub const _SC_2_PBS_TRACK: ::c_int = 40;
+pub const _SC_ADVISORY_INFO: ::c_int = 41;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 42;
+pub const _SC_AIO_MAX: ::c_int = 43;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 44;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 45;
+pub const _SC_ATEXIT_MAX: ::c_int = 46;
+pub const _SC_BARRIERS: ::c_int = 47;
+pub const _SC_CLOCK_SELECTION: ::c_int = 48;
+pub const _SC_CPUTIME: ::c_int = 49;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 50;
+pub const _SC_IOV_MAX: ::c_int = 51;
+pub const _SC_IPV6: ::c_int = 52;
+pub const _SC_MAPPED_FILES: ::c_int = 53;
+pub const _SC_MEMLOCK: ::c_int = 54;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 55;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 56;
+pub const _SC_MESSAGE_PASSING: ::c_int = 57;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 58;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 59;
+pub const _SC_PRIORITIZED_IO: ::c_int = 60;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 61;
+pub const _SC_RAW_SOCKETS: ::c_int = 62;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 63;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 64;
+pub const _SC_REGEXP: ::c_int = 65;
+pub const _SC_RTSIG_MAX: ::c_int = 66;
+pub const _SC_SEMAPHORES: ::c_int = 67;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 68;
+pub const _SC_SHELL: ::c_int = 69;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 70;
+pub const _SC_SPAWN: ::c_int = 71;
+pub const _SC_SPIN_LOCKS: ::c_int = 72;
+pub const _SC_SPORADIC_SERVER: ::c_int = 73;
+pub const _SC_SS_REPL_MAX: ::c_int = 74;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 75;
+pub const _SC_SYMLOOP_MAX: ::c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;
+pub const _SC_THREAD_CPUTIME: ::c_int = 79;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 80;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 81;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 82;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 83;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 84;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 85;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 86;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 87;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 88;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 89;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 90;
+pub const _SC_THREADS: ::c_int = 91;
+pub const _SC_TIMEOUTS: ::c_int = 92;
+pub const _SC_TIMER_MAX: ::c_int = 93;
+pub const _SC_TIMERS: ::c_int = 94;
+pub const _SC_TRACE: ::c_int = 95;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 96;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 97;
+pub const _SC_TRACE_INHERIT: ::c_int = 98;
+pub const _SC_TRACE_LOG: ::c_int = 99;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 100;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 101;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 102;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 103;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 104;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 105;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 106;
+pub const _SC_TTY_NAME_MAX: ::c_int = 107;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 108;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 109;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 110;
+pub const _SC_V6_LP64_OFF64: ::c_int = 111;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 112;
+pub const _SC_V7_ILP32_OFF32: ::c_int = 113;
+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 114;
+pub const _SC_V7_LP64_OFF64: ::c_int = 115;
+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 116;
+pub const _SC_XOPEN_CRYPT: ::c_int = 117;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 118;
+pub const _SC_XOPEN_LEGACY: ::c_int = 119;
+pub const _SC_XOPEN_REALTIME: ::c_int = 120;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 121;
+pub const _SC_XOPEN_STREAMS: ::c_int = 122;
+pub const _SC_XOPEN_UNIX: ::c_int = 123;
+pub const _SC_XOPEN_UUCP: ::c_int = 124;
+pub const _SC_XOPEN_VERSION: ::c_int = 125;
+pub const _SC_PHYS_PAGES: ::c_int = 500;
+pub const _SC_AVPHYS_PAGES: ::c_int = 501;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 502;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 503;
+
+pub const FD_SETSIZE: usize = 1024;
+
+pub const ST_NOSUID: ::c_ulong = 2;
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = 0 as *mut _;
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = 0 as *mut _;
+
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 3;
+pub const PTHREAD_MUTEX_STRICT_NP: ::c_int = 4;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_STRICT_NP;
+
+pub const EVFILT_AIO: i16 = -3;
+pub const EVFILT_PROC: i16 = -5;
+pub const EVFILT_READ: i16 = -1;
+pub const EVFILT_SIGNAL: i16 = -6;
+pub const EVFILT_TIMER: i16 = -7;
+pub const EVFILT_VNODE: i16 = -4;
+pub const EVFILT_WRITE: i16 = -2;
+
+pub const EV_ADD: u16 = 0x1;
+pub const EV_DELETE: u16 = 0x2;
+pub const EV_ENABLE: u16 = 0x4;
+pub const EV_DISABLE: u16 = 0x8;
+pub const EV_ONESHOT: u16 = 0x10;
+pub const EV_CLEAR: u16 = 0x20;
+pub const EV_RECEIPT: u16 = 0x40;
+pub const EV_DISPATCH: u16 = 0x80;
+pub const EV_FLAG1: u16 = 0x2000;
+pub const EV_ERROR: u16 = 0x4000;
+pub const EV_EOF: u16 = 0x8000;
+pub const EV_SYSFLAGS: u16 = 0xf000;
+
+pub const NOTE_LOWAT: u32 = 0x00000001;
+pub const NOTE_EOF: u32 = 0x00000002;
+pub const NOTE_DELETE: u32 = 0x00000001;
+pub const NOTE_WRITE: u32 = 0x00000002;
+pub const NOTE_EXTEND: u32 = 0x00000004;
+pub const NOTE_ATTRIB: u32 = 0x00000008;
+pub const NOTE_LINK: u32 = 0x00000010;
+pub const NOTE_RENAME: u32 = 0x00000020;
+pub const NOTE_REVOKE: u32 = 0x00000040;
+pub const NOTE_TRUNCATE: u32 = 0x00000080;
+pub const NOTE_EXIT: u32 = 0x80000000;
+pub const NOTE_FORK: u32 = 0x40000000;
+pub const NOTE_EXEC: u32 = 0x20000000;
+pub const NOTE_PDATAMASK: u32 = 0x000fffff;
+pub const NOTE_PCTRLMASK: u32 = 0xf0000000;
+pub const NOTE_TRACK: u32 = 0x00000001;
+pub const NOTE_TRACKERR: u32 = 0x00000002;
+pub const NOTE_CHILD: u32 = 0x00000004;
+
+pub const TMP_MAX: ::c_uint = 0x7fffffff;
+
+pub const NI_MAXHOST: ::size_t = 256;
+
+pub const RTLD_LOCAL: ::c_int = 0;
+
+pub const CTL_MAXNAME: ::c_int = 12;
+
+pub const CTLTYPE_NODE: ::c_int = 1;
+pub const CTLTYPE_INT: ::c_int = 2;
+pub const CTLTYPE_STRING: ::c_int = 3;
+pub const CTLTYPE_QUAD: ::c_int = 4;
+pub const CTLTYPE_STRUCT: ::c_int = 5;
+
+pub const CTL_UNSPEC: ::c_int = 0;
+pub const CTL_KERN: ::c_int = 1;
+pub const CTL_VM: ::c_int = 2;
+pub const CTL_FS: ::c_int = 3;
+pub const CTL_NET: ::c_int = 4;
+pub const CTL_DEBUG: ::c_int = 5;
+pub const CTL_HW: ::c_int = 6;
+pub const CTL_MACHDEP: ::c_int = 7;
+pub const CTL_DDB: ::c_int = 9;
+pub const CTL_VFS: ::c_int = 10;
+pub const CTL_MAXID: ::c_int = 11;
+
+pub const HW_NCPUONLINE: ::c_int = 25;
+
+pub const KERN_OSTYPE: ::c_int = 1;
+pub const KERN_OSRELEASE: ::c_int = 2;
+pub const KERN_OSREV: ::c_int = 3;
+pub const KERN_VERSION: ::c_int = 4;
+pub const KERN_MAXVNODES: ::c_int = 5;
+pub const KERN_MAXPROC: ::c_int = 6;
+pub const KERN_MAXFILES: ::c_int = 7;
+pub const KERN_ARGMAX: ::c_int = 8;
+pub const KERN_SECURELVL: ::c_int = 9;
+pub const KERN_HOSTNAME: ::c_int = 10;
+pub const KERN_HOSTID: ::c_int = 11;
+pub const KERN_CLOCKRATE: ::c_int = 12;
+pub const KERN_PROF: ::c_int = 16;
+pub const KERN_POSIX1: ::c_int = 17;
+pub const KERN_NGROUPS: ::c_int = 18;
+pub const KERN_JOB_CONTROL: ::c_int = 19;
+pub const KERN_SAVED_IDS: ::c_int = 20;
+pub const KERN_BOOTTIME: ::c_int = 21;
+pub const KERN_DOMAINNAME: ::c_int = 22;
+pub const KERN_MAXPARTITIONS: ::c_int = 23;
+pub const KERN_RAWPARTITION: ::c_int = 24;
+pub const KERN_MAXTHREAD: ::c_int = 25;
+pub const KERN_NTHREADS: ::c_int = 26;
+pub const KERN_OSVERSION: ::c_int = 27;
+pub const KERN_SOMAXCONN: ::c_int = 28;
+pub const KERN_SOMINCONN: ::c_int = 29;
+#[deprecated(since = "0.2.71", note = "Removed in OpenBSD 6.0")]
+pub const KERN_USERMOUNT: ::c_int = 30;
+pub const KERN_NOSUIDCOREDUMP: ::c_int = 32;
+pub const KERN_FSYNC: ::c_int = 33;
+pub const KERN_SYSVMSG: ::c_int = 34;
+pub const KERN_SYSVSEM: ::c_int = 35;
+pub const KERN_SYSVSHM: ::c_int = 36;
+#[deprecated(since = "0.2.71", note = "Removed in OpenBSD 6.0")]
+pub const KERN_ARND: ::c_int = 37;
+pub const KERN_MSGBUFSIZE: ::c_int = 38;
+pub const KERN_MALLOCSTATS: ::c_int = 39;
+pub const KERN_CPTIME: ::c_int = 40;
+pub const KERN_NCHSTATS: ::c_int = 41;
+pub const KERN_FORKSTAT: ::c_int = 42;
+pub const KERN_NSELCOLL: ::c_int = 43;
+pub const KERN_TTY: ::c_int = 44;
+pub const KERN_CCPU: ::c_int = 45;
+pub const KERN_FSCALE: ::c_int = 46;
+pub const KERN_NPROCS: ::c_int = 47;
+pub const KERN_MSGBUF: ::c_int = 48;
+pub const KERN_POOL: ::c_int = 49;
+pub const KERN_STACKGAPRANDOM: ::c_int = 50;
+pub const KERN_SYSVIPC_INFO: ::c_int = 51;
+pub const KERN_SPLASSERT: ::c_int = 54;
+pub const KERN_PROC_ARGS: ::c_int = 55;
+pub const KERN_NFILES: ::c_int = 56;
+pub const KERN_TTYCOUNT: ::c_int = 57;
+pub const KERN_NUMVNODES: ::c_int = 58;
+pub const KERN_MBSTAT: ::c_int = 59;
+pub const KERN_SEMINFO: ::c_int = 61;
+pub const KERN_SHMINFO: ::c_int = 62;
+pub const KERN_INTRCNT: ::c_int = 63;
+pub const KERN_WATCHDOG: ::c_int = 64;
+pub const KERN_PROC: ::c_int = 66;
+pub const KERN_MAXCLUSTERS: ::c_int = 67;
+pub const KERN_EVCOUNT: ::c_int = 68;
+pub const KERN_TIMECOUNTER: ::c_int = 69;
+pub const KERN_MAXLOCKSPERUID: ::c_int = 70;
+pub const KERN_CPTIME2: ::c_int = 71;
+pub const KERN_CACHEPCT: ::c_int = 72;
+pub const KERN_FILE: ::c_int = 73;
+pub const KERN_CONSDEV: ::c_int = 75;
+pub const KERN_NETLIVELOCKS: ::c_int = 76;
+pub const KERN_POOL_DEBUG: ::c_int = 77;
+pub const KERN_PROC_CWD: ::c_int = 78;
+pub const KERN_PROC_NOBROADCASTKILL: ::c_int = 79;
+pub const KERN_PROC_VMMAP: ::c_int = 80;
+pub const KERN_GLOBAL_PTRACE: ::c_int = 81;
+pub const KERN_CONSBUFSIZE: ::c_int = 82;
+pub const KERN_CONSBUF: ::c_int = 83;
+pub const KERN_AUDIO: ::c_int = 84;
+pub const KERN_CPUSTATS: ::c_int = 85;
+pub const KERN_PFSTATUS: ::c_int = 86;
+pub const KERN_TIMEOUT_STATS: ::c_int = 87;
+pub const KERN_MAXID: ::c_int = 88;
+
+pub const KERN_PROC_ALL: ::c_int = 0;
+pub const KERN_PROC_PID: ::c_int = 1;
+pub const KERN_PROC_PGRP: ::c_int = 2;
+pub const KERN_PROC_SESSION: ::c_int = 3;
+pub const KERN_PROC_TTY: ::c_int = 4;
+pub const KERN_PROC_UID: ::c_int = 5;
+pub const KERN_PROC_RUID: ::c_int = 6;
+pub const KERN_PROC_KTHREAD: ::c_int = 7;
+pub const KERN_PROC_SHOW_THREADS: ::c_int = 0x40000000;
+
+pub const KERN_SYSVIPC_MSG_INFO: ::c_int = 1;
+pub const KERN_SYSVIPC_SEM_INFO: ::c_int = 2;
+pub const KERN_SYSVIPC_SHM_INFO: ::c_int = 3;
+
+pub const KERN_PROC_ARGV: ::c_int = 1;
+pub const KERN_PROC_NARGV: ::c_int = 2;
+pub const KERN_PROC_ENV: ::c_int = 3;
+pub const KERN_PROC_NENV: ::c_int = 4;
+
+pub const KI_NGROUPS: ::c_int = 16;
+pub const KI_MAXCOMLEN: ::c_int = 24;
+pub const KI_WMESGLEN: ::c_int = 8;
+pub const KI_MAXLOGNAME: ::c_int = 32;
+pub const KI_EMULNAMELEN: ::c_int = 8;
+
+pub const CHWFLOW: ::tcflag_t = ::MDMBUF | ::CRTSCTS;
+pub const OLCUC: ::tcflag_t = 0x20;
+pub const ONOCR: ::tcflag_t = 0x40;
+pub const ONLRET: ::tcflag_t = 0x80;
+
+//https://github.com/openbsd/src/blob/master/sys/sys/mount.h
+pub const ISOFSMNT_NORRIP: ::c_int = 0x1; // disable Rock Ridge Ext
+pub const ISOFSMNT_GENS: ::c_int = 0x2; // enable generation numbers
+pub const ISOFSMNT_EXTATT: ::c_int = 0x4; // enable extended attr
+pub const ISOFSMNT_NOJOLIET: ::c_int = 0x8; // disable Joliet Ext
+pub const ISOFSMNT_SESS: ::c_int = 0x10; // use iso_args.sess
+
+pub const NFS_ARGSVERSION: ::c_int = 4; // change when nfs_args changes
+
+pub const NFSMNT_RESVPORT: ::c_int = 0; // always use reserved ports
+pub const NFSMNT_SOFT: ::c_int = 0x1; // soft mount (hard is default)
+pub const NFSMNT_WSIZE: ::c_int = 0x2; // set write size
+pub const NFSMNT_RSIZE: ::c_int = 0x4; // set read size
+pub const NFSMNT_TIMEO: ::c_int = 0x8; // set initial timeout
+pub const NFSMNT_RETRANS: ::c_int = 0x10; // set number of request retries
+pub const NFSMNT_MAXGRPS: ::c_int = 0x20; // set maximum grouplist size
+pub const NFSMNT_INT: ::c_int = 0x40; // allow interrupts on hard mount
+pub const NFSMNT_NOCONN: ::c_int = 0x80; // Don't Connect the socket
+pub const NFSMNT_NQNFS: ::c_int = 0x100; // Use Nqnfs protocol
+pub const NFSMNT_NFSV3: ::c_int = 0x200; // Use NFS Version 3 protocol
+pub const NFSMNT_KERB: ::c_int = 0x400; // Use Kerberos authentication
+pub const NFSMNT_DUMBTIMR: ::c_int = 0x800; // Don't estimate rtt dynamically
+pub const NFSMNT_LEASETERM: ::c_int = 0x1000; // set lease term (nqnfs)
+pub const NFSMNT_READAHEAD: ::c_int = 0x2000; // set read ahead
+pub const NFSMNT_DEADTHRESH: ::c_int = 0x4000; // set dead server retry thresh
+pub const NFSMNT_NOAC: ::c_int = 0x8000; // disable attribute cache
+pub const NFSMNT_RDIRPLUS: ::c_int = 0x10000; // Use Readdirplus for V3
+pub const NFSMNT_READDIRSIZE: ::c_int = 0x20000; // Set readdir size
+
+/* Flags valid only in mount syscall arguments */
+pub const NFSMNT_ACREGMIN: ::c_int = 0x40000; // acregmin field valid
+pub const NFSMNT_ACREGMAX: ::c_int = 0x80000; // acregmax field valid
+pub const NFSMNT_ACDIRMIN: ::c_int = 0x100000; // acdirmin field valid
+pub const NFSMNT_ACDIRMAX: ::c_int = 0x200000; // acdirmax field valid
+
+/* Flags valid only in kernel */
+pub const NFSMNT_INTERNAL: ::c_int = 0xfffc0000; // Bits set internally
+pub const NFSMNT_HASWRITEVERF: ::c_int = 0x40000; // Has write verifier for V3
+pub const NFSMNT_GOTPATHCONF: ::c_int = 0x80000; // Got the V3 pathconf info
+pub const NFSMNT_GOTFSINFO: ::c_int = 0x100000; // Got the V3 fsinfo
+pub const NFSMNT_MNTD: ::c_int = 0x200000; // Mnt server for mnt point
+pub const NFSMNT_DISMINPROG: ::c_int = 0x400000; // Dismount in progress
+pub const NFSMNT_DISMNT: ::c_int = 0x800000; // Dismounted
+pub const NFSMNT_SNDLOCK: ::c_int = 0x1000000; // Send socket lock
+pub const NFSMNT_WANTSND: ::c_int = 0x2000000; // Want above
+pub const NFSMNT_RCVLOCK: ::c_int = 0x4000000; // Rcv socket lock
+pub const NFSMNT_WANTRCV: ::c_int = 0x8000000; // Want above
+pub const NFSMNT_WAITAUTH: ::c_int = 0x10000000; // Wait for authentication
+pub const NFSMNT_HASAUTH: ::c_int = 0x20000000; // Has authenticator
+pub const NFSMNT_WANTAUTH: ::c_int = 0x40000000; // Wants an authenticator
+pub const NFSMNT_AUTHERR: ::c_int = 0x80000000; // Authentication error
+
+pub const MSDOSFSMNT_SHORTNAME: ::c_int = 0x1; // Force old DOS short names only
+pub const MSDOSFSMNT_LONGNAME: ::c_int = 0x2; // Force Win'95 long names
+pub const MSDOSFSMNT_NOWIN95: ::c_int = 0x4; // Completely ignore Win95 entries
+
+pub const NTFS_MFLAG_CASEINS: ::c_int = 0x1;
+pub const NTFS_MFLAG_ALLNAMES: ::c_int = 0x2;
+
+pub const TMPFS_ARGS_VERSION: ::c_int = 1;
+
+pub const MAP_STACK: ::c_int = 0x4000;
+
+// https://github.com/openbsd/src/blob/master/sys/net/if.h#L187
+pub const IFF_UP: ::c_int = 0x1; // interface is up
+pub const IFF_BROADCAST: ::c_int = 0x2; // broadcast address valid
+pub const IFF_DEBUG: ::c_int = 0x4; // turn on debugging
+pub const IFF_LOOPBACK: ::c_int = 0x8; // is a loopback net
+pub const IFF_POINTOPOINT: ::c_int = 0x10; // interface is point-to-point link
+pub const IFF_STATICARP: ::c_int = 0x20; // only static ARP
+pub const IFF_RUNNING: ::c_int = 0x40; // resources allocated
+pub const IFF_NOARP: ::c_int = 0x80; // no address resolution protocol
+pub const IFF_PROMISC: ::c_int = 0x100; // receive all packets
+pub const IFF_ALLMULTI: ::c_int = 0x200; // receive all multicast packets
+pub const IFF_OACTIVE: ::c_int = 0x400; // transmission in progress
+pub const IFF_SIMPLEX: ::c_int = 0x800; // can't hear own transmissions
+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit
+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit
+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit
+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast
+
+pub const PTHREAD_STACK_MIN: ::size_t = 1_usize << _MAX_PAGE_SHIFT;
+pub const MINSIGSTKSZ: ::size_t = 3_usize << _MAX_PAGE_SHIFT;
+pub const SIGSTKSZ: ::size_t = MINSIGSTKSZ + (1_usize << _MAX_PAGE_SHIFT) * 4;
+
+pub const PT_FIRSTMACH: ::c_int = 32;
+
+pub const SOCK_CLOEXEC: ::c_int = 0x8000;
+pub const SOCK_NONBLOCK: ::c_int = 0x4000;
+pub const SOCK_DNS: ::c_int = 0x1000;
+
+pub const BIOCGRSIG: ::c_ulong = 0x40044273;
+pub const BIOCSRSIG: ::c_ulong = 0x80044272;
+pub const BIOCSDLT: ::c_ulong = 0x8004427a;
+
+pub const PTRACE_FORK: ::c_int = 0x0002;
+
+pub const WCONTINUED: ::c_int = 8;
+
+fn _ALIGN(p: usize) -> usize {
+    (p + _ALIGNBYTES) & !_ALIGNBYTES
+}
+
+f! {
+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {
+        (cmsg as *mut ::c_uchar)
+            .offset(_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        _ALIGN(::mem::size_of::<::cmsghdr>()) as ::c_uint + length
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)
+        -> *mut ::cmsghdr
+    {
+        if cmsg.is_null() {
+            return ::CMSG_FIRSTHDR(mhdr);
+        };
+        let next = cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize)
+            + _ALIGN(::mem::size_of::<::cmsghdr>());
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if next > max {
+            0 as *mut ::cmsghdr
+        } else {
+            (cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize))
+                as *mut ::cmsghdr
+        }
+    }
+
+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        (_ALIGN(::mem::size_of::<::cmsghdr>()) + _ALIGN(length as usize))
+            as ::c_uint
+    }
+}
+
+safe_f! {
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        status >> 8
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        (status & 0o177) != 0o177 && (status & 0o177) != 0
+    }
+
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        (status & 0xff) == 0o177
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        (status & 0o177777) == 0o177777
+    }
+}
+
+extern "C" {
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;
+    pub fn settimeofday(
+        tp: *const ::timeval,
+        tz: *const ::timezone,
+    ) -> ::c_int;
+    pub fn execvpe(
+        file: *const ::c_char,
+        argv: *const *const ::c_char,
+        envp: *const *const ::c_char,
+    ) -> ::c_int;
+    pub fn pledge(
+        promises: *const ::c_char,
+        execpromises: *const ::c_char,
+    ) -> ::c_int;
+    pub fn strtonum(
+        nptr: *const ::c_char,
+        minval: ::c_longlong,
+        maxval: ::c_longlong,
+        errstr: *mut *const ::c_char,
+    ) -> ::c_longlong;
+    pub fn dup3(src: ::c_int, dst: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn chflags(path: *const ::c_char, flags: ::c_uint) -> ::c_int;
+    pub fn fchflags(fd: ::c_int, flags: ::c_uint) -> ::c_int;
+    pub fn chflagsat(
+        fd: ::c_int,
+        path: *const ::c_char,
+        flags: ::c_uint,
+        atflag: ::c_int,
+    ) -> ::c_int;
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::size_t,
+        serv: *mut ::c_char,
+        servlen: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn kevent(
+        kq: ::c_int,
+        changelist: *const ::kevent,
+        nchanges: ::c_int,
+        eventlist: *mut ::kevent,
+        nevents: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const ::pthread_attr_t,
+        guardsize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstack(
+        attr: *const ::pthread_attr_t,
+        stackaddr: *mut *mut ::c_void,
+        stacksize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_main_np() -> ::c_int;
+    pub fn pthread_set_name_np(tid: ::pthread_t, name: *const ::c_char);
+    pub fn pthread_stackseg_np(
+        thread: ::pthread_t,
+        sinfo: *mut ::stack_t,
+    ) -> ::c_int;
+    pub fn sysctl(
+        name: *const ::c_int,
+        namelen: ::c_uint,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    pub fn getentropy(buf: *mut ::c_void, buflen: ::size_t) -> ::c_int;
+    pub fn setresgid(rgid: ::gid_t, egid: ::gid_t, sgid: ::gid_t) -> ::c_int;
+    pub fn setresuid(ruid: ::uid_t, euid: ::uid_t, suid: ::uid_t) -> ::c_int;
+    pub fn ptrace(
+        request: ::c_int,
+        pid: ::pid_t,
+        addr: caddr_t,
+        data: ::c_int,
+    ) -> ::c_int;
+    pub fn memmem(
+        haystack: *const ::c_void,
+        haystacklen: ::size_t,
+        needle: *const ::c_void,
+        needlelen: ::size_t,
+    ) -> *mut ::c_void;
+    // #include <link.h>
+    pub fn dl_iterate_phdr(
+        callback: ::Option<
+            unsafe extern "C" fn(
+                info: *mut dl_phdr_info,
+                size: usize,
+                data: *mut ::c_void,
+            ) -> ::c_int,
+        >,
+        data: *mut ::c_void,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        extern {
+            // these functions use statfs which uses the union mount_info:
+            pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;
+            pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "x86")] {
+        mod x86;
+        pub use self::x86::*;
+    } else if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(target_arch = "sparc64")] {
+        mod sparc64;
+        pub use self::sparc64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/bsd/netbsdlike/openbsd/sparc64.rs b/library/libc/src/unix/bsd/netbsdlike/openbsd/sparc64.rs
new file mode 100644
index 00000000..070fc938
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/openbsd/sparc64.rs
@@ -0,0 +1,8 @@
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type c_char = i8;
+
+#[doc(hidden)]
+pub const _ALIGNBYTES: usize = 0xf;
+
+pub const _MAX_PAGE_SHIFT: u32 = 13;
diff --git a/library/libc/src/unix/bsd/netbsdlike/openbsd/x86.rs b/library/libc/src/unix/bsd/netbsdlike/openbsd/x86.rs
new file mode 100644
index 00000000..e87d0ff1
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/openbsd/x86.rs
@@ -0,0 +1,16 @@
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type c_char = i8;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_int>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 4 - 1;
+    }
+}
+
+pub const _MAX_PAGE_SHIFT: u32 = 12;
diff --git a/library/libc/src/unix/bsd/netbsdlike/openbsd/x86_64.rs b/library/libc/src/unix/bsd/netbsdlike/openbsd/x86_64.rs
new file mode 100644
index 00000000..263b6e13
--- /dev/null
+++ b/library/libc/src/unix/bsd/netbsdlike/openbsd/x86_64.rs
@@ -0,0 +1,24 @@
+use PT_FIRSTMACH;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type c_char = i8;
+
+// should be pub(crate), but that requires Rust 1.18.0
+cfg_if! {
+    if #[cfg(libc_const_size_of)] {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;
+    } else {
+        #[doc(hidden)]
+        pub const _ALIGNBYTES: usize = 8 - 1;
+    }
+}
+
+pub const _MAX_PAGE_SHIFT: u32 = 12;
+
+pub const PT_STEP: ::c_int = PT_FIRSTMACH + 0;
+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 1;
+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 2;
+pub const PT_GETFPREGS: ::c_int = PT_FIRSTMACH + 3;
+pub const PT_SETFPREGS: ::c_int = PT_FIRSTMACH + 4;
diff --git a/library/libc/src/unix/haiku/b32.rs b/library/libc/src/unix/haiku/b32.rs
new file mode 100644
index 00000000..cce88648
--- /dev/null
+++ b/library/libc/src/unix/haiku/b32.rs
@@ -0,0 +1,3 @@
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type time_t = i32;
diff --git a/library/libc/src/unix/haiku/b64.rs b/library/libc/src/unix/haiku/b64.rs
new file mode 100644
index 00000000..3e66f14c
--- /dev/null
+++ b/library/libc/src/unix/haiku/b64.rs
@@ -0,0 +1,3 @@
+pub type c_ulong = u64;
+pub type c_long = i64;
+pub type time_t = i64;
diff --git a/library/libc/src/unix/haiku/mod.rs b/library/libc/src/unix/haiku/mod.rs
new file mode 100644
index 00000000..840e2f55
--- /dev/null
+++ b/library/libc/src/unix/haiku/mod.rs
@@ -0,0 +1,1555 @@
+pub type rlim_t = ::uintptr_t;
+pub type sa_family_t = u8;
+pub type pthread_key_t = ::c_int;
+pub type nfds_t = ::c_long;
+pub type tcflag_t = ::c_uint;
+pub type speed_t = ::c_uint;
+pub type c_char = i8;
+pub type clock_t = i32;
+pub type clockid_t = i32;
+pub type suseconds_t = i32;
+pub type wchar_t = i32;
+pub type off_t = i64;
+pub type ino_t = i64;
+pub type blkcnt_t = i64;
+pub type blksize_t = i32;
+pub type dev_t = i32;
+pub type mode_t = u32;
+pub type nlink_t = i32;
+pub type useconds_t = u32;
+pub type socklen_t = u32;
+pub type pthread_t = ::uintptr_t;
+pub type pthread_mutexattr_t = ::uintptr_t;
+pub type pthread_rwlockattr_t = ::uintptr_t;
+pub type sigset_t = u64;
+pub type fsblkcnt_t = i64;
+pub type fsfilcnt_t = i64;
+pub type pthread_attr_t = *mut ::c_void;
+pub type nl_item = ::c_int;
+pub type id_t = i32;
+pub type idtype_t = ::c_uint;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_addr(&self) -> *mut ::c_void {
+        self.si_addr
+    }
+
+    pub unsafe fn si_pid(&self) -> ::pid_t {
+        self.si_pid
+    }
+
+    pub unsafe fn si_uid(&self) -> ::uid_t {
+        self.si_uid
+    }
+
+    pub unsafe fn si_status(&self) -> ::c_int {
+        self.si_status
+    }
+}
+
+s! {
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct sockaddr {
+        pub sa_len: u8,
+        pub sa_family: sa_family_t,
+        pub sa_data: [::c_char; 30],
+    }
+
+    pub struct sockaddr_in {
+        pub sin_len: u8,
+        pub sin_family: sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [u8; 24],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_len: u8,
+        pub sin6_family: sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: socklen_t,
+        pub ai_canonname: *mut c_char,
+        pub ai_addr: *mut ::sockaddr,
+        pub ai_next: *mut addrinfo,
+    }
+
+    pub struct fd_set {
+        fds_bits: [c_ulong; FD_SETSIZE / ULONG_SIZE],
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+        pub tm_gmtoff: ::c_long,
+        pub tm_zone: *const ::c_char,
+    }
+
+    pub struct utsname {
+        pub sysname: [::c_char; 32],
+        pub nodename: [::c_char; 32],
+        pub release: [::c_char; 32],
+        pub version: [::c_char; 32],
+        pub machine: [::c_char; 32],
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::size_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line:  ::c_char,
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+        pub c_cc: [::cc_t; ::NCCS],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct stat {
+        pub st_dev: dev_t,
+        pub st_ino: ino_t,
+        pub st_mode: mode_t,
+        pub st_nlink: nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_size: off_t,
+        pub st_rdev: dev_t,
+        pub st_blksize: blksize_t,
+        pub st_atime: time_t,
+        pub st_atime_nsec: c_long,
+        pub st_mtime: time_t,
+        pub st_mtime_nsec: c_long,
+        pub st_ctime: time_t,
+        pub st_ctime_nsec: c_long,
+        pub st_crtime: time_t,
+        pub st_crtime_nsec: c_long,
+        pub st_type: u32,
+        pub st_blocks: blkcnt_t,
+    }
+
+    pub struct glob_t {
+        pub gl_pathc: ::size_t,
+        __unused1: ::size_t,
+        pub gl_offs: ::size_t,
+        __unused2: ::size_t,
+        pub gl_pathv: *mut *mut c_char,
+
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+        __unused6: *mut ::c_void,
+        __unused7: *mut ::c_void,
+        __unused8: *mut ::c_void,
+    }
+
+    pub struct pthread_mutex_t {
+        flags: u32,
+        lock: i32,
+        unused: i32,
+        owner: i32,
+        owner_count: i32,
+    }
+
+    pub struct pthread_cond_t {
+        flags: u32,
+        unused: i32,
+        mutex: *mut ::c_void,
+        waiter_count: i32,
+        lock: i32,
+    }
+
+    pub struct pthread_rwlock_t {
+        flags: u32,
+        owner: i32,
+        lock_sem: i32,      // this is actually a union
+        lock_count: i32,
+        reader_count: i32,
+        writer_count: i32,
+        waiters: [*mut ::c_void; 2],
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+        pub pw_gecos: *mut ::c_char,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_pid: ::pid_t,
+        pub si_uid: ::uid_t,
+        pub si_addr: *mut ::c_void,
+        pub si_status: ::c_int,
+        pub si_band: c_long,
+        pub sigval: *mut ::c_void,
+    }
+
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        sa_userdata: *mut ::c_void,
+    }
+
+    pub struct sem_t {
+        pub se_type: i32,
+        pub se_named_id: i32, // this is actually a union
+        pub se_unnamed: i32,
+        pub se_padding: [i32; 4],
+    }
+
+    pub struct pthread_condattr_t {
+        pub process_shared: bool,
+        pub clock_id: i32,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct sockaddr_un {
+        pub sun_len: u8,
+        pub sun_family: sa_family_t,
+        pub sun_path: [::c_char; 126]
+    }
+    pub struct sockaddr_storage {
+        pub ss_len: u8,
+        pub ss_family: sa_family_t,
+        __ss_pad1: [u8; 6],
+        __ss_pad2: u64,
+        __ss_pad3: [u8; 112],
+    }
+    pub struct dirent {
+        pub d_dev: dev_t,
+        pub d_pdev: dev_t,
+        pub d_ino: ino_t,
+        pub d_pino: i64,
+        pub d_reclen: ::c_ushort,
+        pub d_name: [::c_char; 1024], // Max length is _POSIX_PATH_MAX
+    }
+
+    pub struct sigevent {
+        pub sigev_notify: ::c_int,
+        pub sigev_signo: ::c_int,
+        pub sigev_value: ::sigval,
+        __unused1: *mut ::c_void, // actually a function pointer
+        pub sigev_notify_attributes: *mut ::pthread_attr_t,
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for sockaddr_un {
+            fn eq(&self, other: &sockaddr_un) -> bool {
+                self.sun_len == other.sun_len
+                    && self.sun_family == other.sun_family
+                    && self
+                    .sun_path
+                    .iter()
+                    .zip(other.sun_path.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_un {}
+        impl ::fmt::Debug for sockaddr_un {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_un")
+                    .field("sun_len", &self.sun_len)
+                    .field("sun_family", &self.sun_family)
+                    // FIXME: .field("sun_path", &self.sun_path)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_un {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sun_len.hash(state);
+                self.sun_family.hash(state);
+                self.sun_path.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_len == other.ss_len
+                    && self.ss_family == other.ss_family
+                    && self
+                    .__ss_pad1
+                    .iter()
+                    .zip(other.__ss_pad1.iter())
+                    .all(|(a, b)| a == b)
+                    && self.__ss_pad2 == other.__ss_pad2
+                    && self
+                    .__ss_pad3
+                    .iter()
+                    .zip(other.__ss_pad3.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_storage {}
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_len", &self.ss_len)
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_pad1", &self.__ss_pad1)
+                    .field("__ss_pad2", &self.__ss_pad2)
+                    // FIXME: .field("__ss_pad3", &self.__ss_pad3)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_len.hash(state);
+                self.ss_family.hash(state);
+                self.__ss_pad1.hash(state);
+                self.__ss_pad2.hash(state);
+                self.__ss_pad3.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_dev == other.d_dev
+                    && self.d_pdev == other.d_pdev
+                    && self.d_ino == other.d_ino
+                    && self.d_pino == other.d_pino
+                    && self.d_reclen == other.d_reclen
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_dev", &self.d_dev)
+                    .field("d_pdev", &self.d_pdev)
+                    .field("d_ino", &self.d_ino)
+                    .field("d_pino", &self.d_pino)
+                    .field("d_reclen", &self.d_reclen)
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_dev.hash(state);
+                self.d_pdev.hash(state);
+                self.d_ino.hash(state);
+                self.d_pino.hash(state);
+                self.d_reclen.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_notify == other.sigev_notify
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_value == other.sigev_value
+                    && self.sigev_notify_attributes
+                        == other.sigev_notify_attributes
+            }
+        }
+        impl Eq for sigevent {}
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_value", &self.sigev_value)
+                    .field("sigev_notify_attributes",
+                           &self.sigev_notify_attributes)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_notify.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_value.hash(state);
+                self.sigev_notify_attributes.hash(state);
+            }
+        }
+    }
+}
+
+// intentionally not public, only used for fd_set
+cfg_if! {
+    if #[cfg(target_pointer_width = "32")] {
+        const ULONG_SIZE: usize = 32;
+    } else if #[cfg(target_pointer_width = "64")] {
+        const ULONG_SIZE: usize = 64;
+    } else {
+        // Unknown target_pointer_width
+    }
+}
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const RAND_MAX: ::c_int = 2147483647;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 2;
+pub const _IOLBF: ::c_int = 1;
+
+pub const F_DUPFD: ::c_int = 0x0001;
+pub const F_GETFD: ::c_int = 0x0002;
+pub const F_SETFD: ::c_int = 0x0004;
+pub const F_GETFL: ::c_int = 0x0008;
+pub const F_SETFL: ::c_int = 0x0010;
+pub const F_GETLK: ::c_int = 0x0020;
+pub const F_SETLK: ::c_int = 0x0080;
+pub const F_SETLKW: ::c_int = 0x0100;
+pub const F_DUPFD_CLOEXEC: ::c_int = 0x0200;
+
+pub const F_RDLCK: ::c_int = 0x0040;
+pub const F_UNLCK: ::c_int = 0x0200;
+pub const F_WRLCK: ::c_int = 0x0400;
+
+pub const AT_FDCWD: ::c_int = -1;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x01;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x02;
+pub const AT_REMOVEDIR: ::c_int = 0x04;
+pub const AT_EACCESS: ::c_int = 0x08;
+
+pub const POLLIN: ::c_short = 0x0001;
+pub const POLLOUT: ::c_short = 0x0002;
+pub const POLLRDNORM: ::c_short = POLLIN;
+pub const POLLWRNORM: ::c_short = POLLOUT;
+pub const POLLRDBAND: ::c_short = 0x0008;
+pub const POLLWRBAND: ::c_short = 0x0010;
+pub const POLLPRI: ::c_short = 0x0020;
+pub const POLLERR: ::c_short = 0x0004;
+pub const POLLHUP: ::c_short = 0x0080;
+pub const POLLNVAL: ::c_short = 0x1000;
+
+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;
+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;
+
+pub const CLOCK_REALTIME: ::c_int = -1;
+pub const CLOCK_MONOTONIC: ::c_int = 0;
+
+pub const RLIMIT_CORE: ::c_int = 0;
+pub const RLIMIT_CPU: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_FSIZE: ::c_int = 3;
+pub const RLIMIT_NOFILE: ::c_int = 4;
+pub const RLIMIT_STACK: ::c_int = 5;
+pub const RLIMIT_AS: ::c_int = 6;
+// Haiku specific
+pub const RLIMIT_NOVMON: ::c_int = 7;
+pub const RLIMIT_NLIMITS: ::c_int = 8;
+
+pub const RUSAGE_SELF: ::c_int = 0;
+
+pub const RTLD_LAZY: ::c_int = 0;
+
+pub const NCCS: usize = 11;
+
+pub const O_RDONLY: ::c_int = 0x0000;
+pub const O_WRONLY: ::c_int = 0x0001;
+pub const O_RDWR: ::c_int = 0x0002;
+pub const O_ACCMODE: ::c_int = 0x0003;
+
+pub const O_EXCL: ::c_int = 0x0100;
+pub const O_CREAT: ::c_int = 0x0200;
+pub const O_TRUNC: ::c_int = 0x0400;
+pub const O_NOCTTY: ::c_int = 0x1000;
+pub const O_NOTRAVERSE: ::c_int = 0x2000;
+
+pub const O_CLOEXEC: ::c_int = 0x00000040;
+pub const O_NONBLOCK: ::c_int = 0x00000080;
+pub const O_APPEND: ::c_int = 0x00000800;
+pub const O_SYNC: ::c_int = 0x00010000;
+pub const O_RSYNC: ::c_int = 0x00020000;
+pub const O_DSYNC: ::c_int = 0x00040000;
+pub const O_NOFOLLOW: ::c_int = 0x00080000;
+pub const O_NOCACHE: ::c_int = 0x00100000;
+pub const O_DIRECTORY: ::c_int = 0x00200000;
+
+pub const S_IFIFO: ::mode_t = 4096;
+pub const S_IFCHR: ::mode_t = 8192;
+pub const S_IFBLK: ::mode_t = 24576;
+pub const S_IFDIR: ::mode_t = 16384;
+pub const S_IFREG: ::mode_t = 32768;
+pub const S_IFLNK: ::mode_t = 40960;
+pub const S_IFSOCK: ::mode_t = 49152;
+pub const S_IFMT: ::mode_t = 61440;
+pub const S_IRWXU: ::mode_t = 448;
+pub const S_IXUSR: ::mode_t = 64;
+pub const S_IWUSR: ::mode_t = 128;
+pub const S_IRUSR: ::mode_t = 256;
+pub const S_IRWXG: ::mode_t = 70;
+pub const S_IXGRP: ::mode_t = 10;
+pub const S_IWGRP: ::mode_t = 20;
+pub const S_IRGRP: ::mode_t = 40;
+pub const S_IRWXO: ::mode_t = 7;
+pub const S_IXOTH: ::mode_t = 1;
+pub const S_IWOTH: ::mode_t = 2;
+pub const S_IROTH: ::mode_t = 4;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGCHLD: ::c_int = 5;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGPIPE: ::c_int = 7;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSTOP: ::c_int = 10;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGCONT: ::c_int = 12;
+pub const SIGTSTP: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+pub const SIGTTIN: ::c_int = 16;
+pub const SIGTTOU: ::c_int = 17;
+pub const SIGUSR1: ::c_int = 18;
+pub const SIGUSR2: ::c_int = 19;
+pub const SIGWINCH: ::c_int = 20;
+pub const SIGKILLTHR: ::c_int = 21;
+pub const SIGTRAP: ::c_int = 22;
+pub const SIGPOLL: ::c_int = 23;
+pub const SIGPROF: ::c_int = 24;
+pub const SIGSYS: ::c_int = 25;
+pub const SIGURG: ::c_int = 26;
+pub const SIGVTALRM: ::c_int = 27;
+pub const SIGXCPU: ::c_int = 28;
+pub const SIGXFSZ: ::c_int = 29;
+pub const SIGBUS: ::c_int = 30;
+
+pub const SIG_BLOCK: ::c_int = 1;
+pub const SIG_UNBLOCK: ::c_int = 2;
+pub const SIG_SETMASK: ::c_int = 3;
+
+pub const SIGEV_NONE: ::c_int = 0;
+pub const SIGEV_SIGNAL: ::c_int = 1;
+pub const SIGEV_THREAD: ::c_int = 2;
+
+pub const EAI_AGAIN: ::c_int = 2;
+pub const EAI_BADFLAGS: ::c_int = 3;
+pub const EAI_FAIL: ::c_int = 4;
+pub const EAI_FAMILY: ::c_int = 5;
+pub const EAI_MEMORY: ::c_int = 6;
+pub const EAI_NODATA: ::c_int = 7;
+pub const EAI_NONAME: ::c_int = 8;
+pub const EAI_SERVICE: ::c_int = 9;
+pub const EAI_SOCKTYPE: ::c_int = 10;
+pub const EAI_SYSTEM: ::c_int = 11;
+pub const EAI_OVERFLOW: ::c_int = 14;
+
+pub const PROT_NONE: ::c_int = 0;
+pub const PROT_READ: ::c_int = 1;
+pub const PROT_WRITE: ::c_int = 2;
+pub const PROT_EXEC: ::c_int = 4;
+
+pub const LC_ALL: ::c_int = 0;
+pub const LC_COLLATE: ::c_int = 1;
+pub const LC_CTYPE: ::c_int = 2;
+pub const LC_MONETARY: ::c_int = 3;
+pub const LC_NUMERIC: ::c_int = 4;
+pub const LC_TIME: ::c_int = 5;
+pub const LC_MESSAGES: ::c_int = 6;
+
+// FIXME: Haiku does not have MAP_FILE, but libstd/os.rs requires it
+pub const MAP_FILE: ::c_int = 0x00;
+pub const MAP_SHARED: ::c_int = 0x01;
+pub const MAP_PRIVATE: ::c_int = 0x02;
+pub const MAP_FIXED: ::c_int = 0x04;
+pub const MAP_ANONYMOUS: ::c_int = 0x08;
+pub const MAP_ANON: ::c_int = MAP_ANONYMOUS;
+
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+pub const MS_ASYNC: ::c_int = 0x01;
+pub const MS_INVALIDATE: ::c_int = 0x04;
+pub const MS_SYNC: ::c_int = 0x02;
+
+pub const E2BIG: ::c_int = -2147454975;
+pub const ECHILD: ::c_int = -2147454974;
+pub const EDEADLK: ::c_int = -2147454973;
+pub const EFBIG: ::c_int = -2147454972;
+pub const EMLINK: ::c_int = -2147454971;
+pub const ENFILE: ::c_int = -2147454970;
+pub const ENODEV: ::c_int = -2147454969;
+pub const ENOLCK: ::c_int = -2147454968;
+pub const ENOSYS: ::c_int = -2147454967;
+pub const ENOTTY: ::c_int = -2147454966;
+pub const ENXIO: ::c_int = -2147454965;
+pub const ESPIPE: ::c_int = -2147454964;
+pub const ESRCH: ::c_int = -2147454963;
+pub const EFPOS: ::c_int = -2147457962;
+pub const ESIGPARM: ::c_int = -2147457961;
+pub const EDOM: ::c_int = -2147454960;
+pub const ERANGE: ::c_int = -2147454959;
+pub const EPROTOTYPE: ::c_int = -2147454958;
+pub const EPROTONOSUPPORT: ::c_int = -2147454957;
+pub const EPFNOSUPPORT: ::c_int = -2147454956;
+pub const EAFNOSUPPORT: ::c_int = -2147454955;
+pub const EADDRINUSE: ::c_int = -2147454954;
+pub const EADDRNOTAVAIL: ::c_int = -2147454953;
+pub const ENETDOWN: ::c_int = -2147454952;
+pub const ENETUNREACH: ::c_int = -2147454951;
+pub const ENETRESET: ::c_int = -2147454950;
+pub const ECONNABORTED: ::c_int = -2147454949;
+pub const ECONNRESET: ::c_int = -2147454948;
+pub const EISCONN: ::c_int = -2147454947;
+pub const ENOTCONN: ::c_int = -2147454946;
+pub const ESHUTDOWN: ::c_int = -2147454945;
+pub const ECONNREFUSED: ::c_int = -2147454944;
+pub const EHOSTUNREACH: ::c_int = -2147454943;
+pub const ENOPROTOOPT: ::c_int = -2147454942;
+pub const ENOBUFS: ::c_int = -2147454941;
+pub const EINPROGRESS: ::c_int = -2147454940;
+pub const EALREADY: ::c_int = -2147454939;
+pub const EILSEQ: ::c_int = -2147454938;
+pub const ENOMSG: ::c_int = -2147454937;
+pub const ESTALE: ::c_int = -2147454936;
+pub const EOVERFLOW: ::c_int = -2147454935;
+pub const EMSGSIZE: ::c_int = -2147454934;
+pub const EOPNOTSUPP: ::c_int = -2147454933;
+pub const ENOTSOCK: ::c_int = -2147454932;
+pub const EHOSTDOWN: ::c_int = -2147454931;
+pub const EBADMSG: ::c_int = -2147454930;
+pub const ECANCELED: ::c_int = -2147454929;
+pub const EDESTADDRREQ: ::c_int = -2147454928;
+pub const EDQUOT: ::c_int = -2147454927;
+pub const EIDRM: ::c_int = -2147454926;
+pub const EMULTIHOP: ::c_int = -2147454925;
+pub const ENODATA: ::c_int = -2147454924;
+pub const ENOLINK: ::c_int = -2147454923;
+pub const ENOSR: ::c_int = -2147454922;
+pub const ENOSTR: ::c_int = -2147454921;
+pub const ENOTSUP: ::c_int = -2147454920;
+pub const EPROTO: ::c_int = -2147454919;
+pub const ETIME: ::c_int = -2147454918;
+pub const ETXTBSY: ::c_int = -2147454917;
+pub const ENOATTR: ::c_int = -2147454916;
+
+// INT_MIN
+pub const ENOMEM: ::c_int = -2147454976;
+
+// POSIX errors that can be mapped to BeOS error codes
+pub const EACCES: ::c_int = -2147483646;
+pub const EINTR: ::c_int = -2147483638;
+pub const EIO: ::c_int = -2147483647;
+pub const EBUSY: ::c_int = -2147483634;
+pub const EFAULT: ::c_int = -2147478783;
+pub const ETIMEDOUT: ::c_int = -2147483639;
+pub const EAGAIN: ::c_int = -2147483637;
+pub const EWOULDBLOCK: ::c_int = -2147483637;
+pub const EBADF: ::c_int = -2147459072;
+pub const EEXIST: ::c_int = -2147459070;
+pub const EINVAL: ::c_int = -2147483643;
+pub const ENAMETOOLONG: ::c_int = -2147459068;
+pub const ENOENT: ::c_int = -2147459069;
+pub const EPERM: ::c_int = -2147483633;
+pub const ENOTDIR: ::c_int = -2147459067;
+pub const EISDIR: ::c_int = -2147459063;
+pub const ENOTEMPTY: ::c_int = -2147459066;
+pub const ENOSPC: ::c_int = -2147459065;
+pub const EROFS: ::c_int = -2147459064;
+pub const EMFILE: ::c_int = -2147459062;
+pub const EXDEV: ::c_int = -2147459061;
+pub const ELOOP: ::c_int = -2147459060;
+pub const ENOEXEC: ::c_int = -2147478782;
+pub const EPIPE: ::c_int = -2147459059;
+
+pub const IPPROTO_RAW: ::c_int = 255;
+
+// These are prefixed with POSIX_ on Haiku
+pub const MADV_NORMAL: ::c_int = 1;
+pub const MADV_SEQUENTIAL: ::c_int = 2;
+pub const MADV_RANDOM: ::c_int = 3;
+pub const MADV_WILLNEED: ::c_int = 4;
+pub const MADV_DONTNEED: ::c_int = 5;
+
+// https://github.com/haiku/haiku/blob/master/headers/posix/net/if.h#L80
+pub const IFF_UP: ::c_int = 0x0001;
+pub const IFF_BROADCAST: ::c_int = 0x0002; // valid broadcast address
+pub const IFF_LOOPBACK: ::c_int = 0x0008;
+pub const IFF_POINTOPOINT: ::c_int = 0x0010; // point-to-point link
+pub const IFF_NOARP: ::c_int = 0x0040; // no address resolution
+pub const IFF_AUTOUP: ::c_int = 0x0080; // auto dial
+pub const IFF_PROMISC: ::c_int = 0x0100; // receive all packets
+pub const IFF_ALLMULTI: ::c_int = 0x0200; // receive all multicast packets
+pub const IFF_SIMPLEX: ::c_int = 0x0800; // doesn't receive own transmissions
+pub const IFF_LINK: ::c_int = 0x1000; // has link
+pub const IFF_AUTO_CONFIGURED: ::c_int = 0x2000;
+pub const IFF_CONFIGURING: ::c_int = 0x4000;
+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_INET: ::c_int = 1;
+pub const AF_APPLETALK: ::c_int = 2;
+pub const AF_ROUTE: ::c_int = 3;
+pub const AF_LINK: ::c_int = 4;
+pub const AF_INET6: ::c_int = 5;
+pub const AF_DLI: ::c_int = 6;
+pub const AF_IPX: ::c_int = 7;
+pub const AF_NOTIFY: ::c_int = 8;
+pub const AF_LOCAL: ::c_int = 9;
+pub const AF_UNIX: ::c_int = AF_LOCAL;
+pub const AF_BLUETOOTH: ::c_int = 10;
+
+pub const IP_OPTIONS: ::c_int = 1;
+pub const IP_HDRINCL: ::c_int = 2;
+pub const IP_TOS: ::c_int = 3;
+pub const IP_TTL: ::c_int = 4;
+pub const IP_RECVOPTS: ::c_int = 5;
+pub const IP_RECVRETOPTS: ::c_int = 6;
+pub const IP_RECVDSTADDR: ::c_int = 7;
+pub const IP_RETOPTS: ::c_int = 8;
+pub const IP_MULTICAST_IF: ::c_int = 9;
+pub const IP_MULTICAST_TTL: ::c_int = 10;
+pub const IP_MULTICAST_LOOP: ::c_int = 11;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;
+pub const IP_BLOCK_SOURCE: ::c_int = 14;
+pub const IP_UNBLOCK_SOURCE: ::c_int = 15;
+pub const IP_ADD_SOURCE_MEMBERSHIP: ::c_int = 16;
+pub const IP_DROP_SOURCE_MEMBERSHIP: ::c_int = 17;
+
+pub const TCP_NODELAY: ::c_int = 0x01;
+pub const TCP_MAXSEG: ::c_int = 0x02;
+pub const TCP_NOPUSH: ::c_int = 0x04;
+pub const TCP_NOOPT: ::c_int = 0x08;
+
+pub const IPV6_MULTICAST_IF: ::c_int = 24;
+pub const IPV6_MULTICAST_HOPS: ::c_int = 25;
+pub const IPV6_MULTICAST_LOOP: ::c_int = 26;
+pub const IPV6_UNICAST_HOPS: ::c_int = 27;
+pub const IPV6_JOIN_GROUP: ::c_int = 28;
+pub const IPV6_LEAVE_GROUP: ::c_int = 29;
+pub const IPV6_V6ONLY: ::c_int = 30;
+pub const IPV6_PKTINFO: ::c_int = 31;
+pub const IPV6_RECVPKTINFO: ::c_int = 32;
+pub const IPV6_HOPLIMIT: ::c_int = 33;
+pub const IPV6_REVCHOPLIMIT: ::c_int = 34;
+pub const IPV6_HOPOPTS: ::c_int = 35;
+pub const IPV6_DSTOPTS: ::c_int = 36;
+pub const IPV6_RTHDR: ::c_int = 37;
+
+pub const MSG_OOB: ::c_int = 0x0001;
+pub const MSG_PEEK: ::c_int = 0x0002;
+pub const MSG_DONTROUTE: ::c_int = 0x0004;
+pub const MSG_EOR: ::c_int = 0x0008;
+pub const MSG_TRUNC: ::c_int = 0x0010;
+pub const MSG_CTRUNC: ::c_int = 0x0020;
+pub const MSG_WAITALL: ::c_int = 0x0040;
+pub const MSG_DONTWAIT: ::c_int = 0x0080;
+pub const MSG_BCAST: ::c_int = 0x0100;
+pub const MSG_MCAST: ::c_int = 0x0200;
+pub const MSG_EOF: ::c_int = 0x0400;
+pub const MSG_NOSIGNAL: ::c_int = 0x0800;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const LOCK_SH: ::c_int = 0x01;
+pub const LOCK_EX: ::c_int = 0x02;
+pub const LOCK_NB: ::c_int = 0x04;
+pub const LOCK_UN: ::c_int = 0x08;
+
+pub const SIGSTKSZ: ::size_t = 16384;
+
+pub const PATH_MAX: ::c_int = 1024;
+
+pub const SA_NOCLDSTOP: ::c_int = 0x01;
+pub const SA_NOCLDWAIT: ::c_int = 0x02;
+pub const SA_RESETHAND: ::c_int = 0x04;
+pub const SA_NODEFER: ::c_int = 0x08;
+pub const SA_RESTART: ::c_int = 0x10;
+pub const SA_ONSTACK: ::c_int = 0x20;
+pub const SA_SIGINFO: ::c_int = 0x40;
+pub const SA_NOMASK: ::c_int = SA_NODEFER;
+pub const SA_STACK: ::c_int = SA_ONSTACK;
+pub const SA_ONESHOT: ::c_int = SA_RESETHAND;
+
+pub const FD_SETSIZE: usize = 1024;
+
+pub const RTLD_LOCAL: ::c_int = 0x0;
+pub const RTLD_NOW: ::c_int = 0x1;
+pub const RTLD_GLOBAL: ::c_int = 0x2;
+pub const RTLD_DEFAULT: *mut ::c_void = 0isize as *mut ::c_void;
+
+pub const BUFSIZ: ::c_uint = 8192;
+pub const FILENAME_MAX: ::c_uint = 256;
+pub const FOPEN_MAX: ::c_uint = 128;
+pub const L_tmpnam: ::c_uint = 512;
+pub const TMP_MAX: ::c_uint = 32768;
+
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 1;
+pub const _PC_MAX_CANON: ::c_int = 2;
+pub const _PC_MAX_INPUT: ::c_int = 3;
+pub const _PC_NAME_MAX: ::c_int = 4;
+pub const _PC_NO_TRUNC: ::c_int = 5;
+pub const _PC_PATH_MAX: ::c_int = 6;
+pub const _PC_PIPE_BUF: ::c_int = 7;
+pub const _PC_VDISABLE: ::c_int = 8;
+pub const _PC_LINK_MAX: ::c_int = 25;
+pub const _PC_SYNC_IO: ::c_int = 26;
+pub const _PC_ASYNC_IO: ::c_int = 27;
+pub const _PC_PRIO_IO: ::c_int = 28;
+pub const _PC_SOCK_MAXBUF: ::c_int = 29;
+pub const _PC_FILESIZEBITS: ::c_int = 30;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 31;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 32;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 33;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 34;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 35;
+pub const _PC_SYMLINK_MAX: ::c_int = 36;
+pub const _PC_2_SYMLINKS: ::c_int = 37;
+pub const _PC_XATTR_EXISTS: ::c_int = 38;
+pub const _PC_XATTR_ENABLED: ::c_int = 39;
+
+pub const FIONBIO: ::c_int = 0xbe000000;
+
+pub const _SC_ARG_MAX: ::c_int = 15;
+pub const _SC_CHILD_MAX: ::c_int = 16;
+pub const _SC_CLK_TCK: ::c_int = 17;
+pub const _SC_JOB_CONTROL: ::c_int = 18;
+pub const _SC_NGROUPS_MAX: ::c_int = 19;
+pub const _SC_OPEN_MAX: ::c_int = 20;
+pub const _SC_SAVED_IDS: ::c_int = 21;
+pub const _SC_STREAM_MAX: ::c_int = 22;
+pub const _SC_TZNAME_MAX: ::c_int = 23;
+pub const _SC_VERSION: ::c_int = 24;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 25;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 26;
+pub const _SC_PAGESIZE: ::c_int = 27;
+pub const _SC_PAGE_SIZE: ::c_int = 27;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 28;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 29;
+pub const _SC_SEMAPHORES: ::c_int = 30;
+pub const _SC_THREADS: ::c_int = 31;
+pub const _SC_IOV_MAX: ::c_int = 32;
+pub const _SC_UIO_MAXIOV: ::c_int = 32;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 34;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 35;
+pub const _SC_ATEXIT_MAX: ::c_int = 37;
+pub const _SC_PASS_MAX: ::c_int = 39;
+pub const _SC_PHYS_PAGES: ::c_int = 40;
+pub const _SC_AVPHYS_PAGES: ::c_int = 41;
+pub const _SC_PIPE: ::c_int = 42;
+pub const _SC_SELECT: ::c_int = 43;
+pub const _SC_POLL: ::c_int = 44;
+pub const _SC_MAPPED_FILES: ::c_int = 45;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 46;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 47;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 48;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 49;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 50;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 51;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 52;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 53;
+pub const _SC_RTSIG_MAX: ::c_int = 54;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 55;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 56;
+pub const _SC_TIMER_MAX: ::c_int = 57;
+pub const _SC_TIMERS: ::c_int = 58;
+pub const _SC_CPUTIME: ::c_int = 59;
+pub const _SC_THREAD_CPUTIME: ::c_int = 60;
+pub const _SC_HOST_NAME_MAX: ::c_int = 61;
+pub const _SC_REGEXP: ::c_int = 62;
+pub const _SC_SYMLOOP_MAX: ::c_int = 63;
+pub const _SC_SHELL: ::c_int = 64;
+
+pub const PTHREAD_STACK_MIN: ::size_t = 8192;
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+    flags: 0,
+    lock: 0,
+    unused: -42,
+    owner: -1,
+    owner_count: 0,
+};
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+    flags: 0,
+    unused: -42,
+    mutex: 0 as *mut _,
+    waiter_count: 0,
+    lock: 0,
+};
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+    flags: 0,
+    owner: -1,
+    lock_sem: 0,
+    lock_count: 0,
+    reader_count: 0,
+    writer_count: 0,
+    waiters: [0 as *mut _; 2],
+};
+
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = 0;
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 1;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 3;
+
+pub const FIOCLEX: c_ulong = 0; // FIXME: does not exist on Haiku!
+
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_RAW: ::c_int = 3;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+pub const SOL_SOCKET: ::c_int = -1;
+pub const SO_ACCEPTCONN: ::c_int = 0x00000001;
+pub const SO_BROADCAST: ::c_int = 0x00000002;
+pub const SO_DEBUG: ::c_int = 0x00000004;
+pub const SO_DONTROUTE: ::c_int = 0x00000008;
+pub const SO_KEEPALIVE: ::c_int = 0x00000010;
+pub const SO_OOBINLINE: ::c_int = 0x00000020;
+pub const SO_REUSEADDR: ::c_int = 0x00000040;
+pub const SO_REUSEPORT: ::c_int = 0x00000080;
+pub const SO_USELOOPBACK: ::c_int = 0x00000100;
+pub const SO_LINGER: ::c_int = 0x00000200;
+pub const SO_SNDBUF: ::c_int = 0x40000001;
+pub const SO_SNDLOWAT: ::c_int = 0x40000002;
+pub const SO_SNDTIMEO: ::c_int = 0x40000003;
+pub const SO_RCVBUF: ::c_int = 0x40000004;
+pub const SO_RCVLOWAT: ::c_int = 0x40000005;
+pub const SO_RCVTIMEO: ::c_int = 0x40000006;
+pub const SO_ERROR: ::c_int = 0x40000007;
+pub const SO_TYPE: ::c_int = 0x40000008;
+pub const SO_NONBLOCK: ::c_int = 0x40000009;
+pub const SO_BINDTODEVICE: ::c_int = 0x4000000a;
+pub const SO_PEERCRED: ::c_int = 0x4000000b;
+
+pub const SCM_RIGHTS: ::c_int = 0x01;
+
+pub const NI_MAXHOST: ::size_t = 1025;
+
+pub const WNOHANG: ::c_int = 0x01;
+pub const WUNTRACED: ::c_int = 0x02;
+pub const WCONTINUED: ::c_int = 0x04;
+pub const WEXITED: ::c_int = 0x08;
+pub const WSTOPPED: ::c_int = 0x10;
+pub const WNOWAIT: ::c_int = 0x20;
+
+pub const CLD_EXITED: ::c_int = 60;
+pub const CLD_KILLED: ::c_int = 61;
+pub const CLD_DUMPED: ::c_int = 62;
+pub const CLD_TRAPPED: ::c_int = 63;
+pub const CLD_STOPPED: ::c_int = 64;
+pub const CLD_CONTINUED: ::c_int = 65;
+
+pub const P_ALL: idtype_t = 0;
+pub const P_PID: idtype_t = 1;
+pub const P_PGID: idtype_t = 2;
+
+pub const UTIME_OMIT: c_long = 1000000001;
+pub const UTIME_NOW: c_long = 1000000000;
+
+pub const VINTR: usize = 0;
+pub const VQUIT: usize = 1;
+pub const VERASE: usize = 2;
+pub const VKILL: usize = 3;
+pub const VEOF: usize = 4;
+pub const VEOL: usize = 5;
+pub const VMIN: usize = 4;
+pub const VTIME: usize = 5;
+pub const VEOL2: usize = 6;
+pub const VSWTCH: usize = 7;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VSUSP: usize = 10;
+
+pub const IGNBRK: ::tcflag_t = 0x01;
+pub const BRKINT: ::tcflag_t = 0x02;
+pub const IGNPAR: ::tcflag_t = 0x04;
+pub const PARMRK: ::tcflag_t = 0x08;
+pub const INPCK: ::tcflag_t = 0x10;
+pub const ISTRIP: ::tcflag_t = 0x20;
+pub const INLCR: ::tcflag_t = 0x40;
+pub const IGNCR: ::tcflag_t = 0x80;
+pub const ICRNL: ::tcflag_t = 0x100;
+pub const IUCLC: ::tcflag_t = 0x200;
+pub const IXON: ::tcflag_t = 0x400;
+pub const IXANY: ::tcflag_t = 0x800;
+pub const IXOFF: ::tcflag_t = 0x1000;
+
+pub const OPOST: ::tcflag_t = 0x00000001;
+pub const OLCUC: ::tcflag_t = 0x00000002;
+pub const ONLCR: ::tcflag_t = 0x00000004;
+pub const OCRNL: ::tcflag_t = 0x00000008;
+pub const ONOCR: ::tcflag_t = 0x00000010;
+pub const ONLRET: ::tcflag_t = 0x00000020;
+pub const OFILL: ::tcflag_t = 0x00000040;
+pub const OFDEL: ::tcflag_t = 0x00000080;
+pub const NLDLY: ::tcflag_t = 0x00000100;
+pub const NL0: ::tcflag_t = 0x00000000;
+pub const NL1: ::tcflag_t = 0x00000100;
+pub const CRDLY: ::tcflag_t = 0x00000600;
+pub const CR0: ::tcflag_t = 0x00000000;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const TABDLY: ::tcflag_t = 0x00001800;
+pub const TAB0: ::tcflag_t = 0x00000000;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const BSDLY: ::tcflag_t = 0x00002000;
+pub const BS0: ::tcflag_t = 0x00000000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VTDLY: ::tcflag_t = 0x00004000;
+pub const VT0: ::tcflag_t = 0x00000000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const FFDLY: ::tcflag_t = 0x00008000;
+pub const FF0: ::tcflag_t = 0x00000000;
+pub const FF1: ::tcflag_t = 0x00008000;
+
+pub const CSIZE: ::tcflag_t = 0x00000020;
+pub const CS5: ::tcflag_t = 0x00000000;
+pub const CS6: ::tcflag_t = 0x00000000;
+pub const CS7: ::tcflag_t = 0x00000000;
+pub const CS8: ::tcflag_t = 0x00000020;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const XLOBLK: ::tcflag_t = 0x00001000;
+pub const CTSFLOW: ::tcflag_t = 0x00002000;
+pub const RTSFLOW: ::tcflag_t = 0x00004000;
+pub const CRTSCTS: ::tcflag_t = RTSFLOW | CTSFLOW;
+
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const XCASE: ::tcflag_t = 0x00000004;
+pub const ECHO: ::tcflag_t = 0x00000008;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const IEXTEN: ::tcflag_t = 0x00000200;
+pub const ECHOCTL: ::tcflag_t = 0x00000400;
+pub const ECHOPRT: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00001000;
+pub const FLUSHO: ::tcflag_t = 0x00002000;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+
+pub const TCGB_CTS: ::c_int = 0x01;
+pub const TCGB_DSR: ::c_int = 0x02;
+pub const TCGB_RI: ::c_int = 0x04;
+pub const TCGB_DCD: ::c_int = 0x08;
+pub const TIOCM_CTS: ::c_int = TCGB_CTS;
+pub const TIOCM_CD: ::c_int = TCGB_DCD;
+pub const TIOCM_CAR: ::c_int = TIOCM_CD;
+pub const TIOCM_RI: ::c_int = TCGB_RI;
+pub const TIOCM_DSR: ::c_int = TCGB_DSR;
+pub const TIOCM_DTR: ::c_int = 0x10;
+pub const TIOCM_RTS: ::c_int = 0x20;
+
+pub const B0: speed_t = 0x00;
+pub const B50: speed_t = 0x01;
+pub const B75: speed_t = 0x02;
+pub const B110: speed_t = 0x03;
+pub const B134: speed_t = 0x04;
+pub const B150: speed_t = 0x05;
+pub const B200: speed_t = 0x06;
+pub const B300: speed_t = 0x07;
+pub const B600: speed_t = 0x08;
+pub const B1200: speed_t = 0x09;
+pub const B1800: speed_t = 0x0A;
+pub const B2400: speed_t = 0x0B;
+pub const B4800: speed_t = 0x0C;
+pub const B9600: speed_t = 0x0D;
+pub const B19200: speed_t = 0x0E;
+pub const B38400: speed_t = 0x0F;
+pub const B57600: speed_t = 0x10;
+pub const B115200: speed_t = 0x11;
+pub const B230400: speed_t = 0x12;
+pub const B31250: speed_t = 0x13;
+
+pub const TCSANOW: ::c_int = 0x01;
+pub const TCSADRAIN: ::c_int = 0x02;
+pub const TCSAFLUSH: ::c_int = 0x04;
+
+pub const TCOOFF: ::c_int = 0x01;
+pub const TCOON: ::c_int = 0x02;
+pub const TCIOFF: ::c_int = 0x04;
+pub const TCION: ::c_int = 0x08;
+
+pub const TCIFLUSH: ::c_int = 0x01;
+pub const TCOFLUSH: ::c_int = 0x02;
+pub const TCIOFLUSH: ::c_int = 0x03;
+
+pub const TCGETA: ::c_int = 0x8000;
+pub const TCSETA: ::c_int = TCGETA + 1;
+pub const TCSETAF: ::c_int = TCGETA + 2;
+pub const TCSETAW: ::c_int = TCGETA + 3;
+pub const TCWAITEVENT: ::c_int = TCGETA + 4;
+pub const TCSBRK: ::c_int = TCGETA + 5;
+pub const TCFLSH: ::c_int = TCGETA + 6;
+pub const TCXONC: ::c_int = TCGETA + 7;
+pub const TCQUERYCONNECTED: ::c_int = TCGETA + 8;
+pub const TCGETBITS: ::c_int = TCGETA + 9;
+pub const TCSETDTR: ::c_int = TCGETA + 10;
+pub const TCSETRTS: ::c_int = TCGETA + 11;
+pub const TIOCGWINSZ: ::c_int = TCGETA + 12;
+pub const TIOCSWINSZ: ::c_int = TCGETA + 13;
+pub const TCVTIME: ::c_int = TCGETA + 14;
+pub const TIOCGPGRP: ::c_int = TCGETA + 15;
+pub const TIOCSPGRP: ::c_int = TCGETA + 16;
+pub const TIOCSCTTY: ::c_int = TCGETA + 17;
+pub const TIOCMGET: ::c_int = TCGETA + 18;
+pub const TIOCMSET: ::c_int = TCGETA + 19;
+pub const TIOCSBRK: ::c_int = TCGETA + 20;
+pub const TIOCCBRK: ::c_int = TCGETA + 21;
+pub const TIOCMBIS: ::c_int = TCGETA + 22;
+pub const TIOCMBIC: ::c_int = TCGETA + 23;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+f! {
+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] &= !(1 << (fd % size));
+        return
+    }
+
+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0
+    }
+
+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] |= 1 << (fd % size);
+        return
+    }
+
+    pub fn FD_ZERO(set: *mut fd_set) -> () {
+        for slot in (*set).fds_bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+}
+
+safe_f! {
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & !0xff) == 0
+    }
+
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        status & 0xff
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        ((status >> 8) & 0xff) != 0
+    }
+
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        ((status >> 16) & 0xff) != 0
+    }
+
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        (status >> 16) & 0xff
+    }
+
+    // actually WIFCORED, but this is used everywhere else
+    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {
+        (status & 0x10000) != 0
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        (status & 0x20000) != 0
+    }
+}
+
+extern "C" {
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+    pub fn getpriority(which: ::c_int, who: id_t) -> ::c_int;
+    pub fn setpriority(
+        which: ::c_int,
+        who: id_t,
+        priority: ::c_int,
+    ) -> ::c_int;
+
+    pub fn utimensat(
+        fd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+    pub fn _errnop() -> *mut ::c_int;
+
+    pub fn abs(i: ::c_int) -> ::c_int;
+    pub fn atof(s: *const ::c_char) -> ::c_double;
+    pub fn labs(i: ::c_long) -> ::c_long;
+    pub fn rand() -> ::c_int;
+    pub fn srand(seed: ::c_uint);
+}
+
+#[link(name = "bsd")]
+extern "C" {
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+
+    pub fn clock_gettime(clk_id: ::c_int, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_settime(clk_id: ::c_int, tp: *const ::timespec) -> ::c_int;
+    pub fn pthread_create(
+        thread: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        f: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const ::pthread_attr_t,
+        guardsize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstack(
+        attr: *const ::pthread_attr_t,
+        stackaddr: *mut *mut ::c_void,
+        stacksize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getclock(
+        attr: *const pthread_condattr_t,
+        clock_id: *mut clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setclock(
+        attr: *mut pthread_condattr_t,
+        clock_id: ::clockid_t,
+    ) -> ::c_int;
+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;
+    pub fn setgroups(ngroups: ::size_t, ptr: *const ::gid_t) -> ::c_int;
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+    pub fn mprotect(
+        addr: *const ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::size_t,
+        serv: *mut ::c_char,
+        sevlen: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn waitid(
+        idtype: idtype_t,
+        id: id_t,
+        infop: *mut ::siginfo_t,
+        options: ::c_int,
+    ) -> ::c_int;
+
+    pub fn glob(
+        pattern: *const ::c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut ::glob_t,
+    ) -> ::c_int;
+    pub fn globfree(pglob: *mut ::glob_t);
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn posix_madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn shm_open(
+        name: *const ::c_char,
+        oflag: ::c_int,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;
+
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+    pub fn madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;
+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;
+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;
+
+    pub fn bind(
+        socket: ::c_int,
+        address: *const ::sockaddr,
+        address_len: ::socklen_t,
+    ) -> ::c_int;
+
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+
+    pub fn sendmsg(
+        fd: ::c_int,
+        msg: *const ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn recvmsg(
+        fd: ::c_int,
+        msg: *mut ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn execvpe(
+        file: *const ::c_char,
+        argv: *const *const ::c_char,
+        environment: *const *const ::c_char,
+    ) -> ::c_int;
+    pub fn getgrgid_r(
+        gid: ::gid_t,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;
+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;
+    pub fn getdtablesize() -> ::c_int;
+    pub fn getgrnam_r(
+        name: *const ::c_char,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;
+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;
+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;
+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    pub fn getpwnam_r(
+        name: *const ::c_char,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+    pub fn openpty(
+        amaster: *mut ::c_int,
+        aslave: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::c_int;
+    pub fn forkpty(
+        amaster: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::pid_t;
+    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "64")] {
+        mod b64;
+        pub use self::b64::*;
+    } else {
+        mod b32;
+        pub use self::b32::*;
+    }
+}
diff --git a/library/libc/src/unix/hermit/aarch64.rs b/library/libc/src/unix/hermit/aarch64.rs
new file mode 100644
index 00000000..1a92e3b4
--- /dev/null
+++ b/library/libc/src/unix/hermit/aarch64.rs
@@ -0,0 +1,2 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
diff --git a/library/libc/src/unix/hermit/mod.rs b/library/libc/src/unix/hermit/mod.rs
new file mode 100644
index 00000000..ad0fd14d
--- /dev/null
+++ b/library/libc/src/unix/hermit/mod.rs
@@ -0,0 +1,1043 @@
+// liblibc port for HermitCore (https://hermitcore.org)
+// HermitCore is a unikernel based on lwIP, newlib, and
+// pthread-embedded.
+// Consider these definitions when porting liblibc to another
+// lwIP/newlib/pte-based target.
+//
+// Ported by Colin Finck <colin.finck@rwth-aachen.de>
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+pub type speed_t = ::c_uint;
+pub type mode_t = u32;
+pub type dev_t = i16;
+pub type nfds_t = ::c_ulong;
+pub type socklen_t = u32;
+pub type sa_family_t = u8;
+pub type clock_t = c_ulong;
+pub type time_t = c_long;
+pub type suseconds_t = c_long;
+pub type off_t = i64;
+pub type rlim_t = ::c_ulonglong;
+pub type sigset_t = ::c_ulong;
+pub type ino_t = u16;
+pub type nlink_t = u16;
+pub type blksize_t = c_long;
+pub type blkcnt_t = c_long;
+pub type stat64 = stat;
+pub type clockid_t = c_ulong;
+pub type pthread_t = pte_handle_t;
+pub type pthread_attr_t = usize;
+pub type pthread_cond_t = usize;
+pub type pthread_condattr_t = usize;
+pub type pthread_key_t = usize;
+pub type pthread_mutex_t = usize;
+pub type pthread_mutexattr_t = usize;
+pub type pthread_rwlock_t = usize;
+pub type pthread_rwlockattr_t = usize;
+
+s_no_extra_traits! {
+    pub struct dirent {
+        pub d_ino: ::c_long,
+        pub d_off: off_t,
+        pub d_reclen: u16,
+        pub d_name: [::c_char; 256],
+    }
+
+    // Dummy
+    pub struct sockaddr_un {
+        pub sun_family: sa_family_t,
+        pub sun_path: [::c_char; 108],
+    }
+
+    pub struct sockaddr {
+        pub sa_len: u8,
+        pub sa_family: sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in {
+        pub sin_len: u8,
+        pub sin_family: sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [::c_char; 8],
+    }
+
+    pub struct fd_set {
+        fds_bits: [::c_ulong; FD_SETSIZE / ULONG_SIZE],
+    }
+
+    pub struct sockaddr_storage {
+        pub s2_len: u8,
+        pub ss_family: sa_family_t,
+        pub s2_data1: [::c_char; 2],
+        pub s2_data2: [u32; 3],
+        pub s2_data3: [u32; 3],
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: dev_t,
+        pub st_size: off_t,
+        pub st_atime: time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: blksize_t,
+        pub st_blocks: blkcnt_t,
+        pub st_spare4: [::c_long; 2],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_un {
+            fn eq(&self, other: &sockaddr_un) -> bool {
+                self.sun_family == other.sun_family
+                    && self
+                    .sun_path
+                    .iter()
+                    .zip(other.sun_path.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_un {}
+        impl ::fmt::Debug for sockaddr_un {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_un")
+                    .field("sun_family", &self.sun_family)
+                    // FIXME: .field("sun_path", &self.sun_path)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_un {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sun_family.hash(state);
+                self.sun_path.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr {
+            fn eq(&self, other: &sockaddr) -> bool {
+                self.sa_len == other.sa_len
+                    && self.sa_family == other.sa_family
+                    && self
+                    .sa_data
+                    .iter()
+                    .zip(other.sa_data.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr {}
+        impl ::fmt::Debug for sockaddr {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr")
+                    .field("sa_len", &self.sa_len)
+                    .field("sa_family", &self.sa_family)
+                    // FIXME: .field("sa_data", &self.sa_data)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sa_len.hash(state);
+                self.sa_family.hash(state);
+                self.sa_data.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_in {
+            fn eq(&self, other: &sockaddr_in) -> bool {
+                self.sin_len == other.sin_len
+                    && self.sin_family == other.sin_family
+                    && self.sin_port == other.sin_port
+                    && self.sin_addr == other.sin_addr
+                    && self
+                    .sin_zero
+                    .iter()
+                    .zip(other.sin_zero.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_in {}
+        impl ::fmt::Debug for sockaddr_in {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_in")
+                    .field("sin_len", &self.sin_len)
+                    .field("sin_family", &self.sin_family)
+                    .field("sin_port", &self.sin_port)
+                    .field("sin_addr", &self.sin_addr)
+                    // FIXME: .field("sin_zero", &self.sin_zero)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_in {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sin_len.hash(state);
+                self.sin_family.hash(state);
+                self.sin_port.hash(state);
+                self.sin_addr.hash(state);
+                self.sin_zero.hash(state);
+            }
+        }
+
+        impl PartialEq for fd_set {
+            fn eq(&self, other: &fd_set) -> bool {
+                self.fds_bits
+                    .iter()
+                    .zip(other.fds_bits.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for fd_set {}
+        impl ::fmt::Debug for fd_set {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("fd_set")
+                    // FIXME: .field("fds_bits", &self.fds_bits)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for fd_set {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.fds_bits.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.s2_len == other.s2_len
+                    && self.ss_family == other.ss_family
+                    && self.s2_data1
+                    .iter()
+                    .zip(other.s2_data1.iter())
+                    .all(|(a,b)| a == b)
+                    && self.s2_data2
+                    .iter()
+                    .zip(other.s2_data2.iter())
+                    .all(|(a,b)| a == b)
+                    && self.s2_data3
+                    .iter()
+                    .zip(other.s2_data3.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_storage {}
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("s2_len", &self.s2_len)
+                    .field("ss_family", &self.ss_family)
+                    // FIXME: .field("s2_data1", &self.s2_data1)
+                    // FIXME: .field("s2_data2", &self.s2_data2)
+                    // FIXME: .field("s2_data3", &self.s2_data3)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.s2_len.hash(state);
+                self.ss_family.hash(state);
+                self.s2_data1.hash(state);
+                self.s2_data2.hash(state);
+                self.s2_data3.hash(state);
+            }
+        }
+
+        impl PartialEq for stat {
+            fn eq(&self, other: &stat) -> bool {
+                self.st_dev == other.st_dev
+                    && self.st_ino == other.st_ino
+                    && self.st_mode == other.st_mode
+                    && self.st_nlink == other.st_nlink
+                    && self.st_uid == other.st_uid
+                    && self.st_gid == other.st_gid
+                    && self.st_rdev == other.st_rdev
+                    && self.st_size == other.st_size
+                    && self.st_atime == other.st_atime
+                    && self.st_atime_nsec == other.st_atime_nsec
+                    && self.st_mtime == other.st_mtime
+                    && self.st_mtime_nsec == other.st_mtime_nsec
+                    && self.st_ctime == other.st_ctime
+                    && self.st_ctime_nsec == other.st_ctime_nsec
+                    && self.st_blksize == other.st_blksize
+                    && self.st_blocks == other.st_blocks
+                    && self
+                    .st_spare4
+                    .iter()
+                    .zip(other.st_spare4.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for stat {}
+        impl ::fmt::Debug for stat {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("stat")
+                    .field("st_dev", &self.st_dev)
+                    .field("st_ino", &self.st_ino)
+                    .field("st_mode", &self.st_mode)
+                    .field("st_nlink", &self.st_nlink)
+                    .field("st_uid", &self.st_uid)
+                    .field("st_gid", &self.st_gid)
+                    .field("st_rdev", &self.st_rdev)
+                    .field("st_size", &self.st_size)
+                    .field("st_atime", &self.st_atime)
+                    .field("st_atime_nsec", &self.st_atime_nsec)
+                    .field("st_mtime", &self.st_mtime)
+                    .field("st_mtime_nsec", &self.st_mtime_nsec)
+                    .field("st_ctime", &self.st_ctime)
+                    .field("st_ctime_nsec", &self.st_ctime_nsec)
+                    .field("st_blksize", &self.st_blksize)
+                    .field("st_blocks", &self.st_blocks)
+                    // FIXME: .field("st_spare4", &self.st_spare4)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for stat {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.st_dev.hash(state);
+                self.st_ino.hash(state);
+                self.st_mode.hash(state);
+                self.st_nlink.hash(state);
+                self.st_uid.hash(state);
+                self.st_gid.hash(state);
+                self.st_rdev.hash(state);
+                self.st_size.hash(state);
+                self.st_atime.hash(state);
+                self.st_atime_nsec.hash(state);
+                self.st_mtime.hash(state);
+                self.st_mtime_nsec.hash(state);
+                self.st_ctime.hash(state);
+                self.st_ctime_nsec.hash(state);
+                self.st_blksize.hash(state);
+                self.st_blocks.hash(state);
+                self.st_spare4.hash(state);
+            }
+        }
+    }
+}
+
+s! {
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: socklen_t,
+        pub ai_addr: *mut ::sockaddr,
+        pub ai_canonname: *mut c_char,
+        pub ai_next: *mut addrinfo,
+    }
+
+    pub struct Dl_info {}
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct passwd { // Unverified
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct pte_handle_t {
+        pub p: usize,
+        pub x: ::c_uint,
+    }
+
+    pub struct sched_param {
+        pub sched_priority: ::c_int,
+    }
+
+    pub struct sem_t {
+        pub value: i32,
+        pub lock: usize,
+        pub sem: usize,
+    }
+
+    pub struct sigaction {
+        pub sa_flags: ::c_int,
+        pub sa_mask: sigset_t,
+        pub sa_handler: usize,
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_len: u8,
+        pub sin6_family: sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct statvfs {}
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+    }
+
+    pub struct tms {
+        pub tms_utime: ::clock_t,
+        pub tms_stime: ::clock_t,
+        pub tms_cutime: ::clock_t,
+        pub tms_cstime: ::clock_t,
+    }
+
+    pub struct termios {}
+
+    pub struct utsname {}
+}
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_INET: ::c_int = 2;
+pub const AF_INET6: ::c_int = 10;
+
+// Dummy
+pub const AF_UNIX: ::c_int = 1;
+
+pub const CLOCK_REALTIME: ::clockid_t = 1;
+pub const CLOCK_MONOTONIC: ::clockid_t = 4;
+
+// Dummy
+pub const EAI_SYSTEM: ::c_int = -11;
+
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EDOTDOT: ::c_int = 73;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+pub const F_GETOWN: ::c_int = 5;
+pub const F_SETOWN: ::c_int = 6;
+pub const F_GETLK: ::c_int = 7;
+pub const F_SETLK: ::c_int = 8;
+pub const F_SETLKW: ::c_int = 9;
+pub const F_RGETLK: ::c_int = 10;
+pub const F_RSETLK: ::c_int = 11;
+pub const F_CNVT: ::c_int = 12;
+pub const F_RSETLKW: ::c_int = 13;
+pub const F_DUPFD_CLOEXEC: ::c_int = 14;
+
+pub const FD_SETSIZE: usize = 1024;
+
+// Dummy
+pub const FIOCLEX: ::c_int = 0x5451;
+
+pub const FIONBIO: ::c_int = 0x8004667e;
+pub const FIONREAD: ::c_int = 0x4004667f;
+
+pub const IP_ADD_MEMBERSHIP: ::c_int = 3;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 4;
+
+pub const IP_TOS: ::c_int = 1;
+pub const IP_TTL: ::c_int = 2;
+
+pub const IP_MULTICAST_TTL: ::c_int = 5;
+pub const IP_MULTICAST_IF: ::c_int = 6;
+pub const IP_MULTICAST_LOOP: ::c_int = 7;
+
+pub const IPV6_JOIN_GROUP: ::c_int = 12;
+pub const IPV6_ADD_MEMBERSHIP: ::c_int = 12;
+pub const IPV6_LEAVE_GROUP: ::c_int = 13;
+pub const IPV6_DROP_MEMBERSHIP: ::c_int = 13;
+pub const IPV6_V6ONLY: ::c_int = 27;
+
+// Dummy
+pub const IPV6_MULTICAST_LOOP: ::c_int = 7;
+
+pub const MSG_PEEK: ::c_int = 0x01;
+pub const MSG_WAITALL: ::c_int = 0x02;
+pub const MSG_OOB: ::c_int = 0x04;
+pub const MSG_DONTWAIT: ::c_int = 0x08;
+pub const MSG_MORE: ::c_int = 0x10;
+
+pub const O_ACCMODE: ::c_int = 3;
+pub const O_RDONLY: ::c_int = 0;
+pub const O_WRONLY: ::c_int = 1;
+pub const O_RDWR: ::c_int = 2;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_TRUNC: ::c_int = 512;
+pub const O_CLOEXEC: ::c_int = 524288;
+
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLPRI: ::c_short = 0x2;
+pub const POLLOUT: ::c_short = 0x4;
+pub const POLLERR: ::c_short = 0x8;
+pub const POLLHUP: ::c_short = 0x10;
+pub const POLLNVAL: ::c_short = 0x20;
+
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = usize::max_value();
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = usize::max_value();
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = usize::max_value();
+
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;
+pub const PTHREAD_STACK_MIN: ::size_t = 0;
+
+// Dummy
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+
+pub const _SC_ARG_MAX: ::c_int = 0;
+pub const _SC_CHILD_MAX: ::c_int = 1;
+pub const _SC_CLK_TCK: ::c_int = 2;
+pub const _SC_NGROUPS_MAX: ::c_int = 3;
+pub const _SC_OPEN_MAX: ::c_int = 4;
+pub const _SC_JOB_CONTROL: ::c_int = 5;
+pub const _SC_SAVED_IDS: ::c_int = 6;
+pub const _SC_VERSION: ::c_int = 7;
+pub const _SC_PAGESIZE: ::c_int = 8;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 9;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 10;
+pub const _SC_PHYS_PAGES: ::c_int = 11;
+pub const _SC_AVPHYS_PAGES: ::c_int = 12;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 13;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 14;
+pub const _SC_RTSIG_MAX: ::c_int = 15;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 16;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 17;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 18;
+pub const _SC_TIMER_MAX: ::c_int = 19;
+pub const _SC_TZNAME_MAX: ::c_int = 20;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 21;
+pub const _SC_FSYNC: ::c_int = 22;
+pub const _SC_MAPPED_FILES: ::c_int = 23;
+pub const _SC_MEMLOCK: ::c_int = 24;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 25;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 26;
+pub const _SC_MESSAGE_PASSING: ::c_int = 27;
+pub const _SC_PRIORITIZED_IO: ::c_int = 28;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 29;
+pub const _SC_SEMAPHORES: ::c_int = 30;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 31;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 32;
+pub const _SC_TIMERS: ::c_int = 33;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 34;
+pub const _SC_AIO_MAX: ::c_int = 35;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 36;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 37;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 38;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 39;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 40;
+pub const _SC_TTY_NAME_MAX: ::c_int = 41;
+pub const _SC_THREADS: ::c_int = 42;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 43;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 44;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 45;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 46;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 47;
+pub const _SC_THREAD_PRIO_CEILING: ::c_int = _SC_THREAD_PRIO_PROTECT;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 48;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 49;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 50;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 51;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 52;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 53;
+pub const _SC_ADVISORY_INFO: ::c_int = 54;
+pub const _SC_ATEXIT_MAX: ::c_int = 55;
+pub const _SC_BARRIERS: ::c_int = 56;
+pub const _SC_BC_BASE_MAX: ::c_int = 57;
+pub const _SC_BC_DIM_MAX: ::c_int = 58;
+pub const _SC_BC_SCALE_MAX: ::c_int = 59;
+pub const _SC_BC_STRING_MAX: ::c_int = 60;
+pub const _SC_CLOCK_SELECTION: ::c_int = 61;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 62;
+pub const _SC_CPUTIME: ::c_int = 63;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 64;
+pub const _SC_HOST_NAME_MAX: ::c_int = 65;
+pub const _SC_IOV_MAX: ::c_int = 66;
+pub const _SC_IPV6: ::c_int = 67;
+pub const _SC_LINE_MAX: ::c_int = 68;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 69;
+pub const _SC_RAW_SOCKETS: ::c_int = 70;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 71;
+pub const _SC_REGEXP: ::c_int = 72;
+pub const _SC_RE_DUP_MAX: ::c_int = 73;
+pub const _SC_SHELL: ::c_int = 74;
+pub const _SC_SPAWN: ::c_int = 75;
+pub const _SC_SPIN_LOCKS: ::c_int = 76;
+pub const _SC_SPORADIC_SERVER: ::c_int = 77;
+pub const _SC_SS_REPL_MAX: ::c_int = 78;
+pub const _SC_SYMLOOP_MAX: ::c_int = 79;
+pub const _SC_THREAD_CPUTIME: ::c_int = 80;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 81;
+pub const _SC_TIMEOUTS: ::c_int = 82;
+pub const _SC_TRACE: ::c_int = 83;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 84;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 85;
+pub const _SC_TRACE_INHERIT: ::c_int = 86;
+pub const _SC_TRACE_LOG: ::c_int = 87;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 88;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 89;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 90;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 91;
+pub const _SC_V7_ILP32_OFF32: ::c_int = 92;
+pub const _SC_V6_ILP32_OFF32: ::c_int = _SC_V7_ILP32_OFF32;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = _SC_V7_ILP32_OFF32;
+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 93;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = _SC_V7_ILP32_OFFBIG;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = _SC_V7_ILP32_OFFBIG;
+pub const _SC_V7_LP64_OFF64: ::c_int = 94;
+pub const _SC_V6_LP64_OFF64: ::c_int = _SC_V7_LP64_OFF64;
+pub const _SC_XBS5_LP64_OFF64: ::c_int = _SC_V7_LP64_OFF64;
+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 95;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = _SC_V7_LPBIG_OFFBIG;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = _SC_V7_LPBIG_OFFBIG;
+pub const _SC_XOPEN_CRYPT: ::c_int = 96;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 97;
+pub const _SC_XOPEN_LEGACY: ::c_int = 98;
+pub const _SC_XOPEN_REALTIME: ::c_int = 99;
+pub const _SC_STREAM_MAX: ::c_int = 100;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 101;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 102;
+pub const _SC_XOPEN_SHM: ::c_int = 103;
+pub const _SC_XOPEN_STREAMS: ::c_int = 104;
+pub const _SC_XOPEN_UNIX: ::c_int = 105;
+pub const _SC_XOPEN_VERSION: ::c_int = 106;
+pub const _SC_2_CHAR_TERM: ::c_int = 107;
+pub const _SC_2_C_BIND: ::c_int = 108;
+pub const _SC_2_C_DEV: ::c_int = 109;
+pub const _SC_2_FORT_DEV: ::c_int = 110;
+pub const _SC_2_FORT_RUN: ::c_int = 111;
+pub const _SC_2_LOCALEDEF: ::c_int = 112;
+pub const _SC_2_PBS: ::c_int = 113;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 114;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 115;
+pub const _SC_2_PBS_LOCATE: ::c_int = 116;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 117;
+pub const _SC_2_PBS_TRACK: ::c_int = 118;
+pub const _SC_2_SW_DEV: ::c_int = 119;
+pub const _SC_2_UPE: ::c_int = 120;
+pub const _SC_2_VERSION: ::c_int = 121;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 122;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 123;
+pub const _SC_XOPEN_UUCP: ::c_int = 124;
+pub const _SC_LEVEL1_ICACHE_SIZE: ::c_int = 125;
+pub const _SC_LEVEL1_ICACHE_ASSOC: ::c_int = 126;
+pub const _SC_LEVEL1_ICACHE_LINESIZE: ::c_int = 127;
+pub const _SC_LEVEL1_DCACHE_SIZE: ::c_int = 128;
+pub const _SC_LEVEL1_DCACHE_ASSOC: ::c_int = 129;
+pub const _SC_LEVEL1_DCACHE_LINESIZE: ::c_int = 130;
+pub const _SC_LEVEL2_CACHE_SIZE: ::c_int = 131;
+pub const _SC_LEVEL2_CACHE_ASSOC: ::c_int = 132;
+pub const _SC_LEVEL2_CACHE_LINESIZE: ::c_int = 133;
+pub const _SC_LEVEL3_CACHE_SIZE: ::c_int = 134;
+pub const _SC_LEVEL3_CACHE_ASSOC: ::c_int = 135;
+pub const _SC_LEVEL3_CACHE_LINESIZE: ::c_int = 136;
+pub const _SC_LEVEL4_CACHE_SIZE: ::c_int = 137;
+pub const _SC_LEVEL4_CACHE_ASSOC: ::c_int = 138;
+pub const _SC_LEVEL4_CACHE_LINESIZE: ::c_int = 139;
+
+pub const S_BLKSIZE: ::mode_t = 1024;
+pub const S_IREAD: ::mode_t = 256;
+pub const S_IWRITE: ::mode_t = 128;
+pub const S_IEXEC: ::mode_t = 64;
+pub const S_ENFMT: ::mode_t = 1024;
+pub const S_IFMT: ::mode_t = 61440;
+pub const S_IFDIR: ::mode_t = 16384;
+pub const S_IFCHR: ::mode_t = 8192;
+pub const S_IFBLK: ::mode_t = 24576;
+pub const S_IFREG: ::mode_t = 32768;
+pub const S_IFLNK: ::mode_t = 40960;
+pub const S_IFSOCK: ::mode_t = 49152;
+pub const S_IFIFO: ::mode_t = 4096;
+pub const S_IRUSR: ::mode_t = 256;
+pub const S_IWUSR: ::mode_t = 128;
+pub const S_IXUSR: ::mode_t = 64;
+pub const S_IRGRP: ::mode_t = 32;
+pub const S_IWGRP: ::mode_t = 16;
+pub const S_IXGRP: ::mode_t = 8;
+pub const S_IROTH: ::mode_t = 4;
+pub const S_IWOTH: ::mode_t = 2;
+pub const S_IXOTH: ::mode_t = 1;
+
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const SIG_SETMASK: ::c_int = 0;
+
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGEMT: ::c_int = 7;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+
+pub const SO_DEBUG: ::c_int = 0x0001;
+pub const SO_ACCEPTCONN: ::c_int = 0x0002;
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_USELOOPBACK: ::c_int = 0x0040;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_CONTIMEO: ::c_int = 0x1009;
+pub const SO_NO_CHECK: ::c_int = 0x100a;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_RAW: ::c_int = 3;
+
+pub const SOL_SOCKET: ::c_int = 0xfff;
+
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+
+pub const TCP_NODELAY: ::c_int = 0x01;
+pub const TCP_KEEPALIVE: ::c_int = 0x02;
+pub const TCP_KEEPIDLE: ::c_int = 0x03;
+pub const TCP_KEEPINTVL: ::c_int = 0x04;
+pub const TCP_KEEPCNT: ::c_int = 0x05;
+
+const ULONG_SIZE: usize = 64;
+
+pub const WNOHANG: ::c_int = 0x00000001;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+safe_f! {
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & 0xff) == 0
+    }
+
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        status & 0x7f
+    }
+}
+
+extern "C" {
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+
+    pub fn abs(i: ::c_int) -> ::c_int;
+    pub fn atof(s: *const ::c_char) -> ::c_double;
+    pub fn labs(i: ::c_long) -> ::c_long;
+    pub fn rand() -> ::c_int;
+    pub fn srand(seed: ::c_uint);
+
+    pub fn bind(
+        s: ::c_int,
+        name: *const ::sockaddr,
+        namelen: ::socklen_t,
+    ) -> ::c_int;
+
+    pub fn clock_gettime(
+        clock_id: ::clockid_t,
+        tp: *mut ::timespec,
+    ) -> ::c_int;
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+
+    // Dummy
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+
+    pub fn memalign(align: ::size_t, nbytes: ::size_t) -> *mut ::c_void;
+
+    pub fn pthread_create(
+        tid: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        start: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        arg: *mut ::c_void,
+    ) -> ::c_int;
+
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const ::sigset_t,
+        oset: *mut ::sigset_t,
+    ) -> ::c_int;
+
+    pub fn recvfrom(
+        s: ::c_int,
+        mem: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        from: *mut ::sockaddr,
+        fromlen: *mut ::socklen_t,
+    ) -> ::c_int;
+
+    pub fn setgroups(ngroups: ::c_int, grouplist: *const ::gid_t) -> ::c_int;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/hermit/x86_64.rs b/library/libc/src/unix/hermit/x86_64.rs
new file mode 100644
index 00000000..76ec3ce8
--- /dev/null
+++ b/library/libc/src/unix/hermit/x86_64.rs
@@ -0,0 +1,2 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
diff --git a/library/libc/src/unix/linux_like/android/b32/arm.rs b/library/libc/src/unix/linux_like/android/b32/arm.rs
new file mode 100644
index 00000000..aa9beb76
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b32/arm.rs
@@ -0,0 +1,523 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+pub type greg_t = i32;
+pub type mcontext_t = sigcontext;
+
+s! {
+    pub struct sigcontext {
+        pub trap_no: ::c_ulong,
+        pub error_code: ::c_ulong,
+        pub oldmask: ::c_ulong,
+        pub arm_r0: ::c_ulong,
+        pub arm_r1: ::c_ulong,
+        pub arm_r2: ::c_ulong,
+        pub arm_r3: ::c_ulong,
+        pub arm_r4: ::c_ulong,
+        pub arm_r5: ::c_ulong,
+        pub arm_r6: ::c_ulong,
+        pub arm_r7: ::c_ulong,
+        pub arm_r8: ::c_ulong,
+        pub arm_r9: ::c_ulong,
+        pub arm_r10: ::c_ulong,
+        pub arm_fp: ::c_ulong,
+        pub arm_ip: ::c_ulong,
+        pub arm_sp: ::c_ulong,
+        pub arm_lr: ::c_ulong,
+        pub arm_pc: ::c_ulong,
+        pub arm_cpsr: ::c_ulong,
+        pub fault_address: ::c_ulong,
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        s_no_extra_traits! {
+            pub struct __c_anonymous_uc_sigmask_with_padding {
+                pub uc_sigmask: ::sigset_t,
+                /* Android has a wrong (smaller) sigset_t on x86. */
+                __padding_rt_sigset: u32,
+            }
+
+            pub union __c_anonymous_uc_sigmask {
+                uc_sigmask: __c_anonymous_uc_sigmask_with_padding,
+                uc_sigmask64: ::sigset64_t,
+            }
+
+            pub struct ucontext_t {
+                pub uc_flags: ::c_ulong,
+                pub uc_link: *mut ucontext_t,
+                pub uc_stack: ::stack_t,
+                pub uc_mcontext: mcontext_t,
+                pub uc_sigmask__c_anonymous_union: __c_anonymous_uc_sigmask,
+                /* The kernel adds extra padding after uc_sigmask to match
+                 * glibc sigset_t on ARM. */
+                __padding: [c_char; 120],
+                __align: [::c_longlong; 0],
+                uc_regspace: [::c_ulong; 128],
+            }
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for __c_anonymous_uc_sigmask_with_padding {
+                    fn eq(
+                        &self, other: &__c_anonymous_uc_sigmask_with_padding
+                    ) -> bool {
+                        self.uc_sigmask == other.uc_sigmask
+                            // Ignore padding
+                    }
+                }
+                impl Eq for __c_anonymous_uc_sigmask_with_padding {}
+                impl ::fmt::Debug for __c_anonymous_uc_sigmask_with_padding {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("uc_sigmask_with_padding")
+                            .field("uc_sigmask_with_padding", &self.uc_sigmask)
+                            // Ignore padding
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for __c_anonymous_uc_sigmask_with_padding {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.uc_sigmask.hash(state)
+                            // Ignore padding
+                    }
+                }
+
+                impl PartialEq for __c_anonymous_uc_sigmask {
+                    fn eq(&self, other: &__c_anonymous_uc_sigmask) -> bool {
+                        unsafe { self.uc_sigmask == other.uc_sigmask }
+                    }
+                }
+                impl Eq for __c_anonymous_uc_sigmask {}
+                impl ::fmt::Debug for __c_anonymous_uc_sigmask {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("uc_sigmask")
+                            .field("uc_sigmask", unsafe { &self.uc_sigmask })
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for __c_anonymous_uc_sigmask {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        unsafe { self.uc_sigmask.hash(state) }
+                    }
+                }
+
+                impl PartialEq for ucontext_t {
+                    fn eq(&self, other: &Self) -> bool {
+                        self.uc_flags == other.uc_flags
+                            && self.uc_link == other.uc_link
+                            && self.uc_stack == other.uc_stack
+                            && self.uc_mcontext == other.uc_mcontext
+                            && self.uc_sigmask__c_anonymous_union
+                                == other.uc_sigmask__c_anonymous_union
+                            && &self.uc_regspace[..] == &other.uc_regspace[..]
+                            // Ignore padding field
+                    }
+                }
+                impl Eq for ucontext_t {}
+                impl ::fmt::Debug for ucontext_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("ucontext_t")
+                            .field("uc_flags", &self.uc_flags)
+                            .field("uc_link", &self.uc_link)
+                            .field("uc_stack", &self.uc_stack)
+                            .field("uc_mcontext", &self.uc_mcontext)
+                            .field(
+                                "uc_sigmask__c_anonymous_union",
+                                &self.uc_sigmask__c_anonymous_union
+                            )
+                            .field("uc_regspace", &&self.uc_regspace[..])
+                            // Ignore padding field
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for ucontext_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.uc_flags.hash(state);
+                        self.uc_link.hash(state);
+                        self.uc_stack.hash(state);
+                        self.uc_mcontext.hash(state);
+                        self.uc_sigmask__c_anonymous_union.hash(state);
+                        &self.uc_regspace[..].hash(state);
+                        // Ignore padding field
+                    }
+                }
+            }
+        }
+    }
+}
+
+pub const O_DIRECT: ::c_int = 0x10000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_LARGEFILE: ::c_int = 0o400000;
+
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_poll: ::c_long = 168;
+pub const SYS_nfsservctl: ::c_long = 169;
+pub const SYS_setresgid: ::c_long = 170;
+pub const SYS_getresgid: ::c_long = 171;
+pub const SYS_prctl: ::c_long = 172;
+pub const SYS_rt_sigreturn: ::c_long = 173;
+pub const SYS_rt_sigaction: ::c_long = 174;
+pub const SYS_rt_sigprocmask: ::c_long = 175;
+pub const SYS_rt_sigpending: ::c_long = 176;
+pub const SYS_rt_sigtimedwait: ::c_long = 177;
+pub const SYS_rt_sigqueueinfo: ::c_long = 178;
+pub const SYS_rt_sigsuspend: ::c_long = 179;
+pub const SYS_pread64: ::c_long = 180;
+pub const SYS_pwrite64: ::c_long = 181;
+pub const SYS_chown: ::c_long = 182;
+pub const SYS_getcwd: ::c_long = 183;
+pub const SYS_capget: ::c_long = 184;
+pub const SYS_capset: ::c_long = 185;
+pub const SYS_sigaltstack: ::c_long = 186;
+pub const SYS_sendfile: ::c_long = 187;
+pub const SYS_vfork: ::c_long = 190;
+pub const SYS_ugetrlimit: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_lchown32: ::c_long = 198;
+pub const SYS_getuid32: ::c_long = 199;
+pub const SYS_getgid32: ::c_long = 200;
+pub const SYS_geteuid32: ::c_long = 201;
+pub const SYS_getegid32: ::c_long = 202;
+pub const SYS_setreuid32: ::c_long = 203;
+pub const SYS_setregid32: ::c_long = 204;
+pub const SYS_getgroups32: ::c_long = 205;
+pub const SYS_setgroups32: ::c_long = 206;
+pub const SYS_fchown32: ::c_long = 207;
+pub const SYS_setresuid32: ::c_long = 208;
+pub const SYS_getresuid32: ::c_long = 209;
+pub const SYS_setresgid32: ::c_long = 210;
+pub const SYS_getresgid32: ::c_long = 211;
+pub const SYS_chown32: ::c_long = 212;
+pub const SYS_setuid32: ::c_long = 213;
+pub const SYS_setgid32: ::c_long = 214;
+pub const SYS_setfsuid32: ::c_long = 215;
+pub const SYS_setfsgid32: ::c_long = 216;
+pub const SYS_getdents64: ::c_long = 217;
+pub const SYS_pivot_root: ::c_long = 218;
+pub const SYS_mincore: ::c_long = 219;
+pub const SYS_madvise: ::c_long = 220;
+pub const SYS_fcntl64: ::c_long = 221;
+pub const SYS_gettid: ::c_long = 224;
+pub const SYS_readahead: ::c_long = 225;
+pub const SYS_setxattr: ::c_long = 226;
+pub const SYS_lsetxattr: ::c_long = 227;
+pub const SYS_fsetxattr: ::c_long = 228;
+pub const SYS_getxattr: ::c_long = 229;
+pub const SYS_lgetxattr: ::c_long = 230;
+pub const SYS_fgetxattr: ::c_long = 231;
+pub const SYS_listxattr: ::c_long = 232;
+pub const SYS_llistxattr: ::c_long = 233;
+pub const SYS_flistxattr: ::c_long = 234;
+pub const SYS_removexattr: ::c_long = 235;
+pub const SYS_lremovexattr: ::c_long = 236;
+pub const SYS_fremovexattr: ::c_long = 237;
+pub const SYS_tkill: ::c_long = 238;
+pub const SYS_sendfile64: ::c_long = 239;
+pub const SYS_futex: ::c_long = 240;
+pub const SYS_sched_setaffinity: ::c_long = 241;
+pub const SYS_sched_getaffinity: ::c_long = 242;
+pub const SYS_io_setup: ::c_long = 243;
+pub const SYS_io_destroy: ::c_long = 244;
+pub const SYS_io_getevents: ::c_long = 245;
+pub const SYS_io_submit: ::c_long = 246;
+pub const SYS_io_cancel: ::c_long = 247;
+pub const SYS_exit_group: ::c_long = 248;
+pub const SYS_lookup_dcookie: ::c_long = 249;
+pub const SYS_epoll_create: ::c_long = 250;
+pub const SYS_epoll_ctl: ::c_long = 251;
+pub const SYS_epoll_wait: ::c_long = 252;
+pub const SYS_remap_file_pages: ::c_long = 253;
+pub const SYS_set_tid_address: ::c_long = 256;
+pub const SYS_timer_create: ::c_long = 257;
+pub const SYS_timer_settime: ::c_long = 258;
+pub const SYS_timer_gettime: ::c_long = 259;
+pub const SYS_timer_getoverrun: ::c_long = 260;
+pub const SYS_timer_delete: ::c_long = 261;
+pub const SYS_clock_settime: ::c_long = 262;
+pub const SYS_clock_gettime: ::c_long = 263;
+pub const SYS_clock_getres: ::c_long = 264;
+pub const SYS_clock_nanosleep: ::c_long = 265;
+pub const SYS_statfs64: ::c_long = 266;
+pub const SYS_fstatfs64: ::c_long = 267;
+pub const SYS_tgkill: ::c_long = 268;
+pub const SYS_utimes: ::c_long = 269;
+pub const SYS_arm_fadvise64_64: ::c_long = 270;
+pub const SYS_pciconfig_iobase: ::c_long = 271;
+pub const SYS_pciconfig_read: ::c_long = 272;
+pub const SYS_pciconfig_write: ::c_long = 273;
+pub const SYS_mq_open: ::c_long = 274;
+pub const SYS_mq_unlink: ::c_long = 275;
+pub const SYS_mq_timedsend: ::c_long = 276;
+pub const SYS_mq_timedreceive: ::c_long = 277;
+pub const SYS_mq_notify: ::c_long = 278;
+pub const SYS_mq_getsetattr: ::c_long = 279;
+pub const SYS_waitid: ::c_long = 280;
+pub const SYS_socket: ::c_long = 281;
+pub const SYS_bind: ::c_long = 282;
+pub const SYS_connect: ::c_long = 283;
+pub const SYS_listen: ::c_long = 284;
+pub const SYS_accept: ::c_long = 285;
+pub const SYS_getsockname: ::c_long = 286;
+pub const SYS_getpeername: ::c_long = 287;
+pub const SYS_socketpair: ::c_long = 288;
+pub const SYS_send: ::c_long = 289;
+pub const SYS_sendto: ::c_long = 290;
+pub const SYS_recv: ::c_long = 291;
+pub const SYS_recvfrom: ::c_long = 292;
+pub const SYS_shutdown: ::c_long = 293;
+pub const SYS_setsockopt: ::c_long = 294;
+pub const SYS_getsockopt: ::c_long = 295;
+pub const SYS_sendmsg: ::c_long = 296;
+pub const SYS_recvmsg: ::c_long = 297;
+pub const SYS_semop: ::c_long = 298;
+pub const SYS_semget: ::c_long = 299;
+pub const SYS_semctl: ::c_long = 300;
+pub const SYS_msgsnd: ::c_long = 301;
+pub const SYS_msgrcv: ::c_long = 302;
+pub const SYS_msgget: ::c_long = 303;
+pub const SYS_msgctl: ::c_long = 304;
+pub const SYS_shmat: ::c_long = 305;
+pub const SYS_shmdt: ::c_long = 306;
+pub const SYS_shmget: ::c_long = 307;
+pub const SYS_shmctl: ::c_long = 308;
+pub const SYS_add_key: ::c_long = 309;
+pub const SYS_request_key: ::c_long = 310;
+pub const SYS_keyctl: ::c_long = 311;
+pub const SYS_semtimedop: ::c_long = 312;
+pub const SYS_vserver: ::c_long = 313;
+pub const SYS_ioprio_set: ::c_long = 314;
+pub const SYS_ioprio_get: ::c_long = 315;
+pub const SYS_inotify_init: ::c_long = 316;
+pub const SYS_inotify_add_watch: ::c_long = 317;
+pub const SYS_inotify_rm_watch: ::c_long = 318;
+pub const SYS_mbind: ::c_long = 319;
+pub const SYS_get_mempolicy: ::c_long = 320;
+pub const SYS_set_mempolicy: ::c_long = 321;
+pub const SYS_openat: ::c_long = 322;
+pub const SYS_mkdirat: ::c_long = 323;
+pub const SYS_mknodat: ::c_long = 324;
+pub const SYS_fchownat: ::c_long = 325;
+pub const SYS_futimesat: ::c_long = 326;
+pub const SYS_fstatat64: ::c_long = 327;
+pub const SYS_unlinkat: ::c_long = 328;
+pub const SYS_renameat: ::c_long = 329;
+pub const SYS_linkat: ::c_long = 330;
+pub const SYS_symlinkat: ::c_long = 331;
+pub const SYS_readlinkat: ::c_long = 332;
+pub const SYS_fchmodat: ::c_long = 333;
+pub const SYS_faccessat: ::c_long = 334;
+pub const SYS_pselect6: ::c_long = 335;
+pub const SYS_ppoll: ::c_long = 336;
+pub const SYS_unshare: ::c_long = 337;
+pub const SYS_set_robust_list: ::c_long = 338;
+pub const SYS_get_robust_list: ::c_long = 339;
+pub const SYS_splice: ::c_long = 340;
+pub const SYS_arm_sync_file_range: ::c_long = 341;
+pub const SYS_tee: ::c_long = 342;
+pub const SYS_vmsplice: ::c_long = 343;
+pub const SYS_move_pages: ::c_long = 344;
+pub const SYS_getcpu: ::c_long = 345;
+pub const SYS_epoll_pwait: ::c_long = 346;
+pub const SYS_kexec_load: ::c_long = 347;
+pub const SYS_utimensat: ::c_long = 348;
+pub const SYS_signalfd: ::c_long = 349;
+pub const SYS_timerfd_create: ::c_long = 350;
+pub const SYS_eventfd: ::c_long = 351;
+pub const SYS_fallocate: ::c_long = 352;
+pub const SYS_timerfd_settime: ::c_long = 353;
+pub const SYS_timerfd_gettime: ::c_long = 354;
+pub const SYS_signalfd4: ::c_long = 355;
+pub const SYS_eventfd2: ::c_long = 356;
+pub const SYS_epoll_create1: ::c_long = 357;
+pub const SYS_dup3: ::c_long = 358;
+pub const SYS_pipe2: ::c_long = 359;
+pub const SYS_inotify_init1: ::c_long = 360;
+pub const SYS_preadv: ::c_long = 361;
+pub const SYS_pwritev: ::c_long = 362;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 363;
+pub const SYS_perf_event_open: ::c_long = 364;
+pub const SYS_recvmmsg: ::c_long = 365;
+pub const SYS_accept4: ::c_long = 366;
+pub const SYS_fanotify_init: ::c_long = 367;
+pub const SYS_fanotify_mark: ::c_long = 368;
+pub const SYS_prlimit64: ::c_long = 369;
+pub const SYS_name_to_handle_at: ::c_long = 370;
+pub const SYS_open_by_handle_at: ::c_long = 371;
+pub const SYS_clock_adjtime: ::c_long = 372;
+pub const SYS_syncfs: ::c_long = 373;
+pub const SYS_sendmmsg: ::c_long = 374;
+pub const SYS_setns: ::c_long = 375;
+pub const SYS_process_vm_readv: ::c_long = 376;
+pub const SYS_process_vm_writev: ::c_long = 377;
+pub const SYS_kcmp: ::c_long = 378;
+pub const SYS_finit_module: ::c_long = 379;
+pub const SYS_sched_setattr: ::c_long = 380;
+pub const SYS_sched_getattr: ::c_long = 381;
+pub const SYS_renameat2: ::c_long = 382;
+pub const SYS_seccomp: ::c_long = 383;
+pub const SYS_getrandom: ::c_long = 384;
+pub const SYS_memfd_create: ::c_long = 385;
+pub const SYS_bpf: ::c_long = 386;
+pub const SYS_execveat: ::c_long = 387;
+pub const SYS_userfaultfd: ::c_long = 388;
+pub const SYS_membarrier: ::c_long = 389;
+pub const SYS_mlock2: ::c_long = 390;
+pub const SYS_copy_file_range: ::c_long = 391;
+pub const SYS_preadv2: ::c_long = 392;
+pub const SYS_pwritev2: ::c_long = 393;
+pub const SYS_pkey_mprotect: ::c_long = 394;
+pub const SYS_pkey_alloc: ::c_long = 395;
+pub const SYS_pkey_free: ::c_long = 396;
+
+// offsets in mcontext_t.gregs from sys/ucontext.h
+pub const REG_R0: ::c_int = 0;
+pub const REG_R1: ::c_int = 1;
+pub const REG_R2: ::c_int = 2;
+pub const REG_R3: ::c_int = 3;
+pub const REG_R4: ::c_int = 4;
+pub const REG_R5: ::c_int = 5;
+pub const REG_R6: ::c_int = 6;
+pub const REG_R7: ::c_int = 7;
+pub const REG_R8: ::c_int = 8;
+pub const REG_R9: ::c_int = 9;
+pub const REG_R10: ::c_int = 10;
+pub const REG_R11: ::c_int = 11;
+pub const REG_R12: ::c_int = 12;
+pub const REG_R13: ::c_int = 13;
+pub const REG_R14: ::c_int = 14;
+pub const REG_R15: ::c_int = 15;
+
+pub const NGREG: ::c_int = 18;
diff --git a/library/libc/src/unix/linux_like/android/b32/mod.rs b/library/libc/src/unix/linux_like/android/b32/mod.rs
new file mode 100644
index 00000000..e686da60
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b32/mod.rs
@@ -0,0 +1,239 @@
+// The following definitions are correct for arm and i686,
+// but may be wrong for mips
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type mode_t = u16;
+pub type off64_t = ::c_longlong;
+pub type sigset_t = ::c_ulong;
+pub type socklen_t = i32;
+pub type time64_t = i64;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct rlimit64 {
+        pub rlim_cur: u64,
+        pub rlim_max: u64,
+    }
+
+    pub struct stat {
+        pub st_dev: ::c_ulonglong,
+        __pad0: [::c_uchar; 4],
+        __st_ino: ::ino_t,
+        pub st_mode: ::c_uint,
+        pub st_nlink: ::c_uint,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulonglong,
+        __pad3: [::c_uchar; 4],
+        pub st_size: ::c_longlong,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::c_ulonglong,
+        pub st_atime: ::c_long,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::c_long,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::c_long,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::c_ulonglong,
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::c_ulonglong,
+        __pad0: [::c_uchar; 4],
+        __st_ino: ::ino_t,
+        pub st_mode: ::c_uint,
+        pub st_nlink: ::c_uint,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulonglong,
+        __pad3: [::c_uchar; 4],
+        pub st_size: ::c_longlong,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::c_ulonglong,
+        pub st_atime: ::c_long,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::c_long,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::c_long,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::c_ulonglong,
+    }
+
+    pub struct statfs64 {
+        pub f_type: u32,
+        pub f_bsize: u32,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::__fsid_t,
+        pub f_namelen: u32,
+        pub f_frsize: u32,
+        pub f_flags: u32,
+        pub f_spare: [u32; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::c_ulong,
+        pub f_bfree: ::c_ulong,
+        pub f_bavail: ::c_ulong,
+        pub f_files: ::c_ulong,
+        pub f_ffree: ::c_ulong,
+        pub f_favail: ::c_ulong,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+    }
+
+    pub struct pthread_attr_t {
+        pub flags: u32,
+        pub stack_base: *mut ::c_void,
+        pub stack_size: ::size_t,
+        pub guard_size: ::size_t,
+        pub sched_policy: i32,
+        pub sched_priority: i32,
+    }
+
+    pub struct pthread_mutex_t { value: ::c_int }
+
+    pub struct pthread_cond_t { value: ::c_int }
+
+    pub struct pthread_rwlock_t {
+        lock: pthread_mutex_t,
+        cond: pthread_cond_t,
+        numLocks: ::c_int,
+        writerThreadId: ::c_int,
+        pendingReaders: ::c_int,
+        pendingWriters: ::c_int,
+        attr: i32,
+        __reserved: [::c_char; 12],
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct statfs {
+        pub f_type: u32,
+        pub f_bsize: u32,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::__fsid_t,
+        pub f_namelen: u32,
+        pub f_frsize: u32,
+        pub f_flags: u32,
+        pub f_spare: [u32; 4],
+    }
+
+    pub struct sysinfo {
+        pub uptime: ::c_long,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub _f: [::c_char; 8],
+    }
+}
+
+s_no_extra_traits! {
+    pub struct sigset64_t {
+        __bits: [::c_ulong; 2]
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl ::fmt::Debug for sigset64_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigset64_t")
+                    .field("__bits", &self.__bits)
+                    .finish()
+            }
+        }
+    }
+}
+
+// These constants must be of the same type of sigaction.sa_flags
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+
+pub const RTLD_GLOBAL: ::c_int = 2;
+pub const RTLD_NOW: ::c_int = 0;
+pub const RTLD_DEFAULT: *mut ::c_void = -1isize as *mut ::c_void;
+
+pub const PTRACE_GETFPREGS: ::c_int = 14;
+pub const PTRACE_SETFPREGS: ::c_int = 15;
+pub const PTRACE_GETREGS: ::c_int = 12;
+pub const PTRACE_SETREGS: ::c_int = 13;
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t =
+    pthread_mutex_t { value: 0 };
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t =
+    pthread_cond_t { value: 0 };
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+    lock: PTHREAD_MUTEX_INITIALIZER,
+    cond: PTHREAD_COND_INITIALIZER,
+    numLocks: 0,
+    writerThreadId: 0,
+    pendingReaders: 0,
+    pendingWriters: 0,
+    attr: 0,
+    __reserved: [0; 12],
+};
+pub const PTHREAD_STACK_MIN: ::size_t = 4096 * 2;
+pub const CPU_SETSIZE: ::size_t = 32;
+pub const __CPU_BITS: ::size_t = 32;
+
+pub const UT_LINESIZE: usize = 8;
+pub const UT_NAMESIZE: usize = 8;
+pub const UT_HOSTSIZE: usize = 16;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+
+extern "C" {
+    pub fn timegm64(tm: *const ::tm) -> ::time64_t;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "x86")] {
+        mod x86;
+        pub use self::x86::*;
+    } else if #[cfg(target_arch = "arm")] {
+        mod arm;
+        pub use self::arm::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/linux_like/android/b32/x86/align.rs b/library/libc/src/unix/linux_like/android/b32/x86/align.rs
new file mode 100644
index 00000000..04df4a05
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b32/x86/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(8))]
+    pub struct max_align_t {
+        priv_: [f64; 2]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/android/b32/x86/mod.rs b/library/libc/src/unix/linux_like/android/b32/x86/mod.rs
new file mode 100644
index 00000000..879ea1a1
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b32/x86/mod.rs
@@ -0,0 +1,582 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type greg_t = i32;
+
+s! {
+    pub struct _libc_fpreg {
+        pub significand: [u16; 4],
+        pub exponent: u16,
+    }
+
+    pub struct _libc_fpstate {
+        pub cw: ::c_ulong,
+        pub sw: ::c_ulong,
+        pub tag: ::c_ulong,
+        pub ipoff: ::c_ulong,
+        pub cssel: ::c_ulong,
+        pub dataoff: ::c_ulong,
+        pub datasel: ::c_ulong,
+        pub _st: [_libc_fpreg; 8],
+        pub status: ::c_ulong,
+    }
+
+    pub struct mcontext_t {
+        pub gregs: [greg_t; 19],
+        pub fpregs: *mut _libc_fpstate,
+        pub oldmask: ::c_ulong,
+        pub cr2: ::c_ulong,
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        s_no_extra_traits! {
+            pub struct __c_anonymous_uc_sigmask_with_padding {
+                pub uc_sigmask: ::sigset_t,
+                /* Android has a wrong (smaller) sigset_t on x86. */
+                __padding_rt_sigset: u32,
+            }
+
+            pub union __c_anonymous_uc_sigmask {
+                uc_sigmask: __c_anonymous_uc_sigmask_with_padding,
+                uc_sigmask64: ::sigset64_t,
+            }
+
+            pub struct ucontext_t {
+                pub uc_flags: ::c_ulong,
+                pub uc_link: *mut ucontext_t,
+                pub uc_stack: ::stack_t,
+                pub uc_mcontext: mcontext_t,
+                pub uc_sigmask__c_anonymous_union: __c_anonymous_uc_sigmask,
+                __padding_rt_sigset: u32,
+                __fpregs_mem: _libc_fpstate,
+            }
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for __c_anonymous_uc_sigmask_with_padding {
+                    fn eq(
+                        &self, other: &__c_anonymous_uc_sigmask_with_padding
+                    ) -> bool {
+                        self.uc_sigmask == other.uc_sigmask
+                            // Ignore padding
+                    }
+                }
+                impl Eq for __c_anonymous_uc_sigmask_with_padding {}
+                impl ::fmt::Debug for __c_anonymous_uc_sigmask_with_padding {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("uc_sigmask_with_padding")
+                            .field("uc_sigmask_with_padding", &self.uc_sigmask)
+                            // Ignore padding
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for __c_anonymous_uc_sigmask_with_padding {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.uc_sigmask.hash(state)
+                            // Ignore padding
+                    }
+                }
+
+                impl PartialEq for __c_anonymous_uc_sigmask {
+                    fn eq(&self, other: &__c_anonymous_uc_sigmask) -> bool {
+                        unsafe { self.uc_sigmask == other.uc_sigmask }
+                    }
+                }
+                impl Eq for __c_anonymous_uc_sigmask {}
+                impl ::fmt::Debug for __c_anonymous_uc_sigmask {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("uc_sigmask")
+                            .field("uc_sigmask", unsafe { &self.uc_sigmask })
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for __c_anonymous_uc_sigmask {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        unsafe { self.uc_sigmask.hash(state) }
+                    }
+                }
+
+                impl PartialEq for ucontext_t {
+                    fn eq(&self, other: &Self) -> bool {
+                        self.uc_flags == other.uc_flags
+                            && self.uc_link == other.uc_link
+                            && self.uc_stack == other.uc_stack
+                            && self.uc_mcontext == other.uc_mcontext
+                            && self.uc_sigmask__c_anonymous_union
+                                == other.uc_sigmask__c_anonymous_union
+                            // Ignore padding field
+                    }
+                }
+                impl Eq for ucontext_t {}
+                impl ::fmt::Debug for ucontext_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("ucontext_t")
+                            .field("uc_flags", &self.uc_flags)
+                            .field("uc_link", &self.uc_link)
+                            .field("uc_stack", &self.uc_stack)
+                            .field("uc_mcontext", &self.uc_mcontext)
+                            .field(
+                                "uc_sigmask__c_anonymous_union",
+                                &self.uc_sigmask__c_anonymous_union
+                            )
+                            // Ignore padding field
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for ucontext_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.uc_flags.hash(state);
+                        self.uc_link.hash(state);
+                        self.uc_stack.hash(state);
+                        self.uc_mcontext.hash(state);
+                        self.uc_sigmask__c_anonymous_union.hash(state);
+                        // Ignore padding field
+                    }
+                }
+            }
+        }
+    }
+}
+
+pub const O_DIRECT: ::c_int = 0x4000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+pub const O_LARGEFILE: ::c_int = 0o0100000;
+
+pub const MAP_32BIT: ::c_int = 0x40;
+
+// Syscall table
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_waitpid: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_time: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_break: ::c_long = 17;
+pub const SYS_oldstat: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_umount: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_stime: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_oldfstat: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_stty: ::c_long = 31;
+pub const SYS_gtty: ::c_long = 32;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_ftime: ::c_long = 35;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_prof: ::c_long = 44;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_lock: ::c_long = 53;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_mpx: ::c_long = 56;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_ulimit: ::c_long = 58;
+pub const SYS_oldolduname: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_sgetmask: ::c_long = 68;
+pub const SYS_ssetmask: ::c_long = 69;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrlimit: ::c_long = 76;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_select: ::c_long = 82;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_oldlstat: ::c_long = 84;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_readdir: ::c_long = 89;
+pub const SYS_mmap: ::c_long = 90;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_profil: ::c_long = 98;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_ioperm: ::c_long = 101;
+pub const SYS_socketcall: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_olduname: ::c_long = 109;
+pub const SYS_iopl: ::c_long = 110;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_idle: ::c_long = 112;
+pub const SYS_vm86old: ::c_long = 113;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_ipc: ::c_long = 117;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_modify_ldt: ::c_long = 123;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_create_module: ::c_long = 127;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_get_kernel_syms: ::c_long = 130;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_afs_syscall: ::c_long = 137;
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+// FIXME: SYS__llseek is in the NDK sources but for some reason is
+//        not available in the tests
+// pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+// FIXME: SYS__newselect is in the NDK sources but for some reason is
+//        not available in the tests
+// pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+// FIXME: SYS__llseek is in the NDK sources but for some reason is
+//        not available in the tests
+// pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_vm86: ::c_long = 166;
+pub const SYS_query_module: ::c_long = 167;
+pub const SYS_poll: ::c_long = 168;
+pub const SYS_nfsservctl: ::c_long = 169;
+pub const SYS_setresgid: ::c_long = 170;
+pub const SYS_getresgid: ::c_long = 171;
+pub const SYS_prctl: ::c_long = 172;
+pub const SYS_rt_sigreturn: ::c_long = 173;
+pub const SYS_rt_sigaction: ::c_long = 174;
+pub const SYS_rt_sigprocmask: ::c_long = 175;
+pub const SYS_rt_sigpending: ::c_long = 176;
+pub const SYS_rt_sigtimedwait: ::c_long = 177;
+pub const SYS_rt_sigqueueinfo: ::c_long = 178;
+pub const SYS_rt_sigsuspend: ::c_long = 179;
+pub const SYS_pread64: ::c_long = 180;
+pub const SYS_pwrite64: ::c_long = 181;
+pub const SYS_chown: ::c_long = 182;
+pub const SYS_getcwd: ::c_long = 183;
+pub const SYS_capget: ::c_long = 184;
+pub const SYS_capset: ::c_long = 185;
+pub const SYS_sigaltstack: ::c_long = 186;
+pub const SYS_sendfile: ::c_long = 187;
+pub const SYS_getpmsg: ::c_long = 188;
+pub const SYS_putpmsg: ::c_long = 189;
+pub const SYS_vfork: ::c_long = 190;
+pub const SYS_ugetrlimit: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_lchown32: ::c_long = 198;
+pub const SYS_getuid32: ::c_long = 199;
+pub const SYS_getgid32: ::c_long = 200;
+pub const SYS_geteuid32: ::c_long = 201;
+pub const SYS_getegid32: ::c_long = 202;
+pub const SYS_setreuid32: ::c_long = 203;
+pub const SYS_setregid32: ::c_long = 204;
+pub const SYS_getgroups32: ::c_long = 205;
+pub const SYS_setgroups32: ::c_long = 206;
+pub const SYS_fchown32: ::c_long = 207;
+pub const SYS_setresuid32: ::c_long = 208;
+pub const SYS_getresuid32: ::c_long = 209;
+pub const SYS_setresgid32: ::c_long = 210;
+pub const SYS_getresgid32: ::c_long = 211;
+pub const SYS_chown32: ::c_long = 212;
+pub const SYS_setuid32: ::c_long = 213;
+pub const SYS_setgid32: ::c_long = 214;
+pub const SYS_setfsuid32: ::c_long = 215;
+pub const SYS_setfsgid32: ::c_long = 216;
+pub const SYS_pivot_root: ::c_long = 217;
+pub const SYS_mincore: ::c_long = 218;
+pub const SYS_madvise: ::c_long = 219;
+pub const SYS_getdents64: ::c_long = 220;
+pub const SYS_fcntl64: ::c_long = 221;
+pub const SYS_gettid: ::c_long = 224;
+pub const SYS_readahead: ::c_long = 225;
+pub const SYS_setxattr: ::c_long = 226;
+pub const SYS_lsetxattr: ::c_long = 227;
+pub const SYS_fsetxattr: ::c_long = 228;
+pub const SYS_getxattr: ::c_long = 229;
+pub const SYS_lgetxattr: ::c_long = 230;
+pub const SYS_fgetxattr: ::c_long = 231;
+pub const SYS_listxattr: ::c_long = 232;
+pub const SYS_llistxattr: ::c_long = 233;
+pub const SYS_flistxattr: ::c_long = 234;
+pub const SYS_removexattr: ::c_long = 235;
+pub const SYS_lremovexattr: ::c_long = 236;
+pub const SYS_fremovexattr: ::c_long = 237;
+pub const SYS_tkill: ::c_long = 238;
+pub const SYS_sendfile64: ::c_long = 239;
+pub const SYS_futex: ::c_long = 240;
+pub const SYS_sched_setaffinity: ::c_long = 241;
+pub const SYS_sched_getaffinity: ::c_long = 242;
+pub const SYS_set_thread_area: ::c_long = 243;
+pub const SYS_get_thread_area: ::c_long = 244;
+pub const SYS_io_setup: ::c_long = 245;
+pub const SYS_io_destroy: ::c_long = 246;
+pub const SYS_io_getevents: ::c_long = 247;
+pub const SYS_io_submit: ::c_long = 248;
+pub const SYS_io_cancel: ::c_long = 249;
+pub const SYS_fadvise64: ::c_long = 250;
+pub const SYS_exit_group: ::c_long = 252;
+pub const SYS_lookup_dcookie: ::c_long = 253;
+pub const SYS_epoll_create: ::c_long = 254;
+pub const SYS_epoll_ctl: ::c_long = 255;
+pub const SYS_epoll_wait: ::c_long = 256;
+pub const SYS_remap_file_pages: ::c_long = 257;
+pub const SYS_set_tid_address: ::c_long = 258;
+pub const SYS_timer_create: ::c_long = 259;
+pub const SYS_timer_settime: ::c_long = 260;
+pub const SYS_timer_gettime: ::c_long = 261;
+pub const SYS_timer_getoverrun: ::c_long = 262;
+pub const SYS_timer_delete: ::c_long = 263;
+pub const SYS_clock_settime: ::c_long = 264;
+pub const SYS_clock_gettime: ::c_long = 265;
+pub const SYS_clock_getres: ::c_long = 266;
+pub const SYS_clock_nanosleep: ::c_long = 267;
+pub const SYS_statfs64: ::c_long = 268;
+pub const SYS_fstatfs64: ::c_long = 269;
+pub const SYS_tgkill: ::c_long = 270;
+pub const SYS_utimes: ::c_long = 271;
+pub const SYS_fadvise64_64: ::c_long = 272;
+pub const SYS_vserver: ::c_long = 273;
+pub const SYS_mbind: ::c_long = 274;
+pub const SYS_get_mempolicy: ::c_long = 275;
+pub const SYS_set_mempolicy: ::c_long = 276;
+pub const SYS_mq_open: ::c_long = 277;
+pub const SYS_mq_unlink: ::c_long = 278;
+pub const SYS_mq_timedsend: ::c_long = 279;
+pub const SYS_mq_timedreceive: ::c_long = 280;
+pub const SYS_mq_notify: ::c_long = 281;
+pub const SYS_mq_getsetattr: ::c_long = 282;
+pub const SYS_kexec_load: ::c_long = 283;
+pub const SYS_waitid: ::c_long = 284;
+pub const SYS_add_key: ::c_long = 286;
+pub const SYS_request_key: ::c_long = 287;
+pub const SYS_keyctl: ::c_long = 288;
+pub const SYS_ioprio_set: ::c_long = 289;
+pub const SYS_ioprio_get: ::c_long = 290;
+pub const SYS_inotify_init: ::c_long = 291;
+pub const SYS_inotify_add_watch: ::c_long = 292;
+pub const SYS_inotify_rm_watch: ::c_long = 293;
+pub const SYS_migrate_pages: ::c_long = 294;
+pub const SYS_openat: ::c_long = 295;
+pub const SYS_mkdirat: ::c_long = 296;
+pub const SYS_mknodat: ::c_long = 297;
+pub const SYS_fchownat: ::c_long = 298;
+pub const SYS_futimesat: ::c_long = 299;
+pub const SYS_fstatat64: ::c_long = 300;
+pub const SYS_unlinkat: ::c_long = 301;
+pub const SYS_renameat: ::c_long = 302;
+pub const SYS_linkat: ::c_long = 303;
+pub const SYS_symlinkat: ::c_long = 304;
+pub const SYS_readlinkat: ::c_long = 305;
+pub const SYS_fchmodat: ::c_long = 306;
+pub const SYS_faccessat: ::c_long = 307;
+pub const SYS_pselect6: ::c_long = 308;
+pub const SYS_ppoll: ::c_long = 309;
+pub const SYS_unshare: ::c_long = 310;
+pub const SYS_set_robust_list: ::c_long = 311;
+pub const SYS_get_robust_list: ::c_long = 312;
+pub const SYS_splice: ::c_long = 313;
+pub const SYS_sync_file_range: ::c_long = 314;
+pub const SYS_tee: ::c_long = 315;
+pub const SYS_vmsplice: ::c_long = 316;
+pub const SYS_move_pages: ::c_long = 317;
+pub const SYS_getcpu: ::c_long = 318;
+pub const SYS_epoll_pwait: ::c_long = 319;
+pub const SYS_utimensat: ::c_long = 320;
+pub const SYS_signalfd: ::c_long = 321;
+pub const SYS_timerfd_create: ::c_long = 322;
+pub const SYS_eventfd: ::c_long = 323;
+pub const SYS_fallocate: ::c_long = 324;
+pub const SYS_timerfd_settime: ::c_long = 325;
+pub const SYS_timerfd_gettime: ::c_long = 326;
+pub const SYS_signalfd4: ::c_long = 327;
+pub const SYS_eventfd2: ::c_long = 328;
+pub const SYS_epoll_create1: ::c_long = 329;
+pub const SYS_dup3: ::c_long = 330;
+pub const SYS_pipe2: ::c_long = 331;
+pub const SYS_inotify_init1: ::c_long = 332;
+pub const SYS_preadv: ::c_long = 333;
+pub const SYS_pwritev: ::c_long = 334;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 335;
+pub const SYS_perf_event_open: ::c_long = 336;
+pub const SYS_recvmmsg: ::c_long = 337;
+pub const SYS_fanotify_init: ::c_long = 338;
+pub const SYS_fanotify_mark: ::c_long = 339;
+pub const SYS_prlimit64: ::c_long = 340;
+pub const SYS_name_to_handle_at: ::c_long = 341;
+pub const SYS_open_by_handle_at: ::c_long = 342;
+pub const SYS_clock_adjtime: ::c_long = 343;
+pub const SYS_syncfs: ::c_long = 344;
+pub const SYS_sendmmsg: ::c_long = 345;
+pub const SYS_setns: ::c_long = 346;
+pub const SYS_process_vm_readv: ::c_long = 347;
+pub const SYS_process_vm_writev: ::c_long = 348;
+pub const SYS_kcmp: ::c_long = 349;
+pub const SYS_finit_module: ::c_long = 350;
+pub const SYS_sched_setattr: ::c_long = 351;
+pub const SYS_sched_getattr: ::c_long = 352;
+pub const SYS_renameat2: ::c_long = 353;
+pub const SYS_seccomp: ::c_long = 354;
+pub const SYS_getrandom: ::c_long = 355;
+pub const SYS_memfd_create: ::c_long = 356;
+pub const SYS_bpf: ::c_long = 357;
+pub const SYS_execveat: ::c_long = 358;
+pub const SYS_socket: ::c_long = 359;
+pub const SYS_socketpair: ::c_long = 360;
+pub const SYS_bind: ::c_long = 361;
+pub const SYS_connect: ::c_long = 362;
+pub const SYS_listen: ::c_long = 363;
+pub const SYS_accept4: ::c_long = 364;
+pub const SYS_getsockopt: ::c_long = 365;
+pub const SYS_setsockopt: ::c_long = 366;
+pub const SYS_getsockname: ::c_long = 367;
+pub const SYS_getpeername: ::c_long = 368;
+pub const SYS_sendto: ::c_long = 369;
+pub const SYS_sendmsg: ::c_long = 370;
+pub const SYS_recvfrom: ::c_long = 371;
+pub const SYS_recvmsg: ::c_long = 372;
+pub const SYS_shutdown: ::c_long = 373;
+pub const SYS_userfaultfd: ::c_long = 374;
+pub const SYS_membarrier: ::c_long = 375;
+pub const SYS_mlock2: ::c_long = 376;
+pub const SYS_copy_file_range: ::c_long = 377;
+pub const SYS_preadv2: ::c_long = 378;
+pub const SYS_pwritev2: ::c_long = 379;
+pub const SYS_pkey_mprotect: ::c_long = 380;
+pub const SYS_pkey_alloc: ::c_long = 381;
+pub const SYS_pkey_free: ::c_long = 382;
+
+// offsets in user_regs_structs, from sys/reg.h
+pub const EBX: ::c_int = 0;
+pub const ECX: ::c_int = 1;
+pub const EDX: ::c_int = 2;
+pub const ESI: ::c_int = 3;
+pub const EDI: ::c_int = 4;
+pub const EBP: ::c_int = 5;
+pub const EAX: ::c_int = 6;
+pub const DS: ::c_int = 7;
+pub const ES: ::c_int = 8;
+pub const FS: ::c_int = 9;
+pub const GS: ::c_int = 10;
+pub const ORIG_EAX: ::c_int = 11;
+pub const EIP: ::c_int = 12;
+pub const CS: ::c_int = 13;
+pub const EFL: ::c_int = 14;
+pub const UESP: ::c_int = 15;
+pub const SS: ::c_int = 16;
+
+// offsets in mcontext_t.gregs from sys/ucontext.h
+pub const REG_GS: ::c_int = 0;
+pub const REG_FS: ::c_int = 1;
+pub const REG_ES: ::c_int = 2;
+pub const REG_DS: ::c_int = 3;
+pub const REG_EDI: ::c_int = 4;
+pub const REG_ESI: ::c_int = 5;
+pub const REG_EBP: ::c_int = 6;
+pub const REG_ESP: ::c_int = 7;
+pub const REG_EBX: ::c_int = 8;
+pub const REG_EDX: ::c_int = 9;
+pub const REG_ECX: ::c_int = 10;
+pub const REG_EAX: ::c_int = 11;
+pub const REG_TRAPNO: ::c_int = 12;
+pub const REG_ERR: ::c_int = 13;
+pub const REG_EIP: ::c_int = 14;
+pub const REG_CS: ::c_int = 15;
+pub const REG_EFL: ::c_int = 16;
+pub const REG_UESP: ::c_int = 17;
+pub const REG_SS: ::c_int = 18;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/android/b64/aarch64/align.rs b/library/libc/src/unix/linux_like/android/b64/aarch64/align.rs
new file mode 100644
index 00000000..154c2c54
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b64/aarch64/align.rs
@@ -0,0 +1,29 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f32; 8]
+    }
+}
+
+s! {
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_sigmask: ::sigset_t,
+        pub uc_mcontext: mcontext_t,
+    }
+
+    #[repr(align(16))]
+    pub struct mcontext_t {
+        pub fault_address: ::c_ulonglong,
+        pub regs: [::c_ulonglong; 31],
+        pub sp: ::c_ulonglong,
+        pub pc: ::c_ulonglong,
+        pub pstate: ::c_ulonglong,
+        // nested arrays to get the right size/length while being able to
+        // auto-derive traits like Debug
+        __reserved: [[u64; 32]; 16],
+    }
+}
diff --git a/library/libc/src/unix/linux_like/android/b64/aarch64/mod.rs b/library/libc/src/unix/linux_like/android/b64/aarch64/mod.rs
new file mode 100644
index 00000000..5acb328b
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b64/aarch64/mod.rs
@@ -0,0 +1,375 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::c_uint,
+        pub st_nlink: ::c_uint,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad1: ::c_ulong,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::c_int,
+        __pad2: ::c_int,
+        pub st_blocks: ::c_long,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused4: ::c_uint,
+        __unused5: ::c_uint,
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::c_uint,
+        pub st_nlink: ::c_uint,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad1: ::c_ulong,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::c_int,
+        __pad2: ::c_int,
+        pub st_blocks: ::c_long,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused4: ::c_uint,
+        __unused5: ::c_uint,
+    }
+}
+
+pub const O_DIRECT: ::c_int = 0x10000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_LARGEFILE: ::c_int = 0o400000;
+
+pub const SIGSTKSZ: ::size_t = 16384;
+pub const MINSIGSTKSZ: ::size_t = 5120;
+
+// From NDK's asm/hwcap.h
+pub const HWCAP_FP: ::c_ulong = 1 << 0;
+pub const HWCAP_ASIMD: ::c_ulong = 1 << 1;
+pub const HWCAP_EVTSTRM: ::c_ulong = 1 << 2;
+pub const HWCAP_AES: ::c_ulong = 1 << 3;
+pub const HWCAP_PMULL: ::c_ulong = 1 << 4;
+pub const HWCAP_SHA1: ::c_ulong = 1 << 5;
+pub const HWCAP_SHA2: ::c_ulong = 1 << 6;
+pub const HWCAP_CRC32: ::c_ulong = 1 << 7;
+pub const HWCAP_ATOMICS: ::c_ulong = 1 << 8;
+pub const HWCAP_FPHP: ::c_ulong = 1 << 9;
+pub const HWCAP_ASIMDHP: ::c_ulong = 1 << 10;
+pub const HWCAP_CPUID: ::c_ulong = 1 << 11;
+pub const HWCAP_ASIMDRDM: ::c_ulong = 1 << 12;
+pub const HWCAP_JSCVT: ::c_ulong = 1 << 13;
+pub const HWCAP_FCMA: ::c_ulong = 1 << 14;
+pub const HWCAP_LRCPC: ::c_ulong = 1 << 15;
+pub const HWCAP_DCPOP: ::c_ulong = 1 << 16;
+pub const HWCAP_SHA3: ::c_ulong = 1 << 17;
+pub const HWCAP_SM3: ::c_ulong = 1 << 18;
+pub const HWCAP_SM4: ::c_ulong = 1 << 19;
+pub const HWCAP_ASIMDDP: ::c_ulong = 1 << 20;
+pub const HWCAP_SHA512: ::c_ulong = 1 << 21;
+pub const HWCAP_SVE: ::c_ulong = 1 << 22;
+pub const HWCAP_ASIMDFHM: ::c_ulong = 1 << 23;
+pub const HWCAP_DIT: ::c_ulong = 1 << 24;
+pub const HWCAP_USCAT: ::c_ulong = 1 << 25;
+pub const HWCAP_ILRCPC: ::c_ulong = 1 << 26;
+pub const HWCAP_FLAGM: ::c_ulong = 1 << 27;
+pub const HWCAP_SSBS: ::c_ulong = 1 << 28;
+pub const HWCAP_SB: ::c_ulong = 1 << 29;
+pub const HWCAP_PACA: ::c_ulong = 1 << 30;
+pub const HWCAP_PACG: ::c_ulong = 1 << 31;
+pub const HWCAP2_DCPODP: ::c_ulong = 1 << 0;
+pub const HWCAP2_SVE2: ::c_ulong = 1 << 1;
+pub const HWCAP2_SVEAES: ::c_ulong = 1 << 2;
+pub const HWCAP2_SVEPMULL: ::c_ulong = 1 << 3;
+pub const HWCAP2_SVEBITPERM: ::c_ulong = 1 << 4;
+pub const HWCAP2_SVESHA3: ::c_ulong = 1 << 5;
+pub const HWCAP2_SVESM4: ::c_ulong = 1 << 6;
+pub const HWCAP2_FLAGM2: ::c_ulong = 1 << 7;
+pub const HWCAP2_FRINT: ::c_ulong = 1 << 8;
+
+pub const SYS_io_setup: ::c_long = 0;
+pub const SYS_io_destroy: ::c_long = 1;
+pub const SYS_io_submit: ::c_long = 2;
+pub const SYS_io_cancel: ::c_long = 3;
+pub const SYS_io_getevents: ::c_long = 4;
+pub const SYS_setxattr: ::c_long = 5;
+pub const SYS_lsetxattr: ::c_long = 6;
+pub const SYS_fsetxattr: ::c_long = 7;
+pub const SYS_getxattr: ::c_long = 8;
+pub const SYS_lgetxattr: ::c_long = 9;
+pub const SYS_fgetxattr: ::c_long = 10;
+pub const SYS_listxattr: ::c_long = 11;
+pub const SYS_llistxattr: ::c_long = 12;
+pub const SYS_flistxattr: ::c_long = 13;
+pub const SYS_removexattr: ::c_long = 14;
+pub const SYS_lremovexattr: ::c_long = 15;
+pub const SYS_fremovexattr: ::c_long = 16;
+pub const SYS_getcwd: ::c_long = 17;
+pub const SYS_lookup_dcookie: ::c_long = 18;
+pub const SYS_eventfd2: ::c_long = 19;
+pub const SYS_epoll_create1: ::c_long = 20;
+pub const SYS_epoll_ctl: ::c_long = 21;
+pub const SYS_epoll_pwait: ::c_long = 22;
+pub const SYS_dup: ::c_long = 23;
+pub const SYS_dup3: ::c_long = 24;
+pub const SYS_inotify_init1: ::c_long = 26;
+pub const SYS_inotify_add_watch: ::c_long = 27;
+pub const SYS_inotify_rm_watch: ::c_long = 28;
+pub const SYS_ioctl: ::c_long = 29;
+pub const SYS_ioprio_set: ::c_long = 30;
+pub const SYS_ioprio_get: ::c_long = 31;
+pub const SYS_flock: ::c_long = 32;
+pub const SYS_mknodat: ::c_long = 33;
+pub const SYS_mkdirat: ::c_long = 34;
+pub const SYS_unlinkat: ::c_long = 35;
+pub const SYS_symlinkat: ::c_long = 36;
+pub const SYS_linkat: ::c_long = 37;
+pub const SYS_renameat: ::c_long = 38;
+pub const SYS_umount2: ::c_long = 39;
+pub const SYS_mount: ::c_long = 40;
+pub const SYS_pivot_root: ::c_long = 41;
+pub const SYS_nfsservctl: ::c_long = 42;
+pub const SYS_fallocate: ::c_long = 47;
+pub const SYS_faccessat: ::c_long = 48;
+pub const SYS_chdir: ::c_long = 49;
+pub const SYS_fchdir: ::c_long = 50;
+pub const SYS_chroot: ::c_long = 51;
+pub const SYS_fchmod: ::c_long = 52;
+pub const SYS_fchmodat: ::c_long = 53;
+pub const SYS_fchownat: ::c_long = 54;
+pub const SYS_fchown: ::c_long = 55;
+pub const SYS_openat: ::c_long = 56;
+pub const SYS_close: ::c_long = 57;
+pub const SYS_vhangup: ::c_long = 58;
+pub const SYS_pipe2: ::c_long = 59;
+pub const SYS_quotactl: ::c_long = 60;
+pub const SYS_getdents64: ::c_long = 61;
+pub const SYS_read: ::c_long = 63;
+pub const SYS_write: ::c_long = 64;
+pub const SYS_readv: ::c_long = 65;
+pub const SYS_writev: ::c_long = 66;
+pub const SYS_pread64: ::c_long = 67;
+pub const SYS_pwrite64: ::c_long = 68;
+pub const SYS_preadv: ::c_long = 69;
+pub const SYS_pwritev: ::c_long = 70;
+pub const SYS_pselect6: ::c_long = 72;
+pub const SYS_ppoll: ::c_long = 73;
+pub const SYS_signalfd4: ::c_long = 74;
+pub const SYS_vmsplice: ::c_long = 75;
+pub const SYS_splice: ::c_long = 76;
+pub const SYS_tee: ::c_long = 77;
+pub const SYS_readlinkat: ::c_long = 78;
+pub const SYS_sync: ::c_long = 81;
+pub const SYS_fsync: ::c_long = 82;
+pub const SYS_fdatasync: ::c_long = 83;
+pub const SYS_sync_file_range: ::c_long = 84;
+pub const SYS_timerfd_create: ::c_long = 85;
+pub const SYS_timerfd_settime: ::c_long = 86;
+pub const SYS_timerfd_gettime: ::c_long = 87;
+pub const SYS_utimensat: ::c_long = 88;
+pub const SYS_acct: ::c_long = 89;
+pub const SYS_capget: ::c_long = 90;
+pub const SYS_capset: ::c_long = 91;
+pub const SYS_personality: ::c_long = 92;
+pub const SYS_exit: ::c_long = 93;
+pub const SYS_exit_group: ::c_long = 94;
+pub const SYS_waitid: ::c_long = 95;
+pub const SYS_set_tid_address: ::c_long = 96;
+pub const SYS_unshare: ::c_long = 97;
+pub const SYS_futex: ::c_long = 98;
+pub const SYS_set_robust_list: ::c_long = 99;
+pub const SYS_get_robust_list: ::c_long = 100;
+pub const SYS_nanosleep: ::c_long = 101;
+pub const SYS_getitimer: ::c_long = 102;
+pub const SYS_setitimer: ::c_long = 103;
+pub const SYS_kexec_load: ::c_long = 104;
+pub const SYS_init_module: ::c_long = 105;
+pub const SYS_delete_module: ::c_long = 106;
+pub const SYS_timer_create: ::c_long = 107;
+pub const SYS_timer_gettime: ::c_long = 108;
+pub const SYS_timer_getoverrun: ::c_long = 109;
+pub const SYS_timer_settime: ::c_long = 110;
+pub const SYS_timer_delete: ::c_long = 111;
+pub const SYS_clock_settime: ::c_long = 112;
+pub const SYS_clock_gettime: ::c_long = 113;
+pub const SYS_clock_getres: ::c_long = 114;
+pub const SYS_clock_nanosleep: ::c_long = 115;
+pub const SYS_syslog: ::c_long = 116;
+pub const SYS_ptrace: ::c_long = 117;
+pub const SYS_sched_setparam: ::c_long = 118;
+pub const SYS_sched_setscheduler: ::c_long = 119;
+pub const SYS_sched_getscheduler: ::c_long = 120;
+pub const SYS_sched_getparam: ::c_long = 121;
+pub const SYS_sched_setaffinity: ::c_long = 122;
+pub const SYS_sched_getaffinity: ::c_long = 123;
+pub const SYS_sched_yield: ::c_long = 124;
+pub const SYS_sched_get_priority_max: ::c_long = 125;
+pub const SYS_sched_get_priority_min: ::c_long = 126;
+pub const SYS_sched_rr_get_interval: ::c_long = 127;
+pub const SYS_restart_syscall: ::c_long = 128;
+pub const SYS_kill: ::c_long = 129;
+pub const SYS_tkill: ::c_long = 130;
+pub const SYS_tgkill: ::c_long = 131;
+pub const SYS_sigaltstack: ::c_long = 132;
+pub const SYS_rt_sigsuspend: ::c_long = 133;
+pub const SYS_rt_sigaction: ::c_long = 134;
+pub const SYS_rt_sigprocmask: ::c_long = 135;
+pub const SYS_rt_sigpending: ::c_long = 136;
+pub const SYS_rt_sigtimedwait: ::c_long = 137;
+pub const SYS_rt_sigqueueinfo: ::c_long = 138;
+pub const SYS_rt_sigreturn: ::c_long = 139;
+pub const SYS_setpriority: ::c_long = 140;
+pub const SYS_getpriority: ::c_long = 141;
+pub const SYS_reboot: ::c_long = 142;
+pub const SYS_setregid: ::c_long = 143;
+pub const SYS_setgid: ::c_long = 144;
+pub const SYS_setreuid: ::c_long = 145;
+pub const SYS_setuid: ::c_long = 146;
+pub const SYS_setresuid: ::c_long = 147;
+pub const SYS_getresuid: ::c_long = 148;
+pub const SYS_setresgid: ::c_long = 149;
+pub const SYS_getresgid: ::c_long = 150;
+pub const SYS_setfsuid: ::c_long = 151;
+pub const SYS_setfsgid: ::c_long = 152;
+pub const SYS_times: ::c_long = 153;
+pub const SYS_setpgid: ::c_long = 154;
+pub const SYS_getpgid: ::c_long = 155;
+pub const SYS_getsid: ::c_long = 156;
+pub const SYS_setsid: ::c_long = 157;
+pub const SYS_getgroups: ::c_long = 158;
+pub const SYS_setgroups: ::c_long = 159;
+pub const SYS_uname: ::c_long = 160;
+pub const SYS_sethostname: ::c_long = 161;
+pub const SYS_setdomainname: ::c_long = 162;
+pub const SYS_getrlimit: ::c_long = 163;
+pub const SYS_setrlimit: ::c_long = 164;
+pub const SYS_getrusage: ::c_long = 165;
+pub const SYS_umask: ::c_long = 166;
+pub const SYS_prctl: ::c_long = 167;
+pub const SYS_getcpu: ::c_long = 168;
+pub const SYS_gettimeofday: ::c_long = 169;
+pub const SYS_settimeofday: ::c_long = 170;
+pub const SYS_adjtimex: ::c_long = 171;
+pub const SYS_getpid: ::c_long = 172;
+pub const SYS_getppid: ::c_long = 173;
+pub const SYS_getuid: ::c_long = 174;
+pub const SYS_geteuid: ::c_long = 175;
+pub const SYS_getgid: ::c_long = 176;
+pub const SYS_getegid: ::c_long = 177;
+pub const SYS_gettid: ::c_long = 178;
+pub const SYS_sysinfo: ::c_long = 179;
+pub const SYS_mq_open: ::c_long = 180;
+pub const SYS_mq_unlink: ::c_long = 181;
+pub const SYS_mq_timedsend: ::c_long = 182;
+pub const SYS_mq_timedreceive: ::c_long = 183;
+pub const SYS_mq_notify: ::c_long = 184;
+pub const SYS_mq_getsetattr: ::c_long = 185;
+pub const SYS_msgget: ::c_long = 186;
+pub const SYS_msgctl: ::c_long = 187;
+pub const SYS_msgrcv: ::c_long = 188;
+pub const SYS_msgsnd: ::c_long = 189;
+pub const SYS_semget: ::c_long = 190;
+pub const SYS_semctl: ::c_long = 191;
+pub const SYS_semtimedop: ::c_long = 192;
+pub const SYS_semop: ::c_long = 193;
+pub const SYS_shmget: ::c_long = 194;
+pub const SYS_shmctl: ::c_long = 195;
+pub const SYS_shmat: ::c_long = 196;
+pub const SYS_shmdt: ::c_long = 197;
+pub const SYS_socket: ::c_long = 198;
+pub const SYS_socketpair: ::c_long = 199;
+pub const SYS_bind: ::c_long = 200;
+pub const SYS_listen: ::c_long = 201;
+pub const SYS_accept: ::c_long = 202;
+pub const SYS_connect: ::c_long = 203;
+pub const SYS_getsockname: ::c_long = 204;
+pub const SYS_getpeername: ::c_long = 205;
+pub const SYS_sendto: ::c_long = 206;
+pub const SYS_recvfrom: ::c_long = 207;
+pub const SYS_setsockopt: ::c_long = 208;
+pub const SYS_getsockopt: ::c_long = 209;
+pub const SYS_shutdown: ::c_long = 210;
+pub const SYS_sendmsg: ::c_long = 211;
+pub const SYS_recvmsg: ::c_long = 212;
+pub const SYS_readahead: ::c_long = 213;
+pub const SYS_brk: ::c_long = 214;
+pub const SYS_munmap: ::c_long = 215;
+pub const SYS_mremap: ::c_long = 216;
+pub const SYS_add_key: ::c_long = 217;
+pub const SYS_request_key: ::c_long = 218;
+pub const SYS_keyctl: ::c_long = 219;
+pub const SYS_clone: ::c_long = 220;
+pub const SYS_execve: ::c_long = 221;
+pub const SYS_swapon: ::c_long = 224;
+pub const SYS_swapoff: ::c_long = 225;
+pub const SYS_mprotect: ::c_long = 226;
+pub const SYS_msync: ::c_long = 227;
+pub const SYS_mlock: ::c_long = 228;
+pub const SYS_munlock: ::c_long = 229;
+pub const SYS_mlockall: ::c_long = 230;
+pub const SYS_munlockall: ::c_long = 231;
+pub const SYS_mincore: ::c_long = 232;
+pub const SYS_madvise: ::c_long = 233;
+pub const SYS_remap_file_pages: ::c_long = 234;
+pub const SYS_mbind: ::c_long = 235;
+pub const SYS_get_mempolicy: ::c_long = 236;
+pub const SYS_set_mempolicy: ::c_long = 237;
+pub const SYS_migrate_pages: ::c_long = 238;
+pub const SYS_move_pages: ::c_long = 239;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 240;
+pub const SYS_perf_event_open: ::c_long = 241;
+pub const SYS_accept4: ::c_long = 242;
+pub const SYS_recvmmsg: ::c_long = 243;
+pub const SYS_arch_specific_syscall: ::c_long = 244;
+pub const SYS_wait4: ::c_long = 260;
+pub const SYS_prlimit64: ::c_long = 261;
+pub const SYS_fanotify_init: ::c_long = 262;
+pub const SYS_fanotify_mark: ::c_long = 263;
+pub const SYS_name_to_handle_at: ::c_long = 264;
+pub const SYS_open_by_handle_at: ::c_long = 265;
+pub const SYS_clock_adjtime: ::c_long = 266;
+pub const SYS_syncfs: ::c_long = 267;
+pub const SYS_setns: ::c_long = 268;
+pub const SYS_sendmmsg: ::c_long = 269;
+pub const SYS_process_vm_readv: ::c_long = 270;
+pub const SYS_process_vm_writev: ::c_long = 271;
+pub const SYS_kcmp: ::c_long = 272;
+pub const SYS_finit_module: ::c_long = 273;
+pub const SYS_sched_setattr: ::c_long = 274;
+pub const SYS_sched_getattr: ::c_long = 275;
+pub const SYS_renameat2: ::c_long = 276;
+pub const SYS_seccomp: ::c_long = 277;
+pub const SYS_getrandom: ::c_long = 278;
+pub const SYS_memfd_create: ::c_long = 279;
+pub const SYS_bpf: ::c_long = 280;
+pub const SYS_execveat: ::c_long = 281;
+pub const SYS_userfaultfd: ::c_long = 282;
+pub const SYS_membarrier: ::c_long = 283;
+pub const SYS_mlock2: ::c_long = 284;
+pub const SYS_copy_file_range: ::c_long = 285;
+pub const SYS_preadv2: ::c_long = 286;
+pub const SYS_pwritev2: ::c_long = 287;
+pub const SYS_pkey_mprotect: ::c_long = 288;
+pub const SYS_pkey_alloc: ::c_long = 289;
+pub const SYS_pkey_free: ::c_long = 290;
+pub const SYS_syscalls: ::c_long = 436;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/android/b64/mod.rs b/library/libc/src/unix/linux_like/android/b64/mod.rs
new file mode 100644
index 00000000..96244d10
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b64/mod.rs
@@ -0,0 +1,322 @@
+// The following definitions are correct for aarch64 and x86_64,
+// but may be wrong for mips64
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type mode_t = u32;
+pub type off64_t = i64;
+pub type socklen_t = u32;
+
+s! {
+    pub struct sigset_t {
+        __val: [::c_ulong; 1],
+    }
+
+    pub struct sigaction {
+        pub sa_flags: ::c_int,
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct rlimit64 {
+        pub rlim_cur: ::c_ulonglong,
+        pub rlim_max: ::c_ulonglong,
+    }
+
+    pub struct pthread_attr_t {
+        pub flags: u32,
+        pub stack_base: *mut ::c_void,
+        pub stack_size: ::size_t,
+        pub guard_size: ::size_t,
+        pub sched_policy: i32,
+        pub sched_priority: i32,
+        __reserved: [::c_char; 16],
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct statfs {
+        pub f_type: u64,
+        pub f_bsize: u64,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::__fsid_t,
+        pub f_namelen: u64,
+        pub f_frsize: u64,
+        pub f_flags: u64,
+        pub f_spare: [u64; 4],
+    }
+
+    pub struct sysinfo {
+        pub uptime: ::c_long,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub _f: [::c_char; 0],
+    }
+
+    pub struct statfs64 {
+        pub f_type: u64,
+        pub f_bsize: u64,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::__fsid_t,
+        pub f_namelen: u64,
+        pub f_frsize: u64,
+        pub f_flags: u64,
+        pub f_spare: [u64; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+}
+
+s_no_extra_traits! {
+    pub struct pthread_mutex_t {
+        value: ::c_int,
+        __reserved: [::c_char; 36],
+    }
+
+    pub struct pthread_cond_t {
+        value: ::c_int,
+        __reserved: [::c_char; 44],
+    }
+
+    pub struct pthread_rwlock_t {
+        numLocks: ::c_int,
+        writerThreadId: ::c_int,
+        pendingReaders: ::c_int,
+        pendingWriters: ::c_int,
+        attr: i32,
+        __reserved: [::c_char; 36],
+    }
+
+    pub struct sigset64_t {
+        __bits: [::c_ulong; 1]
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for pthread_mutex_t {
+            fn eq(&self, other: &pthread_mutex_t) -> bool {
+                self.value == other.value
+                    && self
+                    .__reserved
+                    .iter()
+                    .zip(other.__reserved.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_mutex_t {}
+
+        impl ::fmt::Debug for pthread_mutex_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_mutex_t")
+                    .field("value", &self.value)
+                    // FIXME: .field("__reserved", &self.__reserved)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for pthread_mutex_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.value.hash(state);
+                self.__reserved.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_cond_t {
+            fn eq(&self, other: &pthread_cond_t) -> bool {
+                self.value == other.value
+                    && self
+                    .__reserved
+                    .iter()
+                    .zip(other.__reserved.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_cond_t {}
+
+        impl ::fmt::Debug for pthread_cond_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_cond_t")
+                    .field("value", &self.value)
+                    // FIXME: .field("__reserved", &self.__reserved)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for pthread_cond_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.value.hash(state);
+                self.__reserved.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_rwlock_t {
+            fn eq(&self, other: &pthread_rwlock_t) -> bool {
+                self.numLocks == other.numLocks
+                    && self.writerThreadId == other.writerThreadId
+                    && self.pendingReaders == other.pendingReaders
+                    && self.pendingWriters == other.pendingWriters
+                    && self.attr == other.attr
+                    && self
+                    .__reserved
+                    .iter()
+                    .zip(other.__reserved.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_rwlock_t {}
+
+        impl ::fmt::Debug for pthread_rwlock_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_rwlock_t")
+                    .field("numLocks", &self.numLocks)
+                    .field("writerThreadId", &self.writerThreadId)
+                    .field("pendingReaders", &self.pendingReaders)
+                    .field("pendingWriters", &self.pendingWriters)
+                    .field("attr", &self.attr)
+                    // FIXME: .field("__reserved", &self.__reserved)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for pthread_rwlock_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.numLocks.hash(state);
+                self.writerThreadId.hash(state);
+                self.pendingReaders.hash(state);
+                self.pendingWriters.hash(state);
+                self.attr.hash(state);
+                self.__reserved.hash(state);
+            }
+        }
+
+        impl ::fmt::Debug for sigset64_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigset64_t")
+                    .field("__bits", &self.__bits)
+                    .finish()
+            }
+        }
+    }
+}
+
+// These constants must be of the same type of sigaction.sa_flags
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+
+pub const RTLD_GLOBAL: ::c_int = 0x00100;
+pub const RTLD_NOW: ::c_int = 2;
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+
+// From NDK's linux/auxvec.h
+pub const AT_NULL: ::c_ulong = 0;
+pub const AT_IGNORE: ::c_ulong = 1;
+pub const AT_EXECFD: ::c_ulong = 2;
+pub const AT_PHDR: ::c_ulong = 3;
+pub const AT_PHENT: ::c_ulong = 4;
+pub const AT_PHNUM: ::c_ulong = 5;
+pub const AT_PAGESZ: ::c_ulong = 6;
+pub const AT_BASE: ::c_ulong = 7;
+pub const AT_FLAGS: ::c_ulong = 8;
+pub const AT_ENTRY: ::c_ulong = 9;
+pub const AT_NOTELF: ::c_ulong = 10;
+pub const AT_UID: ::c_ulong = 11;
+pub const AT_EUID: ::c_ulong = 12;
+pub const AT_GID: ::c_ulong = 13;
+pub const AT_EGID: ::c_ulong = 14;
+pub const AT_PLATFORM: ::c_ulong = 15;
+pub const AT_HWCAP: ::c_ulong = 16;
+pub const AT_CLKTCK: ::c_ulong = 17;
+pub const AT_SECURE: ::c_ulong = 23;
+pub const AT_BASE_PLATFORM: ::c_ulong = 24;
+pub const AT_RANDOM: ::c_ulong = 25;
+pub const AT_HWCAP2: ::c_ulong = 26;
+pub const AT_EXECFN: ::c_ulong = 31;
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+    value: 0,
+    __reserved: [0; 36],
+};
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+    value: 0,
+    __reserved: [0; 44],
+};
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+    numLocks: 0,
+    writerThreadId: 0,
+    pendingReaders: 0,
+    pendingWriters: 0,
+    attr: 0,
+    __reserved: [0; 36],
+};
+pub const PTHREAD_STACK_MIN: ::size_t = 4096 * 4;
+pub const CPU_SETSIZE: ::size_t = 1024;
+pub const __CPU_BITS: ::size_t = 64;
+
+pub const UT_LINESIZE: usize = 32;
+pub const UT_NAMESIZE: usize = 32;
+pub const UT_HOSTSIZE: usize = 256;
+
+extern "C" {
+    pub fn getauxval(type_: ::c_ulong) -> ::c_ulong;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/linux_like/android/b64/x86_64/align.rs b/library/libc/src/unix/linux_like/android/b64/x86_64/align.rs
new file mode 100644
index 00000000..7ca870fd
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b64/x86_64/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 4]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/android/b64/x86_64/mod.rs b/library/libc/src/unix/linux_like/android/b64/x86_64/mod.rs
new file mode 100644
index 00000000..27fd17b3
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/b64/x86_64/mod.rs
@@ -0,0 +1,665 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type greg_t = i64;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::c_ulong,
+        pub st_mode: ::c_uint,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::c_long,
+        pub st_blocks: ::c_long,
+        pub st_atime: ::c_long,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::c_long,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::c_long,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 3],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::c_ulong,
+        pub st_mode: ::c_uint,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::c_long,
+        pub st_blocks: ::c_long,
+        pub st_atime: ::c_long,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::c_long,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::c_long,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 3],
+    }
+
+    pub struct _libc_xmmreg {
+        pub element: [u32; 4],
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        s_no_extra_traits! {
+            pub union __c_anonymous_uc_sigmask {
+                uc_sigmask: ::sigset_t,
+                uc_sigmask64: ::sigset64_t,
+            }
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for __c_anonymous_uc_sigmask {
+                    fn eq(&self, other: &__c_anonymous_uc_sigmask) -> bool {
+                        unsafe { self.uc_sigmask == other.uc_sigmask }
+                    }
+                }
+                impl Eq for __c_anonymous_uc_sigmask {}
+                impl ::fmt::Debug for __c_anonymous_uc_sigmask {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("uc_sigmask")
+                            .field("uc_sigmask", unsafe { &self.uc_sigmask })
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for __c_anonymous_uc_sigmask {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        unsafe { self.uc_sigmask.hash(state) }
+                    }
+                }
+            }
+        }
+    }
+}
+
+s_no_extra_traits! {
+    pub struct _libc_fpxreg {
+        pub significand: [u16; 4],
+        pub exponent: u16,
+        __padding: [u16; 3],
+    }
+
+    pub struct _libc_fpstate {
+        pub cwd: u16,
+        pub swd: u16,
+        pub ftw: u16,
+        pub fop: u16,
+        pub rip: u64,
+        pub rdp: u64,
+        pub mxcsr: u32,
+        pub mxcr_mask: u32,
+        pub _st: [_libc_fpxreg; 8],
+        pub _xmm: [_libc_xmmreg; 16],
+        __private: [u32; 24],
+    }
+
+    pub struct mcontext_t {
+        pub gregs: [greg_t; 23],
+        pub fpregs: *mut _libc_fpstate,
+        __private: [u64; 8],
+    }
+
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_mcontext: mcontext_t,
+        pub uc_sigmask64: __c_anonymous_uc_sigmask,
+        __fpregs_mem: _libc_fpstate,
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for _libc_fpxreg {
+            fn eq(&self, other: &Self) -> bool {
+                self.significand == other.significand
+                    && self.exponent == other.exponent
+                    // Ignore padding field
+            }
+        }
+        impl Eq for _libc_fpxreg {}
+        impl ::fmt::Debug for _libc_fpxreg {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("_libc_fpxreg")
+                    .field("significand", &self.significand)
+                    .field("exponent", &self.exponent)
+                    // Ignore padding field
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for _libc_fpxreg {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.significand.hash(state);
+                self.exponent.hash(state);
+                // Ignore padding field
+            }
+        }
+
+        impl PartialEq for _libc_fpstate {
+            fn eq(&self, other: &Self) -> bool {
+                self.cwd == other.cwd
+                    && self.swd == other.swd
+                    && self.ftw == other.ftw
+                    && self.fop == other.fop
+                    && self.rip == other.rip
+                    && self.rdp == other.rdp
+                    && self.mxcsr == other.mxcsr
+                    && self.mxcr_mask == other.mxcr_mask
+                    && self._st == other._st
+                    && self._xmm == other._xmm
+                    // Ignore padding field
+            }
+        }
+        impl Eq for _libc_fpstate {}
+        impl ::fmt::Debug for _libc_fpstate {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("_libc_fpstate")
+                    .field("cwd", &self.cwd)
+                    .field("swd", &self.swd)
+                    .field("ftw", &self.ftw)
+                    .field("fop", &self.fop)
+                    .field("rip", &self.rip)
+                    .field("rdp", &self.rdp)
+                    .field("mxcsr", &self.mxcsr)
+                    .field("mxcr_mask", &self.mxcr_mask)
+                    .field("_st", &self._st)
+                    .field("_xmm", &self._xmm)
+                    // Ignore padding field
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for _libc_fpstate {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.cwd.hash(state);
+                self.swd.hash(state);
+                self.ftw.hash(state);
+                self.fop.hash(state);
+                self.rip.hash(state);
+                self.rdp.hash(state);
+                self.mxcsr.hash(state);
+                self.mxcr_mask.hash(state);
+                self._st.hash(state);
+                self._xmm.hash(state);
+                // Ignore padding field
+            }
+        }
+
+        impl PartialEq for mcontext_t {
+            fn eq(&self, other: &Self) -> bool {
+                self.gregs == other.gregs
+                    && self.fpregs == other.fpregs
+                    // Ignore padding field
+            }
+        }
+        impl Eq for mcontext_t {}
+        impl ::fmt::Debug for mcontext_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("mcontext_t")
+                    .field("gregs", &self.gregs)
+                    .field("fpregs", &self.fpregs)
+                    // Ignore padding field
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for mcontext_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.gregs.hash(state);
+                self.fpregs.hash(state);
+                // Ignore padding field
+            }
+        }
+
+        impl PartialEq for ucontext_t {
+            fn eq(&self, other: &Self) -> bool {
+                self.uc_flags == other.uc_flags
+                    && self.uc_link == other.uc_link
+                    && self.uc_stack == other.uc_stack
+                    && self.uc_mcontext == other.uc_mcontext
+                    && self.uc_sigmask64 == other.uc_sigmask64
+                    // Ignore padding field
+            }
+        }
+        impl Eq for ucontext_t {}
+        impl ::fmt::Debug for ucontext_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("ucontext_t")
+                    .field("uc_flags", &self.uc_flags)
+                    .field("uc_link", &self.uc_link)
+                    .field("uc_stack", &self.uc_stack)
+                    .field("uc_mcontext", &self.uc_mcontext)
+                    .field("uc_sigmask64", &self.uc_sigmask64)
+                    // Ignore padding field
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for ucontext_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uc_flags.hash(state);
+                self.uc_link.hash(state);
+                self.uc_stack.hash(state);
+                self.uc_mcontext.hash(state);
+                self.uc_sigmask64.hash(state);
+                // Ignore padding field
+            }
+        }
+    }
+}
+
+pub const O_DIRECT: ::c_int = 0x4000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+pub const O_LARGEFILE: ::c_int = 0o0100000;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+
+pub const MAP_32BIT: ::c_int = 0x40;
+
+// Syscall table
+
+pub const SYS_read: ::c_long = 0;
+pub const SYS_write: ::c_long = 1;
+pub const SYS_open: ::c_long = 2;
+pub const SYS_close: ::c_long = 3;
+pub const SYS_stat: ::c_long = 4;
+pub const SYS_fstat: ::c_long = 5;
+pub const SYS_lstat: ::c_long = 6;
+pub const SYS_poll: ::c_long = 7;
+pub const SYS_lseek: ::c_long = 8;
+pub const SYS_mmap: ::c_long = 9;
+pub const SYS_mprotect: ::c_long = 10;
+pub const SYS_munmap: ::c_long = 11;
+pub const SYS_brk: ::c_long = 12;
+pub const SYS_rt_sigaction: ::c_long = 13;
+pub const SYS_rt_sigprocmask: ::c_long = 14;
+pub const SYS_rt_sigreturn: ::c_long = 15;
+pub const SYS_ioctl: ::c_long = 16;
+pub const SYS_pread64: ::c_long = 17;
+pub const SYS_pwrite64: ::c_long = 18;
+pub const SYS_readv: ::c_long = 19;
+pub const SYS_writev: ::c_long = 20;
+pub const SYS_access: ::c_long = 21;
+pub const SYS_pipe: ::c_long = 22;
+pub const SYS_select: ::c_long = 23;
+pub const SYS_sched_yield: ::c_long = 24;
+pub const SYS_mremap: ::c_long = 25;
+pub const SYS_msync: ::c_long = 26;
+pub const SYS_mincore: ::c_long = 27;
+pub const SYS_madvise: ::c_long = 28;
+pub const SYS_shmget: ::c_long = 29;
+pub const SYS_shmat: ::c_long = 30;
+pub const SYS_shmctl: ::c_long = 31;
+pub const SYS_dup: ::c_long = 32;
+pub const SYS_dup2: ::c_long = 33;
+pub const SYS_pause: ::c_long = 34;
+pub const SYS_nanosleep: ::c_long = 35;
+pub const SYS_getitimer: ::c_long = 36;
+pub const SYS_alarm: ::c_long = 37;
+pub const SYS_setitimer: ::c_long = 38;
+pub const SYS_getpid: ::c_long = 39;
+pub const SYS_sendfile: ::c_long = 40;
+pub const SYS_socket: ::c_long = 41;
+pub const SYS_connect: ::c_long = 42;
+pub const SYS_accept: ::c_long = 43;
+pub const SYS_sendto: ::c_long = 44;
+pub const SYS_recvfrom: ::c_long = 45;
+pub const SYS_sendmsg: ::c_long = 46;
+pub const SYS_recvmsg: ::c_long = 47;
+pub const SYS_shutdown: ::c_long = 48;
+pub const SYS_bind: ::c_long = 49;
+pub const SYS_listen: ::c_long = 50;
+pub const SYS_getsockname: ::c_long = 51;
+pub const SYS_getpeername: ::c_long = 52;
+pub const SYS_socketpair: ::c_long = 53;
+pub const SYS_setsockopt: ::c_long = 54;
+pub const SYS_getsockopt: ::c_long = 55;
+pub const SYS_clone: ::c_long = 56;
+pub const SYS_fork: ::c_long = 57;
+pub const SYS_vfork: ::c_long = 58;
+pub const SYS_execve: ::c_long = 59;
+pub const SYS_exit: ::c_long = 60;
+pub const SYS_wait4: ::c_long = 61;
+pub const SYS_kill: ::c_long = 62;
+pub const SYS_uname: ::c_long = 63;
+pub const SYS_semget: ::c_long = 64;
+pub const SYS_semop: ::c_long = 65;
+pub const SYS_semctl: ::c_long = 66;
+pub const SYS_shmdt: ::c_long = 67;
+pub const SYS_msgget: ::c_long = 68;
+pub const SYS_msgsnd: ::c_long = 69;
+pub const SYS_msgrcv: ::c_long = 70;
+pub const SYS_msgctl: ::c_long = 71;
+pub const SYS_fcntl: ::c_long = 72;
+pub const SYS_flock: ::c_long = 73;
+pub const SYS_fsync: ::c_long = 74;
+pub const SYS_fdatasync: ::c_long = 75;
+pub const SYS_truncate: ::c_long = 76;
+pub const SYS_ftruncate: ::c_long = 77;
+pub const SYS_getdents: ::c_long = 78;
+pub const SYS_getcwd: ::c_long = 79;
+pub const SYS_chdir: ::c_long = 80;
+pub const SYS_fchdir: ::c_long = 81;
+pub const SYS_rename: ::c_long = 82;
+pub const SYS_mkdir: ::c_long = 83;
+pub const SYS_rmdir: ::c_long = 84;
+pub const SYS_creat: ::c_long = 85;
+pub const SYS_link: ::c_long = 86;
+pub const SYS_unlink: ::c_long = 87;
+pub const SYS_symlink: ::c_long = 88;
+pub const SYS_readlink: ::c_long = 89;
+pub const SYS_chmod: ::c_long = 90;
+pub const SYS_fchmod: ::c_long = 91;
+pub const SYS_chown: ::c_long = 92;
+pub const SYS_fchown: ::c_long = 93;
+pub const SYS_lchown: ::c_long = 94;
+pub const SYS_umask: ::c_long = 95;
+pub const SYS_gettimeofday: ::c_long = 96;
+pub const SYS_getrlimit: ::c_long = 97;
+pub const SYS_getrusage: ::c_long = 98;
+pub const SYS_sysinfo: ::c_long = 99;
+pub const SYS_times: ::c_long = 100;
+pub const SYS_ptrace: ::c_long = 101;
+pub const SYS_getuid: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_getgid: ::c_long = 104;
+pub const SYS_setuid: ::c_long = 105;
+pub const SYS_setgid: ::c_long = 106;
+pub const SYS_geteuid: ::c_long = 107;
+pub const SYS_getegid: ::c_long = 108;
+pub const SYS_setpgid: ::c_long = 109;
+pub const SYS_getppid: ::c_long = 110;
+pub const SYS_getpgrp: ::c_long = 111;
+pub const SYS_setsid: ::c_long = 112;
+pub const SYS_setreuid: ::c_long = 113;
+pub const SYS_setregid: ::c_long = 114;
+pub const SYS_getgroups: ::c_long = 115;
+pub const SYS_setgroups: ::c_long = 116;
+pub const SYS_setresuid: ::c_long = 117;
+pub const SYS_getresuid: ::c_long = 118;
+pub const SYS_setresgid: ::c_long = 119;
+pub const SYS_getresgid: ::c_long = 120;
+pub const SYS_getpgid: ::c_long = 121;
+pub const SYS_setfsuid: ::c_long = 122;
+pub const SYS_setfsgid: ::c_long = 123;
+pub const SYS_getsid: ::c_long = 124;
+pub const SYS_capget: ::c_long = 125;
+pub const SYS_capset: ::c_long = 126;
+pub const SYS_rt_sigpending: ::c_long = 127;
+pub const SYS_rt_sigtimedwait: ::c_long = 128;
+pub const SYS_rt_sigqueueinfo: ::c_long = 129;
+pub const SYS_rt_sigsuspend: ::c_long = 130;
+pub const SYS_sigaltstack: ::c_long = 131;
+pub const SYS_utime: ::c_long = 132;
+pub const SYS_mknod: ::c_long = 133;
+pub const SYS_uselib: ::c_long = 134;
+pub const SYS_personality: ::c_long = 135;
+pub const SYS_ustat: ::c_long = 136;
+pub const SYS_statfs: ::c_long = 137;
+pub const SYS_fstatfs: ::c_long = 138;
+pub const SYS_sysfs: ::c_long = 139;
+pub const SYS_getpriority: ::c_long = 140;
+pub const SYS_setpriority: ::c_long = 141;
+pub const SYS_sched_setparam: ::c_long = 142;
+pub const SYS_sched_getparam: ::c_long = 143;
+pub const SYS_sched_setscheduler: ::c_long = 144;
+pub const SYS_sched_getscheduler: ::c_long = 145;
+pub const SYS_sched_get_priority_max: ::c_long = 146;
+pub const SYS_sched_get_priority_min: ::c_long = 147;
+pub const SYS_sched_rr_get_interval: ::c_long = 148;
+pub const SYS_mlock: ::c_long = 149;
+pub const SYS_munlock: ::c_long = 150;
+pub const SYS_mlockall: ::c_long = 151;
+pub const SYS_munlockall: ::c_long = 152;
+pub const SYS_vhangup: ::c_long = 153;
+pub const SYS_modify_ldt: ::c_long = 154;
+pub const SYS_pivot_root: ::c_long = 155;
+// FIXME: SYS__sysctl is in the NDK sources but for some reason is
+//        not available in the tests
+// pub const SYS__sysctl: ::c_long = 156;
+pub const SYS_prctl: ::c_long = 157;
+pub const SYS_arch_prctl: ::c_long = 158;
+pub const SYS_adjtimex: ::c_long = 159;
+pub const SYS_setrlimit: ::c_long = 160;
+pub const SYS_chroot: ::c_long = 161;
+pub const SYS_sync: ::c_long = 162;
+pub const SYS_acct: ::c_long = 163;
+pub const SYS_settimeofday: ::c_long = 164;
+pub const SYS_mount: ::c_long = 165;
+pub const SYS_umount2: ::c_long = 166;
+pub const SYS_swapon: ::c_long = 167;
+pub const SYS_swapoff: ::c_long = 168;
+pub const SYS_reboot: ::c_long = 169;
+pub const SYS_sethostname: ::c_long = 170;
+pub const SYS_setdomainname: ::c_long = 171;
+pub const SYS_iopl: ::c_long = 172;
+pub const SYS_ioperm: ::c_long = 173;
+pub const SYS_create_module: ::c_long = 174;
+pub const SYS_init_module: ::c_long = 175;
+pub const SYS_delete_module: ::c_long = 176;
+pub const SYS_get_kernel_syms: ::c_long = 177;
+pub const SYS_query_module: ::c_long = 178;
+pub const SYS_quotactl: ::c_long = 179;
+pub const SYS_nfsservctl: ::c_long = 180;
+pub const SYS_getpmsg: ::c_long = 181;
+pub const SYS_putpmsg: ::c_long = 182;
+pub const SYS_afs_syscall: ::c_long = 183;
+pub const SYS_tuxcall: ::c_long = 184;
+pub const SYS_security: ::c_long = 185;
+pub const SYS_gettid: ::c_long = 186;
+pub const SYS_readahead: ::c_long = 187;
+pub const SYS_setxattr: ::c_long = 188;
+pub const SYS_lsetxattr: ::c_long = 189;
+pub const SYS_fsetxattr: ::c_long = 190;
+pub const SYS_getxattr: ::c_long = 191;
+pub const SYS_lgetxattr: ::c_long = 192;
+pub const SYS_fgetxattr: ::c_long = 193;
+pub const SYS_listxattr: ::c_long = 194;
+pub const SYS_llistxattr: ::c_long = 195;
+pub const SYS_flistxattr: ::c_long = 196;
+pub const SYS_removexattr: ::c_long = 197;
+pub const SYS_lremovexattr: ::c_long = 198;
+pub const SYS_fremovexattr: ::c_long = 199;
+pub const SYS_tkill: ::c_long = 200;
+pub const SYS_time: ::c_long = 201;
+pub const SYS_futex: ::c_long = 202;
+pub const SYS_sched_setaffinity: ::c_long = 203;
+pub const SYS_sched_getaffinity: ::c_long = 204;
+pub const SYS_set_thread_area: ::c_long = 205;
+pub const SYS_io_setup: ::c_long = 206;
+pub const SYS_io_destroy: ::c_long = 207;
+pub const SYS_io_getevents: ::c_long = 208;
+pub const SYS_io_submit: ::c_long = 209;
+pub const SYS_io_cancel: ::c_long = 210;
+pub const SYS_get_thread_area: ::c_long = 211;
+pub const SYS_lookup_dcookie: ::c_long = 212;
+pub const SYS_epoll_create: ::c_long = 213;
+pub const SYS_epoll_ctl_old: ::c_long = 214;
+pub const SYS_epoll_wait_old: ::c_long = 215;
+pub const SYS_remap_file_pages: ::c_long = 216;
+pub const SYS_getdents64: ::c_long = 217;
+pub const SYS_set_tid_address: ::c_long = 218;
+pub const SYS_restart_syscall: ::c_long = 219;
+pub const SYS_semtimedop: ::c_long = 220;
+pub const SYS_fadvise64: ::c_long = 221;
+pub const SYS_timer_create: ::c_long = 222;
+pub const SYS_timer_settime: ::c_long = 223;
+pub const SYS_timer_gettime: ::c_long = 224;
+pub const SYS_timer_getoverrun: ::c_long = 225;
+pub const SYS_timer_delete: ::c_long = 226;
+pub const SYS_clock_settime: ::c_long = 227;
+pub const SYS_clock_gettime: ::c_long = 228;
+pub const SYS_clock_getres: ::c_long = 229;
+pub const SYS_clock_nanosleep: ::c_long = 230;
+pub const SYS_exit_group: ::c_long = 231;
+pub const SYS_epoll_wait: ::c_long = 232;
+pub const SYS_epoll_ctl: ::c_long = 233;
+pub const SYS_tgkill: ::c_long = 234;
+pub const SYS_utimes: ::c_long = 235;
+pub const SYS_vserver: ::c_long = 236;
+pub const SYS_mbind: ::c_long = 237;
+pub const SYS_set_mempolicy: ::c_long = 238;
+pub const SYS_get_mempolicy: ::c_long = 239;
+pub const SYS_mq_open: ::c_long = 240;
+pub const SYS_mq_unlink: ::c_long = 241;
+pub const SYS_mq_timedsend: ::c_long = 242;
+pub const SYS_mq_timedreceive: ::c_long = 243;
+pub const SYS_mq_notify: ::c_long = 244;
+pub const SYS_mq_getsetattr: ::c_long = 245;
+pub const SYS_kexec_load: ::c_long = 246;
+pub const SYS_waitid: ::c_long = 247;
+pub const SYS_add_key: ::c_long = 248;
+pub const SYS_request_key: ::c_long = 249;
+pub const SYS_keyctl: ::c_long = 250;
+pub const SYS_ioprio_set: ::c_long = 251;
+pub const SYS_ioprio_get: ::c_long = 252;
+pub const SYS_inotify_init: ::c_long = 253;
+pub const SYS_inotify_add_watch: ::c_long = 254;
+pub const SYS_inotify_rm_watch: ::c_long = 255;
+pub const SYS_migrate_pages: ::c_long = 256;
+pub const SYS_openat: ::c_long = 257;
+pub const SYS_mkdirat: ::c_long = 258;
+pub const SYS_mknodat: ::c_long = 259;
+pub const SYS_fchownat: ::c_long = 260;
+pub const SYS_futimesat: ::c_long = 261;
+pub const SYS_newfstatat: ::c_long = 262;
+pub const SYS_unlinkat: ::c_long = 263;
+pub const SYS_renameat: ::c_long = 264;
+pub const SYS_linkat: ::c_long = 265;
+pub const SYS_symlinkat: ::c_long = 266;
+pub const SYS_readlinkat: ::c_long = 267;
+pub const SYS_fchmodat: ::c_long = 268;
+pub const SYS_faccessat: ::c_long = 269;
+pub const SYS_pselect6: ::c_long = 270;
+pub const SYS_ppoll: ::c_long = 271;
+pub const SYS_unshare: ::c_long = 272;
+pub const SYS_set_robust_list: ::c_long = 273;
+pub const SYS_get_robust_list: ::c_long = 274;
+pub const SYS_splice: ::c_long = 275;
+pub const SYS_tee: ::c_long = 276;
+pub const SYS_sync_file_range: ::c_long = 277;
+pub const SYS_vmsplice: ::c_long = 278;
+pub const SYS_move_pages: ::c_long = 279;
+pub const SYS_utimensat: ::c_long = 280;
+pub const SYS_epoll_pwait: ::c_long = 281;
+pub const SYS_signalfd: ::c_long = 282;
+pub const SYS_timerfd_create: ::c_long = 283;
+pub const SYS_eventfd: ::c_long = 284;
+pub const SYS_fallocate: ::c_long = 285;
+pub const SYS_timerfd_settime: ::c_long = 286;
+pub const SYS_timerfd_gettime: ::c_long = 287;
+pub const SYS_accept4: ::c_long = 288;
+pub const SYS_signalfd4: ::c_long = 289;
+pub const SYS_eventfd2: ::c_long = 290;
+pub const SYS_epoll_create1: ::c_long = 291;
+pub const SYS_dup3: ::c_long = 292;
+pub const SYS_pipe2: ::c_long = 293;
+pub const SYS_inotify_init1: ::c_long = 294;
+pub const SYS_preadv: ::c_long = 295;
+pub const SYS_pwritev: ::c_long = 296;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 297;
+pub const SYS_perf_event_open: ::c_long = 298;
+pub const SYS_recvmmsg: ::c_long = 299;
+pub const SYS_fanotify_init: ::c_long = 300;
+pub const SYS_fanotify_mark: ::c_long = 301;
+pub const SYS_prlimit64: ::c_long = 302;
+pub const SYS_name_to_handle_at: ::c_long = 303;
+pub const SYS_open_by_handle_at: ::c_long = 304;
+pub const SYS_clock_adjtime: ::c_long = 305;
+pub const SYS_syncfs: ::c_long = 306;
+pub const SYS_sendmmsg: ::c_long = 307;
+pub const SYS_setns: ::c_long = 308;
+pub const SYS_getcpu: ::c_long = 309;
+pub const SYS_process_vm_readv: ::c_long = 310;
+pub const SYS_process_vm_writev: ::c_long = 311;
+pub const SYS_kcmp: ::c_long = 312;
+pub const SYS_finit_module: ::c_long = 313;
+pub const SYS_sched_setattr: ::c_long = 314;
+pub const SYS_sched_getattr: ::c_long = 315;
+pub const SYS_renameat2: ::c_long = 316;
+pub const SYS_seccomp: ::c_long = 317;
+pub const SYS_getrandom: ::c_long = 318;
+pub const SYS_memfd_create: ::c_long = 319;
+pub const SYS_kexec_file_load: ::c_long = 320;
+pub const SYS_bpf: ::c_long = 321;
+pub const SYS_execveat: ::c_long = 322;
+pub const SYS_userfaultfd: ::c_long = 323;
+pub const SYS_membarrier: ::c_long = 324;
+pub const SYS_mlock2: ::c_long = 325;
+pub const SYS_copy_file_range: ::c_long = 326;
+pub const SYS_preadv2: ::c_long = 327;
+pub const SYS_pwritev2: ::c_long = 328;
+pub const SYS_pkey_mprotect: ::c_long = 329;
+pub const SYS_pkey_alloc: ::c_long = 330;
+pub const SYS_pkey_free: ::c_long = 331;
+
+// offsets in user_regs_structs, from sys/reg.h
+pub const R15: ::c_int = 0;
+pub const R14: ::c_int = 1;
+pub const R13: ::c_int = 2;
+pub const R12: ::c_int = 3;
+pub const RBP: ::c_int = 4;
+pub const RBX: ::c_int = 5;
+pub const R11: ::c_int = 6;
+pub const R10: ::c_int = 7;
+pub const R9: ::c_int = 8;
+pub const R8: ::c_int = 9;
+pub const RAX: ::c_int = 10;
+pub const RCX: ::c_int = 11;
+pub const RDX: ::c_int = 12;
+pub const RSI: ::c_int = 13;
+pub const RDI: ::c_int = 14;
+pub const ORIG_RAX: ::c_int = 15;
+pub const RIP: ::c_int = 16;
+pub const CS: ::c_int = 17;
+pub const EFLAGS: ::c_int = 18;
+pub const RSP: ::c_int = 19;
+pub const SS: ::c_int = 20;
+pub const FS_BASE: ::c_int = 21;
+pub const GS_BASE: ::c_int = 22;
+pub const DS: ::c_int = 23;
+pub const ES: ::c_int = 24;
+pub const FS: ::c_int = 25;
+pub const GS: ::c_int = 26;
+
+// offsets in mcontext_t.gregs from sys/ucontext.h
+pub const REG_R8: ::c_int = 0;
+pub const REG_R9: ::c_int = 1;
+pub const REG_R10: ::c_int = 2;
+pub const REG_R11: ::c_int = 3;
+pub const REG_R12: ::c_int = 4;
+pub const REG_R13: ::c_int = 5;
+pub const REG_R14: ::c_int = 6;
+pub const REG_R15: ::c_int = 7;
+pub const REG_RDI: ::c_int = 8;
+pub const REG_RSI: ::c_int = 9;
+pub const REG_RBP: ::c_int = 10;
+pub const REG_RBX: ::c_int = 11;
+pub const REG_RDX: ::c_int = 12;
+pub const REG_RAX: ::c_int = 13;
+pub const REG_RCX: ::c_int = 14;
+pub const REG_RSP: ::c_int = 15;
+pub const REG_RIP: ::c_int = 16;
+pub const REG_EFL: ::c_int = 17;
+pub const REG_CSGSFS: ::c_int = 18;
+pub const REG_ERR: ::c_int = 19;
+pub const REG_TRAPNO: ::c_int = 20;
+pub const REG_OLDMASK: ::c_int = 21;
+pub const REG_CR2: ::c_int = 22;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/android/mod.rs b/library/libc/src/unix/linux_like/android/mod.rs
new file mode 100644
index 00000000..09ecdd62
--- /dev/null
+++ b/library/libc/src/unix/linux_like/android/mod.rs
@@ -0,0 +1,2853 @@
+//! Android-specific definitions for linux-like values
+
+pub type clock_t = ::c_long;
+pub type time_t = ::c_long;
+pub type suseconds_t = ::c_long;
+pub type off_t = ::c_long;
+pub type blkcnt_t = ::c_ulong;
+pub type blksize_t = ::c_ulong;
+pub type nlink_t = u32;
+pub type useconds_t = u32;
+pub type pthread_t = ::c_long;
+pub type pthread_mutexattr_t = ::c_long;
+pub type pthread_rwlockattr_t = ::c_long;
+pub type pthread_condattr_t = ::c_long;
+pub type pthread_key_t = ::c_int;
+pub type fsfilcnt_t = ::c_ulong;
+pub type fsblkcnt_t = ::c_ulong;
+pub type nfds_t = ::c_uint;
+pub type rlim_t = ::c_ulong;
+pub type dev_t = ::c_ulong;
+pub type ino_t = ::c_ulong;
+pub type ino64_t = u64;
+pub type __CPU_BITTYPE = ::c_ulong;
+pub type idtype_t = ::c_int;
+pub type loff_t = ::c_longlong;
+pub type __kernel_loff_t = ::c_longlong;
+pub type __kernel_pid_t = ::c_int;
+
+s! {
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct __fsid_t {
+        __val: [::c_int; 2],
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::size_t,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::size_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::size_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::__kernel_loff_t,
+        pub l_len: ::__kernel_loff_t,
+        pub l_pid: ::__kernel_pid_t,
+    }
+
+    pub struct cpu_set_t {
+        #[cfg(target_pointer_width = "64")]
+        __bits: [__CPU_BITTYPE; 16],
+        #[cfg(target_pointer_width = "32")]
+        __bits: [__CPU_BITTYPE; 1],
+    }
+
+    pub struct sem_t {
+        count: ::c_uint,
+        #[cfg(target_pointer_width = "64")]
+        __reserved: [::c_int; 3],
+    }
+
+    pub struct exit_status {
+        pub e_termination: ::c_short,
+        pub e_exit: ::c_short,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        #[cfg(target_pointer_width = "64")]
+        __f_reserved: [u32; 6],
+    }
+
+    pub struct signalfd_siginfo {
+        pub ssi_signo: u32,
+        pub ssi_errno: i32,
+        pub ssi_code: i32,
+        pub ssi_pid: u32,
+        pub ssi_uid: u32,
+        pub ssi_fd: i32,
+        pub ssi_tid: u32,
+        pub ssi_band: u32,
+        pub ssi_overrun: u32,
+        pub ssi_trapno: u32,
+        pub ssi_status: i32,
+        pub ssi_int: i32,
+        pub ssi_ptr: ::c_ulonglong,
+        pub ssi_utime: ::c_ulonglong,
+        pub ssi_stime: ::c_ulonglong,
+        pub ssi_addr: ::c_ulonglong,
+        pub ssi_addr_lsb: u16,
+        _pad2: u16,
+        pub ssi_syscall: i32,
+        pub ssi_call_addr: u64,
+        pub ssi_arch: u32,
+        _pad: [u8; 28],
+    }
+
+    pub struct itimerspec {
+        pub it_interval: ::timespec,
+        pub it_value: ::timespec,
+    }
+
+    pub struct ucred {
+        pub pid: ::pid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+    }
+
+    pub struct genlmsghdr {
+        pub cmd: u8,
+        pub version: u8,
+        pub reserved: u16,
+    }
+
+    pub struct nlmsghdr {
+        pub nlmsg_len: u32,
+        pub nlmsg_type: u16,
+        pub nlmsg_flags: u16,
+        pub nlmsg_seq: u32,
+        pub nlmsg_pid: u32,
+    }
+
+    pub struct nlmsgerr {
+        pub error: ::c_int,
+        pub msg: nlmsghdr,
+    }
+
+    pub struct nl_pktinfo {
+        pub group: u32,
+    }
+
+    pub struct nl_mmap_req {
+        pub nm_block_size: ::c_uint,
+        pub nm_block_nr: ::c_uint,
+        pub nm_frame_size: ::c_uint,
+        pub nm_frame_nr: ::c_uint,
+    }
+
+    pub struct nl_mmap_hdr {
+        pub nm_status: ::c_uint,
+        pub nm_len: ::c_uint,
+        pub nm_group: u32,
+        pub nm_pid: u32,
+        pub nm_uid: u32,
+        pub nm_gid: u32,
+    }
+
+    pub struct nlattr {
+        pub nla_len: u16,
+        pub nla_type: u16,
+    }
+
+    pub struct in6_pktinfo {
+        pub ipi6_addr: ::in6_addr,
+        pub ipi6_ifindex: ::c_int,
+    }
+
+    pub struct inotify_event {
+        pub wd: ::c_int,
+        pub mask: u32,
+        pub cookie: u32,
+        pub len: u32
+    }
+
+    pub struct sock_extended_err {
+        pub ee_errno: u32,
+        pub ee_origin: u8,
+        pub ee_type: u8,
+        pub ee_code: u8,
+        pub ee_pad: u8,
+        pub ee_info: u32,
+        pub ee_data: u32,
+    }
+
+    pub struct regex_t {
+        re_magic: ::c_int,
+        re_nsub: ::size_t,
+        re_endp: *const ::c_char,
+        re_guts: *mut ::c_void,
+    }
+
+    pub struct regmatch_t {
+        pub rm_so: ::ssize_t,
+        pub rm_eo: ::ssize_t,
+    }
+
+    pub struct sockaddr_vm {
+        pub svm_family: ::sa_family_t,
+        pub svm_reserved1: ::c_ushort,
+        pub svm_port: ::c_uint,
+        pub svm_cid: ::c_uint,
+        pub svm_zero: [u8; 4]
+    }
+}
+
+s_no_extra_traits! {
+    pub struct sockaddr_nl {
+        pub nl_family: ::sa_family_t,
+        nl_pad: ::c_ushort,
+        pub nl_pid: u32,
+        pub nl_groups: u32
+    }
+
+    pub struct dirent {
+        pub d_ino: u64,
+        pub d_off: i64,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct dirent64 {
+        pub d_ino: u64,
+        pub d_off: i64,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct lastlog {
+        ll_time: ::time_t,
+        ll_line: [::c_char; UT_LINESIZE],
+        ll_host: [::c_char; UT_HOSTSIZE],
+    }
+
+    pub struct utmp {
+        pub ut_type: ::c_short,
+        pub ut_pid: ::pid_t,
+        pub ut_line: [::c_char; UT_LINESIZE],
+        pub ut_id: [::c_char; 4],
+        pub ut_user: [::c_char; UT_NAMESIZE],
+        pub ut_host: [::c_char; UT_HOSTSIZE],
+        pub ut_exit: exit_status,
+        pub ut_session: ::c_long,
+        pub ut_tv: ::timeval,
+        pub ut_addr_v6: [i32; 4],
+        unused: [::c_char; 20],
+    }
+
+    pub struct sockaddr_alg {
+        pub salg_family: ::sa_family_t,
+        pub salg_type: [::c_uchar; 14],
+        pub salg_feat: u32,
+        pub salg_mask: u32,
+        pub salg_name: [::c_uchar; 64],
+    }
+
+    /// WARNING: The `PartialEq`, `Eq` and `Hash` implementations of this
+    /// type are unsound and will be removed in the future.
+    #[deprecated(
+        note = "this struct has unsafe trait implementations that will be \
+                removed in the future",
+        since = "0.2.80"
+    )]
+    pub struct af_alg_iv {
+        pub ivlen: u32,
+        pub iv: [::c_uchar; 0],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for sockaddr_nl {
+            fn eq(&self, other: &sockaddr_nl) -> bool {
+                self.nl_family == other.nl_family &&
+                    self.nl_pid == other.nl_pid &&
+                    self.nl_groups == other.nl_groups
+            }
+        }
+        impl Eq for sockaddr_nl {}
+        impl ::fmt::Debug for sockaddr_nl {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_nl")
+                    .field("nl_family", &self.nl_family)
+                    .field("nl_pid", &self.nl_pid)
+                    .field("nl_groups", &self.nl_groups)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_nl {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.nl_family.hash(state);
+                self.nl_pid.hash(state);
+                self.nl_groups.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for dirent {}
+
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent64 {
+            fn eq(&self, other: &dirent64) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for dirent64 {}
+
+        impl ::fmt::Debug for dirent64 {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent64")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for dirent64 {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for siginfo_t {
+            fn eq(&self, other: &siginfo_t) -> bool {
+                self.si_signo == other.si_signo
+                    && self.si_errno == other.si_errno
+                    && self.si_code == other.si_code
+                // Ignore _pad
+                // Ignore _align
+            }
+        }
+
+        impl Eq for siginfo_t {}
+
+        impl ::fmt::Debug for siginfo_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("siginfo_t")
+                    .field("si_signo", &self.si_signo)
+                    .field("si_errno", &self.si_errno)
+                    .field("si_code", &self.si_code)
+                // Ignore _pad
+                // Ignore _align
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for siginfo_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.si_signo.hash(state);
+                self.si_errno.hash(state);
+                self.si_code.hash(state);
+                // Ignore _pad
+                // Ignore _align
+            }
+        }
+
+        impl PartialEq for lastlog {
+            fn eq(&self, other: &lastlog) -> bool {
+                self.ll_time == other.ll_time
+                    && self
+                    .ll_line
+                    .iter()
+                    .zip(other.ll_line.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .ll_host
+                    .iter()
+                    .zip(other.ll_host.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for lastlog {}
+
+        impl ::fmt::Debug for lastlog {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("lastlog")
+                    .field("ll_time", &self.ll_time)
+                    .field("ll_line", &self.ll_line)
+                // FIXME: .field("ll_host", &self.ll_host)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for lastlog {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ll_time.hash(state);
+                self.ll_line.hash(state);
+                self.ll_host.hash(state);
+            }
+        }
+
+        impl PartialEq for utmp {
+            fn eq(&self, other: &utmp) -> bool {
+                self.ut_type == other.ut_type
+                    && self.ut_pid == other.ut_pid
+                    && self
+                    .ut_line
+                    .iter()
+                    .zip(other.ut_line.iter())
+                    .all(|(a,b)| a == b)
+                    && self.ut_id == other.ut_id
+                    && self
+                    .ut_user
+                    .iter()
+                    .zip(other.ut_user.iter())
+                    .all(|(a,b)| a == b)
+                    && self
+                    .ut_host
+                    .iter()
+                    .zip(other.ut_host.iter())
+                    .all(|(a,b)| a == b)
+                    && self.ut_exit == other.ut_exit
+                    && self.ut_session == other.ut_session
+                    && self.ut_tv == other.ut_tv
+                    && self.ut_addr_v6 == other.ut_addr_v6
+                    && self.unused == other.unused
+            }
+        }
+
+        impl Eq for utmp {}
+
+        impl ::fmt::Debug for utmp {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmp")
+                    .field("ut_type", &self.ut_type)
+                    .field("ut_pid", &self.ut_pid)
+                    .field("ut_line", &self.ut_line)
+                    .field("ut_id", &self.ut_id)
+                    .field("ut_user", &self.ut_user)
+                // FIXME: .field("ut_host", &self.ut_host)
+                    .field("ut_exit", &self.ut_exit)
+                    .field("ut_session", &self.ut_session)
+                    .field("ut_tv", &self.ut_tv)
+                    .field("ut_addr_v6", &self.ut_addr_v6)
+                    .field("unused", &self.unused)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utmp {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_type.hash(state);
+                self.ut_pid.hash(state);
+                self.ut_line.hash(state);
+                self.ut_id.hash(state);
+                self.ut_user.hash(state);
+                self.ut_host.hash(state);
+                self.ut_exit.hash(state);
+                self.ut_session.hash(state);
+                self.ut_tv.hash(state);
+                self.ut_addr_v6.hash(state);
+                self.unused.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_alg {
+            fn eq(&self, other: &sockaddr_alg) -> bool {
+                self.salg_family == other.salg_family
+                    && self
+                    .salg_type
+                    .iter()
+                    .zip(other.salg_type.iter())
+                    .all(|(a, b)| a == b)
+                    && self.salg_feat == other.salg_feat
+                    && self.salg_mask == other.salg_mask
+                    && self
+                    .salg_name
+                    .iter()
+                    .zip(other.salg_name.iter())
+                    .all(|(a, b)| a == b)
+           }
+        }
+
+        impl Eq for sockaddr_alg {}
+
+        impl ::fmt::Debug for sockaddr_alg {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_alg")
+                    .field("salg_family", &self.salg_family)
+                    .field("salg_type", &self.salg_type)
+                    .field("salg_feat", &self.salg_feat)
+                    .field("salg_mask", &self.salg_mask)
+                    .field("salg_name", &&self.salg_name[..])
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sockaddr_alg {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.salg_family.hash(state);
+                self.salg_type.hash(state);
+                self.salg_feat.hash(state);
+                self.salg_mask.hash(state);
+                self.salg_name.hash(state);
+            }
+        }
+
+        #[allow(deprecated)]
+        impl af_alg_iv {
+            fn as_slice(&self) -> &[u8] {
+                unsafe {
+                    ::core::slice::from_raw_parts(
+                        self.iv.as_ptr(),
+                        self.ivlen as usize
+                    )
+                }
+            }
+        }
+
+        #[allow(deprecated)]
+        impl PartialEq for af_alg_iv {
+            fn eq(&self, other: &af_alg_iv) -> bool {
+                *self.as_slice() == *other.as_slice()
+           }
+        }
+
+        #[allow(deprecated)]
+        impl Eq for af_alg_iv {}
+
+        #[allow(deprecated)]
+        impl ::fmt::Debug for af_alg_iv {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("af_alg_iv")
+                    .field("ivlen", &self.ivlen)
+                    .finish()
+            }
+        }
+
+        #[allow(deprecated)]
+        impl ::hash::Hash for af_alg_iv {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.as_slice().hash(state);
+            }
+        }
+    }
+}
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MS_NOUSER: ::c_ulong = 0xffffffff80000000;
+pub const MS_RMT_MASK: ::c_ulong = 0x02800051;
+
+pub const O_TRUNC: ::c_int = 512;
+pub const O_CLOEXEC: ::c_int = 0x80000;
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_NOATIME: ::c_int = 0o1000000;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+pub const EPOLLONESHOT: ::c_int = 0x40000000;
+pub const EPOLLRDHUP: ::c_int = 0x00002000;
+pub const EPOLLWAKEUP: ::c_int = 0x20000000;
+
+// sys/eventfd.h
+pub const EFD_SEMAPHORE: ::c_int = 0x1;
+pub const EFD_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const EFD_NONBLOCK: ::c_int = O_NONBLOCK;
+
+// sys/timerfd.h
+pub const TFD_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const TFD_NONBLOCK: ::c_int = O_NONBLOCK;
+pub const TFD_TIMER_ABSTIME: ::c_int = 1;
+pub const TFD_TIMER_CANCEL_ON_SET: ::c_int = 2;
+
+pub const USER_PROCESS: ::c_short = 7;
+
+// linux/falloc.h
+pub const FALLOC_FL_KEEP_SIZE: ::c_int = 0x01;
+pub const FALLOC_FL_PUNCH_HOLE: ::c_int = 0x02;
+pub const FALLOC_FL_NO_HIDE_STALE: ::c_int = 0x04;
+pub const FALLOC_FL_COLLAPSE_RANGE: ::c_int = 0x08;
+pub const FALLOC_FL_ZERO_RANGE: ::c_int = 0x10;
+pub const FALLOC_FL_INSERT_RANGE: ::c_int = 0x20;
+pub const FALLOC_FL_UNSHARE_RANGE: ::c_int = 0x40;
+
+pub const BUFSIZ: ::c_uint = 1024;
+pub const FILENAME_MAX: ::c_uint = 4096;
+pub const FOPEN_MAX: ::c_uint = 20;
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+pub const L_tmpnam: ::c_uint = 4096;
+pub const TMP_MAX: ::c_uint = 308915776;
+pub const _PC_LINK_MAX: ::c_int = 1;
+pub const _PC_MAX_CANON: ::c_int = 2;
+pub const _PC_MAX_INPUT: ::c_int = 3;
+pub const _PC_NAME_MAX: ::c_int = 4;
+pub const _PC_PATH_MAX: ::c_int = 5;
+pub const _PC_PIPE_BUF: ::c_int = 6;
+pub const _PC_2_SYMLINKS: ::c_int = 7;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 8;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 9;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 10;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 11;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 12;
+pub const _PC_SYMLINK_MAX: ::c_int = 13;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 14;
+pub const _PC_NO_TRUNC: ::c_int = 15;
+pub const _PC_VDISABLE: ::c_int = 16;
+pub const _PC_ASYNC_IO: ::c_int = 17;
+pub const _PC_PRIO_IO: ::c_int = 18;
+pub const _PC_SYNC_IO: ::c_int = 19;
+
+pub const FIONBIO: ::c_int = 0x5421;
+
+pub const _SC_ARG_MAX: ::c_int = 0;
+pub const _SC_BC_BASE_MAX: ::c_int = 1;
+pub const _SC_BC_DIM_MAX: ::c_int = 2;
+pub const _SC_BC_SCALE_MAX: ::c_int = 3;
+pub const _SC_BC_STRING_MAX: ::c_int = 4;
+pub const _SC_CHILD_MAX: ::c_int = 5;
+pub const _SC_CLK_TCK: ::c_int = 6;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 7;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 8;
+pub const _SC_LINE_MAX: ::c_int = 9;
+pub const _SC_NGROUPS_MAX: ::c_int = 10;
+pub const _SC_OPEN_MAX: ::c_int = 11;
+pub const _SC_PASS_MAX: ::c_int = 12;
+pub const _SC_2_C_BIND: ::c_int = 13;
+pub const _SC_2_C_DEV: ::c_int = 14;
+pub const _SC_2_C_VERSION: ::c_int = 15;
+pub const _SC_2_CHAR_TERM: ::c_int = 16;
+pub const _SC_2_FORT_DEV: ::c_int = 17;
+pub const _SC_2_FORT_RUN: ::c_int = 18;
+pub const _SC_2_LOCALEDEF: ::c_int = 19;
+pub const _SC_2_SW_DEV: ::c_int = 20;
+pub const _SC_2_UPE: ::c_int = 21;
+pub const _SC_2_VERSION: ::c_int = 22;
+pub const _SC_JOB_CONTROL: ::c_int = 23;
+pub const _SC_SAVED_IDS: ::c_int = 24;
+pub const _SC_VERSION: ::c_int = 25;
+pub const _SC_RE_DUP_MAX: ::c_int = 26;
+pub const _SC_STREAM_MAX: ::c_int = 27;
+pub const _SC_TZNAME_MAX: ::c_int = 28;
+pub const _SC_XOPEN_CRYPT: ::c_int = 29;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 30;
+pub const _SC_XOPEN_SHM: ::c_int = 31;
+pub const _SC_XOPEN_VERSION: ::c_int = 32;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 33;
+pub const _SC_XOPEN_REALTIME: ::c_int = 34;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 35;
+pub const _SC_XOPEN_LEGACY: ::c_int = 36;
+pub const _SC_ATEXIT_MAX: ::c_int = 37;
+pub const _SC_IOV_MAX: ::c_int = 38;
+pub const _SC_PAGESIZE: ::c_int = 39;
+pub const _SC_PAGE_SIZE: ::c_int = 40;
+pub const _SC_XOPEN_UNIX: ::c_int = 41;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 42;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 43;
+pub const _SC_XBS5_LP64_OFF64: ::c_int = 44;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 45;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 46;
+pub const _SC_AIO_MAX: ::c_int = 47;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 48;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 49;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 50;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 51;
+pub const _SC_RTSIG_MAX: ::c_int = 52;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 53;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 54;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 55;
+pub const _SC_TIMER_MAX: ::c_int = 56;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 57;
+pub const _SC_FSYNC: ::c_int = 58;
+pub const _SC_MAPPED_FILES: ::c_int = 59;
+pub const _SC_MEMLOCK: ::c_int = 60;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 61;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 62;
+pub const _SC_MESSAGE_PASSING: ::c_int = 63;
+pub const _SC_PRIORITIZED_IO: ::c_int = 64;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 65;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 66;
+pub const _SC_SEMAPHORES: ::c_int = 67;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 68;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 69;
+pub const _SC_TIMERS: ::c_int = 70;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 71;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 72;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 73;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 74;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 75;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 76;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 77;
+pub const _SC_TTY_NAME_MAX: ::c_int = 78;
+pub const _SC_THREADS: ::c_int = 79;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 80;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 81;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 82;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 83;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 84;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 85;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 96;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 97;
+pub const _SC_PHYS_PAGES: ::c_int = 98;
+pub const _SC_AVPHYS_PAGES: ::c_int = 99;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 100;
+
+pub const _SC_2_PBS: ::c_int = 101;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 102;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 103;
+pub const _SC_2_PBS_LOCATE: ::c_int = 104;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 105;
+pub const _SC_2_PBS_TRACK: ::c_int = 106;
+pub const _SC_ADVISORY_INFO: ::c_int = 107;
+pub const _SC_BARRIERS: ::c_int = 108;
+pub const _SC_CLOCK_SELECTION: ::c_int = 109;
+pub const _SC_CPUTIME: ::c_int = 110;
+pub const _SC_HOST_NAME_MAX: ::c_int = 111;
+pub const _SC_IPV6: ::c_int = 112;
+pub const _SC_RAW_SOCKETS: ::c_int = 113;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 114;
+pub const _SC_REGEXP: ::c_int = 115;
+pub const _SC_SHELL: ::c_int = 116;
+pub const _SC_SPAWN: ::c_int = 117;
+pub const _SC_SPIN_LOCKS: ::c_int = 118;
+pub const _SC_SPORADIC_SERVER: ::c_int = 119;
+pub const _SC_SS_REPL_MAX: ::c_int = 120;
+pub const _SC_SYMLOOP_MAX: ::c_int = 121;
+pub const _SC_THREAD_CPUTIME: ::c_int = 122;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 123;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 124;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 125;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 126;
+pub const _SC_TIMEOUTS: ::c_int = 127;
+pub const _SC_TRACE: ::c_int = 128;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 129;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 130;
+pub const _SC_TRACE_INHERIT: ::c_int = 131;
+pub const _SC_TRACE_LOG: ::c_int = 132;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 133;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 134;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 135;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 136;
+pub const _SC_V7_ILP32_OFF32: ::c_int = 137;
+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 138;
+pub const _SC_V7_LP64_OFF64: ::c_int = 139;
+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 140;
+pub const _SC_XOPEN_STREAMS: ::c_int = 141;
+pub const _SC_XOPEN_UUCP: ::c_int = 142;
+
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+
+// stdio.h
+pub const RENAME_NOREPLACE: ::c_int = 1;
+pub const RENAME_EXCHANGE: ::c_int = 2;
+pub const RENAME_WHITEOUT: ::c_int = 4;
+
+pub const FIOCLEX: ::c_int = 0x5451;
+pub const FIONCLEX: ::c_int = 0x5450;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = 31;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const LC_PAPER: ::c_int = 7;
+pub const LC_NAME: ::c_int = 8;
+pub const LC_ADDRESS: ::c_int = 9;
+pub const LC_TELEPHONE: ::c_int = 10;
+pub const LC_MEASUREMENT: ::c_int = 11;
+pub const LC_IDENTIFICATION: ::c_int = 12;
+pub const LC_PAPER_MASK: ::c_int = 1 << LC_PAPER;
+pub const LC_NAME_MASK: ::c_int = 1 << LC_NAME;
+pub const LC_ADDRESS_MASK: ::c_int = 1 << LC_ADDRESS;
+pub const LC_TELEPHONE_MASK: ::c_int = 1 << LC_TELEPHONE;
+pub const LC_MEASUREMENT_MASK: ::c_int = 1 << LC_MEASUREMENT;
+pub const LC_IDENTIFICATION_MASK: ::c_int = 1 << LC_IDENTIFICATION;
+pub const LC_ALL_MASK: ::c_int = ::LC_CTYPE_MASK
+    | ::LC_NUMERIC_MASK
+    | ::LC_TIME_MASK
+    | ::LC_COLLATE_MASK
+    | ::LC_MONETARY_MASK
+    | ::LC_MESSAGES_MASK
+    | LC_PAPER_MASK
+    | LC_NAME_MASK
+    | LC_ADDRESS_MASK
+    | LC_TELEPHONE_MASK
+    | LC_MEASUREMENT_MASK
+    | LC_IDENTIFICATION_MASK;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+
+pub const EMULTIHOP: ::c_int = 72;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const SOCK_DCCP: ::c_int = 6;
+pub const SOCK_PACKET: ::c_int = 10;
+
+pub const IPPROTO_MAX: ::c_int = 256;
+
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SOL_SCTP: ::c_int = 132;
+pub const SOL_IPX: ::c_int = 256;
+pub const SOL_AX25: ::c_int = 257;
+pub const SOL_ATALK: ::c_int = 258;
+pub const SOL_NETROM: ::c_int = 259;
+pub const SOL_ROSE: ::c_int = 260;
+
+/* DCCP socket options */
+pub const DCCP_SOCKOPT_PACKET_SIZE: ::c_int = 1;
+pub const DCCP_SOCKOPT_SERVICE: ::c_int = 2;
+pub const DCCP_SOCKOPT_CHANGE_L: ::c_int = 3;
+pub const DCCP_SOCKOPT_CHANGE_R: ::c_int = 4;
+pub const DCCP_SOCKOPT_GET_CUR_MPS: ::c_int = 5;
+pub const DCCP_SOCKOPT_SERVER_TIMEWAIT: ::c_int = 6;
+pub const DCCP_SOCKOPT_SEND_CSCOV: ::c_int = 10;
+pub const DCCP_SOCKOPT_RECV_CSCOV: ::c_int = 11;
+pub const DCCP_SOCKOPT_AVAILABLE_CCIDS: ::c_int = 12;
+pub const DCCP_SOCKOPT_CCID: ::c_int = 13;
+pub const DCCP_SOCKOPT_TX_CCID: ::c_int = 14;
+pub const DCCP_SOCKOPT_RX_CCID: ::c_int = 15;
+pub const DCCP_SOCKOPT_QPOLICY_ID: ::c_int = 16;
+pub const DCCP_SOCKOPT_QPOLICY_TXQLEN: ::c_int = 17;
+pub const DCCP_SOCKOPT_CCID_RX_INFO: ::c_int = 128;
+pub const DCCP_SOCKOPT_CCID_TX_INFO: ::c_int = 192;
+
+/// maximum number of services provided on the same listening port
+pub const DCCP_SERVICE_LIST_MAX_LEN: ::c_int = 32;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_BUSY_POLL: ::c_int = 46;
+
+pub const TCP_ULP: ::c_int = 31;
+
+pub const IPTOS_ECN_NOTECT: u8 = 0x00;
+
+pub const O_ACCMODE: ::c_int = 3;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 0x101000;
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_NDELAY: ::c_int = 0x800;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_RSYNC: ::c_int = O_SYNC;
+
+pub const NI_MAXHOST: ::size_t = 1025;
+pub const NI_MAXSERV: ::size_t = 32;
+
+pub const NI_NOFQDN: ::c_int = 0x00000001;
+pub const NI_NUMERICHOST: ::c_int = 0x00000002;
+pub const NI_NAMEREQD: ::c_int = 0x00000004;
+pub const NI_NUMERICSERV: ::c_int = 0x00000008;
+pub const NI_DGRAM: ::c_int = 0x00000010;
+
+pub const NCCS: usize = 19;
+pub const TCSBRKP: ::c_int = 0x5425;
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 0x1;
+pub const TCSAFLUSH: ::c_int = 0x2;
+pub const VEOF: usize = 4;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+pub const EXTPROC: ::tcflag_t = 0o200000;
+
+pub const ADFS_SUPER_MAGIC: ::c_long = 0x0000adf5;
+pub const AFFS_SUPER_MAGIC: ::c_long = 0x0000adff;
+pub const CODA_SUPER_MAGIC: ::c_long = 0x73757245;
+pub const CRAMFS_MAGIC: ::c_long = 0x28cd3d45;
+pub const EFS_SUPER_MAGIC: ::c_long = 0x00414a53;
+pub const EXT2_SUPER_MAGIC: ::c_long = 0x0000ef53;
+pub const EXT3_SUPER_MAGIC: ::c_long = 0x0000ef53;
+pub const EXT4_SUPER_MAGIC: ::c_long = 0x0000ef53;
+pub const HPFS_SUPER_MAGIC: ::c_long = 0xf995e849;
+pub const HUGETLBFS_MAGIC: ::c_long = 0x958458f6;
+pub const ISOFS_SUPER_MAGIC: ::c_long = 0x00009660;
+pub const JFFS2_SUPER_MAGIC: ::c_long = 0x000072b6;
+pub const MINIX_SUPER_MAGIC: ::c_long = 0x0000137f;
+pub const MINIX_SUPER_MAGIC2: ::c_long = 0x0000138f;
+pub const MINIX2_SUPER_MAGIC: ::c_long = 0x00002468;
+pub const MINIX2_SUPER_MAGIC2: ::c_long = 0x00002478;
+pub const MSDOS_SUPER_MAGIC: ::c_long = 0x00004d44;
+pub const NCP_SUPER_MAGIC: ::c_long = 0x0000564c;
+pub const NFS_SUPER_MAGIC: ::c_long = 0x00006969;
+pub const OPENPROM_SUPER_MAGIC: ::c_long = 0x00009fa1;
+pub const PROC_SUPER_MAGIC: ::c_long = 0x00009fa0;
+pub const QNX4_SUPER_MAGIC: ::c_long = 0x0000002f;
+pub const REISERFS_SUPER_MAGIC: ::c_long = 0x52654973;
+pub const SMB_SUPER_MAGIC: ::c_long = 0x0000517b;
+pub const TMPFS_MAGIC: ::c_long = 0x01021994;
+pub const USBDEVICE_SUPER_MAGIC: ::c_long = 0x00009fa2;
+
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+
+pub const PTRACE_TRACEME: ::c_int = 0;
+pub const PTRACE_PEEKTEXT: ::c_int = 1;
+pub const PTRACE_PEEKDATA: ::c_int = 2;
+pub const PTRACE_PEEKUSER: ::c_int = 3;
+pub const PTRACE_POKETEXT: ::c_int = 4;
+pub const PTRACE_POKEDATA: ::c_int = 5;
+pub const PTRACE_POKEUSER: ::c_int = 6;
+pub const PTRACE_CONT: ::c_int = 7;
+pub const PTRACE_KILL: ::c_int = 8;
+pub const PTRACE_SINGLESTEP: ::c_int = 9;
+pub const PTRACE_ATTACH: ::c_int = 16;
+pub const PTRACE_DETACH: ::c_int = 17;
+pub const PTRACE_SYSCALL: ::c_int = 24;
+pub const PTRACE_SETOPTIONS: ::c_int = 0x4200;
+pub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;
+pub const PTRACE_GETSIGINFO: ::c_int = 0x4202;
+pub const PTRACE_SETSIGINFO: ::c_int = 0x4203;
+
+pub const PTRACE_EVENT_STOP: ::c_int = 128;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_LOCKS: ::c_int = 10;
+pub const RLIMIT_SIGPENDING: ::c_int = 11;
+pub const RLIMIT_MSGQUEUE: ::c_int = 12;
+pub const RLIMIT_NICE: ::c_int = 13;
+pub const RLIMIT_RTPRIO: ::c_int = 14;
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+
+pub const TCGETS: ::c_int = 0x5401;
+pub const TCSETS: ::c_int = 0x5402;
+pub const TCSETSW: ::c_int = 0x5403;
+pub const TCSETSF: ::c_int = 0x5404;
+pub const TCGETA: ::c_int = 0x5405;
+pub const TCSETA: ::c_int = 0x5406;
+pub const TCSETAW: ::c_int = 0x5407;
+pub const TCSETAF: ::c_int = 0x5408;
+pub const TCSBRK: ::c_int = 0x5409;
+pub const TCXONC: ::c_int = 0x540A;
+pub const TCFLSH: ::c_int = 0x540B;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCINQ: ::c_int = 0x541B;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x540F;
+pub const TIOCSPGRP: ::c_int = 0x5410;
+pub const TIOCOUTQ: ::c_int = 0x5411;
+pub const TIOCSTI: ::c_int = 0x5412;
+pub const TIOCGWINSZ: ::c_int = 0x5413;
+pub const TIOCSWINSZ: ::c_int = 0x5414;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x541B;
+pub const TIOCCONS: ::c_int = 0x541D;
+pub const TIOCSBRK: ::c_int = 0x5427;
+pub const TIOCCBRK: ::c_int = 0x5428;
+
+pub const ST_RDONLY: ::c_ulong = 1;
+pub const ST_NOSUID: ::c_ulong = 2;
+pub const ST_NODEV: ::c_ulong = 4;
+pub const ST_NOEXEC: ::c_ulong = 8;
+pub const ST_SYNCHRONOUS: ::c_ulong = 16;
+pub const ST_MANDLOCK: ::c_ulong = 64;
+pub const ST_NOATIME: ::c_ulong = 1024;
+pub const ST_NODIRATIME: ::c_ulong = 2048;
+pub const ST_RELATIME: ::c_ulong = 4096;
+
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+
+pub const SEM_FAILED: *mut sem_t = 0 as *mut sem_t;
+
+pub const AI_PASSIVE: ::c_int = 0x00000001;
+pub const AI_CANONNAME: ::c_int = 0x00000002;
+pub const AI_NUMERICHOST: ::c_int = 0x00000004;
+pub const AI_NUMERICSERV: ::c_int = 0x00000008;
+pub const AI_MASK: ::c_int = AI_PASSIVE
+    | AI_CANONNAME
+    | AI_NUMERICHOST
+    | AI_NUMERICSERV
+    | AI_ADDRCONFIG;
+pub const AI_ALL: ::c_int = 0x00000100;
+pub const AI_V4MAPPED_CFG: ::c_int = 0x00000200;
+pub const AI_ADDRCONFIG: ::c_int = 0x00000400;
+pub const AI_V4MAPPED: ::c_int = 0x00000800;
+pub const AI_DEFAULT: ::c_int = AI_V4MAPPED_CFG | AI_ADDRCONFIG;
+
+pub const LINUX_REBOOT_MAGIC1: ::c_int = 0xfee1dead;
+pub const LINUX_REBOOT_MAGIC2: ::c_int = 672274793;
+pub const LINUX_REBOOT_MAGIC2A: ::c_int = 85072278;
+pub const LINUX_REBOOT_MAGIC2B: ::c_int = 369367448;
+pub const LINUX_REBOOT_MAGIC2C: ::c_int = 537993216;
+
+pub const LINUX_REBOOT_CMD_RESTART: ::c_int = 0x01234567;
+pub const LINUX_REBOOT_CMD_HALT: ::c_int = 0xCDEF0123;
+pub const LINUX_REBOOT_CMD_CAD_ON: ::c_int = 0x89ABCDEF;
+pub const LINUX_REBOOT_CMD_CAD_OFF: ::c_int = 0x00000000;
+pub const LINUX_REBOOT_CMD_POWER_OFF: ::c_int = 0x4321FEDC;
+pub const LINUX_REBOOT_CMD_RESTART2: ::c_int = 0xA1B2C3D4;
+pub const LINUX_REBOOT_CMD_SW_SUSPEND: ::c_int = 0xD000FCE2;
+pub const LINUX_REBOOT_CMD_KEXEC: ::c_int = 0x45584543;
+
+pub const REG_BASIC: ::c_int = 0;
+pub const REG_EXTENDED: ::c_int = 1;
+pub const REG_ICASE: ::c_int = 2;
+pub const REG_NOSUB: ::c_int = 4;
+pub const REG_NEWLINE: ::c_int = 8;
+pub const REG_NOSPEC: ::c_int = 16;
+pub const REG_PEND: ::c_int = 32;
+pub const REG_DUMP: ::c_int = 128;
+
+pub const REG_NOMATCH: ::c_int = 1;
+pub const REG_BADPAT: ::c_int = 2;
+pub const REG_ECOLLATE: ::c_int = 3;
+pub const REG_ECTYPE: ::c_int = 4;
+pub const REG_EESCAPE: ::c_int = 5;
+pub const REG_ESUBREG: ::c_int = 6;
+pub const REG_EBRACK: ::c_int = 7;
+pub const REG_EPAREN: ::c_int = 8;
+pub const REG_EBRACE: ::c_int = 9;
+pub const REG_BADBR: ::c_int = 10;
+pub const REG_ERANGE: ::c_int = 11;
+pub const REG_ESPACE: ::c_int = 12;
+pub const REG_BADRPT: ::c_int = 13;
+pub const REG_EMPTY: ::c_int = 14;
+pub const REG_ASSERT: ::c_int = 15;
+pub const REG_INVARG: ::c_int = 16;
+pub const REG_ATOI: ::c_int = 255;
+pub const REG_ITOA: ::c_int = 256;
+
+pub const REG_NOTBOL: ::c_int = 1;
+pub const REG_NOTEOL: ::c_int = 2;
+pub const REG_STARTEND: ::c_int = 4;
+pub const REG_TRACE: ::c_int = 256;
+pub const REG_LARGE: ::c_int = 512;
+pub const REG_BACKR: ::c_int = 1024;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const EAI_AGAIN: ::c_int = 2;
+pub const EAI_BADFLAGS: ::c_int = 3;
+pub const EAI_FAIL: ::c_int = 4;
+pub const EAI_FAMILY: ::c_int = 5;
+pub const EAI_MEMORY: ::c_int = 6;
+pub const EAI_NODATA: ::c_int = 7;
+pub const EAI_NONAME: ::c_int = 8;
+pub const EAI_SERVICE: ::c_int = 9;
+pub const EAI_SOCKTYPE: ::c_int = 10;
+pub const EAI_SYSTEM: ::c_int = 11;
+pub const EAI_OVERFLOW: ::c_int = 14;
+
+pub const NETLINK_ROUTE: ::c_int = 0;
+pub const NETLINK_UNUSED: ::c_int = 1;
+pub const NETLINK_USERSOCK: ::c_int = 2;
+pub const NETLINK_FIREWALL: ::c_int = 3;
+pub const NETLINK_SOCK_DIAG: ::c_int = 4;
+pub const NETLINK_NFLOG: ::c_int = 5;
+pub const NETLINK_XFRM: ::c_int = 6;
+pub const NETLINK_SELINUX: ::c_int = 7;
+pub const NETLINK_ISCSI: ::c_int = 8;
+pub const NETLINK_AUDIT: ::c_int = 9;
+pub const NETLINK_FIB_LOOKUP: ::c_int = 10;
+pub const NETLINK_CONNECTOR: ::c_int = 11;
+pub const NETLINK_NETFILTER: ::c_int = 12;
+pub const NETLINK_IP6_FW: ::c_int = 13;
+pub const NETLINK_DNRTMSG: ::c_int = 14;
+pub const NETLINK_KOBJECT_UEVENT: ::c_int = 15;
+pub const NETLINK_GENERIC: ::c_int = 16;
+pub const NETLINK_SCSITRANSPORT: ::c_int = 18;
+pub const NETLINK_ECRYPTFS: ::c_int = 19;
+pub const NETLINK_RDMA: ::c_int = 20;
+pub const NETLINK_CRYPTO: ::c_int = 21;
+pub const NETLINK_INET_DIAG: ::c_int = NETLINK_SOCK_DIAG;
+
+pub const MAX_LINKS: ::c_int = 32;
+
+pub const NLM_F_REQUEST: ::c_int = 1;
+pub const NLM_F_MULTI: ::c_int = 2;
+pub const NLM_F_ACK: ::c_int = 4;
+pub const NLM_F_ECHO: ::c_int = 8;
+pub const NLM_F_DUMP_INTR: ::c_int = 16;
+
+pub const NLM_F_ROOT: ::c_int = 0x100;
+pub const NLM_F_MATCH: ::c_int = 0x200;
+pub const NLM_F_ATOMIC: ::c_int = 0x400;
+pub const NLM_F_DUMP: ::c_int = NLM_F_ROOT | NLM_F_MATCH;
+
+pub const NLM_F_REPLACE: ::c_int = 0x100;
+pub const NLM_F_EXCL: ::c_int = 0x200;
+pub const NLM_F_CREATE: ::c_int = 0x400;
+pub const NLM_F_APPEND: ::c_int = 0x800;
+
+pub const NLMSG_NOOP: ::c_int = 0x1;
+pub const NLMSG_ERROR: ::c_int = 0x2;
+pub const NLMSG_DONE: ::c_int = 0x3;
+pub const NLMSG_OVERRUN: ::c_int = 0x4;
+pub const NLMSG_MIN_TYPE: ::c_int = 0x10;
+
+// linux/netfilter/nfnetlink.h
+pub const NFNLGRP_NONE: ::c_int = 0;
+pub const NFNLGRP_CONNTRACK_NEW: ::c_int = 1;
+pub const NFNLGRP_CONNTRACK_UPDATE: ::c_int = 2;
+pub const NFNLGRP_CONNTRACK_DESTROY: ::c_int = 3;
+pub const NFNLGRP_CONNTRACK_EXP_NEW: ::c_int = 4;
+pub const NFNLGRP_CONNTRACK_EXP_UPDATE: ::c_int = 5;
+pub const NFNLGRP_CONNTRACK_EXP_DESTROY: ::c_int = 6;
+pub const NFNLGRP_NFTABLES: ::c_int = 7;
+pub const NFNLGRP_ACCT_QUOTA: ::c_int = 8;
+
+pub const NFNETLINK_V0: ::c_int = 0;
+
+pub const NFNL_SUBSYS_NONE: ::c_int = 0;
+pub const NFNL_SUBSYS_CTNETLINK: ::c_int = 1;
+pub const NFNL_SUBSYS_CTNETLINK_EXP: ::c_int = 2;
+pub const NFNL_SUBSYS_QUEUE: ::c_int = 3;
+pub const NFNL_SUBSYS_ULOG: ::c_int = 4;
+pub const NFNL_SUBSYS_OSF: ::c_int = 5;
+pub const NFNL_SUBSYS_IPSET: ::c_int = 6;
+pub const NFNL_SUBSYS_ACCT: ::c_int = 7;
+pub const NFNL_SUBSYS_CTNETLINK_TIMEOUT: ::c_int = 8;
+pub const NFNL_SUBSYS_CTHELPER: ::c_int = 9;
+pub const NFNL_SUBSYS_NFTABLES: ::c_int = 10;
+pub const NFNL_SUBSYS_NFT_COMPAT: ::c_int = 11;
+pub const NFNL_SUBSYS_COUNT: ::c_int = 12;
+
+pub const NFNL_MSG_BATCH_BEGIN: ::c_int = NLMSG_MIN_TYPE;
+pub const NFNL_MSG_BATCH_END: ::c_int = NLMSG_MIN_TYPE + 1;
+
+// linux/netfilter/nfnetlink_log.h
+pub const NFULNL_MSG_PACKET: ::c_int = 0;
+pub const NFULNL_MSG_CONFIG: ::c_int = 1;
+
+pub const NFULA_UNSPEC: ::c_int = 0;
+pub const NFULA_PACKET_HDR: ::c_int = 1;
+pub const NFULA_MARK: ::c_int = 2;
+pub const NFULA_TIMESTAMP: ::c_int = 3;
+pub const NFULA_IFINDEX_INDEV: ::c_int = 4;
+pub const NFULA_IFINDEX_OUTDEV: ::c_int = 5;
+pub const NFULA_IFINDEX_PHYSINDEV: ::c_int = 6;
+pub const NFULA_IFINDEX_PHYSOUTDEV: ::c_int = 7;
+pub const NFULA_HWADDR: ::c_int = 8;
+pub const NFULA_PAYLOAD: ::c_int = 9;
+pub const NFULA_PREFIX: ::c_int = 10;
+pub const NFULA_UID: ::c_int = 11;
+pub const NFULA_SEQ: ::c_int = 12;
+pub const NFULA_SEQ_GLOBAL: ::c_int = 13;
+pub const NFULA_GID: ::c_int = 14;
+pub const NFULA_HWTYPE: ::c_int = 15;
+pub const NFULA_HWHEADER: ::c_int = 16;
+pub const NFULA_HWLEN: ::c_int = 17;
+pub const NFULA_CT: ::c_int = 18;
+pub const NFULA_CT_INFO: ::c_int = 19;
+
+pub const NFULNL_CFG_CMD_NONE: ::c_int = 0;
+pub const NFULNL_CFG_CMD_BIND: ::c_int = 1;
+pub const NFULNL_CFG_CMD_UNBIND: ::c_int = 2;
+pub const NFULNL_CFG_CMD_PF_BIND: ::c_int = 3;
+pub const NFULNL_CFG_CMD_PF_UNBIND: ::c_int = 4;
+
+pub const NFULA_CFG_UNSPEC: ::c_int = 0;
+pub const NFULA_CFG_CMD: ::c_int = 1;
+pub const NFULA_CFG_MODE: ::c_int = 2;
+pub const NFULA_CFG_NLBUFSIZ: ::c_int = 3;
+pub const NFULA_CFG_TIMEOUT: ::c_int = 4;
+pub const NFULA_CFG_QTHRESH: ::c_int = 5;
+pub const NFULA_CFG_FLAGS: ::c_int = 6;
+
+pub const NFULNL_COPY_NONE: ::c_int = 0x00;
+pub const NFULNL_COPY_META: ::c_int = 0x01;
+pub const NFULNL_COPY_PACKET: ::c_int = 0x02;
+
+pub const NFULNL_CFG_F_SEQ: ::c_int = 0x0001;
+pub const NFULNL_CFG_F_SEQ_GLOBAL: ::c_int = 0x0002;
+pub const NFULNL_CFG_F_CONNTRACK: ::c_int = 0x0004;
+
+// linux/netfilter/nfnetlink_log.h
+pub const NFQNL_MSG_PACKET: ::c_int = 0;
+pub const NFQNL_MSG_VERDICT: ::c_int = 1;
+pub const NFQNL_MSG_CONFIG: ::c_int = 2;
+pub const NFQNL_MSG_VERDICT_BATCH: ::c_int = 3;
+
+pub const NFQA_UNSPEC: ::c_int = 0;
+pub const NFQA_PACKET_HDR: ::c_int = 1;
+pub const NFQA_VERDICT_HDR: ::c_int = 2;
+pub const NFQA_MARK: ::c_int = 3;
+pub const NFQA_TIMESTAMP: ::c_int = 4;
+pub const NFQA_IFINDEX_INDEV: ::c_int = 5;
+pub const NFQA_IFINDEX_OUTDEV: ::c_int = 6;
+pub const NFQA_IFINDEX_PHYSINDEV: ::c_int = 7;
+pub const NFQA_IFINDEX_PHYSOUTDEV: ::c_int = 8;
+pub const NFQA_HWADDR: ::c_int = 9;
+pub const NFQA_PAYLOAD: ::c_int = 10;
+pub const NFQA_CT: ::c_int = 11;
+pub const NFQA_CT_INFO: ::c_int = 12;
+pub const NFQA_CAP_LEN: ::c_int = 13;
+pub const NFQA_SKB_INFO: ::c_int = 14;
+pub const NFQA_EXP: ::c_int = 15;
+pub const NFQA_UID: ::c_int = 16;
+pub const NFQA_GID: ::c_int = 17;
+pub const NFQA_SECCTX: ::c_int = 18;
+/*
+ FIXME: These are not yet available in musl sanitized kernel headers and
+ make the tests fail. Enable them once musl has them.
+
+ See https://github.com/rust-lang/libc/pull/1628 for more details.
+pub const NFQA_VLAN: ::c_int = 19;
+pub const NFQA_L2HDR: ::c_int = 20;
+
+pub const NFQA_VLAN_UNSPEC: ::c_int = 0;
+pub const NFQA_VLAN_PROTO: ::c_int = 1;
+pub const NFQA_VLAN_TCI: ::c_int = 2;
+*/
+
+pub const NFQNL_CFG_CMD_NONE: ::c_int = 0;
+pub const NFQNL_CFG_CMD_BIND: ::c_int = 1;
+pub const NFQNL_CFG_CMD_UNBIND: ::c_int = 2;
+pub const NFQNL_CFG_CMD_PF_BIND: ::c_int = 3;
+pub const NFQNL_CFG_CMD_PF_UNBIND: ::c_int = 4;
+
+pub const NFQNL_COPY_NONE: ::c_int = 0;
+pub const NFQNL_COPY_META: ::c_int = 1;
+pub const NFQNL_COPY_PACKET: ::c_int = 2;
+
+pub const NFQA_CFG_UNSPEC: ::c_int = 0;
+pub const NFQA_CFG_CMD: ::c_int = 1;
+pub const NFQA_CFG_PARAMS: ::c_int = 2;
+pub const NFQA_CFG_QUEUE_MAXLEN: ::c_int = 3;
+pub const NFQA_CFG_MASK: ::c_int = 4;
+pub const NFQA_CFG_FLAGS: ::c_int = 5;
+
+pub const NFQA_CFG_F_FAIL_OPEN: ::c_int = 0x0001;
+pub const NFQA_CFG_F_CONNTRACK: ::c_int = 0x0002;
+pub const NFQA_CFG_F_GSO: ::c_int = 0x0004;
+pub const NFQA_CFG_F_UID_GID: ::c_int = 0x0008;
+pub const NFQA_CFG_F_SECCTX: ::c_int = 0x0010;
+pub const NFQA_CFG_F_MAX: ::c_int = 0x0020;
+
+pub const NFQA_SKB_CSUMNOTREADY: ::c_int = 0x0001;
+pub const NFQA_SKB_GSO: ::c_int = 0x0002;
+pub const NFQA_SKB_CSUM_NOTVERIFIED: ::c_int = 0x0004;
+
+pub const GENL_NAMSIZ: ::c_int = 16;
+
+pub const GENL_MIN_ID: ::c_int = NLMSG_MIN_TYPE;
+pub const GENL_MAX_ID: ::c_int = 1023;
+
+pub const GENL_ADMIN_PERM: ::c_int = 0x01;
+pub const GENL_CMD_CAP_DO: ::c_int = 0x02;
+pub const GENL_CMD_CAP_DUMP: ::c_int = 0x04;
+pub const GENL_CMD_CAP_HASPOL: ::c_int = 0x08;
+pub const GENL_UNS_ADMIN_PERM: ::c_int = 0x10;
+
+pub const GENL_ID_CTRL: ::c_int = NLMSG_MIN_TYPE;
+pub const GENL_ID_VFS_DQUOT: ::c_int = NLMSG_MIN_TYPE + 1;
+pub const GENL_ID_PMCRAID: ::c_int = NLMSG_MIN_TYPE + 2;
+
+pub const CTRL_CMD_UNSPEC: ::c_int = 0;
+pub const CTRL_CMD_NEWFAMILY: ::c_int = 1;
+pub const CTRL_CMD_DELFAMILY: ::c_int = 2;
+pub const CTRL_CMD_GETFAMILY: ::c_int = 3;
+pub const CTRL_CMD_NEWOPS: ::c_int = 4;
+pub const CTRL_CMD_DELOPS: ::c_int = 5;
+pub const CTRL_CMD_GETOPS: ::c_int = 6;
+pub const CTRL_CMD_NEWMCAST_GRP: ::c_int = 7;
+pub const CTRL_CMD_DELMCAST_GRP: ::c_int = 8;
+pub const CTRL_CMD_GETMCAST_GRP: ::c_int = 9;
+
+pub const CTRL_ATTR_UNSPEC: ::c_int = 0;
+pub const CTRL_ATTR_FAMILY_ID: ::c_int = 1;
+pub const CTRL_ATTR_FAMILY_NAME: ::c_int = 2;
+pub const CTRL_ATTR_VERSION: ::c_int = 3;
+pub const CTRL_ATTR_HDRSIZE: ::c_int = 4;
+pub const CTRL_ATTR_MAXATTR: ::c_int = 5;
+pub const CTRL_ATTR_OPS: ::c_int = 6;
+pub const CTRL_ATTR_MCAST_GROUPS: ::c_int = 7;
+
+pub const CTRL_ATTR_OP_UNSPEC: ::c_int = 0;
+pub const CTRL_ATTR_OP_ID: ::c_int = 1;
+pub const CTRL_ATTR_OP_FLAGS: ::c_int = 2;
+
+pub const CTRL_ATTR_MCAST_GRP_UNSPEC: ::c_int = 0;
+pub const CTRL_ATTR_MCAST_GRP_NAME: ::c_int = 1;
+pub const CTRL_ATTR_MCAST_GRP_ID: ::c_int = 2;
+
+pub const NETLINK_ADD_MEMBERSHIP: ::c_int = 1;
+pub const NETLINK_DROP_MEMBERSHIP: ::c_int = 2;
+pub const NETLINK_PKTINFO: ::c_int = 3;
+pub const NETLINK_BROADCAST_ERROR: ::c_int = 4;
+pub const NETLINK_NO_ENOBUFS: ::c_int = 5;
+pub const NETLINK_RX_RING: ::c_int = 6;
+pub const NETLINK_TX_RING: ::c_int = 7;
+
+pub const GRND_NONBLOCK: ::c_uint = 0x0001;
+pub const GRND_RANDOM: ::c_uint = 0x0002;
+
+pub const SECCOMP_MODE_DISABLED: ::c_uint = 0;
+pub const SECCOMP_MODE_STRICT: ::c_uint = 1;
+pub const SECCOMP_MODE_FILTER: ::c_uint = 2;
+
+pub const NLA_F_NESTED: ::c_int = 1 << 15;
+pub const NLA_F_NET_BYTEORDER: ::c_int = 1 << 14;
+pub const NLA_TYPE_MASK: ::c_int = !(NLA_F_NESTED | NLA_F_NET_BYTEORDER);
+
+pub const NLA_ALIGNTO: ::c_int = 4;
+
+pub const SIGEV_THREAD_ID: ::c_int = 4;
+
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const SFD_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const SFD_NONBLOCK: ::c_int = O_NONBLOCK;
+
+pub const SOCK_NONBLOCK: ::c_int = O_NONBLOCK;
+
+pub const SO_ORIGINAL_DST: ::c_int = 80;
+
+pub const IP_RECVFRAGSIZE: ::c_int = 25;
+
+pub const IPV6_FLOWINFO: ::c_int = 11;
+pub const IPV6_MULTICAST_ALL: ::c_int = 29;
+pub const IPV6_ROUTER_ALERT_ISOLATE: ::c_int = 30;
+pub const IPV6_FLOWLABEL_MGR: ::c_int = 32;
+pub const IPV6_FLOWINFO_SEND: ::c_int = 33;
+pub const IPV6_RECVFRAGSIZE: ::c_int = 77;
+pub const IPV6_FREEBIND: ::c_int = 78;
+pub const IPV6_FLOWINFO_FLOWLABEL: ::c_int = 0x000fffff;
+pub const IPV6_FLOWINFO_PRIORITY: ::c_int = 0x0ff00000;
+
+pub const IUTF8: ::tcflag_t = 0x00004000;
+pub const CMSPAR: ::tcflag_t = 0o10000000000;
+pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+
+pub const MFD_CLOEXEC: ::c_uint = 0x0001;
+pub const MFD_ALLOW_SEALING: ::c_uint = 0x0002;
+pub const MFD_HUGETLB: ::c_uint = 0x0004;
+
+// linux/netfilter.h
+pub const NF_DROP: ::c_int = 0;
+pub const NF_ACCEPT: ::c_int = 1;
+pub const NF_STOLEN: ::c_int = 2;
+pub const NF_QUEUE: ::c_int = 3;
+pub const NF_REPEAT: ::c_int = 4;
+pub const NF_STOP: ::c_int = 5;
+pub const NF_MAX_VERDICT: ::c_int = NF_STOP;
+
+pub const NF_VERDICT_MASK: ::c_int = 0x000000ff;
+pub const NF_VERDICT_FLAG_QUEUE_BYPASS: ::c_int = 0x00008000;
+
+pub const NF_VERDICT_QMASK: ::c_int = 0xffff0000;
+pub const NF_VERDICT_QBITS: ::c_int = 16;
+
+pub const NF_VERDICT_BITS: ::c_int = 16;
+
+pub const NF_INET_PRE_ROUTING: ::c_int = 0;
+pub const NF_INET_LOCAL_IN: ::c_int = 1;
+pub const NF_INET_FORWARD: ::c_int = 2;
+pub const NF_INET_LOCAL_OUT: ::c_int = 3;
+pub const NF_INET_POST_ROUTING: ::c_int = 4;
+pub const NF_INET_NUMHOOKS: ::c_int = 5;
+
+pub const NF_NETDEV_INGRESS: ::c_int = 0;
+pub const NF_NETDEV_NUMHOOKS: ::c_int = 1;
+
+pub const NFPROTO_UNSPEC: ::c_int = 0;
+pub const NFPROTO_INET: ::c_int = 1;
+pub const NFPROTO_IPV4: ::c_int = 2;
+pub const NFPROTO_ARP: ::c_int = 3;
+pub const NFPROTO_NETDEV: ::c_int = 5;
+pub const NFPROTO_BRIDGE: ::c_int = 7;
+pub const NFPROTO_IPV6: ::c_int = 10;
+pub const NFPROTO_DECNET: ::c_int = 12;
+pub const NFPROTO_NUMPROTO: ::c_int = 13;
+
+// linux/netfilter_ipv4.h
+pub const NF_IP_PRE_ROUTING: ::c_int = 0;
+pub const NF_IP_LOCAL_IN: ::c_int = 1;
+pub const NF_IP_FORWARD: ::c_int = 2;
+pub const NF_IP_LOCAL_OUT: ::c_int = 3;
+pub const NF_IP_POST_ROUTING: ::c_int = 4;
+pub const NF_IP_NUMHOOKS: ::c_int = 5;
+
+pub const NF_IP_PRI_FIRST: ::c_int = ::INT_MIN;
+pub const NF_IP_PRI_CONNTRACK_DEFRAG: ::c_int = -400;
+pub const NF_IP_PRI_RAW: ::c_int = -300;
+pub const NF_IP_PRI_SELINUX_FIRST: ::c_int = -225;
+pub const NF_IP_PRI_CONNTRACK: ::c_int = -200;
+pub const NF_IP_PRI_MANGLE: ::c_int = -150;
+pub const NF_IP_PRI_NAT_DST: ::c_int = -100;
+pub const NF_IP_PRI_FILTER: ::c_int = 0;
+pub const NF_IP_PRI_SECURITY: ::c_int = 50;
+pub const NF_IP_PRI_NAT_SRC: ::c_int = 100;
+pub const NF_IP_PRI_SELINUX_LAST: ::c_int = 225;
+pub const NF_IP_PRI_CONNTRACK_HELPER: ::c_int = 300;
+pub const NF_IP_PRI_CONNTRACK_CONFIRM: ::c_int = ::INT_MAX;
+pub const NF_IP_PRI_LAST: ::c_int = ::INT_MAX;
+
+// linux/netfilter_ipv6.h
+pub const NF_IP6_PRE_ROUTING: ::c_int = 0;
+pub const NF_IP6_LOCAL_IN: ::c_int = 1;
+pub const NF_IP6_FORWARD: ::c_int = 2;
+pub const NF_IP6_LOCAL_OUT: ::c_int = 3;
+pub const NF_IP6_POST_ROUTING: ::c_int = 4;
+pub const NF_IP6_NUMHOOKS: ::c_int = 5;
+
+pub const NF_IP6_PRI_FIRST: ::c_int = ::INT_MIN;
+pub const NF_IP6_PRI_CONNTRACK_DEFRAG: ::c_int = -400;
+pub const NF_IP6_PRI_RAW: ::c_int = -300;
+pub const NF_IP6_PRI_SELINUX_FIRST: ::c_int = -225;
+pub const NF_IP6_PRI_CONNTRACK: ::c_int = -200;
+pub const NF_IP6_PRI_MANGLE: ::c_int = -150;
+pub const NF_IP6_PRI_NAT_DST: ::c_int = -100;
+pub const NF_IP6_PRI_FILTER: ::c_int = 0;
+pub const NF_IP6_PRI_SECURITY: ::c_int = 50;
+pub const NF_IP6_PRI_NAT_SRC: ::c_int = 100;
+pub const NF_IP6_PRI_SELINUX_LAST: ::c_int = 225;
+pub const NF_IP6_PRI_CONNTRACK_HELPER: ::c_int = 300;
+pub const NF_IP6_PRI_LAST: ::c_int = ::INT_MAX;
+
+// linux/netfilter_ipv6/ip6_tables.h
+pub const IP6T_SO_ORIGINAL_DST: ::c_int = 80;
+
+// linux/netfilter/nf_tables.h
+pub const NFT_TABLE_MAXNAMELEN: ::c_int = 256;
+pub const NFT_CHAIN_MAXNAMELEN: ::c_int = 256;
+pub const NFT_SET_MAXNAMELEN: ::c_int = 256;
+pub const NFT_OBJ_MAXNAMELEN: ::c_int = 256;
+pub const NFT_USERDATA_MAXLEN: ::c_int = 256;
+
+pub const NFT_REG_VERDICT: ::c_int = 0;
+pub const NFT_REG_1: ::c_int = 1;
+pub const NFT_REG_2: ::c_int = 2;
+pub const NFT_REG_3: ::c_int = 3;
+pub const NFT_REG_4: ::c_int = 4;
+pub const __NFT_REG_MAX: ::c_int = 5;
+pub const NFT_REG32_00: ::c_int = 8;
+pub const NFT_REG32_01: ::c_int = 9;
+pub const NFT_REG32_02: ::c_int = 10;
+pub const NFT_REG32_03: ::c_int = 11;
+pub const NFT_REG32_04: ::c_int = 12;
+pub const NFT_REG32_05: ::c_int = 13;
+pub const NFT_REG32_06: ::c_int = 14;
+pub const NFT_REG32_07: ::c_int = 15;
+pub const NFT_REG32_08: ::c_int = 16;
+pub const NFT_REG32_09: ::c_int = 17;
+pub const NFT_REG32_10: ::c_int = 18;
+pub const NFT_REG32_11: ::c_int = 19;
+pub const NFT_REG32_12: ::c_int = 20;
+pub const NFT_REG32_13: ::c_int = 21;
+pub const NFT_REG32_14: ::c_int = 22;
+pub const NFT_REG32_15: ::c_int = 23;
+
+pub const NFT_REG_SIZE: ::c_int = 16;
+pub const NFT_REG32_SIZE: ::c_int = 4;
+
+pub const NFT_CONTINUE: ::c_int = -1;
+pub const NFT_BREAK: ::c_int = -2;
+pub const NFT_JUMP: ::c_int = -3;
+pub const NFT_GOTO: ::c_int = -4;
+pub const NFT_RETURN: ::c_int = -5;
+
+pub const NFT_MSG_NEWTABLE: ::c_int = 0;
+pub const NFT_MSG_GETTABLE: ::c_int = 1;
+pub const NFT_MSG_DELTABLE: ::c_int = 2;
+pub const NFT_MSG_NEWCHAIN: ::c_int = 3;
+pub const NFT_MSG_GETCHAIN: ::c_int = 4;
+pub const NFT_MSG_DELCHAIN: ::c_int = 5;
+pub const NFT_MSG_NEWRULE: ::c_int = 6;
+pub const NFT_MSG_GETRULE: ::c_int = 7;
+pub const NFT_MSG_DELRULE: ::c_int = 8;
+pub const NFT_MSG_NEWSET: ::c_int = 9;
+pub const NFT_MSG_GETSET: ::c_int = 10;
+pub const NFT_MSG_DELSET: ::c_int = 11;
+pub const NFT_MSG_NEWSETELEM: ::c_int = 12;
+pub const NFT_MSG_GETSETELEM: ::c_int = 13;
+pub const NFT_MSG_DELSETELEM: ::c_int = 14;
+pub const NFT_MSG_NEWGEN: ::c_int = 15;
+pub const NFT_MSG_GETGEN: ::c_int = 16;
+pub const NFT_MSG_TRACE: ::c_int = 17;
+pub const NFT_MSG_NEWOBJ: ::c_int = 18;
+pub const NFT_MSG_GETOBJ: ::c_int = 19;
+pub const NFT_MSG_DELOBJ: ::c_int = 20;
+pub const NFT_MSG_GETOBJ_RESET: ::c_int = 21;
+pub const NFT_MSG_MAX: ::c_int = 25;
+
+pub const NFT_SET_ANONYMOUS: ::c_int = 0x1;
+pub const NFT_SET_CONSTANT: ::c_int = 0x2;
+pub const NFT_SET_INTERVAL: ::c_int = 0x4;
+pub const NFT_SET_MAP: ::c_int = 0x8;
+pub const NFT_SET_TIMEOUT: ::c_int = 0x10;
+pub const NFT_SET_EVAL: ::c_int = 0x20;
+
+pub const NFT_SET_POL_PERFORMANCE: ::c_int = 0;
+pub const NFT_SET_POL_MEMORY: ::c_int = 1;
+
+pub const NFT_SET_ELEM_INTERVAL_END: ::c_int = 0x1;
+
+pub const NFT_DATA_VALUE: ::c_uint = 0;
+pub const NFT_DATA_VERDICT: ::c_uint = 0xffffff00;
+
+pub const NFT_DATA_RESERVED_MASK: ::c_uint = 0xffffff00;
+
+pub const NFT_DATA_VALUE_MAXLEN: ::c_int = 64;
+
+pub const NFT_BYTEORDER_NTOH: ::c_int = 0;
+pub const NFT_BYTEORDER_HTON: ::c_int = 1;
+
+pub const NFT_CMP_EQ: ::c_int = 0;
+pub const NFT_CMP_NEQ: ::c_int = 1;
+pub const NFT_CMP_LT: ::c_int = 2;
+pub const NFT_CMP_LTE: ::c_int = 3;
+pub const NFT_CMP_GT: ::c_int = 4;
+pub const NFT_CMP_GTE: ::c_int = 5;
+
+pub const NFT_RANGE_EQ: ::c_int = 0;
+pub const NFT_RANGE_NEQ: ::c_int = 1;
+
+pub const NFT_LOOKUP_F_INV: ::c_int = 1 << 0;
+
+pub const NFT_DYNSET_OP_ADD: ::c_int = 0;
+pub const NFT_DYNSET_OP_UPDATE: ::c_int = 1;
+
+pub const NFT_DYNSET_F_INV: ::c_int = 1 << 0;
+
+pub const NFT_PAYLOAD_LL_HEADER: ::c_int = 0;
+pub const NFT_PAYLOAD_NETWORK_HEADER: ::c_int = 1;
+pub const NFT_PAYLOAD_TRANSPORT_HEADER: ::c_int = 2;
+
+pub const NFT_PAYLOAD_CSUM_NONE: ::c_int = 0;
+pub const NFT_PAYLOAD_CSUM_INET: ::c_int = 1;
+
+pub const NFT_META_LEN: ::c_int = 0;
+pub const NFT_META_PROTOCOL: ::c_int = 1;
+pub const NFT_META_PRIORITY: ::c_int = 2;
+pub const NFT_META_MARK: ::c_int = 3;
+pub const NFT_META_IIF: ::c_int = 4;
+pub const NFT_META_OIF: ::c_int = 5;
+pub const NFT_META_IIFNAME: ::c_int = 6;
+pub const NFT_META_OIFNAME: ::c_int = 7;
+pub const NFT_META_IIFTYPE: ::c_int = 8;
+pub const NFT_META_OIFTYPE: ::c_int = 9;
+pub const NFT_META_SKUID: ::c_int = 10;
+pub const NFT_META_SKGID: ::c_int = 11;
+pub const NFT_META_NFTRACE: ::c_int = 12;
+pub const NFT_META_RTCLASSID: ::c_int = 13;
+pub const NFT_META_SECMARK: ::c_int = 14;
+pub const NFT_META_NFPROTO: ::c_int = 15;
+pub const NFT_META_L4PROTO: ::c_int = 16;
+pub const NFT_META_BRI_IIFNAME: ::c_int = 17;
+pub const NFT_META_BRI_OIFNAME: ::c_int = 18;
+pub const NFT_META_PKTTYPE: ::c_int = 19;
+pub const NFT_META_CPU: ::c_int = 20;
+pub const NFT_META_IIFGROUP: ::c_int = 21;
+pub const NFT_META_OIFGROUP: ::c_int = 22;
+pub const NFT_META_CGROUP: ::c_int = 23;
+pub const NFT_META_PRANDOM: ::c_int = 24;
+
+pub const NFT_CT_STATE: ::c_int = 0;
+pub const NFT_CT_DIRECTION: ::c_int = 1;
+pub const NFT_CT_STATUS: ::c_int = 2;
+pub const NFT_CT_MARK: ::c_int = 3;
+pub const NFT_CT_SECMARK: ::c_int = 4;
+pub const NFT_CT_EXPIRATION: ::c_int = 5;
+pub const NFT_CT_HELPER: ::c_int = 6;
+pub const NFT_CT_L3PROTOCOL: ::c_int = 7;
+pub const NFT_CT_SRC: ::c_int = 8;
+pub const NFT_CT_DST: ::c_int = 9;
+pub const NFT_CT_PROTOCOL: ::c_int = 10;
+pub const NFT_CT_PROTO_SRC: ::c_int = 11;
+pub const NFT_CT_PROTO_DST: ::c_int = 12;
+pub const NFT_CT_LABELS: ::c_int = 13;
+pub const NFT_CT_PKTS: ::c_int = 14;
+pub const NFT_CT_BYTES: ::c_int = 15;
+
+pub const NFT_LIMIT_PKTS: ::c_int = 0;
+pub const NFT_LIMIT_PKT_BYTES: ::c_int = 1;
+
+pub const NFT_LIMIT_F_INV: ::c_int = 1 << 0;
+
+pub const NFT_QUEUE_FLAG_BYPASS: ::c_int = 0x01;
+pub const NFT_QUEUE_FLAG_CPU_FANOUT: ::c_int = 0x02;
+pub const NFT_QUEUE_FLAG_MASK: ::c_int = 0x03;
+
+pub const NFT_QUOTA_F_INV: ::c_int = 1 << 0;
+
+pub const NFT_REJECT_ICMP_UNREACH: ::c_int = 0;
+pub const NFT_REJECT_TCP_RST: ::c_int = 1;
+pub const NFT_REJECT_ICMPX_UNREACH: ::c_int = 2;
+
+pub const NFT_REJECT_ICMPX_NO_ROUTE: ::c_int = 0;
+pub const NFT_REJECT_ICMPX_PORT_UNREACH: ::c_int = 1;
+pub const NFT_REJECT_ICMPX_HOST_UNREACH: ::c_int = 2;
+pub const NFT_REJECT_ICMPX_ADMIN_PROHIBITED: ::c_int = 3;
+
+pub const NFT_NAT_SNAT: ::c_int = 0;
+pub const NFT_NAT_DNAT: ::c_int = 1;
+
+pub const NFT_TRACETYPE_UNSPEC: ::c_int = 0;
+pub const NFT_TRACETYPE_POLICY: ::c_int = 1;
+pub const NFT_TRACETYPE_RETURN: ::c_int = 2;
+pub const NFT_TRACETYPE_RULE: ::c_int = 3;
+
+pub const NFT_NG_INCREMENTAL: ::c_int = 0;
+pub const NFT_NG_RANDOM: ::c_int = 1;
+
+pub const IFF_TUN: ::c_int = 0x0001;
+pub const IFF_TAP: ::c_int = 0x0002;
+pub const IFF_NO_PI: ::c_int = 0x1000;
+
+// start android/platform/bionic/libc/kernel/uapi/linux/if_ether.h
+// from https://android.googlesource.com/
+// platform/bionic/+/master/libc/kernel/uapi/linux/if_ether.h
+pub const ETH_ALEN: ::c_int = 6;
+pub const ETH_HLEN: ::c_int = 14;
+pub const ETH_ZLEN: ::c_int = 60;
+pub const ETH_DATA_LEN: ::c_int = 1500;
+pub const ETH_FRAME_LEN: ::c_int = 1514;
+pub const ETH_FCS_LEN: ::c_int = 4;
+pub const ETH_MIN_MTU: ::c_int = 68;
+pub const ETH_MAX_MTU: ::c_int = 0xFFFF;
+pub const ETH_P_LOOP: ::c_int = 0x0060;
+pub const ETH_P_PUP: ::c_int = 0x0200;
+pub const ETH_P_PUPAT: ::c_int = 0x0201;
+pub const ETH_P_TSN: ::c_int = 0x22F0;
+pub const ETH_P_IP: ::c_int = 0x0800;
+pub const ETH_P_X25: ::c_int = 0x0805;
+pub const ETH_P_ARP: ::c_int = 0x0806;
+pub const ETH_P_BPQ: ::c_int = 0x08FF;
+pub const ETH_P_IEEEPUP: ::c_int = 0x0a00;
+pub const ETH_P_IEEEPUPAT: ::c_int = 0x0a01;
+pub const ETH_P_BATMAN: ::c_int = 0x4305;
+pub const ETH_P_DEC: ::c_int = 0x6000;
+pub const ETH_P_DNA_DL: ::c_int = 0x6001;
+pub const ETH_P_DNA_RC: ::c_int = 0x6002;
+pub const ETH_P_DNA_RT: ::c_int = 0x6003;
+pub const ETH_P_LAT: ::c_int = 0x6004;
+pub const ETH_P_DIAG: ::c_int = 0x6005;
+pub const ETH_P_CUST: ::c_int = 0x6006;
+pub const ETH_P_SCA: ::c_int = 0x6007;
+pub const ETH_P_TEB: ::c_int = 0x6558;
+pub const ETH_P_RARP: ::c_int = 0x8035;
+pub const ETH_P_ATALK: ::c_int = 0x809B;
+pub const ETH_P_AARP: ::c_int = 0x80F3;
+pub const ETH_P_8021Q: ::c_int = 0x8100;
+/* see rust-lang/libc#924 pub const ETH_P_ERSPAN: ::c_int = 0x88BE;*/
+pub const ETH_P_IPX: ::c_int = 0x8137;
+pub const ETH_P_IPV6: ::c_int = 0x86DD;
+pub const ETH_P_PAUSE: ::c_int = 0x8808;
+pub const ETH_P_SLOW: ::c_int = 0x8809;
+pub const ETH_P_WCCP: ::c_int = 0x883E;
+pub const ETH_P_MPLS_UC: ::c_int = 0x8847;
+pub const ETH_P_MPLS_MC: ::c_int = 0x8848;
+pub const ETH_P_ATMMPOA: ::c_int = 0x884c;
+pub const ETH_P_PPP_DISC: ::c_int = 0x8863;
+pub const ETH_P_PPP_SES: ::c_int = 0x8864;
+pub const ETH_P_LINK_CTL: ::c_int = 0x886c;
+pub const ETH_P_ATMFATE: ::c_int = 0x8884;
+pub const ETH_P_PAE: ::c_int = 0x888E;
+pub const ETH_P_AOE: ::c_int = 0x88A2;
+pub const ETH_P_8021AD: ::c_int = 0x88A8;
+pub const ETH_P_802_EX1: ::c_int = 0x88B5;
+pub const ETH_P_TIPC: ::c_int = 0x88CA;
+pub const ETH_P_MACSEC: ::c_int = 0x88E5;
+pub const ETH_P_8021AH: ::c_int = 0x88E7;
+pub const ETH_P_MVRP: ::c_int = 0x88F5;
+pub const ETH_P_1588: ::c_int = 0x88F7;
+pub const ETH_P_NCSI: ::c_int = 0x88F8;
+pub const ETH_P_PRP: ::c_int = 0x88FB;
+pub const ETH_P_FCOE: ::c_int = 0x8906;
+/* see rust-lang/libc#924 pub const ETH_P_IBOE: ::c_int = 0x8915;*/
+pub const ETH_P_TDLS: ::c_int = 0x890D;
+pub const ETH_P_FIP: ::c_int = 0x8914;
+pub const ETH_P_80221: ::c_int = 0x8917;
+pub const ETH_P_HSR: ::c_int = 0x892F;
+/* see rust-lang/libc#924 pub const ETH_P_NSH: ::c_int = 0x894F;*/
+pub const ETH_P_LOOPBACK: ::c_int = 0x9000;
+pub const ETH_P_QINQ1: ::c_int = 0x9100;
+pub const ETH_P_QINQ2: ::c_int = 0x9200;
+pub const ETH_P_QINQ3: ::c_int = 0x9300;
+pub const ETH_P_EDSA: ::c_int = 0xDADA;
+/* see rust-lang/libc#924 pub const ETH_P_IFE: ::c_int = 0xED3E;*/
+pub const ETH_P_AF_IUCV: ::c_int = 0xFBFB;
+pub const ETH_P_802_3_MIN: ::c_int = 0x0600;
+pub const ETH_P_802_3: ::c_int = 0x0001;
+pub const ETH_P_AX25: ::c_int = 0x0002;
+pub const ETH_P_ALL: ::c_int = 0x0003;
+pub const ETH_P_802_2: ::c_int = 0x0004;
+pub const ETH_P_SNAP: ::c_int = 0x0005;
+pub const ETH_P_DDCMP: ::c_int = 0x0006;
+pub const ETH_P_WAN_PPP: ::c_int = 0x0007;
+pub const ETH_P_PPP_MP: ::c_int = 0x0008;
+pub const ETH_P_LOCALTALK: ::c_int = 0x0009;
+pub const ETH_P_CAN: ::c_int = 0x000C;
+pub const ETH_P_CANFD: ::c_int = 0x000D;
+pub const ETH_P_PPPTALK: ::c_int = 0x0010;
+pub const ETH_P_TR_802_2: ::c_int = 0x0011;
+pub const ETH_P_MOBITEX: ::c_int = 0x0015;
+pub const ETH_P_CONTROL: ::c_int = 0x0016;
+pub const ETH_P_IRDA: ::c_int = 0x0017;
+pub const ETH_P_ECONET: ::c_int = 0x0018;
+pub const ETH_P_HDLC: ::c_int = 0x0019;
+pub const ETH_P_ARCNET: ::c_int = 0x001A;
+pub const ETH_P_DSA: ::c_int = 0x001B;
+pub const ETH_P_TRAILER: ::c_int = 0x001C;
+pub const ETH_P_PHONET: ::c_int = 0x00F5;
+pub const ETH_P_IEEE802154: ::c_int = 0x00F6;
+pub const ETH_P_CAIF: ::c_int = 0x00F7;
+pub const ETH_P_XDSA: ::c_int = 0x00F8;
+/* see rust-lang/libc#924 pub const ETH_P_MAP: ::c_int = 0x00F9;*/
+// end android/platform/bionic/libc/kernel/uapi/linux/if_ether.h
+
+pub const SIOCADDRT: ::c_ulong = 0x0000890B;
+pub const SIOCDELRT: ::c_ulong = 0x0000890C;
+pub const SIOCGIFNAME: ::c_ulong = 0x00008910;
+pub const SIOCSIFLINK: ::c_ulong = 0x00008911;
+pub const SIOCGIFCONF: ::c_ulong = 0x00008912;
+pub const SIOCGIFFLAGS: ::c_ulong = 0x00008913;
+pub const SIOCSIFFLAGS: ::c_ulong = 0x00008914;
+pub const SIOCGIFADDR: ::c_ulong = 0x00008915;
+pub const SIOCSIFADDR: ::c_ulong = 0x00008916;
+pub const SIOCGIFDSTADDR: ::c_ulong = 0x00008917;
+pub const SIOCSIFDSTADDR: ::c_ulong = 0x00008918;
+pub const SIOCGIFBRDADDR: ::c_ulong = 0x00008919;
+pub const SIOCSIFBRDADDR: ::c_ulong = 0x0000891A;
+pub const SIOCGIFNETMASK: ::c_ulong = 0x0000891B;
+pub const SIOCSIFNETMASK: ::c_ulong = 0x0000891C;
+pub const SIOCGIFMETRIC: ::c_ulong = 0x0000891D;
+pub const SIOCSIFMETRIC: ::c_ulong = 0x0000891E;
+pub const SIOCGIFMEM: ::c_ulong = 0x0000891F;
+pub const SIOCSIFMEM: ::c_ulong = 0x00008920;
+pub const SIOCGIFMTU: ::c_ulong = 0x00008921;
+pub const SIOCSIFMTU: ::c_ulong = 0x00008922;
+pub const SIOCSIFHWADDR: ::c_ulong = 0x00008924;
+pub const SIOCGIFENCAP: ::c_ulong = 0x00008925;
+pub const SIOCSIFENCAP: ::c_ulong = 0x00008926;
+pub const SIOCGIFHWADDR: ::c_ulong = 0x00008927;
+pub const SIOCGIFSLAVE: ::c_ulong = 0x00008929;
+pub const SIOCSIFSLAVE: ::c_ulong = 0x00008930;
+pub const SIOCADDMULTI: ::c_ulong = 0x00008931;
+pub const SIOCDELMULTI: ::c_ulong = 0x00008932;
+pub const SIOCDARP: ::c_ulong = 0x00008953;
+pub const SIOCGARP: ::c_ulong = 0x00008954;
+pub const SIOCSARP: ::c_ulong = 0x00008955;
+pub const SIOCDRARP: ::c_ulong = 0x00008960;
+pub const SIOCGRARP: ::c_ulong = 0x00008961;
+pub const SIOCSRARP: ::c_ulong = 0x00008962;
+pub const SIOCGIFMAP: ::c_ulong = 0x00008970;
+pub const SIOCSIFMAP: ::c_ulong = 0x00008971;
+
+// linux/module.h
+pub const MODULE_INIT_IGNORE_MODVERSIONS: ::c_uint = 0x0001;
+pub const MODULE_INIT_IGNORE_VERMAGIC: ::c_uint = 0x0002;
+
+#[deprecated(
+    since = "0.2.55",
+    note = "ENOATTR is not available on Android; use ENODATA instead"
+)]
+pub const ENOATTR: ::c_int = ::ENODATA;
+
+// linux/if_alg.h
+pub const ALG_SET_KEY: ::c_int = 1;
+pub const ALG_SET_IV: ::c_int = 2;
+pub const ALG_SET_OP: ::c_int = 3;
+pub const ALG_SET_AEAD_ASSOCLEN: ::c_int = 4;
+pub const ALG_SET_AEAD_AUTHSIZE: ::c_int = 5;
+
+pub const ALG_OP_DECRYPT: ::c_int = 0;
+pub const ALG_OP_ENCRYPT: ::c_int = 1;
+
+// uapi/linux/vm_sockets.h
+pub const VMADDR_CID_ANY: ::c_uint = 0xFFFFFFFF;
+pub const VMADDR_CID_HYPERVISOR: ::c_uint = 0;
+pub const VMADDR_CID_LOCAL: ::c_uint = 1;
+pub const VMADDR_CID_HOST: ::c_uint = 2;
+pub const VMADDR_PORT_ANY: ::c_uint = 0xFFFFFFFF;
+
+// uapi/linux/inotify.h
+pub const IN_ACCESS: u32 = 0x0000_0001;
+pub const IN_MODIFY: u32 = 0x0000_0002;
+pub const IN_ATTRIB: u32 = 0x0000_0004;
+pub const IN_CLOSE_WRITE: u32 = 0x0000_0008;
+pub const IN_CLOSE_NOWRITE: u32 = 0x0000_0010;
+pub const IN_CLOSE: u32 = IN_CLOSE_WRITE | IN_CLOSE_NOWRITE;
+pub const IN_OPEN: u32 = 0x0000_0020;
+pub const IN_MOVED_FROM: u32 = 0x0000_0040;
+pub const IN_MOVED_TO: u32 = 0x0000_0080;
+pub const IN_MOVE: u32 = IN_MOVED_FROM | IN_MOVED_TO;
+pub const IN_CREATE: u32 = 0x0000_0100;
+pub const IN_DELETE: u32 = 0x0000_0200;
+pub const IN_DELETE_SELF: u32 = 0x0000_0400;
+pub const IN_MOVE_SELF: u32 = 0x0000_0800;
+pub const IN_UNMOUNT: u32 = 0x0000_2000;
+pub const IN_Q_OVERFLOW: u32 = 0x0000_4000;
+pub const IN_IGNORED: u32 = 0x0000_8000;
+pub const IN_ONLYDIR: u32 = 0x0100_0000;
+pub const IN_DONT_FOLLOW: u32 = 0x0200_0000;
+// pub const IN_EXCL_UNLINK:   u32 = 0x0400_0000;
+
+// pub const IN_MASK_CREATE:   u32 = 0x1000_0000;
+// pub const IN_MASK_ADD:      u32 = 0x2000_0000;
+pub const IN_ISDIR: u32 = 0x4000_0000;
+pub const IN_ONESHOT: u32 = 0x8000_0000;
+
+pub const IN_ALL_EVENTS: u32 = IN_ACCESS
+    | IN_MODIFY
+    | IN_ATTRIB
+    | IN_CLOSE_WRITE
+    | IN_CLOSE_NOWRITE
+    | IN_OPEN
+    | IN_MOVED_FROM
+    | IN_MOVED_TO
+    | IN_DELETE
+    | IN_CREATE
+    | IN_DELETE_SELF
+    | IN_MOVE_SELF;
+
+pub const IN_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const IN_NONBLOCK: ::c_int = O_NONBLOCK;
+
+pub const FUTEX_WAIT: ::c_int = 0;
+pub const FUTEX_WAKE: ::c_int = 1;
+pub const FUTEX_FD: ::c_int = 2;
+pub const FUTEX_REQUEUE: ::c_int = 3;
+pub const FUTEX_CMP_REQUEUE: ::c_int = 4;
+pub const FUTEX_WAKE_OP: ::c_int = 5;
+pub const FUTEX_LOCK_PI: ::c_int = 6;
+pub const FUTEX_UNLOCK_PI: ::c_int = 7;
+pub const FUTEX_TRYLOCK_PI: ::c_int = 8;
+pub const FUTEX_WAIT_BITSET: ::c_int = 9;
+pub const FUTEX_WAKE_BITSET: ::c_int = 10;
+pub const FUTEX_WAIT_REQUEUE_PI: ::c_int = 11;
+pub const FUTEX_CMP_REQUEUE_PI: ::c_int = 12;
+
+pub const FUTEX_PRIVATE_FLAG: ::c_int = 128;
+pub const FUTEX_CLOCK_REALTIME: ::c_int = 256;
+pub const FUTEX_CMD_MASK: ::c_int =
+    !(FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME);
+
+// linux/errqueue.h
+pub const SO_EE_ORIGIN_NONE: u8 = 0;
+pub const SO_EE_ORIGIN_LOCAL: u8 = 1;
+pub const SO_EE_ORIGIN_ICMP: u8 = 2;
+pub const SO_EE_ORIGIN_ICMP6: u8 = 3;
+pub const SO_EE_ORIGIN_TXSTATUS: u8 = 4;
+pub const SO_EE_ORIGIN_TIMESTAMPING: u8 = SO_EE_ORIGIN_TXSTATUS;
+
+// errno.h
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+// linux/sched.h
+pub const SCHED_NORMAL: ::c_int = 0;
+pub const SCHED_FIFO: ::c_int = 1;
+pub const SCHED_RR: ::c_int = 2;
+pub const SCHED_BATCH: ::c_int = 3;
+pub const SCHED_IDLE: ::c_int = 5;
+pub const SCHED_DEADLINE: ::c_int = 6;
+
+// bits/seek_constants.h
+pub const SEEK_DATA: ::c_int = 3;
+pub const SEEK_HOLE: ::c_int = 4;
+
+// sys/socket.h
+pub const AF_NFC: ::c_int = 39;
+pub const AF_VSOCK: ::c_int = 40;
+pub const PF_NFC: ::c_int = AF_NFC;
+pub const PF_VSOCK: ::c_int = AF_VSOCK;
+
+f! {
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr,
+                       cmsg: *const cmsghdr) -> *mut cmsghdr {
+        let next = (cmsg as usize
+                    + super::CMSG_ALIGN((*cmsg).cmsg_len as usize))
+            as *mut cmsghdr;
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if (next.offset(1)) as usize > max {
+            0 as *mut cmsghdr
+        } else {
+            next as *mut cmsghdr
+        }
+    }
+
+    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {
+        for slot in cpuset.__bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+
+    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in___bits = 8 * ::mem::size_of_val(&cpuset.__bits[0]);
+        let (idx, offset) = (cpu / size_in___bits, cpu % size_in___bits);
+        cpuset.__bits[idx] |= 1 << offset;
+        ()
+    }
+
+    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in___bits = 8 * ::mem::size_of_val(&cpuset.__bits[0]);
+        let (idx, offset) = (cpu / size_in___bits, cpu % size_in___bits);
+        cpuset.__bits[idx] &= !(1 << offset);
+        ()
+    }
+
+    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {
+        let size_in___bits = 8 * ::mem::size_of_val(&cpuset.__bits[0]);
+        let (idx, offset) = (cpu / size_in___bits, cpu % size_in___bits);
+        0 != (cpuset.__bits[idx] & (1 << offset))
+    }
+
+    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {
+        set1.__bits == set2.__bits
+    }
+    pub fn major(dev: ::dev_t) -> ::c_int {
+        ((dev >> 8) & 0xfff) as ::c_int
+    }
+    pub fn minor(dev: ::dev_t) -> ::c_int {
+        ((dev & 0xff) | ((dev >> 12) & 0xfff00)) as ::c_int
+    }
+    pub fn makedev(ma: ::c_int, mi: ::c_int) -> ::dev_t {
+        let ma = ma as ::dev_t;
+        let mi = mi as ::dev_t;
+        ((ma & 0xfff) << 8) | (mi & 0xff) | ((mi & 0xfff00) << 12)
+    }
+
+    pub fn NLA_ALIGN(len: ::c_int) -> ::c_int {
+        return ((len) + NLA_ALIGNTO - 1) & !(NLA_ALIGNTO - 1)
+    }
+
+    pub fn SO_EE_OFFENDER(ee: *const ::sock_extended_err) -> *mut ::sockaddr {
+        ee.offset(1) as *mut ::sockaddr
+    }
+
+    // Sadly, Android before 5.0 (API level 21), the accept4 syscall is not
+    // exposed by the libc. As work-around, we implement it through `syscall`
+    // directly. This workaround can be removed if the minimum version of
+    // Android is bumped. When the workaround is removed, `accept4` can be
+    // moved back to `linux_like/mod.rs`
+    pub fn accept4(
+        fd: ::c_int,
+        addr: *mut ::sockaddr,
+        len: *mut ::socklen_t,
+        flg: ::c_int
+    ) -> ::c_int {
+        syscall(SYS_accept4, fd, addr, len, flg) as ::c_int
+    }
+}
+
+extern "C" {
+    pub fn getrlimit64(resource: ::c_int, rlim: *mut rlimit64) -> ::c_int;
+    pub fn setrlimit64(resource: ::c_int, rlim: *const rlimit64) -> ::c_int;
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+    pub fn prlimit(
+        pid: ::pid_t,
+        resource: ::c_int,
+        new_limit: *const ::rlimit,
+        old_limit: *mut ::rlimit,
+    ) -> ::c_int;
+    pub fn prlimit64(
+        pid: ::pid_t,
+        resource: ::c_int,
+        new_limit: *const ::rlimit64,
+        old_limit: *mut ::rlimit64,
+    ) -> ::c_int;
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;
+    pub fn madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::size_t,
+        serv: *mut ::c_char,
+        sevlen: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        count: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        count: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn process_vm_readv(
+        pid: ::pid_t,
+        local_iov: *const ::iovec,
+        local_iov_count: ::c_ulong,
+        remote_iov: *const ::iovec,
+        remote_iov_count: ::c_ulong,
+        flags: ::c_ulong,
+    ) -> ::ssize_t;
+    pub fn process_vm_writev(
+        pid: ::pid_t,
+        local_iov: *const ::iovec,
+        local_iov_count: ::c_ulong,
+        remote_iov: *const ::iovec,
+        remote_iov_count: ::c_ulong,
+        flags: ::c_ulong,
+    ) -> ::ssize_t;
+    pub fn ptrace(request: ::c_int, ...) -> ::c_long;
+    pub fn getpriority(which: ::c_int, who: ::id_t) -> ::c_int;
+    pub fn setpriority(which: ::c_int, who: ::id_t, prio: ::c_int) -> ::c_int;
+    pub fn __sched_cpualloc(count: ::size_t) -> *mut ::cpu_set_t;
+    pub fn __sched_cpufree(set: *mut ::cpu_set_t);
+    pub fn __sched_cpucount(
+        setsize: ::size_t,
+        set: *const cpu_set_t,
+    ) -> ::c_int;
+    pub fn sched_getcpu() -> ::c_int;
+
+    pub fn utmpname(name: *const ::c_char) -> ::c_int;
+    pub fn setutent();
+    pub fn getutent() -> *mut utmp;
+
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+    pub fn fallocate(
+        fd: ::c_int,
+        mode: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+    pub fn fallocate64(
+        fd: ::c_int,
+        mode: ::c_int,
+        offset: ::off64_t,
+        len: ::off64_t,
+    ) -> ::c_int;
+    pub fn posix_fallocate(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+    pub fn posix_fallocate64(
+        fd: ::c_int,
+        offset: ::off64_t,
+        len: ::off64_t,
+    ) -> ::c_int;
+    pub fn getxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn lgetxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn fgetxattr(
+        filedes: ::c_int,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn setxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn lsetxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn fsetxattr(
+        filedes: ::c_int,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn listxattr(
+        path: *const c_char,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn llistxattr(
+        path: *const c_char,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn flistxattr(
+        filedes: ::c_int,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn removexattr(path: *const c_char, name: *const c_char) -> ::c_int;
+    pub fn lremovexattr(path: *const c_char, name: *const c_char) -> ::c_int;
+    pub fn fremovexattr(filedes: ::c_int, name: *const c_char) -> ::c_int;
+    pub fn signalfd(
+        fd: ::c_int,
+        mask: *const ::sigset_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn timerfd_create(clock: ::clockid_t, flags: ::c_int) -> ::c_int;
+    pub fn timerfd_gettime(
+        fd: ::c_int,
+        current_value: *mut itimerspec,
+    ) -> ::c_int;
+    pub fn timerfd_settime(
+        fd: ::c_int,
+        flags: ::c_int,
+        new_value: *const itimerspec,
+        old_value: *mut itimerspec,
+    ) -> ::c_int;
+    pub fn syscall(num: ::c_long, ...) -> ::c_long;
+    pub fn sched_getaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut cpu_set_t,
+    ) -> ::c_int;
+    pub fn sched_setaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        cpuset: *const cpu_set_t,
+    ) -> ::c_int;
+    pub fn epoll_create(size: ::c_int) -> ::c_int;
+    pub fn epoll_create1(flags: ::c_int) -> ::c_int;
+    pub fn epoll_wait(
+        epfd: ::c_int,
+        events: *mut ::epoll_event,
+        maxevents: ::c_int,
+        timeout: ::c_int,
+    ) -> ::c_int;
+    pub fn epoll_ctl(
+        epfd: ::c_int,
+        op: ::c_int,
+        fd: ::c_int,
+        event: *mut ::epoll_event,
+    ) -> ::c_int;
+    pub fn pthread_getschedparam(
+        native: ::pthread_t,
+        policy: *mut ::c_int,
+        param: *mut ::sched_param,
+    ) -> ::c_int;
+    pub fn unshare(flags: ::c_int) -> ::c_int;
+    pub fn umount(target: *const ::c_char) -> ::c_int;
+    pub fn sched_get_priority_max(policy: ::c_int) -> ::c_int;
+    pub fn tee(
+        fd_in: ::c_int,
+        fd_out: ::c_int,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn settimeofday(
+        tv: *const ::timeval,
+        tz: *const ::timezone,
+    ) -> ::c_int;
+    pub fn splice(
+        fd_in: ::c_int,
+        off_in: *mut ::loff_t,
+        fd_out: ::c_int,
+        off_out: *mut ::loff_t,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn eventfd(init: ::c_uint, flags: ::c_int) -> ::c_int;
+    pub fn sched_rr_get_interval(pid: ::pid_t, tp: *mut ::timespec)
+        -> ::c_int;
+    pub fn sem_timedwait(
+        sem: *mut sem_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;
+    pub fn sched_setparam(
+        pid: ::pid_t,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn setns(fd: ::c_int, nstype: ::c_int) -> ::c_int;
+    pub fn swapoff(puath: *const ::c_char) -> ::c_int;
+    pub fn vmsplice(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        nr_segs: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mount(
+        src: *const ::c_char,
+        target: *const ::c_char,
+        fstype: *const ::c_char,
+        flags: ::c_ulong,
+        data: *const ::c_void,
+    ) -> ::c_int;
+    pub fn personality(persona: ::c_uint) -> ::c_int;
+    pub fn prctl(option: ::c_int, ...) -> ::c_int;
+    pub fn sched_getparam(pid: ::pid_t, param: *mut ::sched_param) -> ::c_int;
+    pub fn ppoll(
+        fds: *mut ::pollfd,
+        nfds: nfds_t,
+        timeout: *const ::timespec,
+        sigmask: *const sigset_t,
+    ) -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn clone(
+        cb: extern "C" fn(*mut ::c_void) -> ::c_int,
+        child_stack: *mut ::c_void,
+        flags: ::c_int,
+        arg: *mut ::c_void,
+        ...
+    ) -> ::c_int;
+    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;
+    pub fn clock_nanosleep(
+        clk_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const ::pthread_attr_t,
+        guardsize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn sched_get_priority_min(policy: ::c_int) -> ::c_int;
+    pub fn pthread_condattr_getpshared(
+        attr: *const pthread_condattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn sysinfo(info: *mut ::sysinfo) -> ::c_int;
+    pub fn umount2(target: *const ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn pthread_setschedparam(
+        native: ::pthread_t,
+        policy: ::c_int,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn swapon(path: *const ::c_char, swapflags: ::c_int) -> ::c_int;
+    pub fn sched_setscheduler(
+        pid: ::pid_t,
+        policy: ::c_int,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn sendfile(
+        out_fd: ::c_int,
+        in_fd: ::c_int,
+        offset: *mut off_t,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    pub fn setfsgid(gid: ::gid_t) -> ::c_int;
+    pub fn setfsuid(uid: ::uid_t) -> ::c_int;
+    pub fn sigsuspend(mask: *const ::sigset_t) -> ::c_int;
+    pub fn getgrgid_r(
+        gid: ::gid_t,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;
+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;
+    pub fn getgrnam_r(
+        name: *const ::c_char,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;
+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;
+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;
+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    pub fn getpwnam_r(
+        name: *const ::c_char,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn sigtimedwait(
+        set: *const sigset_t,
+        info: *mut siginfo_t,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;
+    pub fn getgrouplist(
+        user: *const ::c_char,
+        group: ::gid_t,
+        groups: *mut ::gid_t,
+        ngroups: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn initgroups(user: *const ::c_char, group: ::gid_t) -> ::c_int;
+    pub fn pthread_mutexattr_getpshared(
+        attr: *const pthread_mutexattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+    pub fn faccessat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_create(
+        native: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        f: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn __errno() -> *mut ::c_int;
+    pub fn inotify_rm_watch(fd: ::c_int, wd: u32) -> ::c_int;
+    pub fn sendmmsg(
+        sockfd: ::c_int,
+        msgvec: *const ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn recvmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn inotify_init() -> ::c_int;
+    pub fn inotify_init1(flags: ::c_int) -> ::c_int;
+    pub fn inotify_add_watch(
+        fd: ::c_int,
+        path: *const ::c_char,
+        mask: u32,
+    ) -> ::c_int;
+
+    pub fn regcomp(
+        preg: *mut ::regex_t,
+        pattern: *const ::c_char,
+        cflags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn regexec(
+        preg: *const ::regex_t,
+        input: *const ::c_char,
+        nmatch: ::size_t,
+        pmatch: *mut regmatch_t,
+        eflags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn regerror(
+        errcode: ::c_int,
+        preg: *const ::regex_t,
+        errbuf: *mut ::c_char,
+        errbuf_size: ::size_t,
+    ) -> ::size_t;
+
+    pub fn regfree(preg: *mut ::regex_t);
+
+    pub fn android_set_abort_message(msg: *const ::c_char);
+}
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "32")] {
+        mod b32;
+        pub use self::b32::*;
+    } else if #[cfg(target_pointer_width = "64")] {
+        mod b64;
+        pub use self::b64::*;
+    } else {
+        // Unknown target_pointer_width
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_value(&self) -> ::sigval {
+        #[repr(C)]
+        struct siginfo_timer {
+            _si_signo: ::c_int,
+            _si_errno: ::c_int,
+            _si_code: ::c_int,
+            _si_tid: ::c_int,
+            _si_overrun: ::c_int,
+            si_sigval: ::sigval,
+        }
+        (*(self as *const siginfo_t as *const siginfo_timer)).si_sigval
+    }
+}
diff --git a/library/libc/src/unix/linux_like/emscripten/align.rs b/library/libc/src/unix/linux_like/emscripten/align.rs
new file mode 100644
index 00000000..b9ea3f39
--- /dev/null
+++ b/library/libc/src/unix/linux_like/emscripten/align.rs
@@ -0,0 +1,74 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            #[allow(missing_debug_implementations)]
+            #[repr(align(4))]
+            pub struct pthread_mutex_t {
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_rwlock_t {
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_mutexattr_t {
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_rwlockattr_t {
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_condattr_t {
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+
+        s_no_extra_traits! {
+            #[cfg_attr(target_pointer_width = "32",
+                       repr(align(4)))]
+            #[cfg_attr(target_pointer_width = "64",
+                       repr(align(8)))]
+            pub struct pthread_cond_t {
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            #[allow(missing_debug_implementations)]
+            #[repr(align(16))]
+            pub struct max_align_t {
+                priv_: [f64; 4]
+            }
+
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for pthread_cond_t {
+                    fn eq(&self, other: &pthread_cond_t) -> bool {
+                        self.size
+                            .iter()
+                            .zip(other.size.iter())
+                            .all(|(a,b)| a == b)
+                    }
+                }
+                impl Eq for pthread_cond_t {}
+                impl ::fmt::Debug for pthread_cond_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("pthread_cond_t")
+                            // FIXME: .field("size", &self.size)
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for pthread_cond_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.size.hash(state);
+                    }
+                }
+            }
+        }
+    };
+}
diff --git a/library/libc/src/unix/linux_like/emscripten/mod.rs b/library/libc/src/unix/linux_like/emscripten/mod.rs
new file mode 100644
index 00000000..9599e199
--- /dev/null
+++ b/library/libc/src/unix/linux_like/emscripten/mod.rs
@@ -0,0 +1,1968 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type useconds_t = u32;
+pub type dev_t = u32;
+pub type socklen_t = u32;
+pub type pthread_t = c_ulong;
+pub type mode_t = u32;
+pub type ino64_t = u64;
+pub type off64_t = i64;
+pub type blkcnt64_t = i32;
+pub type rlim64_t = u64;
+pub type shmatt_t = ::c_ulong;
+pub type mqd_t = ::c_int;
+pub type msgqnum_t = ::c_ulong;
+pub type msglen_t = ::c_ulong;
+pub type nfds_t = ::c_ulong;
+pub type nl_item = ::c_int;
+pub type idtype_t = ::c_uint;
+pub type loff_t = i64;
+pub type pthread_key_t = ::c_uint;
+
+pub type clock_t = c_long;
+pub type time_t = c_long;
+pub type suseconds_t = c_long;
+pub type ino_t = u64;
+pub type off_t = i64;
+pub type blkcnt_t = i32;
+
+pub type blksize_t = c_long;
+pub type fsblkcnt_t = u32;
+pub type fsfilcnt_t = u32;
+pub type rlim_t = ::c_ulonglong;
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type nlink_t = u32;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum fpos64_t {} // FIXME: fill this out with a struct
+impl ::Copy for fpos64_t {}
+impl ::Clone for fpos64_t {
+    fn clone(&self) -> fpos64_t {
+        *self
+    }
+}
+
+s! {
+    pub struct rlimit64 {
+        pub rlim_cur: rlim64_t,
+        pub rlim_max: rlim64_t,
+    }
+
+    pub struct glob_t {
+        pub gl_pathc: ::size_t,
+        pub gl_pathv: *mut *mut c_char,
+        pub gl_offs: ::size_t,
+        pub gl_flags: ::c_int,
+
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct spwd {
+        pub sp_namp: *mut ::c_char,
+        pub sp_pwdp: *mut ::c_char,
+        pub sp_lstchg: ::c_long,
+        pub sp_min: ::c_long,
+        pub sp_max: ::c_long,
+        pub sp_warn: ::c_long,
+        pub sp_inact: ::c_long,
+        pub sp_expire: ::c_long,
+        pub sp_flag: ::c_ulong,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct dqblk {
+        pub dqb_bhardlimit: u64,
+        pub dqb_bsoftlimit: u64,
+        pub dqb_curspace: u64,
+        pub dqb_ihardlimit: u64,
+        pub dqb_isoftlimit: u64,
+        pub dqb_curinodes: u64,
+        pub dqb_btime: u64,
+        pub dqb_itime: u64,
+        pub dqb_valid: u32,
+    }
+
+    pub struct signalfd_siginfo {
+        pub ssi_signo: u32,
+        pub ssi_errno: i32,
+        pub ssi_code: i32,
+        pub ssi_pid: u32,
+        pub ssi_uid: u32,
+        pub ssi_fd: i32,
+        pub ssi_tid: u32,
+        pub ssi_band: u32,
+        pub ssi_overrun: u32,
+        pub ssi_trapno: u32,
+        pub ssi_status: i32,
+        pub ssi_int: i32,
+        pub ssi_ptr: u64,
+        pub ssi_utime: u64,
+        pub ssi_stime: u64,
+        pub ssi_addr: u64,
+        pub ssi_addr_lsb: u16,
+        _pad2: u16,
+        pub ssi_syscall: i32,
+        pub ssi_call_addr: u64,
+        pub ssi_arch: u32,
+        _pad: [u8; 28],
+    }
+
+    pub struct fsid_t {
+        __val: [::c_int; 2],
+    }
+
+    pub struct cpu_set_t {
+        bits: [u32; 32],
+    }
+
+    pub struct if_nameindex {
+        pub if_index: ::c_uint,
+        pub if_name: *mut ::c_char,
+    }
+
+    // System V IPC
+    pub struct msginfo {
+        pub msgpool: ::c_int,
+        pub msgmap: ::c_int,
+        pub msgmax: ::c_int,
+        pub msgmnb: ::c_int,
+        pub msgmni: ::c_int,
+        pub msgssz: ::c_int,
+        pub msgtql: ::c_int,
+        pub msgseg: ::c_ushort,
+    }
+
+    pub struct sembuf {
+        pub sem_num: ::c_ushort,
+        pub sem_op: ::c_short,
+        pub sem_flg: ::c_short,
+    }
+
+    pub struct aiocb {
+        pub aio_fildes: ::c_int,
+        pub aio_lio_opcode: ::c_int,
+        pub aio_reqprio: ::c_int,
+        pub aio_buf: *mut ::c_void,
+        pub aio_nbytes: ::size_t,
+        pub aio_sigevent: ::sigevent,
+        __td: *mut ::c_void,
+        __lock: [::c_int; 2],
+        __err: ::c_int,
+        __ret: ::ssize_t,
+        pub aio_offset: off_t,
+        __next: *mut ::c_void,
+        __prev: *mut ::c_void,
+        __dummy4: [::c_char; 24],
+    }
+
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __unused1: ::c_long,
+        __unused2: ::c_long
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        pub __c_ispeed: ::speed_t,
+        pub __c_ospeed: ::speed_t,
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct pthread_attr_t {
+        __size: [u32; 11]
+    }
+
+    pub struct sigset_t {
+        __val: [::c_ulong; 32],
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::socklen_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct sem_t {
+        __val: [::c_int; 4],
+    }
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        __st_dev_padding: ::c_int,
+        __st_ino_truncated: ::c_long,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_rdev_padding: ::c_int,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::ino_t,
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        __st_dev_padding: ::c_int,
+        __st_ino_truncated: ::c_long,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_rdev_padding: ::c_int,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::ino_t,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        __unused1: ::c_int,
+        pub shm_dtime: ::time_t,
+        __unused2: ::c_int,
+        pub shm_ctime: ::time_t,
+        __unused3: ::c_int,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        __unused1: ::c_int,
+        pub msg_rtime: ::time_t,
+        __unused2: ::c_int,
+        pub msg_ctime: ::time_t,
+        __unused3: ::c_int,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u32,
+        pub f_bfree: u32,
+        pub f_bavail: u32,
+        pub f_files: u32,
+        pub f_ffree: u32,
+        pub f_favail: u32,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct arpd_request {
+        pub req: ::c_ushort,
+        pub ip: u32,
+        pub dev: ::c_ulong,
+        pub stamp: ::c_ulong,
+        pub updated: ::c_ulong,
+        pub ha: [::c_uchar; ::MAX_ADDR_LEN],
+    }
+}
+
+s_no_extra_traits! {
+    pub struct dirent {
+        pub d_ino: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct dirent64 {
+        pub d_ino: ::ino64_t,
+        pub d_off: ::off64_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct sysinfo {
+        pub uptime: ::c_ulong,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub __reserved: [::c_char; 256],
+    }
+
+    pub struct mq_attr {
+        pub mq_flags: ::c_long,
+        pub mq_maxmsg: ::c_long,
+        pub mq_msgsize: ::c_long,
+        pub mq_curmsgs: ::c_long,
+        pad: [::c_long; 4]
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent64 {
+            fn eq(&self, other: &dirent64) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for dirent64 {}
+        impl ::fmt::Debug for dirent64 {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent64")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                    // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for dirent64 {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for sysinfo {
+            fn eq(&self, other: &sysinfo) -> bool {
+                self.uptime == other.uptime
+                    && self.loads == other.loads
+                    && self.totalram == other.totalram
+                    && self.freeram == other.freeram
+                    && self.sharedram == other.sharedram
+                    && self.bufferram == other.bufferram
+                    && self.totalswap == other.totalswap
+                    && self.freeswap == other.freeswap
+                    && self.procs == other.procs
+                    && self.pad == other.pad
+                    && self.totalhigh == other.totalhigh
+                    && self.freehigh == other.freehigh
+                    && self.mem_unit == other.mem_unit
+                    && self
+                    .__reserved
+                    .iter()
+                    .zip(other.__reserved.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sysinfo {}
+        impl ::fmt::Debug for sysinfo {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sysinfo")
+                    .field("uptime", &self.uptime)
+                    .field("loads", &self.loads)
+                    .field("totalram", &self.totalram)
+                    .field("freeram", &self.freeram)
+                    .field("sharedram", &self.sharedram)
+                    .field("bufferram", &self.bufferram)
+                    .field("totalswap", &self.totalswap)
+                    .field("freeswap", &self.freeswap)
+                    .field("procs", &self.procs)
+                    .field("pad", &self.pad)
+                    .field("totalhigh", &self.totalhigh)
+                    .field("freehigh", &self.freehigh)
+                    .field("mem_unit", &self.mem_unit)
+                    // FIXME: .field("__reserved", &self.__reserved)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sysinfo {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uptime.hash(state);
+                self.loads.hash(state);
+                self.totalram.hash(state);
+                self.freeram.hash(state);
+                self.sharedram.hash(state);
+                self.bufferram.hash(state);
+                self.totalswap.hash(state);
+                self.freeswap.hash(state);
+                self.procs.hash(state);
+                self.pad.hash(state);
+                self.totalhigh.hash(state);
+                self.freehigh.hash(state);
+                self.mem_unit.hash(state);
+                self.__reserved.hash(state);
+            }
+        }
+
+        impl PartialEq for mq_attr {
+            fn eq(&self, other: &mq_attr) -> bool {
+                self.mq_flags == other.mq_flags &&
+                self.mq_maxmsg == other.mq_maxmsg &&
+                self.mq_msgsize == other.mq_msgsize &&
+                self.mq_curmsgs == other.mq_curmsgs
+            }
+        }
+        impl Eq for mq_attr {}
+        impl ::fmt::Debug for mq_attr {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("mq_attr")
+                    .field("mq_flags", &self.mq_flags)
+                    .field("mq_maxmsg", &self.mq_maxmsg)
+                    .field("mq_msgsize", &self.mq_msgsize)
+                    .field("mq_curmsgs", &self.mq_curmsgs)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for mq_attr {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.mq_flags.hash(state);
+                self.mq_maxmsg.hash(state);
+                self.mq_msgsize.hash(state);
+                self.mq_curmsgs.hash(state);
+            }
+        }
+    }
+}
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MS_NOUSER: ::c_ulong = 0x80000000;
+pub const MS_RMT_MASK: ::c_ulong = 0x02800051;
+
+pub const ABDAY_1: ::nl_item = 0x20000;
+pub const ABDAY_2: ::nl_item = 0x20001;
+pub const ABDAY_3: ::nl_item = 0x20002;
+pub const ABDAY_4: ::nl_item = 0x20003;
+pub const ABDAY_5: ::nl_item = 0x20004;
+pub const ABDAY_6: ::nl_item = 0x20005;
+pub const ABDAY_7: ::nl_item = 0x20006;
+
+pub const DAY_1: ::nl_item = 0x20007;
+pub const DAY_2: ::nl_item = 0x20008;
+pub const DAY_3: ::nl_item = 0x20009;
+pub const DAY_4: ::nl_item = 0x2000A;
+pub const DAY_5: ::nl_item = 0x2000B;
+pub const DAY_6: ::nl_item = 0x2000C;
+pub const DAY_7: ::nl_item = 0x2000D;
+
+pub const ABMON_1: ::nl_item = 0x2000E;
+pub const ABMON_2: ::nl_item = 0x2000F;
+pub const ABMON_3: ::nl_item = 0x20010;
+pub const ABMON_4: ::nl_item = 0x20011;
+pub const ABMON_5: ::nl_item = 0x20012;
+pub const ABMON_6: ::nl_item = 0x20013;
+pub const ABMON_7: ::nl_item = 0x20014;
+pub const ABMON_8: ::nl_item = 0x20015;
+pub const ABMON_9: ::nl_item = 0x20016;
+pub const ABMON_10: ::nl_item = 0x20017;
+pub const ABMON_11: ::nl_item = 0x20018;
+pub const ABMON_12: ::nl_item = 0x20019;
+
+pub const MON_1: ::nl_item = 0x2001A;
+pub const MON_2: ::nl_item = 0x2001B;
+pub const MON_3: ::nl_item = 0x2001C;
+pub const MON_4: ::nl_item = 0x2001D;
+pub const MON_5: ::nl_item = 0x2001E;
+pub const MON_6: ::nl_item = 0x2001F;
+pub const MON_7: ::nl_item = 0x20020;
+pub const MON_8: ::nl_item = 0x20021;
+pub const MON_9: ::nl_item = 0x20022;
+pub const MON_10: ::nl_item = 0x20023;
+pub const MON_11: ::nl_item = 0x20024;
+pub const MON_12: ::nl_item = 0x20025;
+
+pub const AM_STR: ::nl_item = 0x20026;
+pub const PM_STR: ::nl_item = 0x20027;
+
+pub const D_T_FMT: ::nl_item = 0x20028;
+pub const D_FMT: ::nl_item = 0x20029;
+pub const T_FMT: ::nl_item = 0x2002A;
+pub const T_FMT_AMPM: ::nl_item = 0x2002B;
+
+pub const ERA: ::nl_item = 0x2002C;
+pub const ERA_D_FMT: ::nl_item = 0x2002E;
+pub const ALT_DIGITS: ::nl_item = 0x2002F;
+pub const ERA_D_T_FMT: ::nl_item = 0x20030;
+pub const ERA_T_FMT: ::nl_item = 0x20031;
+
+pub const CODESET: ::nl_item = 14;
+
+pub const CRNCYSTR: ::nl_item = 0x4000F;
+
+pub const RUSAGE_THREAD: ::c_int = 1;
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const RADIXCHAR: ::nl_item = 0x10000;
+pub const THOUSEP: ::nl_item = 0x10001;
+
+pub const YESEXPR: ::nl_item = 0x50000;
+pub const NOEXPR: ::nl_item = 0x50001;
+pub const YESSTR: ::nl_item = 0x50002;
+pub const NOSTR: ::nl_item = 0x50003;
+
+pub const FILENAME_MAX: ::c_uint = 4096;
+pub const L_tmpnam: ::c_uint = 20;
+pub const _PC_LINK_MAX: ::c_int = 0;
+pub const _PC_MAX_CANON: ::c_int = 1;
+pub const _PC_MAX_INPUT: ::c_int = 2;
+pub const _PC_NAME_MAX: ::c_int = 3;
+pub const _PC_PATH_MAX: ::c_int = 4;
+pub const _PC_PIPE_BUF: ::c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 6;
+pub const _PC_NO_TRUNC: ::c_int = 7;
+pub const _PC_VDISABLE: ::c_int = 8;
+pub const _PC_SYNC_IO: ::c_int = 9;
+pub const _PC_ASYNC_IO: ::c_int = 10;
+pub const _PC_PRIO_IO: ::c_int = 11;
+pub const _PC_SOCK_MAXBUF: ::c_int = 12;
+pub const _PC_FILESIZEBITS: ::c_int = 13;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 17;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 18;
+pub const _PC_SYMLINK_MAX: ::c_int = 19;
+pub const _PC_2_SYMLINKS: ::c_int = 20;
+
+pub const _SC_ARG_MAX: ::c_int = 0;
+pub const _SC_CHILD_MAX: ::c_int = 1;
+pub const _SC_CLK_TCK: ::c_int = 2;
+pub const _SC_NGROUPS_MAX: ::c_int = 3;
+pub const _SC_OPEN_MAX: ::c_int = 4;
+pub const _SC_STREAM_MAX: ::c_int = 5;
+pub const _SC_TZNAME_MAX: ::c_int = 6;
+pub const _SC_JOB_CONTROL: ::c_int = 7;
+pub const _SC_SAVED_IDS: ::c_int = 8;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 9;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 10;
+pub const _SC_TIMERS: ::c_int = 11;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 12;
+pub const _SC_PRIORITIZED_IO: ::c_int = 13;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 14;
+pub const _SC_FSYNC: ::c_int = 15;
+pub const _SC_MAPPED_FILES: ::c_int = 16;
+pub const _SC_MEMLOCK: ::c_int = 17;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 18;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 19;
+pub const _SC_MESSAGE_PASSING: ::c_int = 20;
+pub const _SC_SEMAPHORES: ::c_int = 21;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 22;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 23;
+pub const _SC_AIO_MAX: ::c_int = 24;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 25;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 26;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 27;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 28;
+pub const _SC_VERSION: ::c_int = 29;
+pub const _SC_PAGESIZE: ::c_int = 30;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_RTSIG_MAX: ::c_int = 31;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 32;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 33;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 34;
+pub const _SC_TIMER_MAX: ::c_int = 35;
+pub const _SC_BC_BASE_MAX: ::c_int = 36;
+pub const _SC_BC_DIM_MAX: ::c_int = 37;
+pub const _SC_BC_SCALE_MAX: ::c_int = 38;
+pub const _SC_BC_STRING_MAX: ::c_int = 39;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 40;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 42;
+pub const _SC_LINE_MAX: ::c_int = 43;
+pub const _SC_RE_DUP_MAX: ::c_int = 44;
+pub const _SC_2_VERSION: ::c_int = 46;
+pub const _SC_2_C_BIND: ::c_int = 47;
+pub const _SC_2_C_DEV: ::c_int = 48;
+pub const _SC_2_FORT_DEV: ::c_int = 49;
+pub const _SC_2_FORT_RUN: ::c_int = 50;
+pub const _SC_2_SW_DEV: ::c_int = 51;
+pub const _SC_2_LOCALEDEF: ::c_int = 52;
+pub const _SC_UIO_MAXIOV: ::c_int = 60;
+pub const _SC_IOV_MAX: ::c_int = 60;
+pub const _SC_THREADS: ::c_int = 67;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 68;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 69;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 70;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 71;
+pub const _SC_TTY_NAME_MAX: ::c_int = 72;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 73;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 74;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 75;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 79;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 80;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 81;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 82;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 83;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 84;
+pub const _SC_PHYS_PAGES: ::c_int = 85;
+pub const _SC_AVPHYS_PAGES: ::c_int = 86;
+pub const _SC_ATEXIT_MAX: ::c_int = 87;
+pub const _SC_PASS_MAX: ::c_int = 88;
+pub const _SC_XOPEN_VERSION: ::c_int = 89;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 90;
+pub const _SC_XOPEN_UNIX: ::c_int = 91;
+pub const _SC_XOPEN_CRYPT: ::c_int = 92;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 93;
+pub const _SC_XOPEN_SHM: ::c_int = 94;
+pub const _SC_2_CHAR_TERM: ::c_int = 95;
+pub const _SC_2_UPE: ::c_int = 97;
+pub const _SC_XOPEN_XPG2: ::c_int = 98;
+pub const _SC_XOPEN_XPG3: ::c_int = 99;
+pub const _SC_XOPEN_XPG4: ::c_int = 100;
+pub const _SC_NZERO: ::c_int = 109;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 125;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 126;
+pub const _SC_XBS5_LP64_OFF64: ::c_int = 127;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 128;
+pub const _SC_XOPEN_LEGACY: ::c_int = 129;
+pub const _SC_XOPEN_REALTIME: ::c_int = 130;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 131;
+pub const _SC_ADVISORY_INFO: ::c_int = 132;
+pub const _SC_BARRIERS: ::c_int = 133;
+pub const _SC_CLOCK_SELECTION: ::c_int = 137;
+pub const _SC_CPUTIME: ::c_int = 138;
+pub const _SC_THREAD_CPUTIME: ::c_int = 139;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 149;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 153;
+pub const _SC_SPIN_LOCKS: ::c_int = 154;
+pub const _SC_REGEXP: ::c_int = 155;
+pub const _SC_SHELL: ::c_int = 157;
+pub const _SC_SPAWN: ::c_int = 159;
+pub const _SC_SPORADIC_SERVER: ::c_int = 160;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 161;
+pub const _SC_TIMEOUTS: ::c_int = 164;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 165;
+pub const _SC_2_PBS: ::c_int = 168;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 169;
+pub const _SC_2_PBS_LOCATE: ::c_int = 170;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 171;
+pub const _SC_2_PBS_TRACK: ::c_int = 172;
+pub const _SC_SYMLOOP_MAX: ::c_int = 173;
+pub const _SC_STREAMS: ::c_int = 174;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 175;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 176;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 177;
+pub const _SC_V6_LP64_OFF64: ::c_int = 178;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 179;
+pub const _SC_HOST_NAME_MAX: ::c_int = 180;
+pub const _SC_TRACE: ::c_int = 181;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 182;
+pub const _SC_TRACE_INHERIT: ::c_int = 183;
+pub const _SC_TRACE_LOG: ::c_int = 184;
+pub const _SC_IPV6: ::c_int = 235;
+pub const _SC_RAW_SOCKETS: ::c_int = 236;
+pub const _SC_V7_ILP32_OFF32: ::c_int = 237;
+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 238;
+pub const _SC_V7_LP64_OFF64: ::c_int = 239;
+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 240;
+pub const _SC_SS_REPL_MAX: ::c_int = 241;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 242;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 243;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 244;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 245;
+pub const _SC_XOPEN_STREAMS: ::c_int = 246;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 247;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 248;
+
+pub const RLIM_SAVED_MAX: ::rlim_t = RLIM_INFINITY;
+pub const RLIM_SAVED_CUR: ::rlim_t = RLIM_INFINITY;
+
+pub const GLOB_ERR: ::c_int = 1 << 0;
+pub const GLOB_MARK: ::c_int = 1 << 1;
+pub const GLOB_NOSORT: ::c_int = 1 << 2;
+pub const GLOB_DOOFFS: ::c_int = 1 << 3;
+pub const GLOB_NOCHECK: ::c_int = 1 << 4;
+pub const GLOB_APPEND: ::c_int = 1 << 5;
+pub const GLOB_NOESCAPE: ::c_int = 1 << 6;
+
+pub const GLOB_NOSPACE: ::c_int = 1;
+pub const GLOB_ABORTED: ::c_int = 2;
+pub const GLOB_NOMATCH: ::c_int = 3;
+
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+
+pub const S_IEXEC: mode_t = 64;
+pub const S_IWRITE: mode_t = 128;
+pub const S_IREAD: mode_t = 256;
+
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+
+pub const ST_RDONLY: ::c_ulong = 1;
+pub const ST_NOSUID: ::c_ulong = 2;
+pub const ST_NODEV: ::c_ulong = 4;
+pub const ST_NOEXEC: ::c_ulong = 8;
+pub const ST_SYNCHRONOUS: ::c_ulong = 16;
+pub const ST_MANDLOCK: ::c_ulong = 64;
+pub const ST_WRITE: ::c_ulong = 128;
+pub const ST_APPEND: ::c_ulong = 256;
+pub const ST_IMMUTABLE: ::c_ulong = 512;
+pub const ST_NOATIME: ::c_ulong = 1024;
+pub const ST_NODIRATIME: ::c_ulong = 2048;
+
+pub const RTLD_NEXT: *mut ::c_void = -1i64 as *mut ::c_void;
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+pub const RTLD_NODELETE: ::c_int = 0x1000;
+pub const RTLD_NOW: ::c_int = 0x2;
+
+pub const TCP_MD5SIG: ::c_int = 14;
+
+align_const! {
+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+        size: [0; __SIZEOF_PTHREAD_MUTEX_T],
+    };
+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+        size: [0; __SIZEOF_PTHREAD_COND_T],
+    };
+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+        size: [0; __SIZEOF_PTHREAD_RWLOCK_T],
+    };
+}
+
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+pub const PTHREAD_PROCESS_PRIVATE: ::c_int = 0;
+pub const PTHREAD_PROCESS_SHARED: ::c_int = 1;
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+
+pub const SCHED_OTHER: ::c_int = 0;
+pub const SCHED_FIFO: ::c_int = 1;
+pub const SCHED_RR: ::c_int = 2;
+pub const SCHED_BATCH: ::c_int = 3;
+pub const SCHED_IDLE: ::c_int = 5;
+
+pub const AF_IB: ::c_int = 27;
+pub const AF_MPLS: ::c_int = 28;
+pub const AF_NFC: ::c_int = 39;
+pub const AF_VSOCK: ::c_int = 40;
+pub const PF_IB: ::c_int = AF_IB;
+pub const PF_MPLS: ::c_int = AF_MPLS;
+pub const PF_NFC: ::c_int = AF_NFC;
+pub const PF_VSOCK: ::c_int = AF_VSOCK;
+
+// System V IPC
+pub const IPC_PRIVATE: ::key_t = 0;
+
+pub const IPC_CREAT: ::c_int = 0o1000;
+pub const IPC_EXCL: ::c_int = 0o2000;
+pub const IPC_NOWAIT: ::c_int = 0o4000;
+
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+pub const IPC_INFO: ::c_int = 3;
+pub const MSG_STAT: ::c_int = 11;
+pub const MSG_INFO: ::c_int = 12;
+
+pub const MSG_NOERROR: ::c_int = 0o10000;
+pub const MSG_EXCEPT: ::c_int = 0o20000;
+
+pub const SHM_R: ::c_int = 0o400;
+pub const SHM_W: ::c_int = 0o200;
+
+pub const SHM_RDONLY: ::c_int = 0o10000;
+pub const SHM_RND: ::c_int = 0o20000;
+pub const SHM_REMAP: ::c_int = 0o40000;
+pub const SHM_EXEC: ::c_int = 0o100000;
+
+pub const SHM_LOCK: ::c_int = 11;
+pub const SHM_UNLOCK: ::c_int = 12;
+
+pub const SHM_HUGETLB: ::c_int = 0o4000;
+pub const SHM_NORESERVE: ::c_int = 0o10000;
+
+pub const EPOLLRDHUP: ::c_int = 0x2000;
+pub const EPOLLEXCLUSIVE: ::c_int = 0x10000000;
+pub const EPOLLONESHOT: ::c_int = 0x40000000;
+
+pub const QFMT_VFS_OLD: ::c_int = 1;
+pub const QFMT_VFS_V0: ::c_int = 2;
+
+pub const EFD_SEMAPHORE: ::c_int = 0x1;
+
+pub const LOG_NFACILITIES: ::c_int = 24;
+
+pub const SEM_FAILED: *mut ::sem_t = 0 as *mut sem_t;
+
+pub const RB_AUTOBOOT: ::c_int = 0x01234567u32 as i32;
+pub const RB_HALT_SYSTEM: ::c_int = 0xcdef0123u32 as i32;
+pub const RB_ENABLE_CAD: ::c_int = 0x89abcdefu32 as i32;
+pub const RB_DISABLE_CAD: ::c_int = 0x00000000u32 as i32;
+pub const RB_POWER_OFF: ::c_int = 0x4321fedcu32 as i32;
+pub const RB_SW_SUSPEND: ::c_int = 0xd000fce2u32 as i32;
+pub const RB_KEXEC: ::c_int = 0x45584543u32 as i32;
+
+pub const AI_PASSIVE: ::c_int = 0x0001;
+pub const AI_CANONNAME: ::c_int = 0x0002;
+pub const AI_NUMERICHOST: ::c_int = 0x0004;
+pub const AI_V4MAPPED: ::c_int = 0x0008;
+pub const AI_ALL: ::c_int = 0x0010;
+pub const AI_ADDRCONFIG: ::c_int = 0x0020;
+
+pub const AI_NUMERICSERV: ::c_int = 0x0400;
+
+pub const EAI_BADFLAGS: ::c_int = -1;
+pub const EAI_NONAME: ::c_int = -2;
+pub const EAI_AGAIN: ::c_int = -3;
+pub const EAI_FAIL: ::c_int = -4;
+pub const EAI_FAMILY: ::c_int = -6;
+pub const EAI_SOCKTYPE: ::c_int = -7;
+pub const EAI_SERVICE: ::c_int = -8;
+pub const EAI_MEMORY: ::c_int = -10;
+pub const EAI_OVERFLOW: ::c_int = -12;
+
+pub const NI_NUMERICHOST: ::c_int = 1;
+pub const NI_NUMERICSERV: ::c_int = 2;
+pub const NI_NOFQDN: ::c_int = 4;
+pub const NI_NAMEREQD: ::c_int = 8;
+pub const NI_DGRAM: ::c_int = 16;
+
+pub const SYNC_FILE_RANGE_WAIT_BEFORE: ::c_uint = 1;
+pub const SYNC_FILE_RANGE_WRITE: ::c_uint = 2;
+pub const SYNC_FILE_RANGE_WAIT_AFTER: ::c_uint = 4;
+
+pub const EAI_SYSTEM: ::c_int = -11;
+
+pub const AIO_CANCELED: ::c_int = 0;
+pub const AIO_NOTCANCELED: ::c_int = 1;
+pub const AIO_ALLDONE: ::c_int = 2;
+pub const LIO_READ: ::c_int = 0;
+pub const LIO_WRITE: ::c_int = 1;
+pub const LIO_NOP: ::c_int = 2;
+pub const LIO_WAIT: ::c_int = 0;
+pub const LIO_NOWAIT: ::c_int = 1;
+
+pub const MREMAP_MAYMOVE: ::c_int = 1;
+pub const MREMAP_FIXED: ::c_int = 2;
+
+pub const PR_SET_PDEATHSIG: ::c_int = 1;
+pub const PR_GET_PDEATHSIG: ::c_int = 2;
+
+pub const PR_GET_DUMPABLE: ::c_int = 3;
+pub const PR_SET_DUMPABLE: ::c_int = 4;
+
+pub const PR_GET_UNALIGN: ::c_int = 5;
+pub const PR_SET_UNALIGN: ::c_int = 6;
+pub const PR_UNALIGN_NOPRINT: ::c_int = 1;
+pub const PR_UNALIGN_SIGBUS: ::c_int = 2;
+
+pub const PR_GET_KEEPCAPS: ::c_int = 7;
+pub const PR_SET_KEEPCAPS: ::c_int = 8;
+
+pub const PR_GET_FPEMU: ::c_int = 9;
+pub const PR_SET_FPEMU: ::c_int = 10;
+pub const PR_FPEMU_NOPRINT: ::c_int = 1;
+pub const PR_FPEMU_SIGFPE: ::c_int = 2;
+
+pub const PR_GET_FPEXC: ::c_int = 11;
+pub const PR_SET_FPEXC: ::c_int = 12;
+pub const PR_FP_EXC_SW_ENABLE: ::c_int = 0x80;
+pub const PR_FP_EXC_DIV: ::c_int = 0x010000;
+pub const PR_FP_EXC_OVF: ::c_int = 0x020000;
+pub const PR_FP_EXC_UND: ::c_int = 0x040000;
+pub const PR_FP_EXC_RES: ::c_int = 0x080000;
+pub const PR_FP_EXC_INV: ::c_int = 0x100000;
+pub const PR_FP_EXC_DISABLED: ::c_int = 0;
+pub const PR_FP_EXC_NONRECOV: ::c_int = 1;
+pub const PR_FP_EXC_ASYNC: ::c_int = 2;
+pub const PR_FP_EXC_PRECISE: ::c_int = 3;
+
+pub const PR_GET_TIMING: ::c_int = 13;
+pub const PR_SET_TIMING: ::c_int = 14;
+pub const PR_TIMING_STATISTICAL: ::c_int = 0;
+pub const PR_TIMING_TIMESTAMP: ::c_int = 1;
+
+pub const PR_SET_NAME: ::c_int = 15;
+pub const PR_GET_NAME: ::c_int = 16;
+
+pub const PR_GET_ENDIAN: ::c_int = 19;
+pub const PR_SET_ENDIAN: ::c_int = 20;
+pub const PR_ENDIAN_BIG: ::c_int = 0;
+pub const PR_ENDIAN_LITTLE: ::c_int = 1;
+pub const PR_ENDIAN_PPC_LITTLE: ::c_int = 2;
+
+pub const PR_GET_SECCOMP: ::c_int = 21;
+pub const PR_SET_SECCOMP: ::c_int = 22;
+
+pub const PR_CAPBSET_READ: ::c_int = 23;
+pub const PR_CAPBSET_DROP: ::c_int = 24;
+
+pub const PR_GET_TSC: ::c_int = 25;
+pub const PR_SET_TSC: ::c_int = 26;
+pub const PR_TSC_ENABLE: ::c_int = 1;
+pub const PR_TSC_SIGSEGV: ::c_int = 2;
+
+pub const PR_GET_SECUREBITS: ::c_int = 27;
+pub const PR_SET_SECUREBITS: ::c_int = 28;
+
+pub const PR_SET_TIMERSLACK: ::c_int = 29;
+pub const PR_GET_TIMERSLACK: ::c_int = 30;
+
+pub const PR_TASK_PERF_EVENTS_DISABLE: ::c_int = 31;
+pub const PR_TASK_PERF_EVENTS_ENABLE: ::c_int = 32;
+
+pub const PR_MCE_KILL: ::c_int = 33;
+pub const PR_MCE_KILL_CLEAR: ::c_int = 0;
+pub const PR_MCE_KILL_SET: ::c_int = 1;
+
+pub const PR_MCE_KILL_LATE: ::c_int = 0;
+pub const PR_MCE_KILL_EARLY: ::c_int = 1;
+pub const PR_MCE_KILL_DEFAULT: ::c_int = 2;
+
+pub const PR_MCE_KILL_GET: ::c_int = 34;
+
+pub const PR_SET_MM: ::c_int = 35;
+pub const PR_SET_MM_START_CODE: ::c_int = 1;
+pub const PR_SET_MM_END_CODE: ::c_int = 2;
+pub const PR_SET_MM_START_DATA: ::c_int = 3;
+pub const PR_SET_MM_END_DATA: ::c_int = 4;
+pub const PR_SET_MM_START_STACK: ::c_int = 5;
+pub const PR_SET_MM_START_BRK: ::c_int = 6;
+pub const PR_SET_MM_BRK: ::c_int = 7;
+pub const PR_SET_MM_ARG_START: ::c_int = 8;
+pub const PR_SET_MM_ARG_END: ::c_int = 9;
+pub const PR_SET_MM_ENV_START: ::c_int = 10;
+pub const PR_SET_MM_ENV_END: ::c_int = 11;
+pub const PR_SET_MM_AUXV: ::c_int = 12;
+pub const PR_SET_MM_EXE_FILE: ::c_int = 13;
+pub const PR_SET_MM_MAP: ::c_int = 14;
+pub const PR_SET_MM_MAP_SIZE: ::c_int = 15;
+
+pub const PR_SET_PTRACER: ::c_int = 0x59616d61;
+
+pub const PR_SET_CHILD_SUBREAPER: ::c_int = 36;
+pub const PR_GET_CHILD_SUBREAPER: ::c_int = 37;
+
+pub const PR_SET_NO_NEW_PRIVS: ::c_int = 38;
+pub const PR_GET_NO_NEW_PRIVS: ::c_int = 39;
+
+pub const PR_GET_TID_ADDRESS: ::c_int = 40;
+
+pub const PR_SET_THP_DISABLE: ::c_int = 41;
+pub const PR_GET_THP_DISABLE: ::c_int = 42;
+
+pub const PR_MPX_ENABLE_MANAGEMENT: ::c_int = 43;
+pub const PR_MPX_DISABLE_MANAGEMENT: ::c_int = 44;
+
+pub const PR_SET_FP_MODE: ::c_int = 45;
+pub const PR_GET_FP_MODE: ::c_int = 46;
+pub const PR_FP_MODE_FR: ::c_int = 1 << 0;
+pub const PR_FP_MODE_FRE: ::c_int = 1 << 1;
+
+pub const PR_CAP_AMBIENT: ::c_int = 47;
+pub const PR_CAP_AMBIENT_IS_SET: ::c_int = 1;
+pub const PR_CAP_AMBIENT_RAISE: ::c_int = 2;
+pub const PR_CAP_AMBIENT_LOWER: ::c_int = 3;
+pub const PR_CAP_AMBIENT_CLEAR_ALL: ::c_int = 4;
+
+pub const ITIMER_REAL: ::c_int = 0;
+pub const ITIMER_VIRTUAL: ::c_int = 1;
+pub const ITIMER_PROF: ::c_int = 2;
+
+pub const XATTR_CREATE: ::c_int = 0x1;
+pub const XATTR_REPLACE: ::c_int = 0x2;
+
+pub const _POSIX_VDISABLE: ::cc_t = 0;
+
+pub const FALLOC_FL_KEEP_SIZE: ::c_int = 0x01;
+pub const FALLOC_FL_PUNCH_HOLE: ::c_int = 0x02;
+
+// On Linux, libc doesn't define this constant, libattr does instead.
+// We still define it for Linux as it's defined by libc on other platforms,
+// and it's mentioned in the man pages for getxattr and setxattr.
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 512;
+pub const O_NOATIME: ::c_int = 0o1000000;
+pub const O_CLOEXEC: ::c_int = 0x80000;
+
+// Defined as wasi value.
+pub const EPERM: ::c_int = 63;
+pub const ENOENT: ::c_int = 44;
+pub const ESRCH: ::c_int = 71;
+pub const EINTR: ::c_int = 27;
+pub const EIO: ::c_int = 29;
+pub const ENXIO: ::c_int = 60;
+pub const E2BIG: ::c_int = 1;
+pub const ENOEXEC: ::c_int = 45;
+pub const EBADF: ::c_int = 8;
+pub const ECHILD: ::c_int = 12;
+pub const EAGAIN: ::c_int = 6;
+pub const ENOMEM: ::c_int = 48;
+pub const EACCES: ::c_int = 2;
+pub const EFAULT: ::c_int = 21;
+pub const ENOTBLK: ::c_int = 105;
+pub const EBUSY: ::c_int = 10;
+pub const EEXIST: ::c_int = 20;
+pub const EXDEV: ::c_int = 75;
+pub const ENODEV: ::c_int = 43;
+pub const ENOTDIR: ::c_int = 54;
+pub const EISDIR: ::c_int = 31;
+pub const EINVAL: ::c_int = 28;
+pub const ENFILE: ::c_int = 41;
+pub const EMFILE: ::c_int = 33;
+pub const ENOTTY: ::c_int = 59;
+pub const ETXTBSY: ::c_int = 74;
+pub const EFBIG: ::c_int = 22;
+pub const ENOSPC: ::c_int = 51;
+pub const ESPIPE: ::c_int = 70;
+pub const EROFS: ::c_int = 69;
+pub const EMLINK: ::c_int = 34;
+pub const EPIPE: ::c_int = 64;
+pub const EDOM: ::c_int = 18;
+pub const ERANGE: ::c_int = 68;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+pub const ENOLINK: ::c_int = 47;
+pub const EPROTO: ::c_int = 65;
+pub const EDEADLK: ::c_int = 16;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const ENAMETOOLONG: ::c_int = 37;
+pub const ENOLCK: ::c_int = 46;
+pub const ENOSYS: ::c_int = 52;
+pub const ENOTEMPTY: ::c_int = 55;
+pub const ELOOP: ::c_int = 32;
+pub const ENOMSG: ::c_int = 49;
+pub const EIDRM: ::c_int = 24;
+pub const EMULTIHOP: ::c_int = 36;
+pub const EBADMSG: ::c_int = 9;
+pub const EOVERFLOW: ::c_int = 61;
+pub const EILSEQ: ::c_int = 25;
+pub const ENOTSOCK: ::c_int = 57;
+pub const EDESTADDRREQ: ::c_int = 17;
+pub const EMSGSIZE: ::c_int = 35;
+pub const EPROTOTYPE: ::c_int = 67;
+pub const ENOPROTOOPT: ::c_int = 50;
+pub const EPROTONOSUPPORT: ::c_int = 66;
+pub const EAFNOSUPPORT: ::c_int = 5;
+pub const EADDRINUSE: ::c_int = 3;
+pub const EADDRNOTAVAIL: ::c_int = 4;
+pub const ENETDOWN: ::c_int = 38;
+pub const ENETUNREACH: ::c_int = 40;
+pub const ENETRESET: ::c_int = 39;
+pub const ECONNABORTED: ::c_int = 13;
+pub const ECONNRESET: ::c_int = 15;
+pub const ENOBUFS: ::c_int = 42;
+pub const EISCONN: ::c_int = 30;
+pub const ENOTCONN: ::c_int = 53;
+pub const ETIMEDOUT: ::c_int = 73;
+pub const ECONNREFUSED: ::c_int = 14;
+pub const EHOSTUNREACH: ::c_int = 23;
+pub const EALREADY: ::c_int = 7;
+pub const EINPROGRESS: ::c_int = 26;
+pub const ESTALE: ::c_int = 72;
+pub const EDQUOT: ::c_int = 19;
+pub const ECANCELED: ::c_int = 11;
+pub const EOWNERDEAD: ::c_int = 62;
+pub const ENOTRECOVERABLE: ::c_int = 56;
+
+pub const ENOSTR: ::c_int = 100;
+pub const EBFONT: ::c_int = 101;
+pub const EBADSLT: ::c_int = 102;
+pub const EBADRQC: ::c_int = 103;
+pub const ENOANO: ::c_int = 104;
+pub const ECHRNG: ::c_int = 106;
+pub const EL3HLT: ::c_int = 107;
+pub const EL3RST: ::c_int = 108;
+pub const ELNRNG: ::c_int = 109;
+pub const EUNATCH: ::c_int = 110;
+pub const ENOCSI: ::c_int = 111;
+pub const EL2HLT: ::c_int = 112;
+pub const EBADE: ::c_int = 113;
+pub const EBADR: ::c_int = 114;
+pub const EXFULL: ::c_int = 115;
+pub const ENODATA: ::c_int = 116;
+pub const ETIME: ::c_int = 117;
+pub const ENOSR: ::c_int = 118;
+pub const ENONET: ::c_int = 119;
+pub const ENOPKG: ::c_int = 120;
+pub const EREMOTE: ::c_int = 121;
+pub const EADV: ::c_int = 122;
+pub const ESRMNT: ::c_int = 123;
+pub const ECOMM: ::c_int = 124;
+pub const EDOTDOT: ::c_int = 125;
+pub const ENOTUNIQ: ::c_int = 126;
+pub const EBADFD: ::c_int = 127;
+pub const EREMCHG: ::c_int = 128;
+pub const ELIBACC: ::c_int = 129;
+pub const ELIBBAD: ::c_int = 130;
+pub const ELIBSCN: ::c_int = 131;
+pub const ELIBMAX: ::c_int = 132;
+pub const ELIBEXEC: ::c_int = 133;
+pub const ERESTART: ::c_int = 134;
+pub const ESTRPIPE: ::c_int = 135;
+pub const EUSERS: ::c_int = 136;
+pub const ESOCKTNOSUPPORT: ::c_int = 137;
+pub const EOPNOTSUPP: ::c_int = 138;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 139;
+pub const ESHUTDOWN: ::c_int = 140;
+pub const ETOOMANYREFS: ::c_int = 141;
+pub const EHOSTDOWN: ::c_int = 142;
+pub const EUCLEAN: ::c_int = 143;
+pub const ENOTNAM: ::c_int = 144;
+pub const ENAVAIL: ::c_int = 145;
+pub const EISNAM: ::c_int = 146;
+pub const EREMOTEIO: ::c_int = 147;
+pub const ENOMEDIUM: ::c_int = 148;
+pub const EMEDIUMTYPE: ::c_int = 149;
+pub const ENOKEY: ::c_int = 150;
+pub const EKEYEXPIRED: ::c_int = 151;
+pub const EKEYREVOKED: ::c_int = 152;
+pub const EKEYREJECTED: ::c_int = 153;
+pub const ERFKILL: ::c_int = 154;
+pub const EHWPOISON: ::c_int = 155;
+pub const EL2NSYNC: ::c_int = 156;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const BUFSIZ: ::c_uint = 1024;
+pub const TMP_MAX: ::c_uint = 10000;
+pub const FOPEN_MAX: ::c_uint = 1000;
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_EXEC: ::c_int = 0o10000000;
+pub const O_SEARCH: ::c_int = 0o10000000;
+pub const O_ACCMODE: ::c_int = 0o10000003;
+pub const O_NDELAY: ::c_int = O_NONBLOCK;
+pub const NI_MAXHOST: ::socklen_t = 255;
+pub const PTHREAD_STACK_MIN: ::size_t = 2048;
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const POSIX_MADV_DONTNEED: ::c_int = 0;
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+
+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;
+
+pub const TCP_THIN_LINEAR_TIMEOUTS: ::c_int = 16;
+pub const TCP_THIN_DUPACK: ::c_int = 17;
+pub const TCP_USER_TIMEOUT: ::c_int = 18;
+pub const TCP_REPAIR: ::c_int = 19;
+pub const TCP_REPAIR_QUEUE: ::c_int = 20;
+pub const TCP_QUEUE_SEQ: ::c_int = 21;
+pub const TCP_REPAIR_OPTIONS: ::c_int = 22;
+pub const TCP_FASTOPEN: ::c_int = 23;
+pub const TCP_TIMESTAMP: ::c_int = 24;
+
+#[doc(hidden)]
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = ::SIGSYS;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+
+pub const CPU_SETSIZE: ::c_int = 128;
+
+pub const QFMT_VFS_V1: ::c_int = 4;
+
+pub const PTRACE_TRACEME: ::c_int = 0;
+pub const PTRACE_PEEKTEXT: ::c_int = 1;
+pub const PTRACE_PEEKDATA: ::c_int = 2;
+pub const PTRACE_PEEKUSER: ::c_int = 3;
+pub const PTRACE_POKETEXT: ::c_int = 4;
+pub const PTRACE_POKEDATA: ::c_int = 5;
+pub const PTRACE_POKEUSER: ::c_int = 6;
+pub const PTRACE_CONT: ::c_int = 7;
+pub const PTRACE_KILL: ::c_int = 8;
+pub const PTRACE_SINGLESTEP: ::c_int = 9;
+pub const PTRACE_ATTACH: ::c_int = 16;
+pub const PTRACE_DETACH: ::c_int = 17;
+pub const PTRACE_SYSCALL: ::c_int = 24;
+pub const PTRACE_SETOPTIONS: ::c_int = 0x4200;
+pub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;
+pub const PTRACE_GETSIGINFO: ::c_int = 0x4202;
+pub const PTRACE_SETSIGINFO: ::c_int = 0x4203;
+pub const PTRACE_GETREGSET: ::c_int = 0x4204;
+pub const PTRACE_SETREGSET: ::c_int = 0x4205;
+pub const PTRACE_SEIZE: ::c_int = 0x4206;
+pub const PTRACE_INTERRUPT: ::c_int = 0x4207;
+pub const PTRACE_LISTEN: ::c_int = 0x4208;
+pub const PTRACE_PEEKSIGINFO: ::c_int = 0x4209;
+
+pub const EPOLLWAKEUP: ::c_int = 0x20000000;
+
+pub const PTRACE_GETFPREGS: ::c_uint = 14;
+pub const PTRACE_SETFPREGS: ::c_uint = 15;
+pub const PTRACE_GETFPXREGS: ::c_uint = 18;
+pub const PTRACE_SETFPXREGS: ::c_uint = 19;
+pub const PTRACE_GETREGS: ::c_uint = 12;
+pub const PTRACE_SETREGS: ::c_uint = 13;
+
+pub const EFD_NONBLOCK: ::c_int = ::O_NONBLOCK;
+
+pub const SFD_NONBLOCK: ::c_int = ::O_NONBLOCK;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCINQ: ::c_int = ::FIONREAD;
+
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+
+pub const CLOCK_SGI_CYCLE: ::clockid_t = 10;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::c_int = 0x00000800;
+pub const TAB2: ::c_int = 0x00001000;
+pub const TAB3: ::c_int = 0x00001800;
+pub const CR1: ::c_int = 0x00000200;
+pub const CR2: ::c_int = 0x00000400;
+pub const CR3: ::c_int = 0x00000600;
+pub const FF1: ::c_int = 0x00008000;
+pub const BS1: ::c_int = 0x00002000;
+pub const VT1: ::c_int = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_BUSY_POLL: ::c_int = 46;
+
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 28;
+
+pub const O_DIRECT: ::c_int = 0x4000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+pub const O_ASYNC: ::c_int = 0x2000;
+
+pub const FIOCLEX: ::c_int = 0x5451;
+pub const FIONBIO: ::c_int = 0x5421;
+
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_LOCKS: ::c_int = 10;
+pub const RLIMIT_SIGPENDING: ::c_int = 11;
+pub const RLIMIT_MSGQUEUE: ::c_int = 12;
+pub const RLIMIT_NICE: ::c_int = 13;
+pub const RLIMIT_RTPRIO: ::c_int = 14;
+
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+
+pub const SOCK_NONBLOCK: ::c_int = 2048;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+pub const IPPROTO_MAX: ::c_int = 256;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+
+pub const IPV6_RTHDR_LOOSE: ::c_int = 0;
+pub const IPV6_RTHDR_STRICT: ::c_int = 1;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+
+pub const F_GETLK: ::c_int = 12;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETLK: ::c_int = 13;
+pub const F_SETLKW: ::c_int = 14;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const VEOF: usize = 4;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+
+pub const TCGETS: ::c_int = 0x5401;
+pub const TCSETS: ::c_int = 0x5402;
+pub const TCSETSW: ::c_int = 0x5403;
+pub const TCSETSF: ::c_int = 0x5404;
+pub const TCGETA: ::c_int = 0x5405;
+pub const TCSETA: ::c_int = 0x5406;
+pub const TCSETAW: ::c_int = 0x5407;
+pub const TCSETAF: ::c_int = 0x5408;
+pub const TCSBRK: ::c_int = 0x5409;
+pub const TCXONC: ::c_int = 0x540A;
+pub const TCFLSH: ::c_int = 0x540B;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x540F;
+pub const TIOCSPGRP: ::c_int = 0x5410;
+pub const TIOCOUTQ: ::c_int = 0x5411;
+pub const TIOCSTI: ::c_int = 0x5412;
+pub const TIOCGWINSZ: ::c_int = 0x5413;
+pub const TIOCSWINSZ: ::c_int = 0x5414;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x541B;
+pub const TIOCCONS: ::c_int = 0x541D;
+
+pub const SYS_gettid: ::c_long = 224; // Valid for arm (32-bit) and x86 (32-bit)
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+pub const O_TMPFILE: ::c_int = 0x400000;
+
+pub const MAX_ADDR_LEN: usize = 7;
+pub const ARPD_UPDATE: ::c_ushort = 0x01;
+pub const ARPD_LOOKUP: ::c_ushort = 0x02;
+pub const ARPD_FLUSH: ::c_ushort = 0x03;
+pub const ATF_MAGIC: ::c_int = 0x80;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+f! {
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr,
+                       cmsg: *const cmsghdr) -> *mut cmsghdr {
+        if ((*cmsg).cmsg_len as usize) < ::mem::size_of::<cmsghdr>() {
+            return 0 as *mut cmsghdr;
+        };
+        let next = (cmsg as usize +
+                    super::CMSG_ALIGN((*cmsg).cmsg_len as usize))
+            as *mut cmsghdr;
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if (next.offset(1)) as usize > max {
+            0 as *mut cmsghdr
+        } else {
+            next as *mut cmsghdr
+        }
+    }
+
+    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {
+        for slot in cpuset.bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+
+    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits
+            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] |= 1 << offset;
+        ()
+    }
+
+    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits
+            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] &= !(1 << offset);
+        ()
+    }
+
+    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {
+        let size_in_bits = 8 * ::mem::size_of_val(&cpuset.bits[0]);
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        0 != (cpuset.bits[idx] & (1 << offset))
+    }
+
+    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {
+        set1.bits == set2.bits
+    }
+
+    pub fn major(dev: ::dev_t) -> ::c_uint {
+        // see
+        // https://github.com/emscripten-core/emscripten/blob/
+        // master/system/include/libc/sys/sysmacros.h
+        let mut major = 0;
+        major |= (dev & 0x00000fff) >> 8;
+        major |= (dev & 0xfffff000) >> 31 >> 1;
+        major as ::c_uint
+    }
+
+    pub fn minor(dev: ::dev_t) -> ::c_uint {
+        // see
+        // https://github.com/emscripten-core/emscripten/blob/
+        // master/system/include/libc/sys/sysmacros.h
+        let mut minor = 0;
+        minor |= (dev & 0x000000ff) >> 0;
+        minor |= (dev & 0xffffff00) >> 12;
+        minor as ::c_uint
+    }
+
+    pub fn makedev(major: ::c_uint, minor: ::c_uint) -> ::dev_t {
+        let major = major as ::dev_t;
+        let minor = minor as ::dev_t;
+        let mut dev = 0;
+        dev |= (major & 0x00000fff) << 8;
+        dev |= (major & 0xfffff000) << 31 << 1;
+        dev |= (minor & 0x000000ff) << 0;
+        dev |= (minor & 0xffffff00) << 12;
+        dev
+    }
+}
+
+extern "C" {
+    pub fn getrlimit64(resource: ::c_int, rlim: *mut rlimit64) -> ::c_int;
+    pub fn setrlimit64(resource: ::c_int, rlim: *const rlimit64) -> ::c_int;
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn abs(i: ::c_int) -> ::c_int;
+    pub fn atof(s: *const ::c_char) -> ::c_double;
+    pub fn labs(i: ::c_long) -> ::c_long;
+    pub fn rand() -> ::c_int;
+    pub fn srand(seed: ::c_uint);
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+
+    pub fn setpwent();
+    pub fn endpwent();
+    pub fn getpwent() -> *mut passwd;
+
+    pub fn shm_open(
+        name: *const c_char,
+        oflag: ::c_int,
+        mode: mode_t,
+    ) -> ::c_int;
+
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn __errno_location() -> *mut ::c_int;
+
+    pub fn fopen64(
+        filename: *const c_char,
+        mode: *const c_char,
+    ) -> *mut ::FILE;
+    pub fn freopen64(
+        filename: *const c_char,
+        mode: *const c_char,
+        file: *mut ::FILE,
+    ) -> *mut ::FILE;
+    pub fn tmpfile64() -> *mut ::FILE;
+    pub fn fgetpos64(stream: *mut ::FILE, ptr: *mut fpos64_t) -> ::c_int;
+    pub fn fsetpos64(stream: *mut ::FILE, ptr: *const fpos64_t) -> ::c_int;
+    pub fn fseeko64(
+        stream: *mut ::FILE,
+        offset: ::off64_t,
+        whence: ::c_int,
+    ) -> ::c_int;
+    pub fn ftello64(stream: *mut ::FILE) -> ::off64_t;
+    pub fn posix_fallocate(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn dup3(oldfd: ::c_int, newfd: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn mkostemps(
+        template: *mut ::c_char,
+        suffixlen: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn nl_langinfo_l(item: ::nl_item, locale: ::locale_t)
+        -> *mut ::c_char;
+    pub fn accept4(
+        fd: ::c_int,
+        addr: *mut ::sockaddr,
+        len: *mut ::socklen_t,
+        flg: ::c_int,
+    ) -> ::c_int;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::socklen_t,
+        serv: *mut ::c_char,
+        sevlen: ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn getloadavg(loadavg: *mut ::c_double, nelem: ::c_int) -> ::c_int;
+
+    // Not available now on Android
+    pub fn mkfifoat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn if_nameindex() -> *mut if_nameindex;
+    pub fn if_freenameindex(ptr: *mut if_nameindex);
+
+    pub fn mremap(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        new_len: ::size_t,
+        flags: ::c_int,
+        ...
+    ) -> *mut ::c_void;
+
+    pub fn glob(
+        pattern: *const c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut ::glob_t,
+    ) -> ::c_int;
+    pub fn globfree(pglob: *mut ::glob_t);
+
+    pub fn posix_madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;
+
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+    pub fn madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;
+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;
+
+    pub fn getdomainname(name: *mut ::c_char, len: ::size_t) -> ::c_int;
+    pub fn setdomainname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn sendmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_uint,
+    ) -> ::c_int;
+    pub fn recvmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_uint,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn sync();
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+    pub fn getpriority(which: ::c_int, who: ::id_t) -> ::c_int;
+    pub fn setpriority(which: ::c_int, who: ::id_t, prio: ::c_int) -> ::c_int;
+    pub fn pthread_create(
+        native: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        f: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        #[macro_use]
+        mod align;
+    } else {
+        #[macro_use]
+        mod no_align;
+    }
+}
+expand_align!();
diff --git a/library/libc/src/unix/linux_like/emscripten/no_align.rs b/library/libc/src/unix/linux_like/emscripten/no_align.rs
new file mode 100644
index 00000000..768dc73a
--- /dev/null
+++ b/library/libc/src/unix/linux_like/emscripten/no_align.rs
@@ -0,0 +1,63 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            pub struct pthread_mutex_t {
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            pub struct pthread_rwlock_t {
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+
+            pub struct pthread_mutexattr_t {
+                __align: [::c_int; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            pub struct pthread_rwlockattr_t {
+                __align: [::c_int; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],
+            }
+
+            pub struct pthread_condattr_t {
+                __align: [::c_int; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+
+        s_no_extra_traits! {
+            pub struct pthread_cond_t {
+                __align: [*const ::c_void; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+        }
+
+        cfg_if! {
+            if #[cfg(feature = "extra_traits")] {
+                impl PartialEq for pthread_cond_t {
+                    fn eq(&self, other: &pthread_cond_t) -> bool {
+                        self.size
+                            .iter()
+                            .zip(other.size.iter())
+                            .all(|(a,b)| a == b)
+                    }
+                }
+                impl Eq for pthread_cond_t {}
+                impl ::fmt::Debug for pthread_cond_t {
+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                        f.debug_struct("pthread_cond_t")
+                            // FIXME: .field("size", &self.size)
+                            .finish()
+                    }
+                }
+                impl ::hash::Hash for pthread_cond_t {
+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                        self.size.hash(state);
+                    }
+                }
+            }
+        }
+    };
+}
diff --git a/library/libc/src/unix/linux_like/linux/align.rs b/library/libc/src/unix/linux_like/linux/align.rs
new file mode 100644
index 00000000..c3d7850d
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/align.rs
@@ -0,0 +1,150 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            #[cfg_attr(any(target_pointer_width = "32",
+                           target_arch = "x86_64",
+                           target_arch = "llir_x86_64",
+                           target_arch = "powerpc64",
+                           target_arch = "mips64",
+                           target_arch = "s390x",
+                           target_arch = "sparc64",
+                           target_arch = "aarch64",
+                           target_arch = "riscv64",
+                           target_arch = "riscv32"),
+                       repr(align(4)))]
+            #[cfg_attr(not(any(target_pointer_width = "32",
+                               target_arch = "x86_64",
+                               target_arch = "llir_x86_64",
+                               target_arch = "powerpc64",
+                               target_arch = "mips64",
+                               target_arch = "s390x",
+                               target_arch = "sparc64",
+                               target_arch = "aarch64",
+                               target_arch = "riscv64",
+                               target_arch = "riscv32")),
+                       repr(align(8)))]
+            pub struct pthread_mutexattr_t {
+                #[doc(hidden)]
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            #[cfg_attr(any(target_env = "musl", target_pointer_width = "32"),
+                       repr(align(4)))]
+            #[cfg_attr(all(not(target_env = "musl"),
+                           target_pointer_width = "64"),
+                       repr(align(8)))]
+            pub struct pthread_rwlockattr_t {
+                #[doc(hidden)]
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_condattr_t {
+                #[doc(hidden)]
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+
+            #[repr(align(8))]
+            pub struct fanotify_event_metadata {
+                pub event_len: __u32,
+                pub vers: __u8,
+                pub reserved: __u8,
+                pub metadata_len: __u16,
+                pub mask: __u64,
+                pub fd: ::c_int,
+                pub pid: ::c_int,
+            }
+        }
+
+        s_no_extra_traits! {
+            #[cfg_attr(all(target_env = "musl",
+                           target_pointer_width = "32"),
+                       repr(align(4)))]
+            #[cfg_attr(all(target_env = "musl",
+                           target_pointer_width = "64"),
+                       repr(align(8)))]
+            #[cfg_attr(all(not(target_env = "musl"),
+                           target_arch = "x86"),
+                       repr(align(4)))]
+            #[cfg_attr(all(not(target_env = "musl"),
+                           not(target_arch = "x86")),
+                       repr(align(8)))]
+            pub struct pthread_cond_t {
+                #[doc(hidden)]
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "mips",
+                               target_arch = "arm",
+                               target_arch = "hexagon",
+                               target_arch = "powerpc",
+                               target_arch = "sparc",
+                               target_arch = "x86_64",
+                               target_arch = "llir_x86_64",
+                               target_arch = "x86")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "mips",
+                                   target_arch = "arm",
+                                   target_arch = "hexagon",
+                                   target_arch = "powerpc",
+                                   target_arch = "sparc",
+                                   target_arch = "x86_64",
+                                   target_arch = "llir_x86_64",
+                                   target_arch = "x86"))),
+                       repr(align(8)))]
+            pub struct pthread_mutex_t {
+                #[doc(hidden)]
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "mips",
+                               target_arch = "arm",
+                               target_arch = "hexagon",
+                               target_arch = "powerpc",
+                               target_arch = "sparc",
+                               target_arch = "x86_64",
+                               target_arch = "llir_x86_64",
+                               target_arch = "x86")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "mips",
+                                   target_arch = "arm",
+                                   target_arch = "hexagon",
+                                   target_arch = "powerpc",
+                                   target_arch = "sparc",
+                                   target_arch = "x86_64",
+                                   target_arch = "llir_x86_64",
+                                   target_arch = "x86"))),
+                       repr(align(8)))]
+            pub struct pthread_rwlock_t {
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+
+            // linux/can.h
+            #[repr(align(8))]
+            #[allow(missing_debug_implementations)]
+            pub struct can_frame {
+                pub can_id: canid_t,
+                pub can_dlc: u8,
+                __pad: u8,
+                __res0: u8,
+                __res1: u8,
+                pub data: [u8; CAN_MAX_DLEN],
+            }
+
+            #[repr(align(8))]
+            #[allow(missing_debug_implementations)]
+            pub struct canfd_frame {
+                pub can_id: canid_t,
+                pub len: u8,
+                pub flags: u8,
+                __res0: u8,
+                __res1: u8,
+                pub data: [u8; CANFD_MAX_DLEN],
+            }
+        }
+    };
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/align.rs b/library/libc/src/unix/linux_like/linux/gnu/align.rs
new file mode 100644
index 00000000..4a0e0746
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/align.rs
@@ -0,0 +1,13 @@
+s! {
+    // FIXME this is actually a union
+    #[cfg_attr(target_pointer_width = "32",
+               repr(align(4)))]
+    #[cfg_attr(target_pointer_width = "64",
+               repr(align(8)))]
+    pub struct sem_t {
+        #[cfg(target_pointer_width = "32")]
+        __size: [::c_char; 16],
+        #[cfg(target_pointer_width = "64")]
+        __size: [::c_char; 32],
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/arm/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/arm/align.rs
new file mode 100644
index 00000000..825546be
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/arm/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(8))]
+    pub struct max_align_t {
+        priv_: [i64; 2]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/arm/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/arm/mod.rs
new file mode 100644
index 00000000..d084450b
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/arm/mod.rs
@@ -0,0 +1,879 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statfs {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        f_spare: [::__fsword_t; 5],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_ushort,
+        __pad1: ::c_ushort,
+        pub __seq: ::c_ushort,
+        __pad2: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        __pad1: ::c_uint,
+        __st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad2: ::c_uint,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::ino64_t,
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        pub f_flags: ::__fsword_t,
+        pub f_spare: [::__fsword_t; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        __unused1: ::c_ulong,
+        pub shm_dtime: ::time_t,
+        __unused2: ::c_ulong,
+        pub shm_ctime: ::time_t,
+        __unused3: ::c_ulong,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        __glibc_reserved1: ::c_ulong,
+        pub msg_rtime: ::time_t,
+        __glibc_reserved2: ::c_ulong,
+        pub msg_ctime: ::time_t,
+        __glibc_reserved3: ::c_ulong,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved4: ::c_ulong,
+        __glibc_reserved5: ::c_ulong,
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+}
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const O_DIRECT: ::c_int = 0x10000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_LARGEFILE: ::c_int = 0o400000;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 0x101000;
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_NDELAY: ::c_int = 0x800;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const EDEADLOCK: ::c_int = 35;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const FIOCLEX: ::c_ulong = 0x5451;
+pub const FIONCLEX: ::c_ulong = 0x5450;
+pub const FIONBIO: ::c_ulong = 0x5421;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+pub const SFD_NONBLOCK: ::c_int = 0x0800;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = 31;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+pub const TCGETS: ::c_ulong = 0x5401;
+pub const TCSETS: ::c_ulong = 0x5402;
+pub const TCSETSW: ::c_ulong = 0x5403;
+pub const TCSETSF: ::c_ulong = 0x5404;
+pub const TCGETA: ::c_ulong = 0x5405;
+pub const TCSETA: ::c_ulong = 0x5406;
+pub const TCSETAW: ::c_ulong = 0x5407;
+pub const TCSETAF: ::c_ulong = 0x5408;
+pub const TCSBRK: ::c_ulong = 0x5409;
+pub const TCXONC: ::c_ulong = 0x540A;
+pub const TCFLSH: ::c_ulong = 0x540B;
+pub const TIOCINQ: ::c_ulong = 0x541B;
+pub const TIOCGPGRP: ::c_ulong = 0x540F;
+pub const TIOCSPGRP: ::c_ulong = 0x5410;
+pub const TIOCOUTQ: ::c_ulong = 0x5411;
+pub const TIOCGWINSZ: ::c_ulong = 0x5413;
+pub const TIOCSWINSZ: ::c_ulong = 0x5414;
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+pub const FIONREAD: ::c_ulong = 0x541B;
+
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5419;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x541A;
+pub const TIOCEXCL: ::c_ulong = 0x540C;
+pub const TIOCNXCL: ::c_ulong = 0x540D;
+pub const TIOCSCTTY: ::c_ulong = 0x540E;
+pub const TIOCSTI: ::c_ulong = 0x5412;
+pub const TIOCMGET: ::c_ulong = 0x5415;
+pub const TIOCMBIS: ::c_ulong = 0x5416;
+pub const TIOCMBIC: ::c_ulong = 0x5417;
+pub const TIOCMSET: ::c_ulong = 0x5418;
+pub const TIOCCONS: ::c_ulong = 0x541D;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+// Syscall table
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_poll: ::c_long = 168;
+pub const SYS_nfsservctl: ::c_long = 169;
+pub const SYS_setresgid: ::c_long = 170;
+pub const SYS_getresgid: ::c_long = 171;
+pub const SYS_prctl: ::c_long = 172;
+pub const SYS_rt_sigreturn: ::c_long = 173;
+pub const SYS_rt_sigaction: ::c_long = 174;
+pub const SYS_rt_sigprocmask: ::c_long = 175;
+pub const SYS_rt_sigpending: ::c_long = 176;
+pub const SYS_rt_sigtimedwait: ::c_long = 177;
+pub const SYS_rt_sigqueueinfo: ::c_long = 178;
+pub const SYS_rt_sigsuspend: ::c_long = 179;
+pub const SYS_pread64: ::c_long = 180;
+pub const SYS_pwrite64: ::c_long = 181;
+pub const SYS_chown: ::c_long = 182;
+pub const SYS_getcwd: ::c_long = 183;
+pub const SYS_capget: ::c_long = 184;
+pub const SYS_capset: ::c_long = 185;
+pub const SYS_sigaltstack: ::c_long = 186;
+pub const SYS_sendfile: ::c_long = 187;
+pub const SYS_vfork: ::c_long = 190;
+pub const SYS_ugetrlimit: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_lchown32: ::c_long = 198;
+pub const SYS_getuid32: ::c_long = 199;
+pub const SYS_getgid32: ::c_long = 200;
+pub const SYS_geteuid32: ::c_long = 201;
+pub const SYS_getegid32: ::c_long = 202;
+pub const SYS_setreuid32: ::c_long = 203;
+pub const SYS_setregid32: ::c_long = 204;
+pub const SYS_getgroups32: ::c_long = 205;
+pub const SYS_setgroups32: ::c_long = 206;
+pub const SYS_fchown32: ::c_long = 207;
+pub const SYS_setresuid32: ::c_long = 208;
+pub const SYS_getresuid32: ::c_long = 209;
+pub const SYS_setresgid32: ::c_long = 210;
+pub const SYS_getresgid32: ::c_long = 211;
+pub const SYS_chown32: ::c_long = 212;
+pub const SYS_setuid32: ::c_long = 213;
+pub const SYS_setgid32: ::c_long = 214;
+pub const SYS_setfsuid32: ::c_long = 215;
+pub const SYS_setfsgid32: ::c_long = 216;
+pub const SYS_getdents64: ::c_long = 217;
+pub const SYS_pivot_root: ::c_long = 218;
+pub const SYS_mincore: ::c_long = 219;
+pub const SYS_madvise: ::c_long = 220;
+pub const SYS_fcntl64: ::c_long = 221;
+pub const SYS_gettid: ::c_long = 224;
+pub const SYS_readahead: ::c_long = 225;
+pub const SYS_setxattr: ::c_long = 226;
+pub const SYS_lsetxattr: ::c_long = 227;
+pub const SYS_fsetxattr: ::c_long = 228;
+pub const SYS_getxattr: ::c_long = 229;
+pub const SYS_lgetxattr: ::c_long = 230;
+pub const SYS_fgetxattr: ::c_long = 231;
+pub const SYS_listxattr: ::c_long = 232;
+pub const SYS_llistxattr: ::c_long = 233;
+pub const SYS_flistxattr: ::c_long = 234;
+pub const SYS_removexattr: ::c_long = 235;
+pub const SYS_lremovexattr: ::c_long = 236;
+pub const SYS_fremovexattr: ::c_long = 237;
+pub const SYS_tkill: ::c_long = 238;
+pub const SYS_sendfile64: ::c_long = 239;
+pub const SYS_futex: ::c_long = 240;
+pub const SYS_sched_setaffinity: ::c_long = 241;
+pub const SYS_sched_getaffinity: ::c_long = 242;
+pub const SYS_io_setup: ::c_long = 243;
+pub const SYS_io_destroy: ::c_long = 244;
+pub const SYS_io_getevents: ::c_long = 245;
+pub const SYS_io_submit: ::c_long = 246;
+pub const SYS_io_cancel: ::c_long = 247;
+pub const SYS_exit_group: ::c_long = 248;
+pub const SYS_lookup_dcookie: ::c_long = 249;
+pub const SYS_epoll_create: ::c_long = 250;
+pub const SYS_epoll_ctl: ::c_long = 251;
+pub const SYS_epoll_wait: ::c_long = 252;
+pub const SYS_remap_file_pages: ::c_long = 253;
+pub const SYS_set_tid_address: ::c_long = 256;
+pub const SYS_timer_create: ::c_long = 257;
+pub const SYS_timer_settime: ::c_long = 258;
+pub const SYS_timer_gettime: ::c_long = 259;
+pub const SYS_timer_getoverrun: ::c_long = 260;
+pub const SYS_timer_delete: ::c_long = 261;
+pub const SYS_clock_settime: ::c_long = 262;
+pub const SYS_clock_gettime: ::c_long = 263;
+pub const SYS_clock_getres: ::c_long = 264;
+pub const SYS_clock_nanosleep: ::c_long = 265;
+pub const SYS_statfs64: ::c_long = 266;
+pub const SYS_fstatfs64: ::c_long = 267;
+pub const SYS_tgkill: ::c_long = 268;
+pub const SYS_utimes: ::c_long = 269;
+pub const SYS_arm_fadvise64_64: ::c_long = 270;
+pub const SYS_pciconfig_iobase: ::c_long = 271;
+pub const SYS_pciconfig_read: ::c_long = 272;
+pub const SYS_pciconfig_write: ::c_long = 273;
+pub const SYS_mq_open: ::c_long = 274;
+pub const SYS_mq_unlink: ::c_long = 275;
+pub const SYS_mq_timedsend: ::c_long = 276;
+pub const SYS_mq_timedreceive: ::c_long = 277;
+pub const SYS_mq_notify: ::c_long = 278;
+pub const SYS_mq_getsetattr: ::c_long = 279;
+pub const SYS_waitid: ::c_long = 280;
+pub const SYS_socket: ::c_long = 281;
+pub const SYS_bind: ::c_long = 282;
+pub const SYS_connect: ::c_long = 283;
+pub const SYS_listen: ::c_long = 284;
+pub const SYS_accept: ::c_long = 285;
+pub const SYS_getsockname: ::c_long = 286;
+pub const SYS_getpeername: ::c_long = 287;
+pub const SYS_socketpair: ::c_long = 288;
+pub const SYS_send: ::c_long = 289;
+pub const SYS_sendto: ::c_long = 290;
+pub const SYS_recv: ::c_long = 291;
+pub const SYS_recvfrom: ::c_long = 292;
+pub const SYS_shutdown: ::c_long = 293;
+pub const SYS_setsockopt: ::c_long = 294;
+pub const SYS_getsockopt: ::c_long = 295;
+pub const SYS_sendmsg: ::c_long = 296;
+pub const SYS_recvmsg: ::c_long = 297;
+pub const SYS_semop: ::c_long = 298;
+pub const SYS_semget: ::c_long = 299;
+pub const SYS_semctl: ::c_long = 300;
+pub const SYS_msgsnd: ::c_long = 301;
+pub const SYS_msgrcv: ::c_long = 302;
+pub const SYS_msgget: ::c_long = 303;
+pub const SYS_msgctl: ::c_long = 304;
+pub const SYS_shmat: ::c_long = 305;
+pub const SYS_shmdt: ::c_long = 306;
+pub const SYS_shmget: ::c_long = 307;
+pub const SYS_shmctl: ::c_long = 308;
+pub const SYS_add_key: ::c_long = 309;
+pub const SYS_request_key: ::c_long = 310;
+pub const SYS_keyctl: ::c_long = 311;
+pub const SYS_semtimedop: ::c_long = 312;
+pub const SYS_vserver: ::c_long = 313;
+pub const SYS_ioprio_set: ::c_long = 314;
+pub const SYS_ioprio_get: ::c_long = 315;
+pub const SYS_inotify_init: ::c_long = 316;
+pub const SYS_inotify_add_watch: ::c_long = 317;
+pub const SYS_inotify_rm_watch: ::c_long = 318;
+pub const SYS_mbind: ::c_long = 319;
+pub const SYS_get_mempolicy: ::c_long = 320;
+pub const SYS_set_mempolicy: ::c_long = 321;
+pub const SYS_openat: ::c_long = 322;
+pub const SYS_mkdirat: ::c_long = 323;
+pub const SYS_mknodat: ::c_long = 324;
+pub const SYS_fchownat: ::c_long = 325;
+pub const SYS_futimesat: ::c_long = 326;
+pub const SYS_fstatat64: ::c_long = 327;
+pub const SYS_unlinkat: ::c_long = 328;
+pub const SYS_renameat: ::c_long = 329;
+pub const SYS_linkat: ::c_long = 330;
+pub const SYS_symlinkat: ::c_long = 331;
+pub const SYS_readlinkat: ::c_long = 332;
+pub const SYS_fchmodat: ::c_long = 333;
+pub const SYS_faccessat: ::c_long = 334;
+pub const SYS_pselect6: ::c_long = 335;
+pub const SYS_ppoll: ::c_long = 336;
+pub const SYS_unshare: ::c_long = 337;
+pub const SYS_set_robust_list: ::c_long = 338;
+pub const SYS_get_robust_list: ::c_long = 339;
+pub const SYS_splice: ::c_long = 340;
+pub const SYS_arm_sync_file_range: ::c_long = 341;
+pub const SYS_tee: ::c_long = 342;
+pub const SYS_vmsplice: ::c_long = 343;
+pub const SYS_move_pages: ::c_long = 344;
+pub const SYS_getcpu: ::c_long = 345;
+pub const SYS_epoll_pwait: ::c_long = 346;
+pub const SYS_kexec_load: ::c_long = 347;
+pub const SYS_utimensat: ::c_long = 348;
+pub const SYS_signalfd: ::c_long = 349;
+pub const SYS_timerfd_create: ::c_long = 350;
+pub const SYS_eventfd: ::c_long = 351;
+pub const SYS_fallocate: ::c_long = 352;
+pub const SYS_timerfd_settime: ::c_long = 353;
+pub const SYS_timerfd_gettime: ::c_long = 354;
+pub const SYS_signalfd4: ::c_long = 355;
+pub const SYS_eventfd2: ::c_long = 356;
+pub const SYS_epoll_create1: ::c_long = 357;
+pub const SYS_dup3: ::c_long = 358;
+pub const SYS_pipe2: ::c_long = 359;
+pub const SYS_inotify_init1: ::c_long = 360;
+pub const SYS_preadv: ::c_long = 361;
+pub const SYS_pwritev: ::c_long = 362;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 363;
+pub const SYS_perf_event_open: ::c_long = 364;
+pub const SYS_recvmmsg: ::c_long = 365;
+pub const SYS_accept4: ::c_long = 366;
+pub const SYS_fanotify_init: ::c_long = 367;
+pub const SYS_fanotify_mark: ::c_long = 368;
+pub const SYS_prlimit64: ::c_long = 369;
+pub const SYS_name_to_handle_at: ::c_long = 370;
+pub const SYS_open_by_handle_at: ::c_long = 371;
+pub const SYS_clock_adjtime: ::c_long = 372;
+pub const SYS_syncfs: ::c_long = 373;
+pub const SYS_sendmmsg: ::c_long = 374;
+pub const SYS_setns: ::c_long = 375;
+pub const SYS_process_vm_readv: ::c_long = 376;
+pub const SYS_process_vm_writev: ::c_long = 377;
+pub const SYS_kcmp: ::c_long = 378;
+pub const SYS_finit_module: ::c_long = 379;
+pub const SYS_sched_setattr: ::c_long = 380;
+pub const SYS_sched_getattr: ::c_long = 381;
+pub const SYS_renameat2: ::c_long = 382;
+pub const SYS_seccomp: ::c_long = 383;
+pub const SYS_getrandom: ::c_long = 384;
+pub const SYS_memfd_create: ::c_long = 385;
+pub const SYS_bpf: ::c_long = 386;
+pub const SYS_execveat: ::c_long = 387;
+pub const SYS_userfaultfd: ::c_long = 388;
+pub const SYS_membarrier: ::c_long = 389;
+pub const SYS_mlock2: ::c_long = 390;
+pub const SYS_copy_file_range: ::c_long = 391;
+pub const SYS_preadv2: ::c_long = 392;
+pub const SYS_pwritev2: ::c_long = 393;
+pub const SYS_pkey_mprotect: ::c_long = 394;
+pub const SYS_pkey_alloc: ::c_long = 395;
+pub const SYS_pkey_free: ::c_long = 396;
+pub const SYS_statx: ::c_long = 397;
+pub const SYS_pidfd_open: ::c_long = 434;
+pub const SYS_clone3: ::c_long = 435;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/mips/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/mips/align.rs
new file mode 100644
index 00000000..8c228eba
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/mips/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(8))]
+    pub struct max_align_t {
+        priv_: [f32; 4]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/mips/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/mips/mod.rs
new file mode 100644
index 00000000..0903eaee
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/mips/mod.rs
@@ -0,0 +1,903 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+
+s! {
+    pub struct stat64 {
+        pub st_dev: ::c_ulong,
+        st_pad1: [::c_long; 3],
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulong,
+        st_pad2: [::c_long; 2],
+        pub st_size: ::off64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        st_pad3: ::c_long,
+        pub st_blocks: ::blkcnt64_t,
+        st_pad5: [::c_long; 14],
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_files: ::fsblkcnt_t,
+        pub f_ffree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::c_long,
+        f_spare: [::c_long; 6],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_bavail: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_long,
+        pub f_flags: ::c_long,
+        pub f_spare: [::c_long; 5],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct sigaction {
+        pub sa_flags: ::c_int,
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_restorer: ::Option<extern fn()>,
+        _resv: [::c_int; 1],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        pub _pad: [::c_int; 29],
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_uint,
+        pub __seq: ::c_ushort,
+        __pad1: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        #[cfg(target_endian = "big")]
+        __glibc_reserved1: ::c_ulong,
+        pub msg_stime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __glibc_reserved1: ::c_ulong,
+        #[cfg(target_endian = "big")]
+        __glibc_reserved2: ::c_ulong,
+        pub msg_rtime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __glibc_reserved2: ::c_ulong,
+        #[cfg(target_endian = "big")]
+        __glibc_reserved3: ::c_ulong,
+        pub msg_ctime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __glibc_reserved3: ::c_ulong,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved4: ::c_ulong,
+        __glibc_reserved5: ::c_ulong,
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_sysid: ::c_long,
+        pub l_pid: ::pid_t,
+        pad: [::c_long; 4],
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 23],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+}
+
+pub const O_LARGEFILE: ::c_int = 0x2000;
+
+pub const SYS_syscall: ::c_long = 4000 + 0;
+pub const SYS_exit: ::c_long = 4000 + 1;
+pub const SYS_fork: ::c_long = 4000 + 2;
+pub const SYS_read: ::c_long = 4000 + 3;
+pub const SYS_write: ::c_long = 4000 + 4;
+pub const SYS_open: ::c_long = 4000 + 5;
+pub const SYS_close: ::c_long = 4000 + 6;
+pub const SYS_waitpid: ::c_long = 4000 + 7;
+pub const SYS_creat: ::c_long = 4000 + 8;
+pub const SYS_link: ::c_long = 4000 + 9;
+pub const SYS_unlink: ::c_long = 4000 + 10;
+pub const SYS_execve: ::c_long = 4000 + 11;
+pub const SYS_chdir: ::c_long = 4000 + 12;
+pub const SYS_time: ::c_long = 4000 + 13;
+pub const SYS_mknod: ::c_long = 4000 + 14;
+pub const SYS_chmod: ::c_long = 4000 + 15;
+pub const SYS_lchown: ::c_long = 4000 + 16;
+pub const SYS_break: ::c_long = 4000 + 17;
+pub const SYS_lseek: ::c_long = 4000 + 19;
+pub const SYS_getpid: ::c_long = 4000 + 20;
+pub const SYS_mount: ::c_long = 4000 + 21;
+pub const SYS_umount: ::c_long = 4000 + 22;
+pub const SYS_setuid: ::c_long = 4000 + 23;
+pub const SYS_getuid: ::c_long = 4000 + 24;
+pub const SYS_stime: ::c_long = 4000 + 25;
+pub const SYS_ptrace: ::c_long = 4000 + 26;
+pub const SYS_alarm: ::c_long = 4000 + 27;
+pub const SYS_pause: ::c_long = 4000 + 29;
+pub const SYS_utime: ::c_long = 4000 + 30;
+pub const SYS_stty: ::c_long = 4000 + 31;
+pub const SYS_gtty: ::c_long = 4000 + 32;
+pub const SYS_access: ::c_long = 4000 + 33;
+pub const SYS_nice: ::c_long = 4000 + 34;
+pub const SYS_ftime: ::c_long = 4000 + 35;
+pub const SYS_sync: ::c_long = 4000 + 36;
+pub const SYS_kill: ::c_long = 4000 + 37;
+pub const SYS_rename: ::c_long = 4000 + 38;
+pub const SYS_mkdir: ::c_long = 4000 + 39;
+pub const SYS_rmdir: ::c_long = 4000 + 40;
+pub const SYS_dup: ::c_long = 4000 + 41;
+pub const SYS_pipe: ::c_long = 4000 + 42;
+pub const SYS_times: ::c_long = 4000 + 43;
+pub const SYS_prof: ::c_long = 4000 + 44;
+pub const SYS_brk: ::c_long = 4000 + 45;
+pub const SYS_setgid: ::c_long = 4000 + 46;
+pub const SYS_getgid: ::c_long = 4000 + 47;
+pub const SYS_signal: ::c_long = 4000 + 48;
+pub const SYS_geteuid: ::c_long = 4000 + 49;
+pub const SYS_getegid: ::c_long = 4000 + 50;
+pub const SYS_acct: ::c_long = 4000 + 51;
+pub const SYS_umount2: ::c_long = 4000 + 52;
+pub const SYS_lock: ::c_long = 4000 + 53;
+pub const SYS_ioctl: ::c_long = 4000 + 54;
+pub const SYS_fcntl: ::c_long = 4000 + 55;
+pub const SYS_mpx: ::c_long = 4000 + 56;
+pub const SYS_setpgid: ::c_long = 4000 + 57;
+pub const SYS_ulimit: ::c_long = 4000 + 58;
+pub const SYS_umask: ::c_long = 4000 + 60;
+pub const SYS_chroot: ::c_long = 4000 + 61;
+pub const SYS_ustat: ::c_long = 4000 + 62;
+pub const SYS_dup2: ::c_long = 4000 + 63;
+pub const SYS_getppid: ::c_long = 4000 + 64;
+pub const SYS_getpgrp: ::c_long = 4000 + 65;
+pub const SYS_setsid: ::c_long = 4000 + 66;
+pub const SYS_sigaction: ::c_long = 4000 + 67;
+pub const SYS_sgetmask: ::c_long = 4000 + 68;
+pub const SYS_ssetmask: ::c_long = 4000 + 69;
+pub const SYS_setreuid: ::c_long = 4000 + 70;
+pub const SYS_setregid: ::c_long = 4000 + 71;
+pub const SYS_sigsuspend: ::c_long = 4000 + 72;
+pub const SYS_sigpending: ::c_long = 4000 + 73;
+pub const SYS_sethostname: ::c_long = 4000 + 74;
+pub const SYS_setrlimit: ::c_long = 4000 + 75;
+pub const SYS_getrlimit: ::c_long = 4000 + 76;
+pub const SYS_getrusage: ::c_long = 4000 + 77;
+pub const SYS_gettimeofday: ::c_long = 4000 + 78;
+pub const SYS_settimeofday: ::c_long = 4000 + 79;
+pub const SYS_getgroups: ::c_long = 4000 + 80;
+pub const SYS_setgroups: ::c_long = 4000 + 81;
+pub const SYS_symlink: ::c_long = 4000 + 83;
+pub const SYS_readlink: ::c_long = 4000 + 85;
+pub const SYS_uselib: ::c_long = 4000 + 86;
+pub const SYS_swapon: ::c_long = 4000 + 87;
+pub const SYS_reboot: ::c_long = 4000 + 88;
+pub const SYS_readdir: ::c_long = 4000 + 89;
+pub const SYS_mmap: ::c_long = 4000 + 90;
+pub const SYS_munmap: ::c_long = 4000 + 91;
+pub const SYS_truncate: ::c_long = 4000 + 92;
+pub const SYS_ftruncate: ::c_long = 4000 + 93;
+pub const SYS_fchmod: ::c_long = 4000 + 94;
+pub const SYS_fchown: ::c_long = 4000 + 95;
+pub const SYS_getpriority: ::c_long = 4000 + 96;
+pub const SYS_setpriority: ::c_long = 4000 + 97;
+pub const SYS_profil: ::c_long = 4000 + 98;
+pub const SYS_statfs: ::c_long = 4000 + 99;
+pub const SYS_fstatfs: ::c_long = 4000 + 100;
+pub const SYS_ioperm: ::c_long = 4000 + 101;
+pub const SYS_socketcall: ::c_long = 4000 + 102;
+pub const SYS_syslog: ::c_long = 4000 + 103;
+pub const SYS_setitimer: ::c_long = 4000 + 104;
+pub const SYS_getitimer: ::c_long = 4000 + 105;
+pub const SYS_stat: ::c_long = 4000 + 106;
+pub const SYS_lstat: ::c_long = 4000 + 107;
+pub const SYS_fstat: ::c_long = 4000 + 108;
+pub const SYS_iopl: ::c_long = 4000 + 110;
+pub const SYS_vhangup: ::c_long = 4000 + 111;
+pub const SYS_idle: ::c_long = 4000 + 112;
+pub const SYS_vm86: ::c_long = 4000 + 113;
+pub const SYS_wait4: ::c_long = 4000 + 114;
+pub const SYS_swapoff: ::c_long = 4000 + 115;
+pub const SYS_sysinfo: ::c_long = 4000 + 116;
+pub const SYS_ipc: ::c_long = 4000 + 117;
+pub const SYS_fsync: ::c_long = 4000 + 118;
+pub const SYS_sigreturn: ::c_long = 4000 + 119;
+pub const SYS_clone: ::c_long = 4000 + 120;
+pub const SYS_setdomainname: ::c_long = 4000 + 121;
+pub const SYS_uname: ::c_long = 4000 + 122;
+pub const SYS_modify_ldt: ::c_long = 4000 + 123;
+pub const SYS_adjtimex: ::c_long = 4000 + 124;
+pub const SYS_mprotect: ::c_long = 4000 + 125;
+pub const SYS_sigprocmask: ::c_long = 4000 + 126;
+pub const SYS_create_module: ::c_long = 4000 + 127;
+pub const SYS_init_module: ::c_long = 4000 + 128;
+pub const SYS_delete_module: ::c_long = 4000 + 129;
+pub const SYS_get_kernel_syms: ::c_long = 4000 + 130;
+pub const SYS_quotactl: ::c_long = 4000 + 131;
+pub const SYS_getpgid: ::c_long = 4000 + 132;
+pub const SYS_fchdir: ::c_long = 4000 + 133;
+pub const SYS_bdflush: ::c_long = 4000 + 134;
+pub const SYS_sysfs: ::c_long = 4000 + 135;
+pub const SYS_personality: ::c_long = 4000 + 136;
+pub const SYS_afs_syscall: ::c_long = 4000 + 137;
+pub const SYS_setfsuid: ::c_long = 4000 + 138;
+pub const SYS_setfsgid: ::c_long = 4000 + 139;
+pub const SYS__llseek: ::c_long = 4000 + 140;
+pub const SYS_getdents: ::c_long = 4000 + 141;
+pub const SYS__newselect: ::c_long = 4000 + 142;
+pub const SYS_flock: ::c_long = 4000 + 143;
+pub const SYS_msync: ::c_long = 4000 + 144;
+pub const SYS_readv: ::c_long = 4000 + 145;
+pub const SYS_writev: ::c_long = 4000 + 146;
+pub const SYS_cacheflush: ::c_long = 4000 + 147;
+pub const SYS_cachectl: ::c_long = 4000 + 148;
+pub const SYS_sysmips: ::c_long = 4000 + 149;
+pub const SYS_getsid: ::c_long = 4000 + 151;
+pub const SYS_fdatasync: ::c_long = 4000 + 152;
+pub const SYS__sysctl: ::c_long = 4000 + 153;
+pub const SYS_mlock: ::c_long = 4000 + 154;
+pub const SYS_munlock: ::c_long = 4000 + 155;
+pub const SYS_mlockall: ::c_long = 4000 + 156;
+pub const SYS_munlockall: ::c_long = 4000 + 157;
+pub const SYS_sched_setparam: ::c_long = 4000 + 158;
+pub const SYS_sched_getparam: ::c_long = 4000 + 159;
+pub const SYS_sched_setscheduler: ::c_long = 4000 + 160;
+pub const SYS_sched_getscheduler: ::c_long = 4000 + 161;
+pub const SYS_sched_yield: ::c_long = 4000 + 162;
+pub const SYS_sched_get_priority_max: ::c_long = 4000 + 163;
+pub const SYS_sched_get_priority_min: ::c_long = 4000 + 164;
+pub const SYS_sched_rr_get_interval: ::c_long = 4000 + 165;
+pub const SYS_nanosleep: ::c_long = 4000 + 166;
+pub const SYS_mremap: ::c_long = 4000 + 167;
+pub const SYS_accept: ::c_long = 4000 + 168;
+pub const SYS_bind: ::c_long = 4000 + 169;
+pub const SYS_connect: ::c_long = 4000 + 170;
+pub const SYS_getpeername: ::c_long = 4000 + 171;
+pub const SYS_getsockname: ::c_long = 4000 + 172;
+pub const SYS_getsockopt: ::c_long = 4000 + 173;
+pub const SYS_listen: ::c_long = 4000 + 174;
+pub const SYS_recv: ::c_long = 4000 + 175;
+pub const SYS_recvfrom: ::c_long = 4000 + 176;
+pub const SYS_recvmsg: ::c_long = 4000 + 177;
+pub const SYS_send: ::c_long = 4000 + 178;
+pub const SYS_sendmsg: ::c_long = 4000 + 179;
+pub const SYS_sendto: ::c_long = 4000 + 180;
+pub const SYS_setsockopt: ::c_long = 4000 + 181;
+pub const SYS_shutdown: ::c_long = 4000 + 182;
+pub const SYS_socket: ::c_long = 4000 + 183;
+pub const SYS_socketpair: ::c_long = 4000 + 184;
+pub const SYS_setresuid: ::c_long = 4000 + 185;
+pub const SYS_getresuid: ::c_long = 4000 + 186;
+pub const SYS_query_module: ::c_long = 4000 + 187;
+pub const SYS_poll: ::c_long = 4000 + 188;
+pub const SYS_nfsservctl: ::c_long = 4000 + 189;
+pub const SYS_setresgid: ::c_long = 4000 + 190;
+pub const SYS_getresgid: ::c_long = 4000 + 191;
+pub const SYS_prctl: ::c_long = 4000 + 192;
+pub const SYS_rt_sigreturn: ::c_long = 4000 + 193;
+pub const SYS_rt_sigaction: ::c_long = 4000 + 194;
+pub const SYS_rt_sigprocmask: ::c_long = 4000 + 195;
+pub const SYS_rt_sigpending: ::c_long = 4000 + 196;
+pub const SYS_rt_sigtimedwait: ::c_long = 4000 + 197;
+pub const SYS_rt_sigqueueinfo: ::c_long = 4000 + 198;
+pub const SYS_rt_sigsuspend: ::c_long = 4000 + 199;
+pub const SYS_pread64: ::c_long = 4000 + 200;
+pub const SYS_pwrite64: ::c_long = 4000 + 201;
+pub const SYS_chown: ::c_long = 4000 + 202;
+pub const SYS_getcwd: ::c_long = 4000 + 203;
+pub const SYS_capget: ::c_long = 4000 + 204;
+pub const SYS_capset: ::c_long = 4000 + 205;
+pub const SYS_sigaltstack: ::c_long = 4000 + 206;
+pub const SYS_sendfile: ::c_long = 4000 + 207;
+pub const SYS_getpmsg: ::c_long = 4000 + 208;
+pub const SYS_putpmsg: ::c_long = 4000 + 209;
+pub const SYS_mmap2: ::c_long = 4000 + 210;
+pub const SYS_truncate64: ::c_long = 4000 + 211;
+pub const SYS_ftruncate64: ::c_long = 4000 + 212;
+pub const SYS_stat64: ::c_long = 4000 + 213;
+pub const SYS_lstat64: ::c_long = 4000 + 214;
+pub const SYS_fstat64: ::c_long = 4000 + 215;
+pub const SYS_pivot_root: ::c_long = 4000 + 216;
+pub const SYS_mincore: ::c_long = 4000 + 217;
+pub const SYS_madvise: ::c_long = 4000 + 218;
+pub const SYS_getdents64: ::c_long = 4000 + 219;
+pub const SYS_fcntl64: ::c_long = 4000 + 220;
+pub const SYS_gettid: ::c_long = 4000 + 222;
+pub const SYS_readahead: ::c_long = 4000 + 223;
+pub const SYS_setxattr: ::c_long = 4000 + 224;
+pub const SYS_lsetxattr: ::c_long = 4000 + 225;
+pub const SYS_fsetxattr: ::c_long = 4000 + 226;
+pub const SYS_getxattr: ::c_long = 4000 + 227;
+pub const SYS_lgetxattr: ::c_long = 4000 + 228;
+pub const SYS_fgetxattr: ::c_long = 4000 + 229;
+pub const SYS_listxattr: ::c_long = 4000 + 230;
+pub const SYS_llistxattr: ::c_long = 4000 + 231;
+pub const SYS_flistxattr: ::c_long = 4000 + 232;
+pub const SYS_removexattr: ::c_long = 4000 + 233;
+pub const SYS_lremovexattr: ::c_long = 4000 + 234;
+pub const SYS_fremovexattr: ::c_long = 4000 + 235;
+pub const SYS_tkill: ::c_long = 4000 + 236;
+pub const SYS_sendfile64: ::c_long = 4000 + 237;
+pub const SYS_futex: ::c_long = 4000 + 238;
+pub const SYS_sched_setaffinity: ::c_long = 4000 + 239;
+pub const SYS_sched_getaffinity: ::c_long = 4000 + 240;
+pub const SYS_io_setup: ::c_long = 4000 + 241;
+pub const SYS_io_destroy: ::c_long = 4000 + 242;
+pub const SYS_io_getevents: ::c_long = 4000 + 243;
+pub const SYS_io_submit: ::c_long = 4000 + 244;
+pub const SYS_io_cancel: ::c_long = 4000 + 245;
+pub const SYS_exit_group: ::c_long = 4000 + 246;
+pub const SYS_lookup_dcookie: ::c_long = 4000 + 247;
+pub const SYS_epoll_create: ::c_long = 4000 + 248;
+pub const SYS_epoll_ctl: ::c_long = 4000 + 249;
+pub const SYS_epoll_wait: ::c_long = 4000 + 250;
+pub const SYS_remap_file_pages: ::c_long = 4000 + 251;
+pub const SYS_set_tid_address: ::c_long = 4000 + 252;
+pub const SYS_restart_syscall: ::c_long = 4000 + 253;
+pub const SYS_fadvise64: ::c_long = 4000 + 254;
+pub const SYS_statfs64: ::c_long = 4000 + 255;
+pub const SYS_fstatfs64: ::c_long = 4000 + 256;
+pub const SYS_timer_create: ::c_long = 4000 + 257;
+pub const SYS_timer_settime: ::c_long = 4000 + 258;
+pub const SYS_timer_gettime: ::c_long = 4000 + 259;
+pub const SYS_timer_getoverrun: ::c_long = 4000 + 260;
+pub const SYS_timer_delete: ::c_long = 4000 + 261;
+pub const SYS_clock_settime: ::c_long = 4000 + 262;
+pub const SYS_clock_gettime: ::c_long = 4000 + 263;
+pub const SYS_clock_getres: ::c_long = 4000 + 264;
+pub const SYS_clock_nanosleep: ::c_long = 4000 + 265;
+pub const SYS_tgkill: ::c_long = 4000 + 266;
+pub const SYS_utimes: ::c_long = 4000 + 267;
+pub const SYS_mbind: ::c_long = 4000 + 268;
+pub const SYS_get_mempolicy: ::c_long = 4000 + 269;
+pub const SYS_set_mempolicy: ::c_long = 4000 + 270;
+pub const SYS_mq_open: ::c_long = 4000 + 271;
+pub const SYS_mq_unlink: ::c_long = 4000 + 272;
+pub const SYS_mq_timedsend: ::c_long = 4000 + 273;
+pub const SYS_mq_timedreceive: ::c_long = 4000 + 274;
+pub const SYS_mq_notify: ::c_long = 4000 + 275;
+pub const SYS_mq_getsetattr: ::c_long = 4000 + 276;
+pub const SYS_vserver: ::c_long = 4000 + 277;
+pub const SYS_waitid: ::c_long = 4000 + 278;
+/* pub const SYS_sys_setaltroot: ::c_long = 4000 + 279; */
+pub const SYS_add_key: ::c_long = 4000 + 280;
+pub const SYS_request_key: ::c_long = 4000 + 281;
+pub const SYS_keyctl: ::c_long = 4000 + 282;
+pub const SYS_set_thread_area: ::c_long = 4000 + 283;
+pub const SYS_inotify_init: ::c_long = 4000 + 284;
+pub const SYS_inotify_add_watch: ::c_long = 4000 + 285;
+pub const SYS_inotify_rm_watch: ::c_long = 4000 + 286;
+pub const SYS_migrate_pages: ::c_long = 4000 + 287;
+pub const SYS_openat: ::c_long = 4000 + 288;
+pub const SYS_mkdirat: ::c_long = 4000 + 289;
+pub const SYS_mknodat: ::c_long = 4000 + 290;
+pub const SYS_fchownat: ::c_long = 4000 + 291;
+pub const SYS_futimesat: ::c_long = 4000 + 292;
+pub const SYS_fstatat64: ::c_long = 4000 + 293;
+pub const SYS_unlinkat: ::c_long = 4000 + 294;
+pub const SYS_renameat: ::c_long = 4000 + 295;
+pub const SYS_linkat: ::c_long = 4000 + 296;
+pub const SYS_symlinkat: ::c_long = 4000 + 297;
+pub const SYS_readlinkat: ::c_long = 4000 + 298;
+pub const SYS_fchmodat: ::c_long = 4000 + 299;
+pub const SYS_faccessat: ::c_long = 4000 + 300;
+pub const SYS_pselect6: ::c_long = 4000 + 301;
+pub const SYS_ppoll: ::c_long = 4000 + 302;
+pub const SYS_unshare: ::c_long = 4000 + 303;
+pub const SYS_splice: ::c_long = 4000 + 304;
+pub const SYS_sync_file_range: ::c_long = 4000 + 305;
+pub const SYS_tee: ::c_long = 4000 + 306;
+pub const SYS_vmsplice: ::c_long = 4000 + 307;
+pub const SYS_move_pages: ::c_long = 4000 + 308;
+pub const SYS_set_robust_list: ::c_long = 4000 + 309;
+pub const SYS_get_robust_list: ::c_long = 4000 + 310;
+pub const SYS_kexec_load: ::c_long = 4000 + 311;
+pub const SYS_getcpu: ::c_long = 4000 + 312;
+pub const SYS_epoll_pwait: ::c_long = 4000 + 313;
+pub const SYS_ioprio_set: ::c_long = 4000 + 314;
+pub const SYS_ioprio_get: ::c_long = 4000 + 315;
+pub const SYS_utimensat: ::c_long = 4000 + 316;
+pub const SYS_signalfd: ::c_long = 4000 + 317;
+pub const SYS_timerfd: ::c_long = 4000 + 318;
+pub const SYS_eventfd: ::c_long = 4000 + 319;
+pub const SYS_fallocate: ::c_long = 4000 + 320;
+pub const SYS_timerfd_create: ::c_long = 4000 + 321;
+pub const SYS_timerfd_gettime: ::c_long = 4000 + 322;
+pub const SYS_timerfd_settime: ::c_long = 4000 + 323;
+pub const SYS_signalfd4: ::c_long = 4000 + 324;
+pub const SYS_eventfd2: ::c_long = 4000 + 325;
+pub const SYS_epoll_create1: ::c_long = 4000 + 326;
+pub const SYS_dup3: ::c_long = 4000 + 327;
+pub const SYS_pipe2: ::c_long = 4000 + 328;
+pub const SYS_inotify_init1: ::c_long = 4000 + 329;
+pub const SYS_preadv: ::c_long = 4000 + 330;
+pub const SYS_pwritev: ::c_long = 4000 + 331;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 4000 + 332;
+pub const SYS_perf_event_open: ::c_long = 4000 + 333;
+pub const SYS_accept4: ::c_long = 4000 + 334;
+pub const SYS_recvmmsg: ::c_long = 4000 + 335;
+pub const SYS_fanotify_init: ::c_long = 4000 + 336;
+pub const SYS_fanotify_mark: ::c_long = 4000 + 337;
+pub const SYS_prlimit64: ::c_long = 4000 + 338;
+pub const SYS_name_to_handle_at: ::c_long = 4000 + 339;
+pub const SYS_open_by_handle_at: ::c_long = 4000 + 340;
+pub const SYS_clock_adjtime: ::c_long = 4000 + 341;
+pub const SYS_syncfs: ::c_long = 4000 + 342;
+pub const SYS_sendmmsg: ::c_long = 4000 + 343;
+pub const SYS_setns: ::c_long = 4000 + 344;
+pub const SYS_process_vm_readv: ::c_long = 4000 + 345;
+pub const SYS_process_vm_writev: ::c_long = 4000 + 346;
+pub const SYS_kcmp: ::c_long = 4000 + 347;
+pub const SYS_finit_module: ::c_long = 4000 + 348;
+pub const SYS_sched_setattr: ::c_long = 4000 + 349;
+pub const SYS_sched_getattr: ::c_long = 4000 + 350;
+pub const SYS_renameat2: ::c_long = 4000 + 351;
+pub const SYS_seccomp: ::c_long = 4000 + 352;
+pub const SYS_getrandom: ::c_long = 4000 + 353;
+pub const SYS_memfd_create: ::c_long = 4000 + 354;
+pub const SYS_bpf: ::c_long = 4000 + 355;
+pub const SYS_execveat: ::c_long = 4000 + 356;
+pub const SYS_userfaultfd: ::c_long = 4000 + 357;
+pub const SYS_membarrier: ::c_long = 4000 + 358;
+pub const SYS_mlock2: ::c_long = 4000 + 359;
+pub const SYS_copy_file_range: ::c_long = 4000 + 360;
+pub const SYS_preadv2: ::c_long = 4000 + 361;
+pub const SYS_pwritev2: ::c_long = 4000 + 362;
+pub const SYS_pkey_mprotect: ::c_long = 4000 + 363;
+pub const SYS_pkey_alloc: ::c_long = 4000 + 364;
+pub const SYS_pkey_free: ::c_long = 4000 + 365;
+pub const SYS_statx: ::c_long = 4000 + 366;
+pub const SYS_pidfd_open: ::c_long = 4000 + 434;
+pub const SYS_clone3: ::c_long = 4000 + 435;
+
+pub const O_DIRECT: ::c_int = 0x8000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+
+pub const RLIM_INFINITY: ::rlim_t = 0x7fffffff;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 6;
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 8;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 9;
+
+pub const O_APPEND: ::c_int = 8;
+pub const O_CREAT: ::c_int = 256;
+pub const O_EXCL: ::c_int = 1024;
+pub const O_NOCTTY: ::c_int = 2048;
+pub const O_NONBLOCK: ::c_int = 128;
+pub const O_SYNC: ::c_int = 0x4010;
+pub const O_RSYNC: ::c_int = 0x4010;
+pub const O_DSYNC: ::c_int = 0x10;
+pub const O_FSYNC: ::c_int = 0x4010;
+pub const O_ASYNC: ::c_int = 0x1000;
+pub const O_NDELAY: ::c_int = 0x80;
+
+pub const EDEADLK: ::c_int = 45;
+pub const ENAMETOOLONG: ::c_int = 78;
+pub const ENOLCK: ::c_int = 46;
+pub const ENOSYS: ::c_int = 89;
+pub const ENOTEMPTY: ::c_int = 93;
+pub const ELOOP: ::c_int = 90;
+pub const ENOMSG: ::c_int = 35;
+pub const EIDRM: ::c_int = 36;
+pub const ECHRNG: ::c_int = 37;
+pub const EL2NSYNC: ::c_int = 38;
+pub const EL3HLT: ::c_int = 39;
+pub const EL3RST: ::c_int = 40;
+pub const ELNRNG: ::c_int = 41;
+pub const EUNATCH: ::c_int = 42;
+pub const ENOCSI: ::c_int = 43;
+pub const EL2HLT: ::c_int = 44;
+pub const EBADE: ::c_int = 50;
+pub const EBADR: ::c_int = 51;
+pub const EXFULL: ::c_int = 52;
+pub const ENOANO: ::c_int = 53;
+pub const EBADRQC: ::c_int = 54;
+pub const EBADSLT: ::c_int = 55;
+pub const EDEADLOCK: ::c_int = 56;
+pub const EMULTIHOP: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 79;
+pub const ENOTUNIQ: ::c_int = 80;
+pub const EBADFD: ::c_int = 81;
+pub const EBADMSG: ::c_int = 77;
+pub const EREMCHG: ::c_int = 82;
+pub const ELIBACC: ::c_int = 83;
+pub const ELIBBAD: ::c_int = 84;
+pub const ELIBSCN: ::c_int = 85;
+pub const ELIBMAX: ::c_int = 86;
+pub const ELIBEXEC: ::c_int = 87;
+pub const EILSEQ: ::c_int = 88;
+pub const ERESTART: ::c_int = 91;
+pub const ESTRPIPE: ::c_int = 92;
+pub const EUSERS: ::c_int = 94;
+pub const ENOTSOCK: ::c_int = 95;
+pub const EDESTADDRREQ: ::c_int = 96;
+pub const EMSGSIZE: ::c_int = 97;
+pub const EPROTOTYPE: ::c_int = 98;
+pub const ENOPROTOOPT: ::c_int = 99;
+pub const EPROTONOSUPPORT: ::c_int = 120;
+pub const ESOCKTNOSUPPORT: ::c_int = 121;
+pub const EOPNOTSUPP: ::c_int = 122;
+pub const EPFNOSUPPORT: ::c_int = 123;
+pub const EAFNOSUPPORT: ::c_int = 124;
+pub const EADDRINUSE: ::c_int = 125;
+pub const EADDRNOTAVAIL: ::c_int = 126;
+pub const ENETDOWN: ::c_int = 127;
+pub const ENETUNREACH: ::c_int = 128;
+pub const ENETRESET: ::c_int = 129;
+pub const ECONNABORTED: ::c_int = 130;
+pub const ECONNRESET: ::c_int = 131;
+pub const ENOBUFS: ::c_int = 132;
+pub const EISCONN: ::c_int = 133;
+pub const ENOTCONN: ::c_int = 134;
+pub const ESHUTDOWN: ::c_int = 143;
+pub const ETOOMANYREFS: ::c_int = 144;
+pub const ETIMEDOUT: ::c_int = 145;
+pub const ECONNREFUSED: ::c_int = 146;
+pub const EHOSTDOWN: ::c_int = 147;
+pub const EHOSTUNREACH: ::c_int = 148;
+pub const EALREADY: ::c_int = 149;
+pub const EINPROGRESS: ::c_int = 150;
+pub const ESTALE: ::c_int = 151;
+pub const EUCLEAN: ::c_int = 135;
+pub const ENOTNAM: ::c_int = 137;
+pub const ENAVAIL: ::c_int = 138;
+pub const EISNAM: ::c_int = 139;
+pub const EREMOTEIO: ::c_int = 140;
+pub const EDQUOT: ::c_int = 1133;
+pub const ENOMEDIUM: ::c_int = 159;
+pub const EMEDIUMTYPE: ::c_int = 160;
+pub const ECANCELED: ::c_int = 158;
+pub const ENOKEY: ::c_int = 161;
+pub const EKEYEXPIRED: ::c_int = 162;
+pub const EKEYREVOKED: ::c_int = 163;
+pub const EKEYREJECTED: ::c_int = 164;
+pub const EOWNERDEAD: ::c_int = 165;
+pub const ENOTRECOVERABLE: ::c_int = 166;
+pub const ERFKILL: ::c_int = 167;
+
+pub const MAP_NORESERVE: ::c_int = 0x400;
+pub const MAP_ANON: ::c_int = 0x800;
+pub const MAP_ANONYMOUS: ::c_int = 0x800;
+pub const MAP_GROWSDOWN: ::c_int = 0x1000;
+pub const MAP_DENYWRITE: ::c_int = 0x2000;
+pub const MAP_EXECUTABLE: ::c_int = 0x4000;
+pub const MAP_LOCKED: ::c_int = 0x8000;
+pub const MAP_POPULATE: ::c_int = 0x10000;
+pub const MAP_NONBLOCK: ::c_int = 0x20000;
+pub const MAP_STACK: ::c_int = 0x40000;
+
+pub const SOCK_STREAM: ::c_int = 2;
+pub const SOCK_DGRAM: ::c_int = 1;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_STYLE: ::c_int = SO_TYPE;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ACCEPTCONN: ::c_int = 0x1009;
+pub const SO_PROTOCOL: ::c_int = 0x1028;
+pub const SO_DOMAIN: ::c_int = 0x1029;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PASSCRED: ::c_int = 17;
+pub const SO_PEERCRED: ::c_int = 18;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_PEERSEC: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 31;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
+
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = SO_DETACH_FILTER;
+
+pub const FIOCLEX: ::c_ulong = 0x6601;
+pub const FIONCLEX: ::c_ulong = 0x6602;
+pub const FIONBIO: ::c_ulong = 0x667e;
+
+pub const SA_SIGINFO: ::c_int = 0x00000008;
+pub const SA_NOCLDWAIT: ::c_int = 0x00010000;
+
+pub const SIGCHLD: ::c_int = 18;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGTTIN: ::c_int = 26;
+pub const SIGTTOU: ::c_int = 27;
+pub const SIGXCPU: ::c_int = 30;
+pub const SIGXFSZ: ::c_int = 31;
+pub const SIGVTALRM: ::c_int = 28;
+pub const SIGPROF: ::c_int = 29;
+pub const SIGWINCH: ::c_int = 20;
+pub const SIGUSR1: ::c_int = 16;
+pub const SIGUSR2: ::c_int = 17;
+pub const SIGCONT: ::c_int = 25;
+pub const SIGSTOP: ::c_int = 23;
+pub const SIGTSTP: ::c_int = 24;
+pub const SIGURG: ::c_int = 21;
+pub const SIGIO: ::c_int = 22;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGPOLL: ::c_int = 22;
+pub const SIGPWR: ::c_int = 19;
+pub const SIG_SETMASK: ::c_int = 3;
+pub const SIG_BLOCK: ::c_int = 0x1;
+pub const SIG_UNBLOCK: ::c_int = 0x2;
+
+pub const POLLWRNORM: ::c_short = 0x004;
+pub const POLLWRBAND: ::c_short = 0x100;
+
+pub const VEOF: usize = 16;
+pub const VEOL: usize = 17;
+pub const VEOL2: usize = 6;
+pub const VMIN: usize = 4;
+pub const IEXTEN: ::tcflag_t = 0x00000100;
+pub const TOSTOP: ::tcflag_t = 0x00008000;
+pub const FLUSHO: ::tcflag_t = 0x00002000;
+pub const EXTPROC: ::tcflag_t = 0o200000;
+pub const TCSANOW: ::c_int = 0x540e;
+pub const TCSADRAIN: ::c_int = 0x540f;
+pub const TCSAFLUSH: ::c_int = 0x5410;
+
+pub const PTRACE_GETFPXREGS: ::c_uint = 18;
+pub const PTRACE_SETFPXREGS: ::c_uint = 19;
+
+pub const MAP_HUGETLB: ::c_int = 0x080000;
+
+pub const EFD_NONBLOCK: ::c_int = 0x80;
+
+pub const F_GETLK: ::c_int = 14;
+pub const F_GETOWN: ::c_int = 23;
+pub const F_SETOWN: ::c_int = 24;
+
+pub const SFD_NONBLOCK: ::c_int = 0x80;
+
+pub const TCGETS: ::c_ulong = 0x540d;
+pub const TCSETS: ::c_ulong = 0x540e;
+pub const TCSETSW: ::c_ulong = 0x540f;
+pub const TCSETSF: ::c_ulong = 0x5410;
+pub const TCGETA: ::c_ulong = 0x5401;
+pub const TCSETA: ::c_ulong = 0x5402;
+pub const TCSETAW: ::c_ulong = 0x5403;
+pub const TCSETAF: ::c_ulong = 0x5404;
+pub const TCSBRK: ::c_ulong = 0x5405;
+pub const TCXONC: ::c_ulong = 0x5406;
+pub const TCFLSH: ::c_ulong = 0x5407;
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5481;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x5482;
+pub const TIOCINQ: ::c_ulong = 0x467f;
+pub const TIOCLINUX: ::c_ulong = 0x5483;
+pub const TIOCGSERIAL: ::c_ulong = 0x5484;
+pub const TIOCEXCL: ::c_ulong = 0x740d;
+pub const TIOCNXCL: ::c_ulong = 0x740e;
+pub const TIOCSCTTY: ::c_ulong = 0x5480;
+pub const TIOCGPGRP: ::c_ulong = 0x40047477;
+pub const TIOCSPGRP: ::c_ulong = 0x80047476;
+pub const TIOCOUTQ: ::c_ulong = 0x7472;
+pub const TIOCSTI: ::c_ulong = 0x5472;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const TIOCMGET: ::c_ulong = 0x741d;
+pub const TIOCMBIS: ::c_ulong = 0x741b;
+pub const TIOCMBIC: ::c_ulong = 0x741c;
+pub const TIOCMSET: ::c_ulong = 0x741a;
+pub const FIONREAD: ::c_ulong = 0x467f;
+pub const TIOCCONS: ::c_ulong = 0x80047478;
+
+pub const RTLD_DEEPBIND: ::c_int = 0x10;
+pub const RTLD_GLOBAL: ::c_int = 0x4;
+pub const RTLD_NOLOAD: ::c_int = 0x8;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const TIOCM_ST: ::c_int = 0x010;
+pub const TIOCM_SR: ::c_int = 0x020;
+pub const TIOCM_CTS: ::c_int = 0x040;
+pub const TIOCM_CAR: ::c_int = 0x100;
+pub const TIOCM_RNG: ::c_int = 0x200;
+pub const TIOCM_DSR: ::c_int = 0x400;
+
+pub const EHWPOISON: ::c_int = 168;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/mod.rs
new file mode 100644
index 00000000..c7fa1a8a
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/mod.rs
@@ -0,0 +1,357 @@
+//! 32-bit specific definitions for linux-like values
+
+use pthread_mutex_t;
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type clock_t = i32;
+
+pub type shmatt_t = ::c_ulong;
+pub type msgqnum_t = ::c_ulong;
+pub type msglen_t = ::c_ulong;
+pub type nlink_t = u32;
+pub type __u64 = ::c_ulonglong;
+pub type __fsword_t = i32;
+pub type fsblkcnt64_t = u64;
+pub type fsfilcnt64_t = u64;
+
+cfg_if! {
+    if #[cfg(target_arch = "riscv32")] {
+        pub type time_t = i64;
+        pub type suseconds_t = i64;
+        pub type ino_t = u64;
+        pub type off_t = i64;
+        pub type blkcnt_t = i64;
+        pub type fsblkcnt_t = u64;
+        pub type fsfilcnt_t = u64;
+        pub type rlim_t = u64;
+        pub type blksize_t = i64;
+    } else {
+        pub type time_t = i32;
+        pub type suseconds_t = i32;
+        pub type ino_t = u32;
+        pub type off_t = i32;
+        pub type blkcnt_t = i32;
+        pub type fsblkcnt_t = ::c_ulong;
+        pub type fsfilcnt_t = ::c_ulong;
+        pub type rlim_t = c_ulong;
+        pub type blksize_t = i32;
+    }
+}
+
+s! {
+    pub struct stat {
+        #[cfg(not(target_arch = "mips"))]
+        pub st_dev: ::dev_t,
+        #[cfg(target_arch = "mips")]
+        pub st_dev: ::c_ulong,
+
+        #[cfg(not(target_arch = "mips"))]
+        __pad1: ::c_short,
+        #[cfg(target_arch = "mips")]
+        st_pad1: [::c_long; 3],
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        #[cfg(not(target_arch = "mips"))]
+        pub st_rdev: ::dev_t,
+        #[cfg(target_arch = "mips")]
+        pub st_rdev: ::c_ulong,
+        #[cfg(not(target_arch = "mips"))]
+        __pad2: ::c_short,
+        #[cfg(target_arch = "mips")]
+        st_pad2: [::c_long; 2],
+        pub st_size: ::off_t,
+        #[cfg(target_arch = "mips")]
+        st_pad3: ::c_long,
+        #[cfg(not(target_arch = "mips"))]
+        pub st_blksize: ::blksize_t,
+        #[cfg(not(target_arch = "mips"))]
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        #[cfg(not(target_arch = "mips"))]
+        __unused4: ::c_long,
+        #[cfg(not(target_arch = "mips"))]
+        __unused5: ::c_long,
+        #[cfg(target_arch = "mips")]
+        pub st_blksize: ::blksize_t,
+        #[cfg(target_arch = "mips")]
+        pub st_blocks: ::blkcnt_t,
+        #[cfg(target_arch = "mips")]
+        st_pad5: [::c_long; 14],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct pthread_attr_t {
+        __size: [u32; 9]
+    }
+
+    pub struct sigset_t {
+        __val: [::c_ulong; 32],
+    }
+
+    pub struct sysinfo {
+        pub uptime: ::c_long,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        #[deprecated(
+            since = "0.2.58",
+            note = "This padding field might become private in the future"
+        )]
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub _f: [::c_char; 8],
+    }
+
+    pub struct ip_mreqn {
+        pub imr_multiaddr: ::in_addr,
+        pub imr_address: ::in_addr,
+        pub imr_ifindex: ::c_int,
+    }
+}
+
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_TIMESTAMP: ::c_int = 29;
+
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 24;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+
+cfg_if! {
+    if #[cfg(target_arch = "sparc")] {
+        pub const O_NOATIME: ::c_int = 0x200000;
+        pub const O_PATH: ::c_int = 0x1000000;
+        pub const O_TMPFILE: ::c_int = 0x2000000 | O_DIRECTORY;
+        pub const SO_BINDTODEVICE: ::c_int = 0x000d;
+        pub const SO_MARK: ::c_int = 0x0022;
+        pub const SO_RXQ_OVFL: ::c_int = 0x0024;
+        pub const SO_PEEK_OFF: ::c_int = 0x0026;
+        pub const SO_BUSY_POLL: ::c_int = 0x0030;
+
+        pub const SA_ONSTACK: ::c_int = 1;
+
+        pub const PTRACE_DETACH: ::c_uint = 11;
+
+        pub const F_SETLK: ::c_int = 8;
+        pub const F_SETLKW: ::c_int = 9;
+
+        pub const F_RDLCK: ::c_int = 1;
+        pub const F_WRLCK: ::c_int = 2;
+        pub const F_UNLCK: ::c_int = 3;
+
+        pub const SFD_CLOEXEC: ::c_int = 0x400000;
+
+        pub const NCCS: usize = 17;
+
+        pub const O_TRUNC: ::c_int = 0x400;
+        pub const O_CLOEXEC: ::c_int = 0x400000;
+
+        pub const EBFONT: ::c_int = 109;
+        pub const ENOSTR: ::c_int = 72;
+        pub const ENODATA: ::c_int = 111;
+        pub const ETIME: ::c_int = 73;
+        pub const ENOSR: ::c_int = 74;
+        pub const ENONET: ::c_int = 80;
+        pub const ENOPKG: ::c_int = 113;
+        pub const EREMOTE: ::c_int = 71;
+        pub const ENOLINK: ::c_int = 82;
+        pub const EADV: ::c_int = 83;
+        pub const ESRMNT: ::c_int = 84;
+        pub const ECOMM: ::c_int = 85;
+        pub const EPROTO: ::c_int = 86;
+        pub const EDOTDOT: ::c_int = 88;
+
+        pub const SA_NODEFER: ::c_int = 0x20;
+        pub const SA_RESETHAND: ::c_int = 0x4;
+        pub const SA_RESTART: ::c_int = 0x2;
+        pub const SA_NOCLDSTOP: ::c_int = 0x00000008;
+
+        pub const EPOLL_CLOEXEC: ::c_int = 0x400000;
+
+        pub const EFD_CLOEXEC: ::c_int = 0x400000;
+    } else {
+        pub const O_NOATIME: ::c_int = 0o1000000;
+        pub const O_PATH: ::c_int = 0o10000000;
+        pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+        pub const SO_BINDTODEVICE: ::c_int = 25;
+        pub const SO_MARK: ::c_int = 36;
+        pub const SO_RXQ_OVFL: ::c_int = 40;
+        pub const SO_PEEK_OFF: ::c_int = 42;
+        pub const SO_BUSY_POLL: ::c_int = 46;
+
+        pub const SA_ONSTACK: ::c_int = 0x08000000;
+
+        pub const PTRACE_DETACH: ::c_uint = 17;
+
+        pub const F_SETLK: ::c_int = 6;
+        pub const F_SETLKW: ::c_int = 7;
+
+        pub const F_RDLCK: ::c_int = 0;
+        pub const F_WRLCK: ::c_int = 1;
+        pub const F_UNLCK: ::c_int = 2;
+
+        pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+        pub const NCCS: usize = 32;
+
+        pub const O_TRUNC: ::c_int = 512;
+        pub const O_CLOEXEC: ::c_int = 0x80000;
+        pub const EBFONT: ::c_int = 59;
+        pub const ENOSTR: ::c_int = 60;
+        pub const ENODATA: ::c_int = 61;
+        pub const ETIME: ::c_int = 62;
+        pub const ENOSR: ::c_int = 63;
+        pub const ENONET: ::c_int = 64;
+        pub const ENOPKG: ::c_int = 65;
+        pub const EREMOTE: ::c_int = 66;
+        pub const ENOLINK: ::c_int = 67;
+        pub const EADV: ::c_int = 68;
+        pub const ESRMNT: ::c_int = 69;
+        pub const ECOMM: ::c_int = 70;
+        pub const EPROTO: ::c_int = 71;
+        pub const EDOTDOT: ::c_int = 73;
+
+        pub const SA_NODEFER: ::c_int = 0x40000000;
+        pub const SA_RESETHAND: ::c_int = 0x80000000;
+        pub const SA_RESTART: ::c_int = 0x10000000;
+        pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+        pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+        pub const EFD_CLOEXEC: ::c_int = 0x80000;
+    }
+}
+
+align_const! {
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
+                0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,
+                0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
+                0, 0, 0,
+            ],
+        };
+}
+
+pub const PTRACE_GETFPREGS: ::c_uint = 14;
+pub const PTRACE_SETFPREGS: ::c_uint = 15;
+pub const PTRACE_GETREGS: ::c_uint = 12;
+pub const PTRACE_SETREGS: ::c_uint = 13;
+
+pub const TIOCSBRK: ::c_int = 0x5427;
+pub const TIOCCBRK: ::c_int = 0x5428;
+
+extern "C" {
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_int,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "x86")] {
+        mod x86;
+        pub use self::x86::*;
+    } else if #[cfg(target_arch = "arm")] {
+        mod arm;
+        pub use self::arm::*;
+    } else if #[cfg(target_arch = "mips")] {
+        mod mips;
+        pub use self::mips::*;
+    } else if #[cfg(target_arch = "powerpc")] {
+        mod powerpc;
+        pub use self::powerpc::*;
+    } else if #[cfg(target_arch = "sparc")] {
+        mod sparc;
+        pub use self::sparc::*;
+    } else if #[cfg(target_arch = "riscv32")] {
+        mod riscv32;
+        pub use self::riscv32::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/powerpc.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/powerpc.rs
new file mode 100644
index 00000000..c22b7924
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/powerpc.rs
@@ -0,0 +1,876 @@
+pub type c_char = u8;
+pub type wchar_t = i32;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statfs {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        f_spare: [::__fsword_t; 5],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct ipc_perm {
+        __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        __seq: u32,
+        __pad1: u32,
+        __glibc_reserved1: u64,
+        __glibc_reserved2: u64,
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad2: ::c_ushort,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __glibc_reserved4: ::c_ulong,
+        __glibc_reserved5: ::c_ulong,
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        pub f_flags: ::__fsword_t,
+        pub f_spare: [::__fsword_t; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        __glibc_reserved1: ::c_uint,
+        pub shm_atime: ::time_t,
+        __glibc_reserved2: ::c_uint,
+        pub shm_dtime: ::time_t,
+        __glibc_reserved3: ::c_uint,
+        pub shm_ctime: ::time_t,
+        __glibc_reserved4: ::c_uint,
+        pub shm_segsz: ::size_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __glibc_reserved5: ::c_ulong,
+        __glibc_reserved6: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        __glibc_reserved1: ::c_uint,
+        pub msg_stime: ::time_t,
+        __glibc_reserved2: ::c_uint,
+        pub msg_rtime: ::time_t,
+        __glibc_reserved3: ::c_uint,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved4: ::c_ulong,
+        __glibc_reserved5: ::c_ulong,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+}
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const O_DIRECT: ::c_int = 0x20000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_LARGEFILE: ::c_int = 0o200000;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 0x101000;
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_NDELAY: ::c_int = 0x800;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_LOCKED: ::c_int = 0x00080;
+pub const MAP_NORESERVE: ::c_int = 0x00040;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const EDEADLOCK: ::c_int = 58;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_RCVLOWAT: ::c_int = 16;
+pub const SO_SNDLOWAT: ::c_int = 17;
+pub const SO_RCVTIMEO: ::c_int = 18;
+pub const SO_SNDTIMEO: ::c_int = 19;
+pub const SO_PASSCRED: ::c_int = 20;
+pub const SO_PEERCRED: ::c_int = 21;
+
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const FIOCLEX: ::c_ulong = 0x20006601;
+pub const FIONCLEX: ::c_ulong = 0x20006602;
+pub const FIONBIO: ::c_ulong = 0x8004667e;
+
+pub const MCL_CURRENT: ::c_int = 0x2000;
+pub const MCL_FUTURE: ::c_int = 0x4000;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+pub const SFD_NONBLOCK: ::c_int = 0x0800;
+
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5419;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x541A;
+pub const TIOCEXCL: ::c_ulong = 0x540C;
+pub const TIOCNXCL: ::c_ulong = 0x540D;
+pub const TIOCSCTTY: ::c_ulong = 0x540E;
+pub const TIOCSTI: ::c_ulong = 0x5412;
+pub const TIOCMGET: ::c_ulong = 0x5415;
+pub const TIOCMBIS: ::c_ulong = 0x5416;
+pub const TIOCMBIC: ::c_ulong = 0x5417;
+pub const TIOCMSET: ::c_ulong = 0x5418;
+pub const TIOCCONS: ::c_ulong = 0x541D;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = 31;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGSTKSZ: ::size_t = 0x4000;
+pub const MINSIGSTKSZ: ::size_t = 4096;
+pub const CBAUD: ::tcflag_t = 0xff;
+pub const TAB1: ::tcflag_t = 0x400;
+pub const TAB2: ::tcflag_t = 0x800;
+pub const TAB3: ::tcflag_t = 0xc00;
+pub const CR1: ::tcflag_t = 0x1000;
+pub const CR2: ::tcflag_t = 0x2000;
+pub const CR3: ::tcflag_t = 0x3000;
+pub const FF1: ::tcflag_t = 0x4000;
+pub const BS1: ::tcflag_t = 0x8000;
+pub const VT1: ::tcflag_t = 0x10000;
+pub const VWERASE: usize = 0xa;
+pub const VREPRINT: usize = 0xb;
+pub const VSUSP: usize = 0xc;
+pub const VSTART: usize = 0xd;
+pub const VSTOP: usize = 0xe;
+pub const VDISCARD: usize = 0x10;
+pub const VTIME: usize = 0x7;
+pub const IXON: ::tcflag_t = 0x200;
+pub const IXOFF: ::tcflag_t = 0x400;
+pub const ONLCR: ::tcflag_t = 0x2;
+pub const CSIZE: ::tcflag_t = 0x300;
+pub const CS6: ::tcflag_t = 0x100;
+pub const CS7: ::tcflag_t = 0x200;
+pub const CS8: ::tcflag_t = 0x300;
+pub const CSTOPB: ::tcflag_t = 0x400;
+pub const CREAD: ::tcflag_t = 0x800;
+pub const PARENB: ::tcflag_t = 0x1000;
+pub const PARODD: ::tcflag_t = 0x2000;
+pub const HUPCL: ::tcflag_t = 0x4000;
+pub const CLOCAL: ::tcflag_t = 0x8000;
+pub const ECHOKE: ::tcflag_t = 0x1;
+pub const ECHOE: ::tcflag_t = 0x2;
+pub const ECHOK: ::tcflag_t = 0x4;
+pub const ECHONL: ::tcflag_t = 0x10;
+pub const ECHOPRT: ::tcflag_t = 0x20;
+pub const ECHOCTL: ::tcflag_t = 0x40;
+pub const ISIG: ::tcflag_t = 0x80;
+pub const ICANON: ::tcflag_t = 0x100;
+pub const PENDIN: ::tcflag_t = 0x20000000;
+pub const NOFLSH: ::tcflag_t = 0x80000000;
+pub const VSWTC: usize = 9;
+pub const OLCUC: ::tcflag_t = 0o000004;
+pub const NLDLY: ::tcflag_t = 0o001400;
+pub const CRDLY: ::tcflag_t = 0o030000;
+pub const TABDLY: ::tcflag_t = 0o006000;
+pub const BSDLY: ::tcflag_t = 0o100000;
+pub const FFDLY: ::tcflag_t = 0o040000;
+pub const VTDLY: ::tcflag_t = 0o200000;
+pub const XTABS: ::tcflag_t = 0o006000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const CBAUDEX: ::speed_t = 0o000020;
+pub const B57600: ::speed_t = 0o0020;
+pub const B115200: ::speed_t = 0o0021;
+pub const B230400: ::speed_t = 0o0022;
+pub const B460800: ::speed_t = 0o0023;
+pub const B500000: ::speed_t = 0o0024;
+pub const B576000: ::speed_t = 0o0025;
+pub const B921600: ::speed_t = 0o0026;
+pub const B1000000: ::speed_t = 0o0027;
+pub const B1152000: ::speed_t = 0o0030;
+pub const B1500000: ::speed_t = 0o0031;
+pub const B2000000: ::speed_t = 0o0032;
+pub const B2500000: ::speed_t = 0o0033;
+pub const B3000000: ::speed_t = 0o0034;
+pub const B3500000: ::speed_t = 0o0035;
+pub const B4000000: ::speed_t = 0o0036;
+pub const BOTHER: ::speed_t = 0o0037;
+
+pub const VEOL: usize = 6;
+pub const VEOL2: usize = 8;
+pub const VMIN: usize = 5;
+pub const IEXTEN: ::tcflag_t = 0x400;
+pub const TOSTOP: ::tcflag_t = 0x400000;
+pub const FLUSHO: ::tcflag_t = 0x800000;
+pub const EXTPROC: ::tcflag_t = 0x10000000;
+pub const TCGETS: ::c_ulong = 0x403c7413;
+pub const TCSETS: ::c_ulong = 0x803c7414;
+pub const TCSETSW: ::c_ulong = 0x803c7415;
+pub const TCSETSF: ::c_ulong = 0x803c7416;
+pub const TCGETA: ::c_ulong = 0x40147417;
+pub const TCSETA: ::c_ulong = 0x80147418;
+pub const TCSETAW: ::c_ulong = 0x80147419;
+pub const TCSETAF: ::c_ulong = 0x8014741c;
+pub const TCSBRK: ::c_ulong = 0x2000741d;
+pub const TCXONC: ::c_ulong = 0x2000741e;
+pub const TCFLSH: ::c_ulong = 0x2000741f;
+pub const TIOCINQ: ::c_ulong = 0x4004667f;
+pub const TIOCGPGRP: ::c_ulong = 0x40047477;
+pub const TIOCSPGRP: ::c_ulong = 0x80047476;
+pub const TIOCOUTQ: ::c_ulong = 0x40047473;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const TIOCGRS485: ::c_int = 0x542e;
+pub const TIOCSRS485: ::c_int = 0x542f;
+pub const FIONREAD: ::c_ulong = 0x4004667f;
+
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_waitpid: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_time: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_break: ::c_long = 17;
+pub const SYS_oldstat: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_umount: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_stime: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_oldfstat: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_stty: ::c_long = 31;
+pub const SYS_gtty: ::c_long = 32;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_ftime: ::c_long = 35;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_prof: ::c_long = 44;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_lock: ::c_long = 53;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_mpx: ::c_long = 56;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_ulimit: ::c_long = 58;
+pub const SYS_oldolduname: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_sgetmask: ::c_long = 68;
+pub const SYS_ssetmask: ::c_long = 69;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrlimit: ::c_long = 76;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_select: ::c_long = 82;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_oldlstat: ::c_long = 84;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_readdir: ::c_long = 89;
+pub const SYS_mmap: ::c_long = 90;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_profil: ::c_long = 98;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_ioperm: ::c_long = 101;
+pub const SYS_socketcall: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_olduname: ::c_long = 109;
+pub const SYS_iopl: ::c_long = 110;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_idle: ::c_long = 112;
+pub const SYS_vm86: ::c_long = 113;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_ipc: ::c_long = 117;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_modify_ldt: ::c_long = 123;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_create_module: ::c_long = 127;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_get_kernel_syms: ::c_long = 130;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_afs_syscall: ::c_long = 137; /* Syscall for Andrew File System */
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_query_module: ::c_long = 166;
+pub const SYS_poll: ::c_long = 167;
+pub const SYS_nfsservctl: ::c_long = 168;
+pub const SYS_setresgid: ::c_long = 169;
+pub const SYS_getresgid: ::c_long = 170;
+pub const SYS_prctl: ::c_long = 171;
+pub const SYS_rt_sigreturn: ::c_long = 172;
+pub const SYS_rt_sigaction: ::c_long = 173;
+pub const SYS_rt_sigprocmask: ::c_long = 174;
+pub const SYS_rt_sigpending: ::c_long = 175;
+pub const SYS_rt_sigtimedwait: ::c_long = 176;
+pub const SYS_rt_sigqueueinfo: ::c_long = 177;
+pub const SYS_rt_sigsuspend: ::c_long = 178;
+pub const SYS_pread64: ::c_long = 179;
+pub const SYS_pwrite64: ::c_long = 180;
+pub const SYS_chown: ::c_long = 181;
+pub const SYS_getcwd: ::c_long = 182;
+pub const SYS_capget: ::c_long = 183;
+pub const SYS_capset: ::c_long = 184;
+pub const SYS_sigaltstack: ::c_long = 185;
+pub const SYS_sendfile: ::c_long = 186;
+pub const SYS_getpmsg: ::c_long = 187; /* some people actually want streams */
+pub const SYS_putpmsg: ::c_long = 188; /* some people actually want streams */
+pub const SYS_vfork: ::c_long = 189;
+pub const SYS_ugetrlimit: ::c_long = 190; /* SuS compliant getrlimit */
+pub const SYS_readahead: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_pciconfig_read: ::c_long = 198;
+pub const SYS_pciconfig_write: ::c_long = 199;
+pub const SYS_pciconfig_iobase: ::c_long = 200;
+pub const SYS_multiplexer: ::c_long = 201;
+pub const SYS_getdents64: ::c_long = 202;
+pub const SYS_pivot_root: ::c_long = 203;
+pub const SYS_fcntl64: ::c_long = 204;
+pub const SYS_madvise: ::c_long = 205;
+pub const SYS_mincore: ::c_long = 206;
+pub const SYS_gettid: ::c_long = 207;
+pub const SYS_tkill: ::c_long = 208;
+pub const SYS_setxattr: ::c_long = 209;
+pub const SYS_lsetxattr: ::c_long = 210;
+pub const SYS_fsetxattr: ::c_long = 211;
+pub const SYS_getxattr: ::c_long = 212;
+pub const SYS_lgetxattr: ::c_long = 213;
+pub const SYS_fgetxattr: ::c_long = 214;
+pub const SYS_listxattr: ::c_long = 215;
+pub const SYS_llistxattr: ::c_long = 216;
+pub const SYS_flistxattr: ::c_long = 217;
+pub const SYS_removexattr: ::c_long = 218;
+pub const SYS_lremovexattr: ::c_long = 219;
+pub const SYS_fremovexattr: ::c_long = 220;
+pub const SYS_futex: ::c_long = 221;
+pub const SYS_sched_setaffinity: ::c_long = 222;
+pub const SYS_sched_getaffinity: ::c_long = 223;
+pub const SYS_tuxcall: ::c_long = 225;
+pub const SYS_sendfile64: ::c_long = 226;
+pub const SYS_io_setup: ::c_long = 227;
+pub const SYS_io_destroy: ::c_long = 228;
+pub const SYS_io_getevents: ::c_long = 229;
+pub const SYS_io_submit: ::c_long = 230;
+pub const SYS_io_cancel: ::c_long = 231;
+pub const SYS_set_tid_address: ::c_long = 232;
+pub const SYS_fadvise64: ::c_long = 233;
+pub const SYS_exit_group: ::c_long = 234;
+pub const SYS_lookup_dcookie: ::c_long = 235;
+pub const SYS_epoll_create: ::c_long = 236;
+pub const SYS_epoll_ctl: ::c_long = 237;
+pub const SYS_epoll_wait: ::c_long = 238;
+pub const SYS_remap_file_pages: ::c_long = 239;
+pub const SYS_timer_create: ::c_long = 240;
+pub const SYS_timer_settime: ::c_long = 241;
+pub const SYS_timer_gettime: ::c_long = 242;
+pub const SYS_timer_getoverrun: ::c_long = 243;
+pub const SYS_timer_delete: ::c_long = 244;
+pub const SYS_clock_settime: ::c_long = 245;
+pub const SYS_clock_gettime: ::c_long = 246;
+pub const SYS_clock_getres: ::c_long = 247;
+pub const SYS_clock_nanosleep: ::c_long = 248;
+pub const SYS_swapcontext: ::c_long = 249;
+pub const SYS_tgkill: ::c_long = 250;
+pub const SYS_utimes: ::c_long = 251;
+pub const SYS_statfs64: ::c_long = 252;
+pub const SYS_fstatfs64: ::c_long = 253;
+pub const SYS_fadvise64_64: ::c_long = 254;
+pub const SYS_rtas: ::c_long = 255;
+pub const SYS_sys_debug_setcontext: ::c_long = 256;
+pub const SYS_migrate_pages: ::c_long = 258;
+pub const SYS_mbind: ::c_long = 259;
+pub const SYS_get_mempolicy: ::c_long = 260;
+pub const SYS_set_mempolicy: ::c_long = 261;
+pub const SYS_mq_open: ::c_long = 262;
+pub const SYS_mq_unlink: ::c_long = 263;
+pub const SYS_mq_timedsend: ::c_long = 264;
+pub const SYS_mq_timedreceive: ::c_long = 265;
+pub const SYS_mq_notify: ::c_long = 266;
+pub const SYS_mq_getsetattr: ::c_long = 267;
+pub const SYS_kexec_load: ::c_long = 268;
+pub const SYS_add_key: ::c_long = 269;
+pub const SYS_request_key: ::c_long = 270;
+pub const SYS_keyctl: ::c_long = 271;
+pub const SYS_waitid: ::c_long = 272;
+pub const SYS_ioprio_set: ::c_long = 273;
+pub const SYS_ioprio_get: ::c_long = 274;
+pub const SYS_inotify_init: ::c_long = 275;
+pub const SYS_inotify_add_watch: ::c_long = 276;
+pub const SYS_inotify_rm_watch: ::c_long = 277;
+pub const SYS_spu_run: ::c_long = 278;
+pub const SYS_spu_create: ::c_long = 279;
+pub const SYS_pselect6: ::c_long = 280;
+pub const SYS_ppoll: ::c_long = 281;
+pub const SYS_unshare: ::c_long = 282;
+pub const SYS_splice: ::c_long = 283;
+pub const SYS_tee: ::c_long = 284;
+pub const SYS_vmsplice: ::c_long = 285;
+pub const SYS_openat: ::c_long = 286;
+pub const SYS_mkdirat: ::c_long = 287;
+pub const SYS_mknodat: ::c_long = 288;
+pub const SYS_fchownat: ::c_long = 289;
+pub const SYS_futimesat: ::c_long = 290;
+pub const SYS_fstatat64: ::c_long = 291;
+pub const SYS_unlinkat: ::c_long = 292;
+pub const SYS_renameat: ::c_long = 293;
+pub const SYS_linkat: ::c_long = 294;
+pub const SYS_symlinkat: ::c_long = 295;
+pub const SYS_readlinkat: ::c_long = 296;
+pub const SYS_fchmodat: ::c_long = 297;
+pub const SYS_faccessat: ::c_long = 298;
+pub const SYS_get_robust_list: ::c_long = 299;
+pub const SYS_set_robust_list: ::c_long = 300;
+pub const SYS_move_pages: ::c_long = 301;
+pub const SYS_getcpu: ::c_long = 302;
+pub const SYS_epoll_pwait: ::c_long = 303;
+pub const SYS_utimensat: ::c_long = 304;
+pub const SYS_signalfd: ::c_long = 305;
+pub const SYS_timerfd_create: ::c_long = 306;
+pub const SYS_eventfd: ::c_long = 307;
+pub const SYS_sync_file_range2: ::c_long = 308;
+pub const SYS_fallocate: ::c_long = 309;
+pub const SYS_subpage_prot: ::c_long = 310;
+pub const SYS_timerfd_settime: ::c_long = 311;
+pub const SYS_timerfd_gettime: ::c_long = 312;
+pub const SYS_signalfd4: ::c_long = 313;
+pub const SYS_eventfd2: ::c_long = 314;
+pub const SYS_epoll_create1: ::c_long = 315;
+pub const SYS_dup3: ::c_long = 316;
+pub const SYS_pipe2: ::c_long = 317;
+pub const SYS_inotify_init1: ::c_long = 318;
+pub const SYS_perf_event_open: ::c_long = 319;
+pub const SYS_preadv: ::c_long = 320;
+pub const SYS_pwritev: ::c_long = 321;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 322;
+pub const SYS_fanotify_init: ::c_long = 323;
+pub const SYS_fanotify_mark: ::c_long = 324;
+pub const SYS_prlimit64: ::c_long = 325;
+pub const SYS_socket: ::c_long = 326;
+pub const SYS_bind: ::c_long = 327;
+pub const SYS_connect: ::c_long = 328;
+pub const SYS_listen: ::c_long = 329;
+pub const SYS_accept: ::c_long = 330;
+pub const SYS_getsockname: ::c_long = 331;
+pub const SYS_getpeername: ::c_long = 332;
+pub const SYS_socketpair: ::c_long = 333;
+pub const SYS_send: ::c_long = 334;
+pub const SYS_sendto: ::c_long = 335;
+pub const SYS_recv: ::c_long = 336;
+pub const SYS_recvfrom: ::c_long = 337;
+pub const SYS_shutdown: ::c_long = 338;
+pub const SYS_setsockopt: ::c_long = 339;
+pub const SYS_getsockopt: ::c_long = 340;
+pub const SYS_sendmsg: ::c_long = 341;
+pub const SYS_recvmsg: ::c_long = 342;
+pub const SYS_recvmmsg: ::c_long = 343;
+pub const SYS_accept4: ::c_long = 344;
+pub const SYS_name_to_handle_at: ::c_long = 345;
+pub const SYS_open_by_handle_at: ::c_long = 346;
+pub const SYS_clock_adjtime: ::c_long = 347;
+pub const SYS_syncfs: ::c_long = 348;
+pub const SYS_sendmmsg: ::c_long = 349;
+pub const SYS_setns: ::c_long = 350;
+pub const SYS_process_vm_readv: ::c_long = 351;
+pub const SYS_process_vm_writev: ::c_long = 352;
+pub const SYS_finit_module: ::c_long = 353;
+pub const SYS_kcmp: ::c_long = 354;
+pub const SYS_sched_setattr: ::c_long = 355;
+pub const SYS_sched_getattr: ::c_long = 356;
+pub const SYS_renameat2: ::c_long = 357;
+pub const SYS_seccomp: ::c_long = 358;
+pub const SYS_getrandom: ::c_long = 359;
+pub const SYS_memfd_create: ::c_long = 360;
+pub const SYS_bpf: ::c_long = 361;
+pub const SYS_execveat: ::c_long = 362;
+pub const SYS_switch_endian: ::c_long = 363;
+pub const SYS_userfaultfd: ::c_long = 364;
+pub const SYS_membarrier: ::c_long = 365;
+pub const SYS_mlock2: ::c_long = 378;
+pub const SYS_copy_file_range: ::c_long = 379;
+pub const SYS_preadv2: ::c_long = 380;
+pub const SYS_pwritev2: ::c_long = 381;
+pub const SYS_kexec_file_load: ::c_long = 382;
+pub const SYS_statx: ::c_long = 383;
+pub const SYS_pidfd_open: ::c_long = 434;
+pub const SYS_clone3: ::c_long = 435;
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/riscv32/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/riscv32/mod.rs
new file mode 100644
index 00000000..1732c231
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/riscv32/mod.rs
@@ -0,0 +1,820 @@
+//! RISC-V-specific definitions for 32-bit linux-like values
+
+pub type c_char = u8;
+pub type wchar_t = ::c_int;
+
+s! {
+    pub struct pthread_attr_t {
+        __size: [::c_ulong; 7],
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        pub msg_rtime: ::time_t,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved4: ::c_ulong,
+        __glibc_reserved5: ::c_ulong,
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub __pad1: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub __pad2: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_int; 2usize],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub __pad1: ::dev_t,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub __pad2: ::c_int,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_int; 2],
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_flags: ::c_long,
+        pub f_spare: [::c_long; 4],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_blocks: ::fsblkcnt64_t,
+        pub f_bfree: ::fsblkcnt64_t,
+        pub f_bavail: ::fsblkcnt64_t,
+        pub f_files: ::fsfilcnt64_t,
+        pub f_ffree: ::fsfilcnt64_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_flags: ::c_long,
+        pub f_spare: [::c_long; 4],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        pub __f_spare: [::c_int; 6],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt64_t,
+        pub f_bfree: ::fsblkcnt64_t,
+        pub f_bavail: ::fsblkcnt64_t,
+        pub f_files: ::fsfilcnt64_t,
+        pub f_ffree: ::fsfilcnt64_t,
+        pub f_favail: ::fsfilcnt64_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        pub __f_spare: [::c_int; 6],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [u64; 0],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t,
+    }
+
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<unsafe extern "C" fn()>,
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_ushort,
+        __pad1: ::c_ushort,
+        pub __seq: ::c_ushort,
+        __pad2: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused5: ::c_ulong,
+        __unused6: ::c_ulong,
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+}
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const TIOCGSOFTCAR: ::c_ulong = 21529;
+pub const TIOCSSOFTCAR: ::c_ulong = 21530;
+pub const TIOCGRS485: ::c_int = 21550;
+pub const TIOCSRS485: ::c_int = 21551;
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 1052672;
+pub const MAP_GROWSDOWN: ::c_int = 256;
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = 26;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PEERSEC: ::c_int = 31;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = 35;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = 41;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = 27;
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SA_SIGINFO: ::c_int = 4;
+pub const SA_NOCLDWAIT: ::c_int = 2;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0;
+pub const SIG_UNBLOCK: ::c_int = 1;
+pub const POLLWRNORM: ::c_short = 256;
+pub const POLLWRBAND: ::c_short = 512;
+pub const O_ASYNC: ::c_int = 8192;
+pub const O_NDELAY: ::c_int = 2048;
+pub const EFD_NONBLOCK: ::c_int = 2048;
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+pub const SFD_NONBLOCK: ::c_int = 2048;
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+pub const TIOCLINUX: ::c_ulong = 21532;
+pub const TIOCGSERIAL: ::c_ulong = 21534;
+pub const TIOCEXCL: ::c_ulong = 21516;
+pub const TIOCNXCL: ::c_ulong = 21517;
+pub const TIOCSCTTY: ::c_ulong = 21518;
+pub const TIOCSTI: ::c_ulong = 21522;
+pub const TIOCMGET: ::c_ulong = 21525;
+pub const TIOCMBIS: ::c_ulong = 21526;
+pub const TIOCMBIC: ::c_ulong = 21527;
+pub const TIOCMSET: ::c_ulong = 21528;
+pub const TIOCCONS: ::c_ulong = 21533;
+pub const TIOCM_ST: ::c_int = 8;
+pub const TIOCM_SR: ::c_int = 16;
+pub const TIOCM_CTS: ::c_int = 32;
+pub const TIOCM_CAR: ::c_int = 64;
+pub const TIOCM_RNG: ::c_int = 128;
+pub const TIOCM_DSR: ::c_int = 256;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const O_DIRECT: ::c_int = 16384;
+pub const O_DIRECTORY: ::c_int = 65536;
+pub const O_NOFOLLOW: ::c_int = 131072;
+pub const MAP_HUGETLB: ::c_int = 262144;
+pub const MAP_LOCKED: ::c_int = 8192;
+pub const MAP_NORESERVE: ::c_int = 16384;
+pub const MAP_ANON: ::c_int = 32;
+pub const MAP_ANONYMOUS: ::c_int = 32;
+pub const MAP_DENYWRITE: ::c_int = 2048;
+pub const MAP_EXECUTABLE: ::c_int = 4096;
+pub const MAP_POPULATE: ::c_int = 32768;
+pub const MAP_NONBLOCK: ::c_int = 65536;
+pub const MAP_STACK: ::c_int = 131072;
+pub const MAP_SYNC: ::c_int = 0x080000;
+pub const EDEADLOCK: ::c_int = 35;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const FIOCLEX: ::c_ulong = 21585;
+pub const FIONCLEX: ::c_ulong = 21584;
+pub const FIONBIO: ::c_ulong = 21537;
+pub const MCL_CURRENT: ::c_int = 1;
+pub const MCL_FUTURE: ::c_int = 2;
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const CBAUD: ::tcflag_t = 4111;
+pub const TAB1: ::tcflag_t = 2048;
+pub const TAB2: ::tcflag_t = 4096;
+pub const TAB3: ::tcflag_t = 6144;
+pub const CR1: ::tcflag_t = 512;
+pub const CR2: ::tcflag_t = 1024;
+pub const CR3: ::tcflag_t = 1536;
+pub const FF1: ::tcflag_t = 32768;
+pub const BS1: ::tcflag_t = 8192;
+pub const VT1: ::tcflag_t = 16384;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 1024;
+pub const IXOFF: ::tcflag_t = 4096;
+pub const ONLCR: ::tcflag_t = 4;
+pub const CSIZE: ::tcflag_t = 48;
+pub const CS6: ::tcflag_t = 16;
+pub const CS7: ::tcflag_t = 32;
+pub const CS8: ::tcflag_t = 48;
+pub const CSTOPB: ::tcflag_t = 64;
+pub const CREAD: ::tcflag_t = 128;
+pub const PARENB: ::tcflag_t = 256;
+pub const PARODD: ::tcflag_t = 512;
+pub const HUPCL: ::tcflag_t = 1024;
+pub const CLOCAL: ::tcflag_t = 2048;
+pub const ECHOKE: ::tcflag_t = 2048;
+pub const ECHOE: ::tcflag_t = 16;
+pub const ECHOK: ::tcflag_t = 32;
+pub const ECHONL: ::tcflag_t = 64;
+pub const ECHOPRT: ::tcflag_t = 1024;
+pub const ECHOCTL: ::tcflag_t = 512;
+pub const ISIG: ::tcflag_t = 1;
+pub const ICANON: ::tcflag_t = 2;
+pub const PENDIN: ::tcflag_t = 16384;
+pub const NOFLSH: ::tcflag_t = 128;
+pub const CIBAUD: ::tcflag_t = 269418496;
+pub const CBAUDEX: ::tcflag_t = 4096;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 2;
+pub const NLDLY: ::tcflag_t = 256;
+pub const CRDLY: ::tcflag_t = 1536;
+pub const TABDLY: ::tcflag_t = 6144;
+pub const BSDLY: ::tcflag_t = 8192;
+pub const FFDLY: ::tcflag_t = 32768;
+pub const VTDLY: ::tcflag_t = 16384;
+pub const XTABS: ::tcflag_t = 6144;
+pub const B0: ::speed_t = 0;
+pub const B50: ::speed_t = 1;
+pub const B75: ::speed_t = 2;
+pub const B110: ::speed_t = 3;
+pub const B134: ::speed_t = 4;
+pub const B150: ::speed_t = 5;
+pub const B200: ::speed_t = 6;
+pub const B300: ::speed_t = 7;
+pub const B600: ::speed_t = 8;
+pub const B1200: ::speed_t = 9;
+pub const B1800: ::speed_t = 10;
+pub const B2400: ::speed_t = 11;
+pub const B4800: ::speed_t = 12;
+pub const B9600: ::speed_t = 13;
+pub const B19200: ::speed_t = 14;
+pub const B38400: ::speed_t = 15;
+pub const EXTA: ::speed_t = 14;
+pub const EXTB: ::speed_t = 15;
+pub const B57600: ::speed_t = 4097;
+pub const B115200: ::speed_t = 4098;
+pub const B230400: ::speed_t = 4099;
+pub const B460800: ::speed_t = 4100;
+pub const B500000: ::speed_t = 4101;
+pub const B576000: ::speed_t = 4102;
+pub const B921600: ::speed_t = 4103;
+pub const B1000000: ::speed_t = 4104;
+pub const B1152000: ::speed_t = 4105;
+pub const B1500000: ::speed_t = 4106;
+pub const B2000000: ::speed_t = 4107;
+pub const B2500000: ::speed_t = 4108;
+pub const B3000000: ::speed_t = 4109;
+pub const B3500000: ::speed_t = 4110;
+pub const B4000000: ::speed_t = 4111;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 32768;
+pub const TOSTOP: ::tcflag_t = 256;
+pub const FLUSHO: ::tcflag_t = 4096;
+pub const EXTPROC: ::tcflag_t = 65536;
+pub const TCGETS: ::c_ulong = 21505;
+pub const TCSETS: ::c_ulong = 21506;
+pub const TCSETSW: ::c_ulong = 21507;
+pub const TCSETSF: ::c_ulong = 21508;
+pub const TCGETA: ::c_ulong = 21509;
+pub const TCSETA: ::c_ulong = 21510;
+pub const TCSETAW: ::c_ulong = 21511;
+pub const TCSETAF: ::c_ulong = 21512;
+pub const TCSBRK: ::c_ulong = 21513;
+pub const TCXONC: ::c_ulong = 21514;
+pub const TCFLSH: ::c_ulong = 21515;
+pub const TIOCINQ: ::c_ulong = 21531;
+pub const TIOCGPGRP: ::c_ulong = 21519;
+pub const TIOCSPGRP: ::c_ulong = 21520;
+pub const TIOCOUTQ: ::c_ulong = 21521;
+pub const TIOCGWINSZ: ::c_ulong = 21523;
+pub const TIOCSWINSZ: ::c_ulong = 21524;
+pub const FIONREAD: ::c_ulong = 21531;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+pub const SYS_read: ::c_long = 63;
+pub const SYS_write: ::c_long = 64;
+pub const SYS_close: ::c_long = 57;
+pub const SYS_fstat: ::c_long = 80;
+pub const SYS_lseek: ::c_long = 62;
+pub const SYS_mmap: ::c_long = 222;
+pub const SYS_mprotect: ::c_long = 226;
+pub const SYS_munmap: ::c_long = 215;
+pub const SYS_brk: ::c_long = 214;
+pub const SYS_rt_sigaction: ::c_long = 134;
+pub const SYS_rt_sigprocmask: ::c_long = 135;
+pub const SYS_rt_sigreturn: ::c_long = 139;
+pub const SYS_ioctl: ::c_long = 29;
+pub const SYS_pread64: ::c_long = 67;
+pub const SYS_pwrite64: ::c_long = 68;
+pub const SYS_readv: ::c_long = 65;
+pub const SYS_writev: ::c_long = 66;
+pub const SYS_sched_yield: ::c_long = 124;
+pub const SYS_mremap: ::c_long = 216;
+pub const SYS_msync: ::c_long = 227;
+pub const SYS_mincore: ::c_long = 232;
+pub const SYS_madvise: ::c_long = 233;
+pub const SYS_shmget: ::c_long = 194;
+pub const SYS_shmat: ::c_long = 196;
+pub const SYS_shmctl: ::c_long = 195;
+pub const SYS_dup: ::c_long = 23;
+pub const SYS_nanosleep: ::c_long = 101;
+pub const SYS_getitimer: ::c_long = 102;
+pub const SYS_setitimer: ::c_long = 103;
+pub const SYS_getpid: ::c_long = 172;
+pub const SYS_sendfile: ::c_long = 71;
+pub const SYS_socket: ::c_long = 198;
+pub const SYS_connect: ::c_long = 203;
+pub const SYS_accept: ::c_long = 202;
+pub const SYS_sendto: ::c_long = 206;
+pub const SYS_recvfrom: ::c_long = 207;
+pub const SYS_sendmsg: ::c_long = 211;
+pub const SYS_recvmsg: ::c_long = 212;
+pub const SYS_shutdown: ::c_long = 210;
+pub const SYS_bind: ::c_long = 200;
+pub const SYS_listen: ::c_long = 201;
+pub const SYS_getsockname: ::c_long = 204;
+pub const SYS_getpeername: ::c_long = 205;
+pub const SYS_socketpair: ::c_long = 199;
+pub const SYS_setsockopt: ::c_long = 208;
+pub const SYS_getsockopt: ::c_long = 209;
+pub const SYS_clone: ::c_long = 220;
+pub const SYS_execve: ::c_long = 221;
+pub const SYS_exit: ::c_long = 93;
+pub const SYS_wait4: ::c_long = 260;
+pub const SYS_kill: ::c_long = 129;
+pub const SYS_uname: ::c_long = 160;
+pub const SYS_semget: ::c_long = 190;
+pub const SYS_semop: ::c_long = 193;
+pub const SYS_semctl: ::c_long = 191;
+pub const SYS_shmdt: ::c_long = 197;
+pub const SYS_msgget: ::c_long = 186;
+pub const SYS_msgsnd: ::c_long = 189;
+pub const SYS_msgrcv: ::c_long = 188;
+pub const SYS_msgctl: ::c_long = 187;
+pub const SYS_fcntl: ::c_long = 25;
+pub const SYS_flock: ::c_long = 32;
+pub const SYS_fsync: ::c_long = 82;
+pub const SYS_fdatasync: ::c_long = 83;
+pub const SYS_truncate: ::c_long = 45;
+pub const SYS_ftruncate: ::c_long = 46;
+pub const SYS_getcwd: ::c_long = 17;
+pub const SYS_chdir: ::c_long = 49;
+pub const SYS_fchdir: ::c_long = 50;
+pub const SYS_fchmod: ::c_long = 52;
+pub const SYS_fchown: ::c_long = 55;
+pub const SYS_umask: ::c_long = 166;
+pub const SYS_gettimeofday: ::c_long = 169;
+pub const SYS_getrlimit: ::c_long = 163;
+pub const SYS_getrusage: ::c_long = 165;
+pub const SYS_sysinfo: ::c_long = 179;
+pub const SYS_times: ::c_long = 153;
+pub const SYS_ptrace: ::c_long = 117;
+pub const SYS_getuid: ::c_long = 174;
+pub const SYS_syslog: ::c_long = 116;
+pub const SYS_getgid: ::c_long = 176;
+pub const SYS_setuid: ::c_long = 146;
+pub const SYS_setgid: ::c_long = 144;
+pub const SYS_geteuid: ::c_long = 175;
+pub const SYS_getegid: ::c_long = 177;
+pub const SYS_setpgid: ::c_long = 154;
+pub const SYS_getppid: ::c_long = 173;
+pub const SYS_setsid: ::c_long = 157;
+pub const SYS_setreuid: ::c_long = 145;
+pub const SYS_setregid: ::c_long = 143;
+pub const SYS_getgroups: ::c_long = 158;
+pub const SYS_setgroups: ::c_long = 159;
+pub const SYS_setresuid: ::c_long = 147;
+pub const SYS_getresuid: ::c_long = 148;
+pub const SYS_setresgid: ::c_long = 149;
+pub const SYS_getresgid: ::c_long = 150;
+pub const SYS_getpgid: ::c_long = 155;
+pub const SYS_setfsuid: ::c_long = 151;
+pub const SYS_setfsgid: ::c_long = 152;
+pub const SYS_getsid: ::c_long = 156;
+pub const SYS_capget: ::c_long = 90;
+pub const SYS_capset: ::c_long = 91;
+pub const SYS_rt_sigpending: ::c_long = 136;
+pub const SYS_rt_sigtimedwait: ::c_long = 137;
+pub const SYS_rt_sigqueueinfo: ::c_long = 138;
+pub const SYS_rt_sigsuspend: ::c_long = 133;
+pub const SYS_sigaltstack: ::c_long = 132;
+pub const SYS_personality: ::c_long = 92;
+pub const SYS_statfs: ::c_long = 43;
+pub const SYS_fstatfs: ::c_long = 44;
+pub const SYS_getpriority: ::c_long = 141;
+pub const SYS_setpriority: ::c_long = 140;
+pub const SYS_sched_setparam: ::c_long = 118;
+pub const SYS_sched_getparam: ::c_long = 121;
+pub const SYS_sched_setscheduler: ::c_long = 119;
+pub const SYS_sched_getscheduler: ::c_long = 120;
+pub const SYS_sched_get_priority_max: ::c_long = 125;
+pub const SYS_sched_get_priority_min: ::c_long = 126;
+pub const SYS_sched_rr_get_interval: ::c_long = 127;
+pub const SYS_mlock: ::c_long = 228;
+pub const SYS_munlock: ::c_long = 229;
+pub const SYS_mlockall: ::c_long = 230;
+pub const SYS_munlockall: ::c_long = 231;
+pub const SYS_vhangup: ::c_long = 58;
+pub const SYS_pivot_root: ::c_long = 41;
+pub const SYS_prctl: ::c_long = 167;
+pub const SYS_adjtimex: ::c_long = 171;
+pub const SYS_setrlimit: ::c_long = 164;
+pub const SYS_chroot: ::c_long = 51;
+pub const SYS_sync: ::c_long = 81;
+pub const SYS_acct: ::c_long = 89;
+pub const SYS_settimeofday: ::c_long = 170;
+pub const SYS_mount: ::c_long = 40;
+pub const SYS_umount2: ::c_long = 39;
+pub const SYS_swapon: ::c_long = 224;
+pub const SYS_swapoff: ::c_long = 225;
+pub const SYS_reboot: ::c_long = 142;
+pub const SYS_sethostname: ::c_long = 161;
+pub const SYS_setdomainname: ::c_long = 162;
+pub const SYS_init_module: ::c_long = 105;
+pub const SYS_delete_module: ::c_long = 106;
+pub const SYS_quotactl: ::c_long = 60;
+pub const SYS_nfsservctl: ::c_long = 42;
+pub const SYS_gettid: ::c_long = 178;
+pub const SYS_readahead: ::c_long = 213;
+pub const SYS_setxattr: ::c_long = 5;
+pub const SYS_lsetxattr: ::c_long = 6;
+pub const SYS_fsetxattr: ::c_long = 7;
+pub const SYS_getxattr: ::c_long = 8;
+pub const SYS_lgetxattr: ::c_long = 9;
+pub const SYS_fgetxattr: ::c_long = 10;
+pub const SYS_listxattr: ::c_long = 11;
+pub const SYS_llistxattr: ::c_long = 12;
+pub const SYS_flistxattr: ::c_long = 13;
+pub const SYS_removexattr: ::c_long = 14;
+pub const SYS_lremovexattr: ::c_long = 15;
+pub const SYS_fremovexattr: ::c_long = 16;
+pub const SYS_tkill: ::c_long = 130;
+pub const SYS_futex: ::c_long = 98;
+pub const SYS_sched_setaffinity: ::c_long = 122;
+pub const SYS_sched_getaffinity: ::c_long = 123;
+pub const SYS_io_setup: ::c_long = 0;
+pub const SYS_io_destroy: ::c_long = 1;
+pub const SYS_io_getevents: ::c_long = 4;
+pub const SYS_io_submit: ::c_long = 2;
+pub const SYS_io_cancel: ::c_long = 3;
+pub const SYS_lookup_dcookie: ::c_long = 18;
+pub const SYS_remap_file_pages: ::c_long = 234;
+pub const SYS_getdents64: ::c_long = 61;
+pub const SYS_set_tid_address: ::c_long = 96;
+pub const SYS_restart_syscall: ::c_long = 128;
+pub const SYS_semtimedop: ::c_long = 192;
+pub const SYS_fadvise64: ::c_long = 223;
+pub const SYS_timer_create: ::c_long = 107;
+pub const SYS_timer_settime: ::c_long = 110;
+pub const SYS_timer_gettime: ::c_long = 108;
+pub const SYS_timer_getoverrun: ::c_long = 109;
+pub const SYS_timer_delete: ::c_long = 111;
+pub const SYS_clock_settime: ::c_long = 112;
+pub const SYS_clock_gettime: ::c_long = 113;
+pub const SYS_clock_getres: ::c_long = 114;
+pub const SYS_clock_nanosleep: ::c_long = 115;
+pub const SYS_exit_group: ::c_long = 94;
+pub const SYS_epoll_ctl: ::c_long = 21;
+pub const SYS_tgkill: ::c_long = 131;
+pub const SYS_mbind: ::c_long = 235;
+pub const SYS_set_mempolicy: ::c_long = 237;
+pub const SYS_get_mempolicy: ::c_long = 236;
+pub const SYS_mq_open: ::c_long = 180;
+pub const SYS_mq_unlink: ::c_long = 181;
+pub const SYS_mq_timedsend: ::c_long = 182;
+pub const SYS_mq_timedreceive: ::c_long = 183;
+pub const SYS_mq_notify: ::c_long = 184;
+pub const SYS_mq_getsetattr: ::c_long = 185;
+pub const SYS_kexec_load: ::c_long = 104;
+pub const SYS_waitid: ::c_long = 95;
+pub const SYS_add_key: ::c_long = 217;
+pub const SYS_request_key: ::c_long = 218;
+pub const SYS_keyctl: ::c_long = 219;
+pub const SYS_ioprio_set: ::c_long = 30;
+pub const SYS_ioprio_get: ::c_long = 31;
+pub const SYS_inotify_add_watch: ::c_long = 27;
+pub const SYS_inotify_rm_watch: ::c_long = 28;
+pub const SYS_migrate_pages: ::c_long = 238;
+pub const SYS_openat: ::c_long = 56;
+pub const SYS_mkdirat: ::c_long = 34;
+pub const SYS_mknodat: ::c_long = 33;
+pub const SYS_fchownat: ::c_long = 54;
+pub const SYS_newfstatat: ::c_long = 79;
+pub const SYS_unlinkat: ::c_long = 35;
+pub const SYS_linkat: ::c_long = 37;
+pub const SYS_symlinkat: ::c_long = 36;
+pub const SYS_readlinkat: ::c_long = 78;
+pub const SYS_fchmodat: ::c_long = 53;
+pub const SYS_faccessat: ::c_long = 48;
+pub const SYS_pselect6: ::c_long = 72;
+pub const SYS_ppoll: ::c_long = 73;
+pub const SYS_unshare: ::c_long = 97;
+pub const SYS_set_robust_list: ::c_long = 99;
+pub const SYS_get_robust_list: ::c_long = 100;
+pub const SYS_splice: ::c_long = 76;
+pub const SYS_tee: ::c_long = 77;
+pub const SYS_sync_file_range: ::c_long = 84;
+pub const SYS_vmsplice: ::c_long = 75;
+pub const SYS_move_pages: ::c_long = 239;
+pub const SYS_utimensat: ::c_long = 88;
+pub const SYS_epoll_pwait: ::c_long = 22;
+pub const SYS_timerfd_create: ::c_long = 85;
+pub const SYS_fallocate: ::c_long = 47;
+pub const SYS_timerfd_settime: ::c_long = 86;
+pub const SYS_timerfd_gettime: ::c_long = 87;
+pub const SYS_accept4: ::c_long = 242;
+pub const SYS_signalfd4: ::c_long = 74;
+pub const SYS_eventfd2: ::c_long = 19;
+pub const SYS_epoll_create1: ::c_long = 20;
+pub const SYS_dup3: ::c_long = 24;
+pub const SYS_pipe2: ::c_long = 59;
+pub const SYS_inotify_init1: ::c_long = 26;
+pub const SYS_preadv: ::c_long = 69;
+pub const SYS_pwritev: ::c_long = 70;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 240;
+pub const SYS_perf_event_open: ::c_long = 241;
+pub const SYS_recvmmsg: ::c_long = 243;
+pub const SYS_fanotify_init: ::c_long = 262;
+pub const SYS_fanotify_mark: ::c_long = 263;
+pub const SYS_prlimit64: ::c_long = 261;
+pub const SYS_name_to_handle_at: ::c_long = 264;
+pub const SYS_open_by_handle_at: ::c_long = 265;
+pub const SYS_clock_adjtime: ::c_long = 266;
+pub const SYS_syncfs: ::c_long = 267;
+pub const SYS_sendmmsg: ::c_long = 269;
+pub const SYS_setns: ::c_long = 268;
+pub const SYS_getcpu: ::c_long = 168;
+pub const SYS_process_vm_readv: ::c_long = 270;
+pub const SYS_process_vm_writev: ::c_long = 271;
+pub const SYS_kcmp: ::c_long = 272;
+pub const SYS_finit_module: ::c_long = 273;
+pub const SYS_sched_setattr: ::c_long = 274;
+pub const SYS_sched_getattr: ::c_long = 275;
+pub const SYS_renameat2: ::c_long = 276;
+pub const SYS_seccomp: ::c_long = 277;
+pub const SYS_getrandom: ::c_long = 278;
+pub const SYS_memfd_create: ::c_long = 279;
+pub const SYS_bpf: ::c_long = 280;
+pub const SYS_execveat: ::c_long = 281;
+pub const SYS_userfaultfd: ::c_long = 282;
+pub const SYS_membarrier: ::c_long = 283;
+pub const SYS_mlock2: ::c_long = 284;
+pub const SYS_copy_file_range: ::c_long = 285;
+pub const SYS_preadv2: ::c_long = 286;
+pub const SYS_pwritev2: ::c_long = 287;
+pub const SYS_pkey_mprotect: ::c_long = 288;
+pub const SYS_pkey_alloc: ::c_long = 289;
+pub const SYS_pkey_free: ::c_long = 290;
+pub const SYS_statx: ::c_long = 291;
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/sparc/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/sparc/align.rs
new file mode 100644
index 00000000..98fda883
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/sparc/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(8))]
+    pub struct max_align_t {
+        priv_: [i64; 3]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/sparc/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/sparc/mod.rs
new file mode 100644
index 00000000..33400b3a
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/sparc/mod.rs
@@ -0,0 +1,918 @@
+//! SPARC-specific definitions for 32-bit linux-like values
+
+pub type c_char = i8;
+pub type wchar_t = i32;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statfs {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        f_spare: [::__fsword_t; 5],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+        __reserved:  ::c_short,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad2: ::c_ushort,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 2],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad2: ::c_ushort,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __reserved: [::c_long; 2],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        pub f_flags: ::__fsword_t,
+        pub f_spare: [::__fsword_t; 4],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        __pad1: ::c_ushort,
+        pub mode: ::c_ushort,
+        __pad2: ::c_ushort,
+        pub __seq: ::c_ushort,
+        __unused1: ::c_ulonglong,
+        __unused2: ::c_ulonglong,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        __pad1: ::c_uint,
+        pub shm_atime: ::time_t,
+        __pad2: ::c_uint,
+        pub shm_dtime: ::time_t,
+        __pad3: ::c_uint,
+        pub shm_ctime: ::time_t,
+        pub shm_segsz: ::size_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __reserved1: ::c_ulong,
+        __reserved2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        __pad1: ::c_uint,
+        pub msg_stime: ::time_t,
+        __pad2: ::c_uint,
+        pub msg_rtime: ::time_t,
+        __pad3: ::c_uint,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: ::c_ushort,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved1: ::c_ulong,
+        __glibc_reserved2: ::c_ulong,
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+}
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+
+pub const TIOCGSOFTCAR: ::c_ulong = 0x40047464;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x80047465;
+
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 6;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 7;
+
+pub const O_APPEND: ::c_int = 0x8;
+pub const O_CREAT: ::c_int = 0x200;
+pub const O_EXCL: ::c_int = 0x800;
+pub const O_NOCTTY: ::c_int = 0x8000;
+pub const O_NONBLOCK: ::c_int = 0x4000;
+pub const O_SYNC: ::c_int = 0x802000;
+pub const O_RSYNC: ::c_int = 0x802000;
+pub const O_DSYNC: ::c_int = 0x2000;
+pub const O_FSYNC: ::c_int = 0x802000;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_GROWSDOWN: ::c_int = 0x0200;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const EDEADLK: ::c_int = 78;
+pub const ENAMETOOLONG: ::c_int = 63;
+pub const ENOLCK: ::c_int = 79;
+pub const ENOSYS: ::c_int = 90;
+pub const ENOTEMPTY: ::c_int = 66;
+pub const ELOOP: ::c_int = 62;
+pub const ENOMSG: ::c_int = 75;
+pub const EIDRM: ::c_int = 77;
+pub const ECHRNG: ::c_int = 94;
+pub const EL2NSYNC: ::c_int = 95;
+pub const EL3HLT: ::c_int = 96;
+pub const EL3RST: ::c_int = 97;
+pub const ELNRNG: ::c_int = 98;
+pub const EUNATCH: ::c_int = 99;
+pub const ENOCSI: ::c_int = 100;
+pub const EL2HLT: ::c_int = 101;
+pub const EBADE: ::c_int = 102;
+pub const EBADR: ::c_int = 103;
+pub const EXFULL: ::c_int = 104;
+pub const ENOANO: ::c_int = 105;
+pub const EBADRQC: ::c_int = 106;
+pub const EBADSLT: ::c_int = 107;
+pub const EMULTIHOP: ::c_int = 87;
+pub const EOVERFLOW: ::c_int = 92;
+pub const ENOTUNIQ: ::c_int = 115;
+pub const EBADFD: ::c_int = 93;
+pub const EBADMSG: ::c_int = 76;
+pub const EREMCHG: ::c_int = 89;
+pub const ELIBACC: ::c_int = 114;
+pub const ELIBBAD: ::c_int = 112;
+pub const ELIBSCN: ::c_int = 124;
+pub const ELIBMAX: ::c_int = 123;
+pub const ELIBEXEC: ::c_int = 110;
+pub const EILSEQ: ::c_int = 122;
+pub const ERESTART: ::c_int = 116;
+pub const ESTRPIPE: ::c_int = 91;
+pub const EUSERS: ::c_int = 68;
+pub const ENOTSOCK: ::c_int = 38;
+pub const EDESTADDRREQ: ::c_int = 39;
+pub const EMSGSIZE: ::c_int = 40;
+pub const EPROTOTYPE: ::c_int = 41;
+pub const ENOPROTOOPT: ::c_int = 42;
+pub const EPROTONOSUPPORT: ::c_int = 43;
+pub const ESOCKTNOSUPPORT: ::c_int = 44;
+pub const EOPNOTSUPP: ::c_int = 45;
+pub const EPFNOSUPPORT: ::c_int = 46;
+pub const EAFNOSUPPORT: ::c_int = 47;
+pub const EADDRINUSE: ::c_int = 48;
+pub const EADDRNOTAVAIL: ::c_int = 49;
+pub const ENETDOWN: ::c_int = 50;
+pub const ENETUNREACH: ::c_int = 51;
+pub const ENETRESET: ::c_int = 52;
+pub const ECONNABORTED: ::c_int = 53;
+pub const ECONNRESET: ::c_int = 54;
+pub const ENOBUFS: ::c_int = 55;
+pub const EISCONN: ::c_int = 56;
+pub const ENOTCONN: ::c_int = 57;
+pub const ESHUTDOWN: ::c_int = 58;
+pub const ETOOMANYREFS: ::c_int = 59;
+pub const ETIMEDOUT: ::c_int = 60;
+pub const ECONNREFUSED: ::c_int = 61;
+pub const EHOSTDOWN: ::c_int = 64;
+pub const EHOSTUNREACH: ::c_int = 65;
+pub const EALREADY: ::c_int = 37;
+pub const EINPROGRESS: ::c_int = 36;
+pub const ESTALE: ::c_int = 70;
+pub const EDQUOT: ::c_int = 69;
+pub const ENOMEDIUM: ::c_int = 125;
+pub const EMEDIUMTYPE: ::c_int = 126;
+pub const ECANCELED: ::c_int = 127;
+pub const ENOKEY: ::c_int = 128;
+pub const EKEYEXPIRED: ::c_int = 129;
+pub const EKEYREVOKED: ::c_int = 130;
+pub const EKEYREJECTED: ::c_int = 131;
+pub const EOWNERDEAD: ::c_int = 132;
+pub const ENOTRECOVERABLE: ::c_int = 133;
+pub const EHWPOISON: ::c_int = 135;
+pub const ERFKILL: ::c_int = 134;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+
+pub const SO_PASSCRED: ::c_int = 2;
+pub const SO_REUSEADDR: ::c_int = 4;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_DONTROUTE: ::c_int = 16;
+pub const SO_BROADCAST: ::c_int = 32;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDBUFFORCE: ::c_int = 0x100a;
+pub const SO_RCVBUFFORCE: ::c_int = 0x100b;
+pub const SO_DOMAIN: ::c_int = 0x1029;
+pub const SO_KEEPALIVE: ::c_int = 8;
+pub const SO_OOBINLINE: ::c_int = 0x100;
+pub const SO_LINGER: ::c_int = 128;
+pub const SO_REUSEPORT: ::c_int = 0x200;
+pub const SO_ACCEPTCONN: ::c_int = 0x8000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const SA_SIGINFO: ::c_int = 0x200;
+pub const SA_NOCLDWAIT: ::c_int = 0x100;
+
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGCHLD: ::c_int = 20;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGUSR1: ::c_int = 30;
+pub const SIGUSR2: ::c_int = 31;
+pub const SIGCONT: ::c_int = 19;
+pub const SIGSTOP: ::c_int = 17;
+pub const SIGTSTP: ::c_int = 18;
+pub const SIGURG: ::c_int = 16;
+pub const SIGIO: ::c_int = 23;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGPOLL: ::c_int = 23;
+pub const SIGPWR: ::c_int = 29;
+pub const SIG_SETMASK: ::c_int = 4;
+pub const SIG_BLOCK: ::c_int = 1;
+pub const SIG_UNBLOCK: ::c_int = 2;
+
+pub const POLLWRNORM: ::c_short = 4;
+pub const POLLWRBAND: ::c_short = 0x100;
+
+pub const O_ASYNC: ::c_int = 0x40;
+pub const O_NDELAY: ::c_int = 0x4004;
+
+pub const EFD_NONBLOCK: ::c_int = 0x4000;
+
+pub const F_GETLK: ::c_int = 7;
+pub const F_GETOWN: ::c_int = 5;
+pub const F_SETOWN: ::c_int = 6;
+
+pub const SFD_NONBLOCK: ::c_int = 0x4000;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+pub const TIOCEXCL: ::c_ulong = 0x2000740d;
+pub const TIOCNXCL: ::c_ulong = 0x2000740e;
+pub const TIOCSCTTY: ::c_ulong = 0x20007484;
+pub const TIOCSTI: ::c_ulong = 0x80017472;
+pub const TIOCMGET: ::c_ulong = 0x4004746a;
+pub const TIOCMBIS: ::c_ulong = 0x8004746c;
+pub const TIOCMBIC: ::c_ulong = 0x8004746b;
+pub const TIOCMSET: ::c_ulong = 0x8004746d;
+pub const TIOCCONS: ::c_ulong = 0x20007424;
+
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+pub const O_DIRECTORY: ::c_int = 0o200000;
+pub const O_NOFOLLOW: ::c_int = 0o400000;
+pub const O_LARGEFILE: ::c_int = 0x40000;
+pub const O_DIRECT: ::c_int = 0x100000;
+
+pub const MAP_LOCKED: ::c_int = 0x0100;
+pub const MAP_NORESERVE: ::c_int = 0x00040;
+
+pub const EDEADLOCK: ::c_int = 108;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+
+pub const SO_PEERCRED: ::c_int = 0x40;
+pub const SO_RCVLOWAT: ::c_int = 0x800;
+pub const SO_SNDLOWAT: ::c_int = 0x1000;
+pub const SO_RCVTIMEO: ::c_int = 0x2000;
+pub const SO_SNDTIMEO: ::c_int = 0x4000;
+
+pub const FIOCLEX: ::c_ulong = 0x20006601;
+pub const FIONCLEX: ::c_ulong = 0x20006602;
+pub const FIONBIO: ::c_ulong = 0x8004667e;
+
+pub const MCL_CURRENT: ::c_int = 0x2000;
+pub const MCL_FUTURE: ::c_int = 0x4000;
+
+pub const SIGSTKSZ: ::size_t = 16384;
+pub const MINSIGSTKSZ: ::size_t = 4096;
+pub const CBAUD: ::tcflag_t = 0x0000100f;
+pub const TAB1: ::tcflag_t = 0x800;
+pub const TAB2: ::tcflag_t = 0x1000;
+pub const TAB3: ::tcflag_t = 0x1800;
+pub const CR1: ::tcflag_t = 0x200;
+pub const CR2: ::tcflag_t = 0x400;
+pub const CR3: ::tcflag_t = 0x600;
+pub const FF1: ::tcflag_t = 0x8000;
+pub const BS1: ::tcflag_t = 0x2000;
+pub const VT1: ::tcflag_t = 0x4000;
+pub const VWERASE: usize = 0xe;
+pub const VREPRINT: usize = 0xc;
+pub const VSUSP: usize = 0xa;
+pub const VSTART: usize = 0x8;
+pub const VSTOP: usize = 0x9;
+pub const VDISCARD: usize = 0xd;
+pub const VTIME: usize = 0x5;
+pub const IXON: ::tcflag_t = 0x400;
+pub const IXOFF: ::tcflag_t = 0x1000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x30;
+pub const CS6: ::tcflag_t = 0x10;
+pub const CS7: ::tcflag_t = 0x20;
+pub const CS8: ::tcflag_t = 0x30;
+pub const CSTOPB: ::tcflag_t = 0x40;
+pub const CREAD: ::tcflag_t = 0x80;
+pub const PARENB: ::tcflag_t = 0x100;
+pub const PARODD: ::tcflag_t = 0x200;
+pub const HUPCL: ::tcflag_t = 0x400;
+pub const CLOCAL: ::tcflag_t = 0x800;
+pub const ECHOKE: ::tcflag_t = 0x800;
+pub const ECHOE: ::tcflag_t = 0x10;
+pub const ECHOK: ::tcflag_t = 0x20;
+pub const ECHONL: ::tcflag_t = 0x40;
+pub const ECHOPRT: ::tcflag_t = 0x400;
+pub const ECHOCTL: ::tcflag_t = 0x200;
+pub const ISIG: ::tcflag_t = 0x1;
+pub const ICANON: ::tcflag_t = 0x2;
+pub const PENDIN: ::tcflag_t = 0x4000;
+pub const NOFLSH: ::tcflag_t = 0x80;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0x00001000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0x1000;
+pub const B57600: ::speed_t = 0x1001;
+pub const B115200: ::speed_t = 0x1002;
+pub const B230400: ::speed_t = 0x1003;
+pub const B460800: ::speed_t = 0x1004;
+pub const B76800: ::speed_t = 0x1005;
+pub const B153600: ::speed_t = 0x1006;
+pub const B307200: ::speed_t = 0x1007;
+pub const B614400: ::speed_t = 0x1008;
+pub const B921600: ::speed_t = 0x1009;
+pub const B500000: ::speed_t = 0x100a;
+pub const B576000: ::speed_t = 0x100b;
+pub const B1000000: ::speed_t = 0x100c;
+pub const B1152000: ::speed_t = 0x100d;
+pub const B1500000: ::speed_t = 0x100e;
+pub const B2000000: ::speed_t = 0x100f;
+
+pub const VEOL: usize = 5;
+pub const VEOL2: usize = 6;
+pub const VMIN: usize = 4;
+pub const IEXTEN: ::tcflag_t = 0x8000;
+pub const TOSTOP: ::tcflag_t = 0x100;
+pub const FLUSHO: ::tcflag_t = 0x1000;
+pub const EXTPROC: ::tcflag_t = 0x10000;
+pub const TCGETS: ::c_ulong = 0x40245408;
+pub const TCSETS: ::c_ulong = 0x80245409;
+pub const TCSETSW: ::c_ulong = 0x8024540a;
+pub const TCSETSF: ::c_ulong = 0x8024540b;
+pub const TCGETA: ::c_ulong = 0x40125401;
+pub const TCSETA: ::c_ulong = 0x80125402;
+pub const TCSETAW: ::c_ulong = 0x80125403;
+pub const TCSETAF: ::c_ulong = 0x80125404;
+pub const TCSBRK: ::c_ulong = 0x20005405;
+pub const TCXONC: ::c_ulong = 0x20005406;
+pub const TCFLSH: ::c_ulong = 0x20005407;
+pub const TIOCINQ: ::c_ulong = 0x4004667f;
+pub const TIOCGPGRP: ::c_ulong = 0x40047483;
+pub const TIOCSPGRP: ::c_ulong = 0x80047482;
+pub const TIOCOUTQ: ::c_ulong = 0x40047473;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const FIONREAD: ::c_ulong = 0x4004667f;
+
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_wait4: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execv: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_chown: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_brk: ::c_long = 17;
+pub const SYS_perfctr: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_capget: ::c_long = 21;
+pub const SYS_capset: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_vmsplice: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_sigaltstack: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_lchown32: ::c_long = 31;
+pub const SYS_fchown32: ::c_long = 32;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_chown32: ::c_long = 35;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_stat: ::c_long = 38;
+pub const SYS_sendfile: ::c_long = 39;
+pub const SYS_lstat: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_getuid32: ::c_long = 44;
+pub const SYS_umount2: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_getgid32: ::c_long = 53;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_reboot: ::c_long = 55;
+pub const SYS_mmap2: ::c_long = 56;
+pub const SYS_symlink: ::c_long = 57;
+pub const SYS_readlink: ::c_long = 58;
+pub const SYS_execve: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_fstat: ::c_long = 62;
+pub const SYS_fstat64: ::c_long = 63;
+pub const SYS_getpagesize: ::c_long = 64;
+pub const SYS_msync: ::c_long = 65;
+pub const SYS_vfork: ::c_long = 66;
+pub const SYS_pread64: ::c_long = 67;
+pub const SYS_pwrite64: ::c_long = 68;
+pub const SYS_geteuid32: ::c_long = 69;
+pub const SYS_getegid32: ::c_long = 70;
+pub const SYS_mmap: ::c_long = 71;
+pub const SYS_setreuid32: ::c_long = 72;
+pub const SYS_munmap: ::c_long = 73;
+pub const SYS_mprotect: ::c_long = 74;
+pub const SYS_madvise: ::c_long = 75;
+pub const SYS_vhangup: ::c_long = 76;
+pub const SYS_truncate64: ::c_long = 77;
+pub const SYS_mincore: ::c_long = 78;
+pub const SYS_getgroups: ::c_long = 79;
+pub const SYS_setgroups: ::c_long = 80;
+pub const SYS_getpgrp: ::c_long = 81;
+pub const SYS_setgroups32: ::c_long = 82;
+pub const SYS_setitimer: ::c_long = 83;
+pub const SYS_ftruncate64: ::c_long = 84;
+pub const SYS_swapon: ::c_long = 85;
+pub const SYS_getitimer: ::c_long = 86;
+pub const SYS_setuid32: ::c_long = 87;
+pub const SYS_sethostname: ::c_long = 88;
+pub const SYS_setgid32: ::c_long = 89;
+pub const SYS_dup2: ::c_long = 90;
+pub const SYS_setfsuid32: ::c_long = 91;
+pub const SYS_fcntl: ::c_long = 92;
+pub const SYS_select: ::c_long = 93;
+pub const SYS_setfsgid32: ::c_long = 94;
+pub const SYS_fsync: ::c_long = 95;
+pub const SYS_setpriority: ::c_long = 96;
+pub const SYS_socket: ::c_long = 97;
+pub const SYS_connect: ::c_long = 98;
+pub const SYS_accept: ::c_long = 99;
+pub const SYS_getpriority: ::c_long = 100;
+pub const SYS_rt_sigreturn: ::c_long = 101;
+pub const SYS_rt_sigaction: ::c_long = 102;
+pub const SYS_rt_sigprocmask: ::c_long = 103;
+pub const SYS_rt_sigpending: ::c_long = 104;
+pub const SYS_rt_sigtimedwait: ::c_long = 105;
+pub const SYS_rt_sigqueueinfo: ::c_long = 106;
+pub const SYS_rt_sigsuspend: ::c_long = 107;
+pub const SYS_setresuid32: ::c_long = 108;
+pub const SYS_getresuid32: ::c_long = 109;
+pub const SYS_setresgid32: ::c_long = 110;
+pub const SYS_getresgid32: ::c_long = 111;
+pub const SYS_setregid32: ::c_long = 112;
+pub const SYS_recvmsg: ::c_long = 113;
+pub const SYS_sendmsg: ::c_long = 114;
+pub const SYS_getgroups32: ::c_long = 115;
+pub const SYS_gettimeofday: ::c_long = 116;
+pub const SYS_getrusage: ::c_long = 117;
+pub const SYS_getsockopt: ::c_long = 118;
+pub const SYS_getcwd: ::c_long = 119;
+pub const SYS_readv: ::c_long = 120;
+pub const SYS_writev: ::c_long = 121;
+pub const SYS_settimeofday: ::c_long = 122;
+pub const SYS_fchown: ::c_long = 123;
+pub const SYS_fchmod: ::c_long = 124;
+pub const SYS_recvfrom: ::c_long = 125;
+pub const SYS_setreuid: ::c_long = 126;
+pub const SYS_setregid: ::c_long = 127;
+pub const SYS_rename: ::c_long = 128;
+pub const SYS_truncate: ::c_long = 129;
+pub const SYS_ftruncate: ::c_long = 130;
+pub const SYS_flock: ::c_long = 131;
+pub const SYS_lstat64: ::c_long = 132;
+pub const SYS_sendto: ::c_long = 133;
+pub const SYS_shutdown: ::c_long = 134;
+pub const SYS_socketpair: ::c_long = 135;
+pub const SYS_mkdir: ::c_long = 136;
+pub const SYS_rmdir: ::c_long = 137;
+pub const SYS_utimes: ::c_long = 138;
+pub const SYS_stat64: ::c_long = 139;
+pub const SYS_sendfile64: ::c_long = 140;
+pub const SYS_getpeername: ::c_long = 141;
+pub const SYS_futex: ::c_long = 142;
+pub const SYS_gettid: ::c_long = 143;
+pub const SYS_getrlimit: ::c_long = 144;
+pub const SYS_setrlimit: ::c_long = 145;
+pub const SYS_pivot_root: ::c_long = 146;
+pub const SYS_prctl: ::c_long = 147;
+pub const SYS_pciconfig_read: ::c_long = 148;
+pub const SYS_pciconfig_write: ::c_long = 149;
+pub const SYS_getsockname: ::c_long = 150;
+pub const SYS_inotify_init: ::c_long = 151;
+pub const SYS_inotify_add_watch: ::c_long = 152;
+pub const SYS_poll: ::c_long = 153;
+pub const SYS_getdents64: ::c_long = 154;
+pub const SYS_fcntl64: ::c_long = 155;
+pub const SYS_inotify_rm_watch: ::c_long = 156;
+pub const SYS_statfs: ::c_long = 157;
+pub const SYS_fstatfs: ::c_long = 158;
+pub const SYS_umount: ::c_long = 159;
+pub const SYS_sched_set_affinity: ::c_long = 160;
+pub const SYS_sched_get_affinity: ::c_long = 161;
+pub const SYS_getdomainname: ::c_long = 162;
+pub const SYS_setdomainname: ::c_long = 163;
+pub const SYS_quotactl: ::c_long = 165;
+pub const SYS_set_tid_address: ::c_long = 166;
+pub const SYS_mount: ::c_long = 167;
+pub const SYS_ustat: ::c_long = 168;
+pub const SYS_setxattr: ::c_long = 169;
+pub const SYS_lsetxattr: ::c_long = 170;
+pub const SYS_fsetxattr: ::c_long = 171;
+pub const SYS_getxattr: ::c_long = 172;
+pub const SYS_lgetxattr: ::c_long = 173;
+pub const SYS_getdents: ::c_long = 174;
+pub const SYS_setsid: ::c_long = 175;
+pub const SYS_fchdir: ::c_long = 176;
+pub const SYS_fgetxattr: ::c_long = 177;
+pub const SYS_listxattr: ::c_long = 178;
+pub const SYS_llistxattr: ::c_long = 179;
+pub const SYS_flistxattr: ::c_long = 180;
+pub const SYS_removexattr: ::c_long = 181;
+pub const SYS_lremovexattr: ::c_long = 182;
+pub const SYS_sigpending: ::c_long = 183;
+pub const SYS_query_module: ::c_long = 184;
+pub const SYS_setpgid: ::c_long = 185;
+pub const SYS_fremovexattr: ::c_long = 186;
+pub const SYS_tkill: ::c_long = 187;
+pub const SYS_exit_group: ::c_long = 188;
+pub const SYS_uname: ::c_long = 189;
+pub const SYS_init_module: ::c_long = 190;
+pub const SYS_personality: ::c_long = 191;
+pub const SYS_remap_file_pages: ::c_long = 192;
+pub const SYS_epoll_create: ::c_long = 193;
+pub const SYS_epoll_ctl: ::c_long = 194;
+pub const SYS_epoll_wait: ::c_long = 195;
+pub const SYS_ioprio_set: ::c_long = 196;
+pub const SYS_getppid: ::c_long = 197;
+pub const SYS_sigaction: ::c_long = 198;
+pub const SYS_sgetmask: ::c_long = 199;
+pub const SYS_ssetmask: ::c_long = 200;
+pub const SYS_sigsuspend: ::c_long = 201;
+pub const SYS_oldlstat: ::c_long = 202;
+pub const SYS_uselib: ::c_long = 203;
+pub const SYS_readdir: ::c_long = 204;
+pub const SYS_readahead: ::c_long = 205;
+pub const SYS_socketcall: ::c_long = 206;
+pub const SYS_syslog: ::c_long = 207;
+pub const SYS_lookup_dcookie: ::c_long = 208;
+pub const SYS_fadvise64: ::c_long = 209;
+pub const SYS_fadvise64_64: ::c_long = 210;
+pub const SYS_tgkill: ::c_long = 211;
+pub const SYS_waitpid: ::c_long = 212;
+pub const SYS_swapoff: ::c_long = 213;
+pub const SYS_sysinfo: ::c_long = 214;
+pub const SYS_ipc: ::c_long = 215;
+pub const SYS_sigreturn: ::c_long = 216;
+pub const SYS_clone: ::c_long = 217;
+pub const SYS_ioprio_get: ::c_long = 218;
+pub const SYS_adjtimex: ::c_long = 219;
+pub const SYS_sigprocmask: ::c_long = 220;
+pub const SYS_create_module: ::c_long = 221;
+pub const SYS_delete_module: ::c_long = 222;
+pub const SYS_get_kernel_syms: ::c_long = 223;
+pub const SYS_getpgid: ::c_long = 224;
+pub const SYS_bdflush: ::c_long = 225;
+pub const SYS_sysfs: ::c_long = 226;
+pub const SYS_afs_syscall: ::c_long = 227;
+pub const SYS_setfsuid: ::c_long = 228;
+pub const SYS_setfsgid: ::c_long = 229;
+pub const SYS__newselect: ::c_long = 230;
+pub const SYS_time: ::c_long = 231;
+pub const SYS_splice: ::c_long = 232;
+pub const SYS_stime: ::c_long = 233;
+pub const SYS_statfs64: ::c_long = 234;
+pub const SYS_fstatfs64: ::c_long = 235;
+pub const SYS__llseek: ::c_long = 236;
+pub const SYS_mlock: ::c_long = 237;
+pub const SYS_munlock: ::c_long = 238;
+pub const SYS_mlockall: ::c_long = 239;
+pub const SYS_munlockall: ::c_long = 240;
+pub const SYS_sched_setparam: ::c_long = 241;
+pub const SYS_sched_getparam: ::c_long = 242;
+pub const SYS_sched_setscheduler: ::c_long = 243;
+pub const SYS_sched_getscheduler: ::c_long = 244;
+pub const SYS_sched_yield: ::c_long = 245;
+pub const SYS_sched_get_priority_max: ::c_long = 246;
+pub const SYS_sched_get_priority_min: ::c_long = 247;
+pub const SYS_sched_rr_get_interval: ::c_long = 248;
+pub const SYS_nanosleep: ::c_long = 249;
+pub const SYS_mremap: ::c_long = 250;
+pub const SYS__sysctl: ::c_long = 251;
+pub const SYS_getsid: ::c_long = 252;
+pub const SYS_fdatasync: ::c_long = 253;
+pub const SYS_nfsservctl: ::c_long = 254;
+pub const SYS_sync_file_range: ::c_long = 255;
+pub const SYS_clock_settime: ::c_long = 256;
+pub const SYS_clock_gettime: ::c_long = 257;
+pub const SYS_clock_getres: ::c_long = 258;
+pub const SYS_clock_nanosleep: ::c_long = 259;
+pub const SYS_sched_getaffinity: ::c_long = 260;
+pub const SYS_sched_setaffinity: ::c_long = 261;
+pub const SYS_timer_settime: ::c_long = 262;
+pub const SYS_timer_gettime: ::c_long = 263;
+pub const SYS_timer_getoverrun: ::c_long = 264;
+pub const SYS_timer_delete: ::c_long = 265;
+pub const SYS_timer_create: ::c_long = 266;
+pub const SYS_io_setup: ::c_long = 268;
+pub const SYS_io_destroy: ::c_long = 269;
+pub const SYS_io_submit: ::c_long = 270;
+pub const SYS_io_cancel: ::c_long = 271;
+pub const SYS_io_getevents: ::c_long = 272;
+pub const SYS_mq_open: ::c_long = 273;
+pub const SYS_mq_unlink: ::c_long = 274;
+pub const SYS_mq_timedsend: ::c_long = 275;
+pub const SYS_mq_timedreceive: ::c_long = 276;
+pub const SYS_mq_notify: ::c_long = 277;
+pub const SYS_mq_getsetattr: ::c_long = 278;
+pub const SYS_waitid: ::c_long = 279;
+pub const SYS_tee: ::c_long = 280;
+pub const SYS_add_key: ::c_long = 281;
+pub const SYS_request_key: ::c_long = 282;
+pub const SYS_keyctl: ::c_long = 283;
+pub const SYS_openat: ::c_long = 284;
+pub const SYS_mkdirat: ::c_long = 285;
+pub const SYS_mknodat: ::c_long = 286;
+pub const SYS_fchownat: ::c_long = 287;
+pub const SYS_futimesat: ::c_long = 288;
+pub const SYS_fstatat64: ::c_long = 289;
+pub const SYS_unlinkat: ::c_long = 290;
+pub const SYS_renameat: ::c_long = 291;
+pub const SYS_linkat: ::c_long = 292;
+pub const SYS_symlinkat: ::c_long = 293;
+pub const SYS_readlinkat: ::c_long = 294;
+pub const SYS_fchmodat: ::c_long = 295;
+pub const SYS_faccessat: ::c_long = 296;
+pub const SYS_pselect6: ::c_long = 297;
+pub const SYS_ppoll: ::c_long = 298;
+pub const SYS_unshare: ::c_long = 299;
+pub const SYS_set_robust_list: ::c_long = 300;
+pub const SYS_get_robust_list: ::c_long = 301;
+pub const SYS_migrate_pages: ::c_long = 302;
+pub const SYS_mbind: ::c_long = 303;
+pub const SYS_get_mempolicy: ::c_long = 304;
+pub const SYS_set_mempolicy: ::c_long = 305;
+pub const SYS_kexec_load: ::c_long = 306;
+pub const SYS_move_pages: ::c_long = 307;
+pub const SYS_getcpu: ::c_long = 308;
+pub const SYS_epoll_pwait: ::c_long = 309;
+pub const SYS_utimensat: ::c_long = 310;
+pub const SYS_signalfd: ::c_long = 311;
+pub const SYS_timerfd_create: ::c_long = 312;
+pub const SYS_eventfd: ::c_long = 313;
+pub const SYS_fallocate: ::c_long = 314;
+pub const SYS_timerfd_settime: ::c_long = 315;
+pub const SYS_timerfd_gettime: ::c_long = 316;
+pub const SYS_signalfd4: ::c_long = 317;
+pub const SYS_eventfd2: ::c_long = 318;
+pub const SYS_epoll_create1: ::c_long = 319;
+pub const SYS_dup3: ::c_long = 320;
+pub const SYS_pipe2: ::c_long = 321;
+pub const SYS_inotify_init1: ::c_long = 322;
+pub const SYS_accept4: ::c_long = 323;
+pub const SYS_preadv: ::c_long = 324;
+pub const SYS_pwritev: ::c_long = 325;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 326;
+pub const SYS_perf_event_open: ::c_long = 327;
+pub const SYS_recvmmsg: ::c_long = 328;
+pub const SYS_fanotify_init: ::c_long = 329;
+pub const SYS_fanotify_mark: ::c_long = 330;
+pub const SYS_prlimit64: ::c_long = 331;
+pub const SYS_name_to_handle_at: ::c_long = 332;
+pub const SYS_open_by_handle_at: ::c_long = 333;
+pub const SYS_clock_adjtime: ::c_long = 334;
+pub const SYS_syncfs: ::c_long = 335;
+pub const SYS_sendmmsg: ::c_long = 336;
+pub const SYS_setns: ::c_long = 337;
+pub const SYS_process_vm_readv: ::c_long = 338;
+pub const SYS_process_vm_writev: ::c_long = 339;
+pub const SYS_kern_features: ::c_long = 340;
+pub const SYS_kcmp: ::c_long = 341;
+pub const SYS_finit_module: ::c_long = 342;
+pub const SYS_sched_setattr: ::c_long = 343;
+pub const SYS_sched_getattr: ::c_long = 344;
+pub const SYS_renameat2: ::c_long = 345;
+pub const SYS_seccomp: ::c_long = 346;
+pub const SYS_getrandom: ::c_long = 347;
+pub const SYS_memfd_create: ::c_long = 348;
+pub const SYS_bpf: ::c_long = 349;
+pub const SYS_execveat: ::c_long = 350;
+pub const SYS_membarrier: ::c_long = 351;
+pub const SYS_userfaultfd: ::c_long = 352;
+pub const SYS_bind: ::c_long = 353;
+pub const SYS_listen: ::c_long = 354;
+pub const SYS_setsockopt: ::c_long = 355;
+pub const SYS_mlock2: ::c_long = 356;
+pub const SYS_copy_file_range: ::c_long = 357;
+pub const SYS_preadv2: ::c_long = 358;
+pub const SYS_pwritev2: ::c_long = 359;
+pub const SYS_statx: ::c_long = 360;
+pub const SYS_pidfd_open: ::c_long = 434;
+// Reserved in the kernel, but not actually implemented yet
+pub const SYS_clone3: ::c_long = 435;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/x86/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/x86/align.rs
new file mode 100644
index 00000000..96634749
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/x86/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 6]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b32/x86/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b32/x86/mod.rs
new file mode 100644
index 00000000..130ed850
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b32/x86/mod.rs
@@ -0,0 +1,1169 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type greg_t = i32;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statfs {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        f_spare: [::__fsword_t; 5],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct _libc_fpreg {
+        pub significand: [u16; 4],
+        pub exponent: u16,
+    }
+
+    pub struct _libc_fpstate {
+        pub cw: ::c_ulong,
+        pub sw: ::c_ulong,
+        pub tag: ::c_ulong,
+        pub ipoff: ::c_ulong,
+        pub cssel: ::c_ulong,
+        pub dataoff: ::c_ulong,
+        pub datasel: ::c_ulong,
+        pub _st: [_libc_fpreg; 8],
+        pub status: ::c_ulong,
+    }
+
+    pub struct user_fpregs_struct {
+        pub cwd: ::c_long,
+        pub swd: ::c_long,
+        pub twd: ::c_long,
+        pub fip: ::c_long,
+        pub fcs: ::c_long,
+        pub foo: ::c_long,
+        pub fos: ::c_long,
+        pub st_space: [::c_long; 20],
+    }
+
+    pub struct user_regs_struct {
+        pub ebx: ::c_long,
+        pub ecx: ::c_long,
+        pub edx: ::c_long,
+        pub esi: ::c_long,
+        pub edi: ::c_long,
+        pub ebp: ::c_long,
+        pub eax: ::c_long,
+        pub xds: ::c_long,
+        pub xes: ::c_long,
+        pub xfs: ::c_long,
+        pub xgs: ::c_long,
+        pub orig_eax: ::c_long,
+        pub eip: ::c_long,
+        pub xcs: ::c_long,
+        pub eflags: ::c_long,
+        pub esp: ::c_long,
+        pub xss: ::c_long,
+    }
+
+    pub struct user {
+        pub regs: user_regs_struct,
+        pub u_fpvalid: ::c_int,
+        pub i387: user_fpregs_struct,
+        pub u_tsize: ::c_ulong,
+        pub u_dsize: ::c_ulong,
+        pub u_ssize: ::c_ulong,
+        pub start_code: ::c_ulong,
+        pub start_stack: ::c_ulong,
+        pub signal: ::c_long,
+        __reserved: ::c_int,
+        pub u_ar0: *mut user_regs_struct,
+        pub u_fpstate: *mut user_fpregs_struct,
+        pub magic: ::c_ulong,
+        pub u_comm: [c_char; 32],
+        pub u_debugreg: [::c_int; 8],
+    }
+
+    pub struct mcontext_t {
+        pub gregs: [greg_t; 19],
+        pub fpregs: *mut _libc_fpstate,
+        pub oldmask: ::c_ulong,
+        pub cr2: ::c_ulong,
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_ushort,
+        __pad1: ::c_ushort,
+        pub __seq: ::c_ushort,
+        __pad2: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        __pad1: ::c_uint,
+        __st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad2: ::c_uint,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::ino64_t,
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        pub f_flags: ::__fsword_t,
+        pub f_spare: [::__fsword_t; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        __unused1: ::c_ulong,
+        pub shm_dtime: ::time_t,
+        __unused2: ::c_ulong,
+        pub shm_ctime: ::time_t,
+        __unused3: ::c_ulong,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        __glibc_reserved1: ::c_ulong,
+        pub msg_rtime: ::time_t,
+        __glibc_reserved2: ::c_ulong,
+        pub msg_ctime: ::time_t,
+        __glibc_reserved3: ::c_ulong,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved4: ::c_ulong,
+        __glibc_reserved5: ::c_ulong,
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+}
+
+s_no_extra_traits! {
+    pub struct user_fpxregs_struct {
+        pub cwd: ::c_ushort,
+        pub swd: ::c_ushort,
+        pub twd: ::c_ushort,
+        pub fop: ::c_ushort,
+        pub fip: ::c_long,
+        pub fcs: ::c_long,
+        pub foo: ::c_long,
+        pub fos: ::c_long,
+        pub mxcsr: ::c_long,
+        __reserved: ::c_long,
+        pub st_space: [::c_long; 32],
+        pub xmm_space: [::c_long; 32],
+        padding: [::c_long; 56],
+    }
+
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_mcontext: mcontext_t,
+        pub uc_sigmask: ::sigset_t,
+        __private: [u8; 112],
+        __ssp: [::c_ulong; 4],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for user_fpxregs_struct {
+            fn eq(&self, other: &user_fpxregs_struct) -> bool {
+                self.cwd == other.cwd
+                    && self.swd == other.swd
+                    && self.twd == other.twd
+                    && self.fop == other.fop
+                    && self.fip == other.fip
+                    && self.fcs == other.fcs
+                    && self.foo == other.foo
+                    && self.fos == other.fos
+                    && self.mxcsr == other.mxcsr
+                // Ignore __reserved field
+                    && self.st_space == other.st_space
+                    && self.xmm_space == other.xmm_space
+                // Ignore padding field
+            }
+        }
+
+        impl Eq for user_fpxregs_struct {}
+
+        impl ::fmt::Debug for user_fpxregs_struct {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("user_fpxregs_struct")
+                    .field("cwd", &self.cwd)
+                    .field("swd", &self.swd)
+                    .field("twd", &self.twd)
+                    .field("fop", &self.fop)
+                    .field("fip", &self.fip)
+                    .field("fcs", &self.fcs)
+                    .field("foo", &self.foo)
+                    .field("fos", &self.fos)
+                    .field("mxcsr", &self.mxcsr)
+                // Ignore __reserved field
+                    .field("st_space", &self.st_space)
+                    .field("xmm_space", &self.xmm_space)
+                // Ignore padding field
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for user_fpxregs_struct {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.cwd.hash(state);
+                self.swd.hash(state);
+                self.twd.hash(state);
+                self.fop.hash(state);
+                self.fip.hash(state);
+                self.fcs.hash(state);
+                self.foo.hash(state);
+                self.fos.hash(state);
+                self.mxcsr.hash(state);
+                // Ignore __reserved field
+                self.st_space.hash(state);
+                self.xmm_space.hash(state);
+                // Ignore padding field
+            }
+        }
+
+        impl PartialEq for ucontext_t {
+            fn eq(&self, other: &ucontext_t) -> bool {
+                self.uc_flags == other.uc_flags
+                    && self.uc_link == other.uc_link
+                    && self.uc_stack == other.uc_stack
+                    && self.uc_mcontext == other.uc_mcontext
+                    && self.uc_sigmask == other.uc_sigmask
+                // Ignore __private field
+            }
+        }
+
+        impl Eq for ucontext_t {}
+
+        impl ::fmt::Debug for ucontext_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("ucontext_t")
+                    .field("uc_flags", &self.uc_flags)
+                    .field("uc_link", &self.uc_link)
+                    .field("uc_stack", &self.uc_stack)
+                    .field("uc_mcontext", &self.uc_mcontext)
+                    .field("uc_sigmask", &self.uc_sigmask)
+                // Ignore __private field
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for ucontext_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uc_flags.hash(state);
+                self.uc_link.hash(state);
+                self.uc_stack.hash(state);
+                self.uc_mcontext.hash(state);
+                self.uc_sigmask.hash(state);
+                // Ignore __private field
+            }
+        }
+    }
+}
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const O_DIRECT: ::c_int = 0x4000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+pub const O_LARGEFILE: ::c_int = 0o0100000;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 0x101000;
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_NDELAY: ::c_int = 0x800;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_32BIT: ::c_int = 0x0040;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const EDEADLOCK: ::c_int = 35;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+
+pub const FIOCLEX: ::c_ulong = 0x5451;
+pub const FIONCLEX: ::c_ulong = 0x5450;
+pub const FIONBIO: ::c_ulong = 0x5421;
+
+pub const PTRACE_GETFPXREGS: ::c_uint = 18;
+pub const PTRACE_SETFPXREGS: ::c_uint = 19;
+pub const PTRACE_SYSEMU: ::c_uint = 31;
+pub const PTRACE_SYSEMU_SINGLESTEP: ::c_uint = 32;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+pub const SFD_NONBLOCK: ::c_int = 0x0800;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = 31;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5419;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x541A;
+pub const TIOCEXCL: ::c_ulong = 0x540C;
+pub const TIOCNXCL: ::c_ulong = 0x540D;
+pub const TIOCSCTTY: ::c_ulong = 0x540E;
+pub const TIOCSTI: ::c_ulong = 0x5412;
+pub const TIOCMGET: ::c_ulong = 0x5415;
+pub const TIOCMBIS: ::c_ulong = 0x5416;
+pub const TIOCMBIC: ::c_ulong = 0x5417;
+pub const TIOCMSET: ::c_ulong = 0x5418;
+pub const TIOCCONS: ::c_ulong = 0x541D;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+pub const TCGETS: ::c_ulong = 0x5401;
+pub const TCSETS: ::c_ulong = 0x5402;
+pub const TCSETSW: ::c_ulong = 0x5403;
+pub const TCSETSF: ::c_ulong = 0x5404;
+pub const TCGETA: ::c_ulong = 0x5405;
+pub const TCSETA: ::c_ulong = 0x5406;
+pub const TCSETAW: ::c_ulong = 0x5407;
+pub const TCSETAF: ::c_ulong = 0x5408;
+pub const TCSBRK: ::c_ulong = 0x5409;
+pub const TCXONC: ::c_ulong = 0x540A;
+pub const TCFLSH: ::c_ulong = 0x540B;
+pub const TIOCINQ: ::c_ulong = 0x541B;
+pub const TIOCGPGRP: ::c_ulong = 0x540F;
+pub const TIOCSPGRP: ::c_ulong = 0x5410;
+pub const TIOCOUTQ: ::c_ulong = 0x5411;
+pub const TIOCGWINSZ: ::c_ulong = 0x5413;
+pub const TIOCSWINSZ: ::c_ulong = 0x5414;
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+pub const FIONREAD: ::c_ulong = 0x541B;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+// Syscall table
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_waitpid: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_time: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_break: ::c_long = 17;
+pub const SYS_oldstat: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_umount: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_stime: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_oldfstat: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_stty: ::c_long = 31;
+pub const SYS_gtty: ::c_long = 32;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_ftime: ::c_long = 35;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_prof: ::c_long = 44;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_lock: ::c_long = 53;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_mpx: ::c_long = 56;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_ulimit: ::c_long = 58;
+pub const SYS_oldolduname: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_sgetmask: ::c_long = 68;
+pub const SYS_ssetmask: ::c_long = 69;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrlimit: ::c_long = 76;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_select: ::c_long = 82;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_oldlstat: ::c_long = 84;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_readdir: ::c_long = 89;
+pub const SYS_mmap: ::c_long = 90;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_profil: ::c_long = 98;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_ioperm: ::c_long = 101;
+pub const SYS_socketcall: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_olduname: ::c_long = 109;
+pub const SYS_iopl: ::c_long = 110;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_idle: ::c_long = 112;
+pub const SYS_vm86old: ::c_long = 113;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_ipc: ::c_long = 117;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_modify_ldt: ::c_long = 123;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_create_module: ::c_long = 127;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_get_kernel_syms: ::c_long = 130;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_afs_syscall: ::c_long = 137;
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_vm86: ::c_long = 166;
+pub const SYS_query_module: ::c_long = 167;
+pub const SYS_poll: ::c_long = 168;
+pub const SYS_nfsservctl: ::c_long = 169;
+pub const SYS_setresgid: ::c_long = 170;
+pub const SYS_getresgid: ::c_long = 171;
+pub const SYS_prctl: ::c_long = 172;
+pub const SYS_rt_sigreturn: ::c_long = 173;
+pub const SYS_rt_sigaction: ::c_long = 174;
+pub const SYS_rt_sigprocmask: ::c_long = 175;
+pub const SYS_rt_sigpending: ::c_long = 176;
+pub const SYS_rt_sigtimedwait: ::c_long = 177;
+pub const SYS_rt_sigqueueinfo: ::c_long = 178;
+pub const SYS_rt_sigsuspend: ::c_long = 179;
+pub const SYS_pread64: ::c_long = 180;
+pub const SYS_pwrite64: ::c_long = 181;
+pub const SYS_chown: ::c_long = 182;
+pub const SYS_getcwd: ::c_long = 183;
+pub const SYS_capget: ::c_long = 184;
+pub const SYS_capset: ::c_long = 185;
+pub const SYS_sigaltstack: ::c_long = 186;
+pub const SYS_sendfile: ::c_long = 187;
+pub const SYS_getpmsg: ::c_long = 188;
+pub const SYS_putpmsg: ::c_long = 189;
+pub const SYS_vfork: ::c_long = 190;
+pub const SYS_ugetrlimit: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_lchown32: ::c_long = 198;
+pub const SYS_getuid32: ::c_long = 199;
+pub const SYS_getgid32: ::c_long = 200;
+pub const SYS_geteuid32: ::c_long = 201;
+pub const SYS_getegid32: ::c_long = 202;
+pub const SYS_setreuid32: ::c_long = 203;
+pub const SYS_setregid32: ::c_long = 204;
+pub const SYS_getgroups32: ::c_long = 205;
+pub const SYS_setgroups32: ::c_long = 206;
+pub const SYS_fchown32: ::c_long = 207;
+pub const SYS_setresuid32: ::c_long = 208;
+pub const SYS_getresuid32: ::c_long = 209;
+pub const SYS_setresgid32: ::c_long = 210;
+pub const SYS_getresgid32: ::c_long = 211;
+pub const SYS_chown32: ::c_long = 212;
+pub const SYS_setuid32: ::c_long = 213;
+pub const SYS_setgid32: ::c_long = 214;
+pub const SYS_setfsuid32: ::c_long = 215;
+pub const SYS_setfsgid32: ::c_long = 216;
+pub const SYS_pivot_root: ::c_long = 217;
+pub const SYS_mincore: ::c_long = 218;
+pub const SYS_madvise: ::c_long = 219;
+pub const SYS_getdents64: ::c_long = 220;
+pub const SYS_fcntl64: ::c_long = 221;
+pub const SYS_gettid: ::c_long = 224;
+pub const SYS_readahead: ::c_long = 225;
+pub const SYS_setxattr: ::c_long = 226;
+pub const SYS_lsetxattr: ::c_long = 227;
+pub const SYS_fsetxattr: ::c_long = 228;
+pub const SYS_getxattr: ::c_long = 229;
+pub const SYS_lgetxattr: ::c_long = 230;
+pub const SYS_fgetxattr: ::c_long = 231;
+pub const SYS_listxattr: ::c_long = 232;
+pub const SYS_llistxattr: ::c_long = 233;
+pub const SYS_flistxattr: ::c_long = 234;
+pub const SYS_removexattr: ::c_long = 235;
+pub const SYS_lremovexattr: ::c_long = 236;
+pub const SYS_fremovexattr: ::c_long = 237;
+pub const SYS_tkill: ::c_long = 238;
+pub const SYS_sendfile64: ::c_long = 239;
+pub const SYS_futex: ::c_long = 240;
+pub const SYS_sched_setaffinity: ::c_long = 241;
+pub const SYS_sched_getaffinity: ::c_long = 242;
+pub const SYS_set_thread_area: ::c_long = 243;
+pub const SYS_get_thread_area: ::c_long = 244;
+pub const SYS_io_setup: ::c_long = 245;
+pub const SYS_io_destroy: ::c_long = 246;
+pub const SYS_io_getevents: ::c_long = 247;
+pub const SYS_io_submit: ::c_long = 248;
+pub const SYS_io_cancel: ::c_long = 249;
+pub const SYS_fadvise64: ::c_long = 250;
+pub const SYS_exit_group: ::c_long = 252;
+pub const SYS_lookup_dcookie: ::c_long = 253;
+pub const SYS_epoll_create: ::c_long = 254;
+pub const SYS_epoll_ctl: ::c_long = 255;
+pub const SYS_epoll_wait: ::c_long = 256;
+pub const SYS_remap_file_pages: ::c_long = 257;
+pub const SYS_set_tid_address: ::c_long = 258;
+pub const SYS_timer_create: ::c_long = 259;
+pub const SYS_timer_settime: ::c_long = 260;
+pub const SYS_timer_gettime: ::c_long = 261;
+pub const SYS_timer_getoverrun: ::c_long = 262;
+pub const SYS_timer_delete: ::c_long = 263;
+pub const SYS_clock_settime: ::c_long = 264;
+pub const SYS_clock_gettime: ::c_long = 265;
+pub const SYS_clock_getres: ::c_long = 266;
+pub const SYS_clock_nanosleep: ::c_long = 267;
+pub const SYS_statfs64: ::c_long = 268;
+pub const SYS_fstatfs64: ::c_long = 269;
+pub const SYS_tgkill: ::c_long = 270;
+pub const SYS_utimes: ::c_long = 271;
+pub const SYS_fadvise64_64: ::c_long = 272;
+pub const SYS_vserver: ::c_long = 273;
+pub const SYS_mbind: ::c_long = 274;
+pub const SYS_get_mempolicy: ::c_long = 275;
+pub const SYS_set_mempolicy: ::c_long = 276;
+pub const SYS_mq_open: ::c_long = 277;
+pub const SYS_mq_unlink: ::c_long = 278;
+pub const SYS_mq_timedsend: ::c_long = 279;
+pub const SYS_mq_timedreceive: ::c_long = 280;
+pub const SYS_mq_notify: ::c_long = 281;
+pub const SYS_mq_getsetattr: ::c_long = 282;
+pub const SYS_kexec_load: ::c_long = 283;
+pub const SYS_waitid: ::c_long = 284;
+pub const SYS_add_key: ::c_long = 286;
+pub const SYS_request_key: ::c_long = 287;
+pub const SYS_keyctl: ::c_long = 288;
+pub const SYS_ioprio_set: ::c_long = 289;
+pub const SYS_ioprio_get: ::c_long = 290;
+pub const SYS_inotify_init: ::c_long = 291;
+pub const SYS_inotify_add_watch: ::c_long = 292;
+pub const SYS_inotify_rm_watch: ::c_long = 293;
+pub const SYS_migrate_pages: ::c_long = 294;
+pub const SYS_openat: ::c_long = 295;
+pub const SYS_mkdirat: ::c_long = 296;
+pub const SYS_mknodat: ::c_long = 297;
+pub const SYS_fchownat: ::c_long = 298;
+pub const SYS_futimesat: ::c_long = 299;
+pub const SYS_fstatat64: ::c_long = 300;
+pub const SYS_unlinkat: ::c_long = 301;
+pub const SYS_renameat: ::c_long = 302;
+pub const SYS_linkat: ::c_long = 303;
+pub const SYS_symlinkat: ::c_long = 304;
+pub const SYS_readlinkat: ::c_long = 305;
+pub const SYS_fchmodat: ::c_long = 306;
+pub const SYS_faccessat: ::c_long = 307;
+pub const SYS_pselect6: ::c_long = 308;
+pub const SYS_ppoll: ::c_long = 309;
+pub const SYS_unshare: ::c_long = 310;
+pub const SYS_set_robust_list: ::c_long = 311;
+pub const SYS_get_robust_list: ::c_long = 312;
+pub const SYS_splice: ::c_long = 313;
+pub const SYS_sync_file_range: ::c_long = 314;
+pub const SYS_tee: ::c_long = 315;
+pub const SYS_vmsplice: ::c_long = 316;
+pub const SYS_move_pages: ::c_long = 317;
+pub const SYS_getcpu: ::c_long = 318;
+pub const SYS_epoll_pwait: ::c_long = 319;
+pub const SYS_utimensat: ::c_long = 320;
+pub const SYS_signalfd: ::c_long = 321;
+pub const SYS_timerfd_create: ::c_long = 322;
+pub const SYS_eventfd: ::c_long = 323;
+pub const SYS_fallocate: ::c_long = 324;
+pub const SYS_timerfd_settime: ::c_long = 325;
+pub const SYS_timerfd_gettime: ::c_long = 326;
+pub const SYS_signalfd4: ::c_long = 327;
+pub const SYS_eventfd2: ::c_long = 328;
+pub const SYS_epoll_create1: ::c_long = 329;
+pub const SYS_dup3: ::c_long = 330;
+pub const SYS_pipe2: ::c_long = 331;
+pub const SYS_inotify_init1: ::c_long = 332;
+pub const SYS_preadv: ::c_long = 333;
+pub const SYS_pwritev: ::c_long = 334;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 335;
+pub const SYS_perf_event_open: ::c_long = 336;
+pub const SYS_recvmmsg: ::c_long = 337;
+pub const SYS_fanotify_init: ::c_long = 338;
+pub const SYS_fanotify_mark: ::c_long = 339;
+pub const SYS_prlimit64: ::c_long = 340;
+pub const SYS_name_to_handle_at: ::c_long = 341;
+pub const SYS_open_by_handle_at: ::c_long = 342;
+pub const SYS_clock_adjtime: ::c_long = 343;
+pub const SYS_syncfs: ::c_long = 344;
+pub const SYS_sendmmsg: ::c_long = 345;
+pub const SYS_setns: ::c_long = 346;
+pub const SYS_process_vm_readv: ::c_long = 347;
+pub const SYS_process_vm_writev: ::c_long = 348;
+pub const SYS_kcmp: ::c_long = 349;
+pub const SYS_finit_module: ::c_long = 350;
+pub const SYS_sched_setattr: ::c_long = 351;
+pub const SYS_sched_getattr: ::c_long = 352;
+pub const SYS_renameat2: ::c_long = 353;
+pub const SYS_seccomp: ::c_long = 354;
+pub const SYS_getrandom: ::c_long = 355;
+pub const SYS_memfd_create: ::c_long = 356;
+pub const SYS_bpf: ::c_long = 357;
+pub const SYS_execveat: ::c_long = 358;
+pub const SYS_socket: ::c_long = 359;
+pub const SYS_socketpair: ::c_long = 360;
+pub const SYS_bind: ::c_long = 361;
+pub const SYS_connect: ::c_long = 362;
+pub const SYS_listen: ::c_long = 363;
+pub const SYS_accept4: ::c_long = 364;
+pub const SYS_getsockopt: ::c_long = 365;
+pub const SYS_setsockopt: ::c_long = 366;
+pub const SYS_getsockname: ::c_long = 367;
+pub const SYS_getpeername: ::c_long = 368;
+pub const SYS_sendto: ::c_long = 369;
+pub const SYS_sendmsg: ::c_long = 370;
+pub const SYS_recvfrom: ::c_long = 371;
+pub const SYS_recvmsg: ::c_long = 372;
+pub const SYS_shutdown: ::c_long = 373;
+pub const SYS_userfaultfd: ::c_long = 374;
+pub const SYS_membarrier: ::c_long = 375;
+pub const SYS_mlock2: ::c_long = 376;
+pub const SYS_copy_file_range: ::c_long = 377;
+pub const SYS_preadv2: ::c_long = 378;
+pub const SYS_pwritev2: ::c_long = 379;
+pub const SYS_pkey_mprotect: ::c_long = 380;
+pub const SYS_pkey_alloc: ::c_long = 381;
+pub const SYS_pkey_free: ::c_long = 382;
+pub const SYS_statx: ::c_long = 383;
+pub const SYS_pidfd_open: ::c_long = 434;
+pub const SYS_clone3: ::c_long = 435;
+
+// offsets in user_regs_structs, from sys/reg.h
+pub const EBX: ::c_int = 0;
+pub const ECX: ::c_int = 1;
+pub const EDX: ::c_int = 2;
+pub const ESI: ::c_int = 3;
+pub const EDI: ::c_int = 4;
+pub const EBP: ::c_int = 5;
+pub const EAX: ::c_int = 6;
+pub const DS: ::c_int = 7;
+pub const ES: ::c_int = 8;
+pub const FS: ::c_int = 9;
+pub const GS: ::c_int = 10;
+pub const ORIG_EAX: ::c_int = 11;
+pub const EIP: ::c_int = 12;
+pub const CS: ::c_int = 13;
+pub const EFL: ::c_int = 14;
+pub const UESP: ::c_int = 15;
+pub const SS: ::c_int = 16;
+
+// offsets in mcontext_t.gregs from sys/ucontext.h
+pub const REG_GS: ::c_int = 0;
+pub const REG_FS: ::c_int = 1;
+pub const REG_ES: ::c_int = 2;
+pub const REG_DS: ::c_int = 3;
+pub const REG_EDI: ::c_int = 4;
+pub const REG_ESI: ::c_int = 5;
+pub const REG_EBP: ::c_int = 6;
+pub const REG_ESP: ::c_int = 7;
+pub const REG_EBX: ::c_int = 8;
+pub const REG_EDX: ::c_int = 9;
+pub const REG_ECX: ::c_int = 10;
+pub const REG_EAX: ::c_int = 11;
+pub const REG_TRAPNO: ::c_int = 12;
+pub const REG_ERR: ::c_int = 13;
+pub const REG_EIP: ::c_int = 14;
+pub const REG_CS: ::c_int = 15;
+pub const REG_EFL: ::c_int = 16;
+pub const REG_UESP: ::c_int = 17;
+pub const REG_SS: ::c_int = 18;
+
+extern "C" {
+    pub fn getcontext(ucp: *mut ucontext_t) -> ::c_int;
+    pub fn setcontext(ucp: *const ucontext_t) -> ::c_int;
+    pub fn makecontext(
+        ucp: *mut ucontext_t,
+        func: extern "C" fn(),
+        argc: ::c_int,
+        ...
+    );
+    pub fn swapcontext(
+        uocp: *mut ucontext_t,
+        ucp: *const ucontext_t,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/align.rs
new file mode 100644
index 00000000..154c2c54
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/align.rs
@@ -0,0 +1,29 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f32; 8]
+    }
+}
+
+s! {
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_sigmask: ::sigset_t,
+        pub uc_mcontext: mcontext_t,
+    }
+
+    #[repr(align(16))]
+    pub struct mcontext_t {
+        pub fault_address: ::c_ulonglong,
+        pub regs: [::c_ulonglong; 31],
+        pub sp: ::c_ulonglong,
+        pub pc: ::c_ulonglong,
+        pub pstate: ::c_ulonglong,
+        // nested arrays to get the right size/length while being able to
+        // auto-derive traits like Debug
+        __reserved: [[u64; 32]; 16],
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/ilp32.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/ilp32.rs
new file mode 100644
index 00000000..24b7f4e6
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/ilp32.rs
@@ -0,0 +1,62 @@
+use pthread_mutex_t;
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 32;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 48;
+
+align_const! {
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+}
+
+pub const SYS_sync_file_range2: ::c_long = 84;
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/lp64.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/lp64.rs
new file mode 100644
index 00000000..14d39e54
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/lp64.rs
@@ -0,0 +1,71 @@
+use pthread_mutex_t;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 8;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 48;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 8;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+align_const! {
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0,
+            ],
+        };
+}
+
+pub const SYS_renameat: ::c_long = 38;
+pub const SYS_sync_file_range: ::c_long = 84;
+pub const SYS_getrlimit: ::c_long = 163;
+pub const SYS_setrlimit: ::c_long = 164;
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/mod.rs
new file mode 100644
index 00000000..e9a06c77
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/aarch64/mod.rs
@@ -0,0 +1,1008 @@
+//! AArch64-specific definitions for 64-bit linux-like values
+
+pub type c_char = u8;
+pub type wchar_t = u32;
+pub type nlink_t = u32;
+pub type blksize_t = i32;
+pub type suseconds_t = i64;
+pub type __u64 = ::c_ulonglong;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        #[cfg(target_arch = "sparc64")]
+        __reserved0: ::c_int,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statfs {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        f_spare: [::__fsword_t; 5],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad1: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        __pad2: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_int; 2],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad1: ::dev_t,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        __pad2: ::c_int,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_int; 2],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        pub f_flags: ::__fsword_t,
+        pub f_spare: [::__fsword_t; 4],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct pthread_attr_t {
+        __size: [usize; 8]
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_uint,
+        pub __seq: ::c_ushort,
+        __pad1: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct ip_mreqn {
+        pub imr_multiaddr: ::in_addr,
+        pub imr_address: ::in_addr,
+        pub imr_ifindex: ::c_int,
+    }
+}
+
+pub const VEOF: usize = 4;
+
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 0x101000;
+pub const O_NOATIME: ::c_int = 0o1000000;
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PEERSEC: ::c_int = 31;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_BUSY_POLL: ::c_int = 46;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = SO_DETACH_FILTER;
+pub const SO_ATTACH_REUSEPORT_CBPF: ::c_int = 51;
+pub const SO_ATTACH_REUSEPORT_EBPF: ::c_int = 52;
+pub const SO_CNX_ADVICE: ::c_int = 53;
+pub const SCM_TIMESTAMPING_OPT_STATS: ::c_int = 54;
+pub const SO_MEMINFO: ::c_int = 55;
+pub const SO_INCOMING_NAPI_ID: ::c_int = 56;
+pub const SO_COOKIE: ::c_int = 57;
+pub const SCM_TIMESTAMPING_PKTINFO: ::c_int = 58;
+pub const SO_PEERGROUPS: ::c_int = 59;
+pub const SO_ZEROCOPY: ::c_int = 60;
+pub const SO_TXTIME: ::c_int = 61;
+pub const SCM_TXTIME: ::c_int = SO_TXTIME;
+pub const SO_BINDTOIFINDEX: ::c_int = 62;
+pub const SO_TIMESTAMP_NEW: ::c_int = 63;
+pub const SO_TIMESTAMPNS_NEW: ::c_int = 64;
+pub const SO_TIMESTAMPING_NEW: ::c_int = 65;
+pub const SO_RCVTIMEO_NEW: ::c_int = 66;
+pub const SO_SNDTIMEO_NEW: ::c_int = 67;
+pub const SO_DETACH_REUSEPORT_BPF: ::c_int = 68;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = 31;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_NDELAY: ::c_int = 0x800;
+
+pub const PTRACE_DETACH: ::c_uint = 17;
+
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+
+pub const SFD_NONBLOCK: ::c_int = 0x0800;
+
+pub const TIOCEXCL: ::c_ulong = 0x540C;
+pub const TIOCNXCL: ::c_ulong = 0x540D;
+pub const TIOCSCTTY: ::c_ulong = 0x540E;
+pub const TIOCSTI: ::c_ulong = 0x5412;
+pub const TIOCMGET: ::c_ulong = 0x5415;
+pub const TIOCMBIS: ::c_ulong = 0x5416;
+pub const TIOCMBIC: ::c_ulong = 0x5417;
+pub const TIOCMSET: ::c_ulong = 0x5418;
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5419;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x541A;
+pub const TIOCCONS: ::c_ulong = 0x541D;
+pub const TIOCSBRK: ::c_ulong = 0x5427;
+pub const TIOCCBRK: ::c_ulong = 0x5428;
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 512;
+
+pub const O_CLOEXEC: ::c_int = 0x80000;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const O_DIRECT: ::c_int = 0x10000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const EDEADLOCK: ::c_int = 35;
+
+pub const FIOCLEX: ::c_ulong = 0x5451;
+pub const FIONCLEX: ::c_ulong = 0x5450;
+pub const FIONBIO: ::c_ulong = 0x5421;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const SIGSTKSZ: ::size_t = 16384;
+pub const MINSIGSTKSZ: ::size_t = 5120;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+pub const TCGETS: ::c_ulong = 0x5401;
+pub const TCSETS: ::c_ulong = 0x5402;
+pub const TCSETSW: ::c_ulong = 0x5403;
+pub const TCSETSF: ::c_ulong = 0x5404;
+pub const TCGETA: ::c_ulong = 0x5405;
+pub const TCSETA: ::c_ulong = 0x5406;
+pub const TCSETAW: ::c_ulong = 0x5407;
+pub const TCSETAF: ::c_ulong = 0x5408;
+pub const TCSBRK: ::c_ulong = 0x5409;
+pub const TCXONC: ::c_ulong = 0x540A;
+pub const TCFLSH: ::c_ulong = 0x540B;
+pub const TIOCINQ: ::c_ulong = 0x541B;
+pub const TIOCGPGRP: ::c_ulong = 0x540F;
+pub const TIOCSPGRP: ::c_ulong = 0x5410;
+pub const TIOCOUTQ: ::c_ulong = 0x5411;
+pub const TIOCGWINSZ: ::c_ulong = 0x5413;
+pub const TIOCSWINSZ: ::c_ulong = 0x5414;
+pub const FIONREAD: ::c_ulong = 0x541B;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+
+// sys/auxv.h
+pub const HWCAP_FP: ::c_ulong = 1 << 0;
+pub const HWCAP_ASIMD: ::c_ulong = 1 << 1;
+pub const HWCAP_EVTSTRM: ::c_ulong = 1 << 2;
+pub const HWCAP_AES: ::c_ulong = 1 << 3;
+pub const HWCAP_PMULL: ::c_ulong = 1 << 4;
+pub const HWCAP_SHA1: ::c_ulong = 1 << 5;
+pub const HWCAP_SHA2: ::c_ulong = 1 << 6;
+pub const HWCAP_CRC32: ::c_ulong = 1 << 7;
+pub const HWCAP_ATOMICS: ::c_ulong = 1 << 8;
+pub const HWCAP_FPHP: ::c_ulong = 1 << 9;
+pub const HWCAP_ASIMDHP: ::c_ulong = 1 << 10;
+pub const HWCAP_CPUID: ::c_ulong = 1 << 11;
+pub const HWCAP_ASIMDRDM: ::c_ulong = 1 << 12;
+pub const HWCAP_JSCVT: ::c_ulong = 1 << 13;
+pub const HWCAP_FCMA: ::c_ulong = 1 << 14;
+pub const HWCAP_LRCPC: ::c_ulong = 1 << 15;
+pub const HWCAP_DCPOP: ::c_ulong = 1 << 16;
+pub const HWCAP_SHA3: ::c_ulong = 1 << 17;
+pub const HWCAP_SM3: ::c_ulong = 1 << 18;
+pub const HWCAP_SM4: ::c_ulong = 1 << 19;
+pub const HWCAP_ASIMDDP: ::c_ulong = 1 << 20;
+pub const HWCAP_SHA512: ::c_ulong = 1 << 21;
+pub const HWCAP_SVE: ::c_ulong = 1 << 22;
+pub const HWCAP_ASIMDFHM: ::c_ulong = 1 << 23;
+pub const HWCAP_DIT: ::c_ulong = 1 << 24;
+pub const HWCAP_USCAT: ::c_ulong = 1 << 25;
+pub const HWCAP_ILRCPC: ::c_ulong = 1 << 26;
+pub const HWCAP_FLAGM: ::c_ulong = 1 << 27;
+pub const HWCAP_SSBS: ::c_ulong = 1 << 28;
+pub const HWCAP_SB: ::c_ulong = 1 << 29;
+pub const HWCAP_PACA: ::c_ulong = 1 << 30;
+pub const HWCAP_PACG: ::c_ulong = 1 << 31;
+// FIXME: enable these again once linux-api-headers are up to date enough on CI.
+// See discussion in https://github.com/rust-lang/libc/pull/1638
+//pub const HWCAP2_DCPODP: ::c_ulong = 1 << 0;
+//pub const HWCAP2_SVE2: ::c_ulong = 1 << 1;
+//pub const HWCAP2_SVEAES: ::c_ulong = 1 << 2;
+//pub const HWCAP2_SVEPMULL: ::c_ulong = 1 << 3;
+//pub const HWCAP2_SVEBITPERM: ::c_ulong = 1 << 4;
+//pub const HWCAP2_SVESHA3: ::c_ulong = 1 << 5;
+//pub const HWCAP2_SVESM4: ::c_ulong = 1 << 6;
+//pub const HWCAP2_FLAGM2: ::c_ulong = 1 << 7;
+//pub const HWCAP2_FRINT: ::c_ulong = 1 << 8;
+
+// Syscall table
+pub const SYS_io_setup: ::c_long = 0;
+pub const SYS_io_destroy: ::c_long = 1;
+pub const SYS_io_submit: ::c_long = 2;
+pub const SYS_io_cancel: ::c_long = 3;
+pub const SYS_io_getevents: ::c_long = 4;
+pub const SYS_setxattr: ::c_long = 5;
+pub const SYS_lsetxattr: ::c_long = 6;
+pub const SYS_fsetxattr: ::c_long = 7;
+pub const SYS_getxattr: ::c_long = 8;
+pub const SYS_lgetxattr: ::c_long = 9;
+pub const SYS_fgetxattr: ::c_long = 10;
+pub const SYS_listxattr: ::c_long = 11;
+pub const SYS_llistxattr: ::c_long = 12;
+pub const SYS_flistxattr: ::c_long = 13;
+pub const SYS_removexattr: ::c_long = 14;
+pub const SYS_lremovexattr: ::c_long = 15;
+pub const SYS_fremovexattr: ::c_long = 16;
+pub const SYS_getcwd: ::c_long = 17;
+pub const SYS_lookup_dcookie: ::c_long = 18;
+pub const SYS_eventfd2: ::c_long = 19;
+pub const SYS_epoll_create1: ::c_long = 20;
+pub const SYS_epoll_ctl: ::c_long = 21;
+pub const SYS_epoll_pwait: ::c_long = 22;
+pub const SYS_dup: ::c_long = 23;
+pub const SYS_dup3: ::c_long = 24;
+pub const SYS_fcntl: ::c_long = 25;
+pub const SYS_inotify_init1: ::c_long = 26;
+pub const SYS_inotify_add_watch: ::c_long = 27;
+pub const SYS_inotify_rm_watch: ::c_long = 28;
+pub const SYS_ioctl: ::c_long = 29;
+pub const SYS_ioprio_set: ::c_long = 30;
+pub const SYS_ioprio_get: ::c_long = 31;
+pub const SYS_flock: ::c_long = 32;
+pub const SYS_mknodat: ::c_long = 33;
+pub const SYS_mkdirat: ::c_long = 34;
+pub const SYS_unlinkat: ::c_long = 35;
+pub const SYS_symlinkat: ::c_long = 36;
+pub const SYS_linkat: ::c_long = 37;
+// 38 is renameat only on LP64
+pub const SYS_umount2: ::c_long = 39;
+pub const SYS_mount: ::c_long = 40;
+pub const SYS_pivot_root: ::c_long = 41;
+pub const SYS_nfsservctl: ::c_long = 42;
+pub const SYS_statfs: ::c_long = 43;
+pub const SYS_fstatfs: ::c_long = 44;
+pub const SYS_truncate: ::c_long = 45;
+pub const SYS_ftruncate: ::c_long = 46;
+pub const SYS_fallocate: ::c_long = 47;
+pub const SYS_faccessat: ::c_long = 48;
+pub const SYS_chdir: ::c_long = 49;
+pub const SYS_fchdir: ::c_long = 50;
+pub const SYS_chroot: ::c_long = 51;
+pub const SYS_fchmod: ::c_long = 52;
+pub const SYS_fchmodat: ::c_long = 53;
+pub const SYS_fchownat: ::c_long = 54;
+pub const SYS_fchown: ::c_long = 55;
+pub const SYS_openat: ::c_long = 56;
+pub const SYS_close: ::c_long = 57;
+pub const SYS_vhangup: ::c_long = 58;
+pub const SYS_pipe2: ::c_long = 59;
+pub const SYS_quotactl: ::c_long = 60;
+pub const SYS_getdents64: ::c_long = 61;
+pub const SYS_lseek: ::c_long = 62;
+pub const SYS_read: ::c_long = 63;
+pub const SYS_write: ::c_long = 64;
+pub const SYS_readv: ::c_long = 65;
+pub const SYS_writev: ::c_long = 66;
+pub const SYS_pread64: ::c_long = 67;
+pub const SYS_pwrite64: ::c_long = 68;
+pub const SYS_preadv: ::c_long = 69;
+pub const SYS_pwritev: ::c_long = 70;
+pub const SYS_pselect6: ::c_long = 72;
+pub const SYS_ppoll: ::c_long = 73;
+pub const SYS_signalfd4: ::c_long = 74;
+pub const SYS_vmsplice: ::c_long = 75;
+pub const SYS_splice: ::c_long = 76;
+pub const SYS_tee: ::c_long = 77;
+pub const SYS_readlinkat: ::c_long = 78;
+pub const SYS_newfstatat: ::c_long = 79;
+pub const SYS_fstat: ::c_long = 80;
+pub const SYS_sync: ::c_long = 81;
+pub const SYS_fsync: ::c_long = 82;
+pub const SYS_fdatasync: ::c_long = 83;
+// 84 sync_file_range on LP64 and sync_file_range2 on ILP32
+pub const SYS_timerfd_create: ::c_long = 85;
+pub const SYS_timerfd_settime: ::c_long = 86;
+pub const SYS_timerfd_gettime: ::c_long = 87;
+pub const SYS_utimensat: ::c_long = 88;
+pub const SYS_acct: ::c_long = 89;
+pub const SYS_capget: ::c_long = 90;
+pub const SYS_capset: ::c_long = 91;
+pub const SYS_personality: ::c_long = 92;
+pub const SYS_exit: ::c_long = 93;
+pub const SYS_exit_group: ::c_long = 94;
+pub const SYS_waitid: ::c_long = 95;
+pub const SYS_set_tid_address: ::c_long = 96;
+pub const SYS_unshare: ::c_long = 97;
+pub const SYS_futex: ::c_long = 98;
+pub const SYS_set_robust_list: ::c_long = 99;
+pub const SYS_get_robust_list: ::c_long = 100;
+pub const SYS_nanosleep: ::c_long = 101;
+pub const SYS_getitimer: ::c_long = 102;
+pub const SYS_setitimer: ::c_long = 103;
+pub const SYS_kexec_load: ::c_long = 104;
+pub const SYS_init_module: ::c_long = 105;
+pub const SYS_delete_module: ::c_long = 106;
+pub const SYS_timer_create: ::c_long = 107;
+pub const SYS_timer_gettime: ::c_long = 108;
+pub const SYS_timer_getoverrun: ::c_long = 109;
+pub const SYS_timer_settime: ::c_long = 110;
+pub const SYS_timer_delete: ::c_long = 111;
+pub const SYS_clock_settime: ::c_long = 112;
+pub const SYS_clock_gettime: ::c_long = 113;
+pub const SYS_clock_getres: ::c_long = 114;
+pub const SYS_clock_nanosleep: ::c_long = 115;
+pub const SYS_syslog: ::c_long = 116;
+pub const SYS_ptrace: ::c_long = 117;
+pub const SYS_sched_setparam: ::c_long = 118;
+pub const SYS_sched_setscheduler: ::c_long = 119;
+pub const SYS_sched_getscheduler: ::c_long = 120;
+pub const SYS_sched_getparam: ::c_long = 121;
+pub const SYS_sched_setaffinity: ::c_long = 122;
+pub const SYS_sched_getaffinity: ::c_long = 123;
+pub const SYS_sched_yield: ::c_long = 124;
+pub const SYS_sched_get_priority_max: ::c_long = 125;
+pub const SYS_sched_get_priority_min: ::c_long = 126;
+pub const SYS_sched_rr_get_interval: ::c_long = 127;
+pub const SYS_restart_syscall: ::c_long = 128;
+pub const SYS_kill: ::c_long = 129;
+pub const SYS_tkill: ::c_long = 130;
+pub const SYS_tgkill: ::c_long = 131;
+pub const SYS_sigaltstack: ::c_long = 132;
+pub const SYS_rt_sigsuspend: ::c_long = 133;
+pub const SYS_rt_sigaction: ::c_long = 134;
+pub const SYS_rt_sigprocmask: ::c_long = 135;
+pub const SYS_rt_sigpending: ::c_long = 136;
+pub const SYS_rt_sigtimedwait: ::c_long = 137;
+pub const SYS_rt_sigqueueinfo: ::c_long = 138;
+pub const SYS_rt_sigreturn: ::c_long = 139;
+pub const SYS_setpriority: ::c_long = 140;
+pub const SYS_getpriority: ::c_long = 141;
+pub const SYS_reboot: ::c_long = 142;
+pub const SYS_setregid: ::c_long = 143;
+pub const SYS_setgid: ::c_long = 144;
+pub const SYS_setreuid: ::c_long = 145;
+pub const SYS_setuid: ::c_long = 146;
+pub const SYS_setresuid: ::c_long = 147;
+pub const SYS_getresuid: ::c_long = 148;
+pub const SYS_setresgid: ::c_long = 149;
+pub const SYS_getresgid: ::c_long = 150;
+pub const SYS_setfsuid: ::c_long = 151;
+pub const SYS_setfsgid: ::c_long = 152;
+pub const SYS_times: ::c_long = 153;
+pub const SYS_setpgid: ::c_long = 154;
+pub const SYS_getpgid: ::c_long = 155;
+pub const SYS_getsid: ::c_long = 156;
+pub const SYS_setsid: ::c_long = 157;
+pub const SYS_getgroups: ::c_long = 158;
+pub const SYS_setgroups: ::c_long = 159;
+pub const SYS_uname: ::c_long = 160;
+pub const SYS_sethostname: ::c_long = 161;
+pub const SYS_setdomainname: ::c_long = 162;
+// 163 is getrlimit only on LP64
+// 164 is setrlimit only on LP64
+pub const SYS_getrusage: ::c_long = 165;
+pub const SYS_umask: ::c_long = 166;
+pub const SYS_prctl: ::c_long = 167;
+pub const SYS_getcpu: ::c_long = 168;
+pub const SYS_gettimeofday: ::c_long = 169;
+pub const SYS_settimeofday: ::c_long = 170;
+pub const SYS_adjtimex: ::c_long = 171;
+pub const SYS_getpid: ::c_long = 172;
+pub const SYS_getppid: ::c_long = 173;
+pub const SYS_getuid: ::c_long = 174;
+pub const SYS_geteuid: ::c_long = 175;
+pub const SYS_getgid: ::c_long = 176;
+pub const SYS_getegid: ::c_long = 177;
+pub const SYS_gettid: ::c_long = 178;
+pub const SYS_sysinfo: ::c_long = 179;
+pub const SYS_mq_open: ::c_long = 180;
+pub const SYS_mq_unlink: ::c_long = 181;
+pub const SYS_mq_timedsend: ::c_long = 182;
+pub const SYS_mq_timedreceive: ::c_long = 183;
+pub const SYS_mq_notify: ::c_long = 184;
+pub const SYS_mq_getsetattr: ::c_long = 185;
+pub const SYS_msgget: ::c_long = 186;
+pub const SYS_msgctl: ::c_long = 187;
+pub const SYS_msgrcv: ::c_long = 188;
+pub const SYS_msgsnd: ::c_long = 189;
+pub const SYS_semget: ::c_long = 190;
+pub const SYS_semctl: ::c_long = 191;
+pub const SYS_semtimedop: ::c_long = 192;
+pub const SYS_semop: ::c_long = 193;
+pub const SYS_shmget: ::c_long = 194;
+pub const SYS_shmctl: ::c_long = 195;
+pub const SYS_shmat: ::c_long = 196;
+pub const SYS_shmdt: ::c_long = 197;
+pub const SYS_socket: ::c_long = 198;
+pub const SYS_socketpair: ::c_long = 199;
+pub const SYS_bind: ::c_long = 200;
+pub const SYS_listen: ::c_long = 201;
+pub const SYS_accept: ::c_long = 202;
+pub const SYS_connect: ::c_long = 203;
+pub const SYS_getsockname: ::c_long = 204;
+pub const SYS_getpeername: ::c_long = 205;
+pub const SYS_sendto: ::c_long = 206;
+pub const SYS_recvfrom: ::c_long = 207;
+pub const SYS_setsockopt: ::c_long = 208;
+pub const SYS_getsockopt: ::c_long = 209;
+pub const SYS_shutdown: ::c_long = 210;
+pub const SYS_sendmsg: ::c_long = 211;
+pub const SYS_recvmsg: ::c_long = 212;
+pub const SYS_readahead: ::c_long = 213;
+pub const SYS_brk: ::c_long = 214;
+pub const SYS_munmap: ::c_long = 215;
+pub const SYS_mremap: ::c_long = 216;
+pub const SYS_add_key: ::c_long = 217;
+pub const SYS_request_key: ::c_long = 218;
+pub const SYS_keyctl: ::c_long = 219;
+pub const SYS_clone: ::c_long = 220;
+pub const SYS_execve: ::c_long = 221;
+pub const SYS_mmap: ::c_long = 222;
+pub const SYS_swapon: ::c_long = 224;
+pub const SYS_swapoff: ::c_long = 225;
+pub const SYS_mprotect: ::c_long = 226;
+pub const SYS_msync: ::c_long = 227;
+pub const SYS_mlock: ::c_long = 228;
+pub const SYS_munlock: ::c_long = 229;
+pub const SYS_mlockall: ::c_long = 230;
+pub const SYS_munlockall: ::c_long = 231;
+pub const SYS_mincore: ::c_long = 232;
+pub const SYS_madvise: ::c_long = 233;
+pub const SYS_remap_file_pages: ::c_long = 234;
+pub const SYS_mbind: ::c_long = 235;
+pub const SYS_get_mempolicy: ::c_long = 236;
+pub const SYS_set_mempolicy: ::c_long = 237;
+pub const SYS_migrate_pages: ::c_long = 238;
+pub const SYS_move_pages: ::c_long = 239;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 240;
+pub const SYS_perf_event_open: ::c_long = 241;
+pub const SYS_accept4: ::c_long = 242;
+pub const SYS_recvmmsg: ::c_long = 243;
+pub const SYS_wait4: ::c_long = 260;
+pub const SYS_prlimit64: ::c_long = 261;
+pub const SYS_fanotify_init: ::c_long = 262;
+pub const SYS_fanotify_mark: ::c_long = 263;
+pub const SYS_name_to_handle_at: ::c_long = 264;
+pub const SYS_open_by_handle_at: ::c_long = 265;
+pub const SYS_clock_adjtime: ::c_long = 266;
+pub const SYS_syncfs: ::c_long = 267;
+pub const SYS_setns: ::c_long = 268;
+pub const SYS_sendmmsg: ::c_long = 269;
+pub const SYS_process_vm_readv: ::c_long = 270;
+pub const SYS_process_vm_writev: ::c_long = 271;
+pub const SYS_kcmp: ::c_long = 272;
+pub const SYS_finit_module: ::c_long = 273;
+pub const SYS_sched_setattr: ::c_long = 274;
+pub const SYS_sched_getattr: ::c_long = 275;
+pub const SYS_renameat2: ::c_long = 276;
+pub const SYS_seccomp: ::c_long = 277;
+pub const SYS_getrandom: ::c_long = 278;
+pub const SYS_memfd_create: ::c_long = 279;
+pub const SYS_bpf: ::c_long = 280;
+pub const SYS_execveat: ::c_long = 281;
+pub const SYS_userfaultfd: ::c_long = 282;
+pub const SYS_membarrier: ::c_long = 283;
+pub const SYS_mlock2: ::c_long = 284;
+pub const SYS_copy_file_range: ::c_long = 285;
+pub const SYS_preadv2: ::c_long = 286;
+pub const SYS_pwritev2: ::c_long = 287;
+pub const SYS_pkey_mprotect: ::c_long = 288;
+pub const SYS_pkey_alloc: ::c_long = 289;
+pub const SYS_pkey_free: ::c_long = 290;
+pub const SYS_statx: ::c_long = 291;
+pub const SYS_pidfd_open: ::c_long = 434;
+pub const SYS_clone3: ::c_long = 435;
+
+extern "C" {
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_int,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "32")] {
+        mod ilp32;
+        pub use self::ilp32::*;
+    } else {
+        mod lp64;
+        pub use self::lp64::*;
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/mips64/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/mips64/align.rs
new file mode 100644
index 00000000..7ca870fd
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/mips64/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 4]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/mips64/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/mips64/mod.rs
new file mode 100644
index 00000000..ca825289
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/mips64/mod.rs
@@ -0,0 +1,1023 @@
+use pthread_mutex_t;
+
+pub type blksize_t = i64;
+pub type c_char = i8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type nlink_t = u64;
+pub type suseconds_t = i64;
+pub type wchar_t = i32;
+pub type __u64 = ::c_ulong;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::c_ulong,
+        st_pad1: [::c_long; 2],
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulong,
+        st_pad2: [::c_ulong; 1],
+        pub st_size: ::off_t,
+        st_pad3: ::c_long,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        st_pad4: ::c_long,
+        pub st_blocks: ::blkcnt_t,
+        st_pad5: [::c_long; 7],
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_files: ::fsblkcnt_t,
+        pub f_ffree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::c_long,
+        f_spare: [::c_long; 6],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::c_ulong,
+        st_pad1: [::c_long; 2],
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulong,
+        st_pad2: [::c_long; 2],
+        pub st_size: ::off64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        st_pad3: ::c_long,
+        pub st_blocks: ::blkcnt64_t,
+        st_pad5: [::c_long; 7],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_bavail: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_long,
+        pub f_flags: ::c_long,
+        pub f_spare: [::c_long; 5],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct pthread_attr_t {
+        __size: [::c_ulong; 7]
+    }
+
+    pub struct sigaction {
+        pub sa_flags: ::c_int,
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        _pad: ::c_int,
+        _pad2: [::c_long; 14],
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_uint,
+        pub __seq: ::c_ushort,
+        __pad1: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 23],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+}
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+align_const! {
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+}
+
+pub const SYS_read: ::c_long = 5000 + 0;
+pub const SYS_write: ::c_long = 5000 + 1;
+pub const SYS_open: ::c_long = 5000 + 2;
+pub const SYS_close: ::c_long = 5000 + 3;
+pub const SYS_stat: ::c_long = 5000 + 4;
+pub const SYS_fstat: ::c_long = 5000 + 5;
+pub const SYS_lstat: ::c_long = 5000 + 6;
+pub const SYS_poll: ::c_long = 5000 + 7;
+pub const SYS_lseek: ::c_long = 5000 + 8;
+pub const SYS_mmap: ::c_long = 5000 + 9;
+pub const SYS_mprotect: ::c_long = 5000 + 10;
+pub const SYS_munmap: ::c_long = 5000 + 11;
+pub const SYS_brk: ::c_long = 5000 + 12;
+pub const SYS_rt_sigaction: ::c_long = 5000 + 13;
+pub const SYS_rt_sigprocmask: ::c_long = 5000 + 14;
+pub const SYS_ioctl: ::c_long = 5000 + 15;
+pub const SYS_pread64: ::c_long = 5000 + 16;
+pub const SYS_pwrite64: ::c_long = 5000 + 17;
+pub const SYS_readv: ::c_long = 5000 + 18;
+pub const SYS_writev: ::c_long = 5000 + 19;
+pub const SYS_access: ::c_long = 5000 + 20;
+pub const SYS_pipe: ::c_long = 5000 + 21;
+pub const SYS__newselect: ::c_long = 5000 + 22;
+pub const SYS_sched_yield: ::c_long = 5000 + 23;
+pub const SYS_mremap: ::c_long = 5000 + 24;
+pub const SYS_msync: ::c_long = 5000 + 25;
+pub const SYS_mincore: ::c_long = 5000 + 26;
+pub const SYS_madvise: ::c_long = 5000 + 27;
+pub const SYS_shmget: ::c_long = 5000 + 28;
+pub const SYS_shmat: ::c_long = 5000 + 29;
+pub const SYS_shmctl: ::c_long = 5000 + 30;
+pub const SYS_dup: ::c_long = 5000 + 31;
+pub const SYS_dup2: ::c_long = 5000 + 32;
+pub const SYS_pause: ::c_long = 5000 + 33;
+pub const SYS_nanosleep: ::c_long = 5000 + 34;
+pub const SYS_getitimer: ::c_long = 5000 + 35;
+pub const SYS_setitimer: ::c_long = 5000 + 36;
+pub const SYS_alarm: ::c_long = 5000 + 37;
+pub const SYS_getpid: ::c_long = 5000 + 38;
+pub const SYS_sendfile: ::c_long = 5000 + 39;
+pub const SYS_socket: ::c_long = 5000 + 40;
+pub const SYS_connect: ::c_long = 5000 + 41;
+pub const SYS_accept: ::c_long = 5000 + 42;
+pub const SYS_sendto: ::c_long = 5000 + 43;
+pub const SYS_recvfrom: ::c_long = 5000 + 44;
+pub const SYS_sendmsg: ::c_long = 5000 + 45;
+pub const SYS_recvmsg: ::c_long = 5000 + 46;
+pub const SYS_shutdown: ::c_long = 5000 + 47;
+pub const SYS_bind: ::c_long = 5000 + 48;
+pub const SYS_listen: ::c_long = 5000 + 49;
+pub const SYS_getsockname: ::c_long = 5000 + 50;
+pub const SYS_getpeername: ::c_long = 5000 + 51;
+pub const SYS_socketpair: ::c_long = 5000 + 52;
+pub const SYS_setsockopt: ::c_long = 5000 + 53;
+pub const SYS_getsockopt: ::c_long = 5000 + 54;
+pub const SYS_clone: ::c_long = 5000 + 55;
+pub const SYS_fork: ::c_long = 5000 + 56;
+pub const SYS_execve: ::c_long = 5000 + 57;
+pub const SYS_exit: ::c_long = 5000 + 58;
+pub const SYS_wait4: ::c_long = 5000 + 59;
+pub const SYS_kill: ::c_long = 5000 + 60;
+pub const SYS_uname: ::c_long = 5000 + 61;
+pub const SYS_semget: ::c_long = 5000 + 62;
+pub const SYS_semop: ::c_long = 5000 + 63;
+pub const SYS_semctl: ::c_long = 5000 + 64;
+pub const SYS_shmdt: ::c_long = 5000 + 65;
+pub const SYS_msgget: ::c_long = 5000 + 66;
+pub const SYS_msgsnd: ::c_long = 5000 + 67;
+pub const SYS_msgrcv: ::c_long = 5000 + 68;
+pub const SYS_msgctl: ::c_long = 5000 + 69;
+pub const SYS_fcntl: ::c_long = 5000 + 70;
+pub const SYS_flock: ::c_long = 5000 + 71;
+pub const SYS_fsync: ::c_long = 5000 + 72;
+pub const SYS_fdatasync: ::c_long = 5000 + 73;
+pub const SYS_truncate: ::c_long = 5000 + 74;
+pub const SYS_ftruncate: ::c_long = 5000 + 75;
+pub const SYS_getdents: ::c_long = 5000 + 76;
+pub const SYS_getcwd: ::c_long = 5000 + 77;
+pub const SYS_chdir: ::c_long = 5000 + 78;
+pub const SYS_fchdir: ::c_long = 5000 + 79;
+pub const SYS_rename: ::c_long = 5000 + 80;
+pub const SYS_mkdir: ::c_long = 5000 + 81;
+pub const SYS_rmdir: ::c_long = 5000 + 82;
+pub const SYS_creat: ::c_long = 5000 + 83;
+pub const SYS_link: ::c_long = 5000 + 84;
+pub const SYS_unlink: ::c_long = 5000 + 85;
+pub const SYS_symlink: ::c_long = 5000 + 86;
+pub const SYS_readlink: ::c_long = 5000 + 87;
+pub const SYS_chmod: ::c_long = 5000 + 88;
+pub const SYS_fchmod: ::c_long = 5000 + 89;
+pub const SYS_chown: ::c_long = 5000 + 90;
+pub const SYS_fchown: ::c_long = 5000 + 91;
+pub const SYS_lchown: ::c_long = 5000 + 92;
+pub const SYS_umask: ::c_long = 5000 + 93;
+pub const SYS_gettimeofday: ::c_long = 5000 + 94;
+pub const SYS_getrlimit: ::c_long = 5000 + 95;
+pub const SYS_getrusage: ::c_long = 5000 + 96;
+pub const SYS_sysinfo: ::c_long = 5000 + 97;
+pub const SYS_times: ::c_long = 5000 + 98;
+pub const SYS_ptrace: ::c_long = 5000 + 99;
+pub const SYS_getuid: ::c_long = 5000 + 100;
+pub const SYS_syslog: ::c_long = 5000 + 101;
+pub const SYS_getgid: ::c_long = 5000 + 102;
+pub const SYS_setuid: ::c_long = 5000 + 103;
+pub const SYS_setgid: ::c_long = 5000 + 104;
+pub const SYS_geteuid: ::c_long = 5000 + 105;
+pub const SYS_getegid: ::c_long = 5000 + 106;
+pub const SYS_setpgid: ::c_long = 5000 + 107;
+pub const SYS_getppid: ::c_long = 5000 + 108;
+pub const SYS_getpgrp: ::c_long = 5000 + 109;
+pub const SYS_setsid: ::c_long = 5000 + 110;
+pub const SYS_setreuid: ::c_long = 5000 + 111;
+pub const SYS_setregid: ::c_long = 5000 + 112;
+pub const SYS_getgroups: ::c_long = 5000 + 113;
+pub const SYS_setgroups: ::c_long = 5000 + 114;
+pub const SYS_setresuid: ::c_long = 5000 + 115;
+pub const SYS_getresuid: ::c_long = 5000 + 116;
+pub const SYS_setresgid: ::c_long = 5000 + 117;
+pub const SYS_getresgid: ::c_long = 5000 + 118;
+pub const SYS_getpgid: ::c_long = 5000 + 119;
+pub const SYS_setfsuid: ::c_long = 5000 + 120;
+pub const SYS_setfsgid: ::c_long = 5000 + 121;
+pub const SYS_getsid: ::c_long = 5000 + 122;
+pub const SYS_capget: ::c_long = 5000 + 123;
+pub const SYS_capset: ::c_long = 5000 + 124;
+pub const SYS_rt_sigpending: ::c_long = 5000 + 125;
+pub const SYS_rt_sigtimedwait: ::c_long = 5000 + 126;
+pub const SYS_rt_sigqueueinfo: ::c_long = 5000 + 127;
+pub const SYS_rt_sigsuspend: ::c_long = 5000 + 128;
+pub const SYS_sigaltstack: ::c_long = 5000 + 129;
+pub const SYS_utime: ::c_long = 5000 + 130;
+pub const SYS_mknod: ::c_long = 5000 + 131;
+pub const SYS_personality: ::c_long = 5000 + 132;
+pub const SYS_ustat: ::c_long = 5000 + 133;
+pub const SYS_statfs: ::c_long = 5000 + 134;
+pub const SYS_fstatfs: ::c_long = 5000 + 135;
+pub const SYS_sysfs: ::c_long = 5000 + 136;
+pub const SYS_getpriority: ::c_long = 5000 + 137;
+pub const SYS_setpriority: ::c_long = 5000 + 138;
+pub const SYS_sched_setparam: ::c_long = 5000 + 139;
+pub const SYS_sched_getparam: ::c_long = 5000 + 140;
+pub const SYS_sched_setscheduler: ::c_long = 5000 + 141;
+pub const SYS_sched_getscheduler: ::c_long = 5000 + 142;
+pub const SYS_sched_get_priority_max: ::c_long = 5000 + 143;
+pub const SYS_sched_get_priority_min: ::c_long = 5000 + 144;
+pub const SYS_sched_rr_get_interval: ::c_long = 5000 + 145;
+pub const SYS_mlock: ::c_long = 5000 + 146;
+pub const SYS_munlock: ::c_long = 5000 + 147;
+pub const SYS_mlockall: ::c_long = 5000 + 148;
+pub const SYS_munlockall: ::c_long = 5000 + 149;
+pub const SYS_vhangup: ::c_long = 5000 + 150;
+pub const SYS_pivot_root: ::c_long = 5000 + 151;
+pub const SYS__sysctl: ::c_long = 5000 + 152;
+pub const SYS_prctl: ::c_long = 5000 + 153;
+pub const SYS_adjtimex: ::c_long = 5000 + 154;
+pub const SYS_setrlimit: ::c_long = 5000 + 155;
+pub const SYS_chroot: ::c_long = 5000 + 156;
+pub const SYS_sync: ::c_long = 5000 + 157;
+pub const SYS_acct: ::c_long = 5000 + 158;
+pub const SYS_settimeofday: ::c_long = 5000 + 159;
+pub const SYS_mount: ::c_long = 5000 + 160;
+pub const SYS_umount2: ::c_long = 5000 + 161;
+pub const SYS_swapon: ::c_long = 5000 + 162;
+pub const SYS_swapoff: ::c_long = 5000 + 163;
+pub const SYS_reboot: ::c_long = 5000 + 164;
+pub const SYS_sethostname: ::c_long = 5000 + 165;
+pub const SYS_setdomainname: ::c_long = 5000 + 166;
+pub const SYS_create_module: ::c_long = 5000 + 167;
+pub const SYS_init_module: ::c_long = 5000 + 168;
+pub const SYS_delete_module: ::c_long = 5000 + 169;
+pub const SYS_get_kernel_syms: ::c_long = 5000 + 170;
+pub const SYS_query_module: ::c_long = 5000 + 171;
+pub const SYS_quotactl: ::c_long = 5000 + 172;
+pub const SYS_nfsservctl: ::c_long = 5000 + 173;
+pub const SYS_getpmsg: ::c_long = 5000 + 174;
+pub const SYS_putpmsg: ::c_long = 5000 + 175;
+pub const SYS_afs_syscall: ::c_long = 5000 + 176;
+pub const SYS_gettid: ::c_long = 5000 + 178;
+pub const SYS_readahead: ::c_long = 5000 + 179;
+pub const SYS_setxattr: ::c_long = 5000 + 180;
+pub const SYS_lsetxattr: ::c_long = 5000 + 181;
+pub const SYS_fsetxattr: ::c_long = 5000 + 182;
+pub const SYS_getxattr: ::c_long = 5000 + 183;
+pub const SYS_lgetxattr: ::c_long = 5000 + 184;
+pub const SYS_fgetxattr: ::c_long = 5000 + 185;
+pub const SYS_listxattr: ::c_long = 5000 + 186;
+pub const SYS_llistxattr: ::c_long = 5000 + 187;
+pub const SYS_flistxattr: ::c_long = 5000 + 188;
+pub const SYS_removexattr: ::c_long = 5000 + 189;
+pub const SYS_lremovexattr: ::c_long = 5000 + 190;
+pub const SYS_fremovexattr: ::c_long = 5000 + 191;
+pub const SYS_tkill: ::c_long = 5000 + 192;
+pub const SYS_futex: ::c_long = 5000 + 194;
+pub const SYS_sched_setaffinity: ::c_long = 5000 + 195;
+pub const SYS_sched_getaffinity: ::c_long = 5000 + 196;
+pub const SYS_cacheflush: ::c_long = 5000 + 197;
+pub const SYS_cachectl: ::c_long = 5000 + 198;
+pub const SYS_sysmips: ::c_long = 5000 + 199;
+pub const SYS_io_setup: ::c_long = 5000 + 200;
+pub const SYS_io_destroy: ::c_long = 5000 + 201;
+pub const SYS_io_getevents: ::c_long = 5000 + 202;
+pub const SYS_io_submit: ::c_long = 5000 + 203;
+pub const SYS_io_cancel: ::c_long = 5000 + 204;
+pub const SYS_exit_group: ::c_long = 5000 + 205;
+pub const SYS_lookup_dcookie: ::c_long = 5000 + 206;
+pub const SYS_epoll_create: ::c_long = 5000 + 207;
+pub const SYS_epoll_ctl: ::c_long = 5000 + 208;
+pub const SYS_epoll_wait: ::c_long = 5000 + 209;
+pub const SYS_remap_file_pages: ::c_long = 5000 + 210;
+pub const SYS_rt_sigreturn: ::c_long = 5000 + 211;
+pub const SYS_set_tid_address: ::c_long = 5000 + 212;
+pub const SYS_restart_syscall: ::c_long = 5000 + 213;
+pub const SYS_semtimedop: ::c_long = 5000 + 214;
+pub const SYS_fadvise64: ::c_long = 5000 + 215;
+pub const SYS_timer_create: ::c_long = 5000 + 216;
+pub const SYS_timer_settime: ::c_long = 5000 + 217;
+pub const SYS_timer_gettime: ::c_long = 5000 + 218;
+pub const SYS_timer_getoverrun: ::c_long = 5000 + 219;
+pub const SYS_timer_delete: ::c_long = 5000 + 220;
+pub const SYS_clock_settime: ::c_long = 5000 + 221;
+pub const SYS_clock_gettime: ::c_long = 5000 + 222;
+pub const SYS_clock_getres: ::c_long = 5000 + 223;
+pub const SYS_clock_nanosleep: ::c_long = 5000 + 224;
+pub const SYS_tgkill: ::c_long = 5000 + 225;
+pub const SYS_utimes: ::c_long = 5000 + 226;
+pub const SYS_mbind: ::c_long = 5000 + 227;
+pub const SYS_get_mempolicy: ::c_long = 5000 + 228;
+pub const SYS_set_mempolicy: ::c_long = 5000 + 229;
+pub const SYS_mq_open: ::c_long = 5000 + 230;
+pub const SYS_mq_unlink: ::c_long = 5000 + 231;
+pub const SYS_mq_timedsend: ::c_long = 5000 + 232;
+pub const SYS_mq_timedreceive: ::c_long = 5000 + 233;
+pub const SYS_mq_notify: ::c_long = 5000 + 234;
+pub const SYS_mq_getsetattr: ::c_long = 5000 + 235;
+pub const SYS_vserver: ::c_long = 5000 + 236;
+pub const SYS_waitid: ::c_long = 5000 + 237;
+/* pub const SYS_sys_setaltroot: ::c_long = 5000 + 238; */
+pub const SYS_add_key: ::c_long = 5000 + 239;
+pub const SYS_request_key: ::c_long = 5000 + 240;
+pub const SYS_keyctl: ::c_long = 5000 + 241;
+pub const SYS_set_thread_area: ::c_long = 5000 + 242;
+pub const SYS_inotify_init: ::c_long = 5000 + 243;
+pub const SYS_inotify_add_watch: ::c_long = 5000 + 244;
+pub const SYS_inotify_rm_watch: ::c_long = 5000 + 245;
+pub const SYS_migrate_pages: ::c_long = 5000 + 246;
+pub const SYS_openat: ::c_long = 5000 + 247;
+pub const SYS_mkdirat: ::c_long = 5000 + 248;
+pub const SYS_mknodat: ::c_long = 5000 + 249;
+pub const SYS_fchownat: ::c_long = 5000 + 250;
+pub const SYS_futimesat: ::c_long = 5000 + 251;
+pub const SYS_newfstatat: ::c_long = 5000 + 252;
+pub const SYS_unlinkat: ::c_long = 5000 + 253;
+pub const SYS_renameat: ::c_long = 5000 + 254;
+pub const SYS_linkat: ::c_long = 5000 + 255;
+pub const SYS_symlinkat: ::c_long = 5000 + 256;
+pub const SYS_readlinkat: ::c_long = 5000 + 257;
+pub const SYS_fchmodat: ::c_long = 5000 + 258;
+pub const SYS_faccessat: ::c_long = 5000 + 259;
+pub const SYS_pselect6: ::c_long = 5000 + 260;
+pub const SYS_ppoll: ::c_long = 5000 + 261;
+pub const SYS_unshare: ::c_long = 5000 + 262;
+pub const SYS_splice: ::c_long = 5000 + 263;
+pub const SYS_sync_file_range: ::c_long = 5000 + 264;
+pub const SYS_tee: ::c_long = 5000 + 265;
+pub const SYS_vmsplice: ::c_long = 5000 + 266;
+pub const SYS_move_pages: ::c_long = 5000 + 267;
+pub const SYS_set_robust_list: ::c_long = 5000 + 268;
+pub const SYS_get_robust_list: ::c_long = 5000 + 269;
+pub const SYS_kexec_load: ::c_long = 5000 + 270;
+pub const SYS_getcpu: ::c_long = 5000 + 271;
+pub const SYS_epoll_pwait: ::c_long = 5000 + 272;
+pub const SYS_ioprio_set: ::c_long = 5000 + 273;
+pub const SYS_ioprio_get: ::c_long = 5000 + 274;
+pub const SYS_utimensat: ::c_long = 5000 + 275;
+pub const SYS_signalfd: ::c_long = 5000 + 276;
+pub const SYS_timerfd: ::c_long = 5000 + 277;
+pub const SYS_eventfd: ::c_long = 5000 + 278;
+pub const SYS_fallocate: ::c_long = 5000 + 279;
+pub const SYS_timerfd_create: ::c_long = 5000 + 280;
+pub const SYS_timerfd_gettime: ::c_long = 5000 + 281;
+pub const SYS_timerfd_settime: ::c_long = 5000 + 282;
+pub const SYS_signalfd4: ::c_long = 5000 + 283;
+pub const SYS_eventfd2: ::c_long = 5000 + 284;
+pub const SYS_epoll_create1: ::c_long = 5000 + 285;
+pub const SYS_dup3: ::c_long = 5000 + 286;
+pub const SYS_pipe2: ::c_long = 5000 + 287;
+pub const SYS_inotify_init1: ::c_long = 5000 + 288;
+pub const SYS_preadv: ::c_long = 5000 + 289;
+pub const SYS_pwritev: ::c_long = 5000 + 290;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 5000 + 291;
+pub const SYS_perf_event_open: ::c_long = 5000 + 292;
+pub const SYS_accept4: ::c_long = 5000 + 293;
+pub const SYS_recvmmsg: ::c_long = 5000 + 294;
+pub const SYS_fanotify_init: ::c_long = 5000 + 295;
+pub const SYS_fanotify_mark: ::c_long = 5000 + 296;
+pub const SYS_prlimit64: ::c_long = 5000 + 297;
+pub const SYS_name_to_handle_at: ::c_long = 5000 + 298;
+pub const SYS_open_by_handle_at: ::c_long = 5000 + 299;
+pub const SYS_clock_adjtime: ::c_long = 5000 + 300;
+pub const SYS_syncfs: ::c_long = 5000 + 301;
+pub const SYS_sendmmsg: ::c_long = 5000 + 302;
+pub const SYS_setns: ::c_long = 5000 + 303;
+pub const SYS_process_vm_readv: ::c_long = 5000 + 304;
+pub const SYS_process_vm_writev: ::c_long = 5000 + 305;
+pub const SYS_kcmp: ::c_long = 5000 + 306;
+pub const SYS_finit_module: ::c_long = 5000 + 307;
+pub const SYS_getdents64: ::c_long = 5000 + 308;
+pub const SYS_sched_setattr: ::c_long = 5000 + 309;
+pub const SYS_sched_getattr: ::c_long = 5000 + 310;
+pub const SYS_renameat2: ::c_long = 5000 + 311;
+pub const SYS_seccomp: ::c_long = 5000 + 312;
+pub const SYS_getrandom: ::c_long = 5000 + 313;
+pub const SYS_memfd_create: ::c_long = 5000 + 314;
+pub const SYS_bpf: ::c_long = 5000 + 315;
+pub const SYS_execveat: ::c_long = 5000 + 316;
+pub const SYS_userfaultfd: ::c_long = 5000 + 317;
+pub const SYS_membarrier: ::c_long = 5000 + 318;
+pub const SYS_mlock2: ::c_long = 5000 + 319;
+pub const SYS_copy_file_range: ::c_long = 5000 + 320;
+pub const SYS_preadv2: ::c_long = 5000 + 321;
+pub const SYS_pwritev2: ::c_long = 5000 + 322;
+pub const SYS_pkey_mprotect: ::c_long = 5000 + 323;
+pub const SYS_pkey_alloc: ::c_long = 5000 + 324;
+pub const SYS_pkey_free: ::c_long = 5000 + 325;
+pub const SYS_statx: ::c_long = 5000 + 326;
+pub const SYS_pidfd_open: ::c_long = 5000 + 434;
+pub const SYS_clone3: ::c_long = 5000 + 435;
+
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 512;
+
+pub const O_NOATIME: ::c_int = 0o1000000;
+pub const O_CLOEXEC: ::c_int = 0x80000;
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const O_DIRECT: ::c_int = 0x8000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 6;
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 8;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 9;
+
+pub const O_APPEND: ::c_int = 8;
+pub const O_CREAT: ::c_int = 256;
+pub const O_EXCL: ::c_int = 1024;
+pub const O_NOCTTY: ::c_int = 2048;
+pub const O_NONBLOCK: ::c_int = 128;
+pub const O_SYNC: ::c_int = 0x4010;
+pub const O_RSYNC: ::c_int = 0x4010;
+pub const O_DSYNC: ::c_int = 0x10;
+pub const O_FSYNC: ::c_int = 0x4010;
+pub const O_ASYNC: ::c_int = 0x1000;
+pub const O_NDELAY: ::c_int = 0x80;
+
+pub const EDEADLK: ::c_int = 45;
+pub const ENAMETOOLONG: ::c_int = 78;
+pub const ENOLCK: ::c_int = 46;
+pub const ENOSYS: ::c_int = 89;
+pub const ENOTEMPTY: ::c_int = 93;
+pub const ELOOP: ::c_int = 90;
+pub const ENOMSG: ::c_int = 35;
+pub const EIDRM: ::c_int = 36;
+pub const ECHRNG: ::c_int = 37;
+pub const EL2NSYNC: ::c_int = 38;
+pub const EL3HLT: ::c_int = 39;
+pub const EL3RST: ::c_int = 40;
+pub const ELNRNG: ::c_int = 41;
+pub const EUNATCH: ::c_int = 42;
+pub const ENOCSI: ::c_int = 43;
+pub const EL2HLT: ::c_int = 44;
+pub const EBADE: ::c_int = 50;
+pub const EBADR: ::c_int = 51;
+pub const EXFULL: ::c_int = 52;
+pub const ENOANO: ::c_int = 53;
+pub const EBADRQC: ::c_int = 54;
+pub const EBADSLT: ::c_int = 55;
+pub const EDEADLOCK: ::c_int = 56;
+pub const EMULTIHOP: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 79;
+pub const ENOTUNIQ: ::c_int = 80;
+pub const EBADFD: ::c_int = 81;
+pub const EBADMSG: ::c_int = 77;
+pub const EREMCHG: ::c_int = 82;
+pub const ELIBACC: ::c_int = 83;
+pub const ELIBBAD: ::c_int = 84;
+pub const ELIBSCN: ::c_int = 85;
+pub const ELIBMAX: ::c_int = 86;
+pub const ELIBEXEC: ::c_int = 87;
+pub const EILSEQ: ::c_int = 88;
+pub const ERESTART: ::c_int = 91;
+pub const ESTRPIPE: ::c_int = 92;
+pub const EUSERS: ::c_int = 94;
+pub const ENOTSOCK: ::c_int = 95;
+pub const EDESTADDRREQ: ::c_int = 96;
+pub const EMSGSIZE: ::c_int = 97;
+pub const EPROTOTYPE: ::c_int = 98;
+pub const ENOPROTOOPT: ::c_int = 99;
+pub const EPROTONOSUPPORT: ::c_int = 120;
+pub const ESOCKTNOSUPPORT: ::c_int = 121;
+pub const EOPNOTSUPP: ::c_int = 122;
+pub const EPFNOSUPPORT: ::c_int = 123;
+pub const EAFNOSUPPORT: ::c_int = 124;
+pub const EADDRINUSE: ::c_int = 125;
+pub const EADDRNOTAVAIL: ::c_int = 126;
+pub const ENETDOWN: ::c_int = 127;
+pub const ENETUNREACH: ::c_int = 128;
+pub const ENETRESET: ::c_int = 129;
+pub const ECONNABORTED: ::c_int = 130;
+pub const ECONNRESET: ::c_int = 131;
+pub const ENOBUFS: ::c_int = 132;
+pub const EISCONN: ::c_int = 133;
+pub const ENOTCONN: ::c_int = 134;
+pub const ESHUTDOWN: ::c_int = 143;
+pub const ETOOMANYREFS: ::c_int = 144;
+pub const ETIMEDOUT: ::c_int = 145;
+pub const ECONNREFUSED: ::c_int = 146;
+pub const EHOSTDOWN: ::c_int = 147;
+pub const EHOSTUNREACH: ::c_int = 148;
+pub const EALREADY: ::c_int = 149;
+pub const EINPROGRESS: ::c_int = 150;
+pub const ESTALE: ::c_int = 151;
+pub const EUCLEAN: ::c_int = 135;
+pub const ENOTNAM: ::c_int = 137;
+pub const ENAVAIL: ::c_int = 138;
+pub const EISNAM: ::c_int = 139;
+pub const EREMOTEIO: ::c_int = 140;
+pub const EDQUOT: ::c_int = 1133;
+pub const ENOMEDIUM: ::c_int = 159;
+pub const EMEDIUMTYPE: ::c_int = 160;
+pub const ECANCELED: ::c_int = 158;
+pub const ENOKEY: ::c_int = 161;
+pub const EKEYEXPIRED: ::c_int = 162;
+pub const EKEYREVOKED: ::c_int = 163;
+pub const EKEYREJECTED: ::c_int = 164;
+pub const EOWNERDEAD: ::c_int = 165;
+pub const ENOTRECOVERABLE: ::c_int = 166;
+pub const ERFKILL: ::c_int = 167;
+
+pub const MAP_NORESERVE: ::c_int = 0x400;
+pub const MAP_ANON: ::c_int = 0x800;
+pub const MAP_ANONYMOUS: ::c_int = 0x800;
+pub const MAP_GROWSDOWN: ::c_int = 0x1000;
+pub const MAP_DENYWRITE: ::c_int = 0x2000;
+pub const MAP_EXECUTABLE: ::c_int = 0x4000;
+pub const MAP_LOCKED: ::c_int = 0x8000;
+pub const MAP_POPULATE: ::c_int = 0x10000;
+pub const MAP_NONBLOCK: ::c_int = 0x20000;
+pub const MAP_STACK: ::c_int = 0x40000;
+pub const MAP_HUGETLB: ::c_int = 0x080000;
+
+pub const SOCK_STREAM: ::c_int = 2;
+pub const SOCK_DGRAM: ::c_int = 1;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_STYLE: ::c_int = SO_TYPE;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ACCEPTCONN: ::c_int = 0x1009;
+pub const SO_PROTOCOL: ::c_int = 0x1028;
+pub const SO_DOMAIN: ::c_int = 0x1029;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_PASSCRED: ::c_int = 17;
+pub const SO_PEERCRED: ::c_int = 18;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_PEERSEC: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 31;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_BUSY_POLL: ::c_int = 46;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = SO_DETACH_FILTER;
+
+pub const FIOCLEX: ::c_ulong = 0x6601;
+pub const FIONCLEX: ::c_ulong = 0x6602;
+pub const FIONBIO: ::c_ulong = 0x667e;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000008;
+pub const SA_NOCLDWAIT: ::c_int = 0x00010000;
+
+pub const SIGCHLD: ::c_int = 18;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGTTIN: ::c_int = 26;
+pub const SIGTTOU: ::c_int = 27;
+pub const SIGXCPU: ::c_int = 30;
+pub const SIGXFSZ: ::c_int = 31;
+pub const SIGVTALRM: ::c_int = 28;
+pub const SIGPROF: ::c_int = 29;
+pub const SIGWINCH: ::c_int = 20;
+pub const SIGUSR1: ::c_int = 16;
+pub const SIGUSR2: ::c_int = 17;
+pub const SIGCONT: ::c_int = 25;
+pub const SIGSTOP: ::c_int = 23;
+pub const SIGTSTP: ::c_int = 24;
+pub const SIGURG: ::c_int = 21;
+pub const SIGIO: ::c_int = 22;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGPOLL: ::c_int = 22;
+pub const SIGPWR: ::c_int = 19;
+pub const SIG_SETMASK: ::c_int = 3;
+pub const SIG_BLOCK: ::c_int = 0x1;
+pub const SIG_UNBLOCK: ::c_int = 0x2;
+
+pub const POLLWRNORM: ::c_short = 0x004;
+pub const POLLWRBAND: ::c_short = 0x100;
+
+pub const VEOF: usize = 16;
+pub const VEOL: usize = 17;
+pub const VEOL2: usize = 6;
+pub const VMIN: usize = 4;
+pub const IEXTEN: ::tcflag_t = 0x00000100;
+pub const TOSTOP: ::tcflag_t = 0x00008000;
+pub const FLUSHO: ::tcflag_t = 0x00002000;
+pub const EXTPROC: ::tcflag_t = 0o200000;
+pub const TCSANOW: ::c_int = 0x540e;
+pub const TCSADRAIN: ::c_int = 0x540f;
+pub const TCSAFLUSH: ::c_int = 0x5410;
+
+pub const PTRACE_GETFPREGS: ::c_uint = 14;
+pub const PTRACE_SETFPREGS: ::c_uint = 15;
+pub const PTRACE_DETACH: ::c_uint = 17;
+pub const PTRACE_GETFPXREGS: ::c_uint = 18;
+pub const PTRACE_SETFPXREGS: ::c_uint = 19;
+pub const PTRACE_GETREGS: ::c_uint = 12;
+pub const PTRACE_SETREGS: ::c_uint = 13;
+
+pub const EFD_NONBLOCK: ::c_int = 0x80;
+
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+pub const F_GETLK: ::c_int = 14;
+pub const F_GETOWN: ::c_int = 23;
+pub const F_SETOWN: ::c_int = 24;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const SFD_NONBLOCK: ::c_int = 0x80;
+
+pub const TCGETS: ::c_ulong = 0x540d;
+pub const TCSETS: ::c_ulong = 0x540e;
+pub const TCSETSW: ::c_ulong = 0x540f;
+pub const TCSETSF: ::c_ulong = 0x5410;
+pub const TCGETA: ::c_ulong = 0x5401;
+pub const TCSETA: ::c_ulong = 0x5402;
+pub const TCSETAW: ::c_ulong = 0x5403;
+pub const TCSETAF: ::c_ulong = 0x5404;
+pub const TCSBRK: ::c_ulong = 0x5405;
+pub const TCXONC: ::c_ulong = 0x5406;
+pub const TCFLSH: ::c_ulong = 0x5407;
+pub const TIOCSBRK: ::c_ulong = 0x5427;
+pub const TIOCCBRK: ::c_ulong = 0x5428;
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5481;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x5482;
+pub const TIOCINQ: ::c_ulong = 0x467f;
+pub const TIOCLINUX: ::c_ulong = 0x5483;
+pub const TIOCGSERIAL: ::c_ulong = 0x5484;
+pub const TIOCEXCL: ::c_ulong = 0x740d;
+pub const TIOCNXCL: ::c_ulong = 0x740e;
+pub const TIOCSCTTY: ::c_ulong = 0x5480;
+pub const TIOCGPGRP: ::c_ulong = 0x40047477;
+pub const TIOCSPGRP: ::c_ulong = 0x80047476;
+pub const TIOCOUTQ: ::c_ulong = 0x7472;
+pub const TIOCSTI: ::c_ulong = 0x5472;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const TIOCMGET: ::c_ulong = 0x741d;
+pub const TIOCMBIS: ::c_ulong = 0x741b;
+pub const TIOCMBIC: ::c_ulong = 0x741c;
+pub const TIOCMSET: ::c_ulong = 0x741a;
+pub const FIONREAD: ::c_ulong = 0x467f;
+pub const TIOCCONS: ::c_ulong = 0x80047478;
+
+pub const RTLD_DEEPBIND: ::c_int = 0x10;
+pub const RTLD_GLOBAL: ::c_int = 0x4;
+pub const RTLD_NOLOAD: ::c_int = 0x8;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const TIOCM_ST: ::c_int = 0x010;
+pub const TIOCM_SR: ::c_int = 0x020;
+pub const TIOCM_CTS: ::c_int = 0x040;
+pub const TIOCM_CAR: ::c_int = 0x100;
+pub const TIOCM_RNG: ::c_int = 0x200;
+pub const TIOCM_DSR: ::c_int = 0x400;
+
+pub const EHWPOISON: ::c_int = 168;
+
+extern "C" {
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_int,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/mod.rs
new file mode 100644
index 00000000..138adc91
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/mod.rs
@@ -0,0 +1,95 @@
+//! 64-bit specific definitions for linux-like values
+
+pub type ino_t = u64;
+pub type off_t = i64;
+pub type blkcnt_t = i64;
+pub type shmatt_t = u64;
+pub type msgqnum_t = u64;
+pub type msglen_t = u64;
+pub type fsblkcnt_t = u64;
+pub type fsfilcnt_t = u64;
+pub type rlim_t = u64;
+cfg_if! {
+    if #[cfg(all(target_arch = "aarch64", target_pointer_width = "32"))] {
+        pub type clock_t = i32;
+        pub type time_t = i32;
+        pub type __fsword_t = i32;
+    } else {
+        pub type __fsword_t = i64;
+        pub type clock_t = i64;
+        pub type time_t = i64;
+    }
+}
+
+s! {
+    pub struct sigset_t {
+        #[cfg(target_pointer_width = "32")]
+        __val: [u32; 32],
+        #[cfg(target_pointer_width = "64")]
+        __val: [u64; 16],
+    }
+
+    pub struct sysinfo {
+        pub uptime: i64,
+        pub loads: [u64; 3],
+        pub totalram: u64,
+        pub freeram: u64,
+        pub sharedram: u64,
+        pub bufferram: u64,
+        pub totalswap: u64,
+        pub freeswap: u64,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: u64,
+        pub freehigh: u64,
+        pub mem_unit: ::c_uint,
+        pub _f: [::c_char; 0],
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        pub msg_rtime: ::time_t,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: u64,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved4: u64,
+        __glibc_reserved5: u64,
+    }
+
+}
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+
+pub const O_LARGEFILE: ::c_int = 0;
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(any(target_arch = "powerpc64"))] {
+        mod powerpc64;
+        pub use self::powerpc64::*;
+    } else if #[cfg(any(target_arch = "sparc64"))] {
+        mod sparc64;
+        pub use self::sparc64::*;
+    } else if #[cfg(any(target_arch = "mips64"))] {
+        mod mips64;
+        pub use self::mips64::*;
+    } else if #[cfg(any(target_arch = "s390x"))] {
+        mod s390x;
+        pub use self::s390x::*;
+    } else if #[cfg(any(target_arch = "x86_64"))] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(any(target_arch = "riscv64"))] {
+        mod riscv64;
+        pub use self::riscv64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/align.rs
new file mode 100644
index 00000000..29d1e1c7
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [i64; 4]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/mod.rs
new file mode 100644
index 00000000..e5e4262c
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/mod.rs
@@ -0,0 +1,1065 @@
+//! PowerPC64-specific definitions for 64-bit linux-like values
+
+use pthread_mutex_t;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type c_char = u8;
+pub type wchar_t = i32;
+pub type nlink_t = u64;
+pub type blksize_t = i64;
+pub type suseconds_t = i64;
+pub type __u64 = ::c_ulong;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        #[cfg(target_arch = "sparc64")]
+        __reserved0: ::c_int,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statfs {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        f_spare: [::__fsword_t; 5],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 3],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __reserved: [::c_long; 3],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        pub f_flags: ::__fsword_t,
+        pub f_spare: [::__fsword_t; 4],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct pthread_attr_t {
+        __size: [u64; 7]
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: u32,
+        __pad1: u32,
+        __unused1: u64,
+        __unused2: ::c_ulong,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_segsz: ::size_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct ip_mreqn {
+        pub imr_multiaddr: ::in_addr,
+        pub imr_address: ::in_addr,
+        pub imr_ifindex: ::c_int,
+    }
+}
+
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const VEOF: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5419;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x541A;
+
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 0x101000;
+pub const O_NOATIME: ::c_int = 0o1000000;
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 20;
+pub const SO_PEERCRED: ::c_int = 21;
+pub const SO_RCVLOWAT: ::c_int = 16;
+pub const SO_SNDLOWAT: ::c_int = 17;
+pub const SO_RCVTIMEO: ::c_int = 18;
+pub const SO_SNDTIMEO: ::c_int = 19;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PEERSEC: ::c_int = 31;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_BUSY_POLL: ::c_int = 46;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = SO_DETACH_FILTER;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = 31;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_NDELAY: ::c_int = 0x800;
+
+pub const PTRACE_DETACH: ::c_uint = 17;
+
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+
+pub const SFD_NONBLOCK: ::c_int = 0x0800;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+pub const TIOCEXCL: ::c_ulong = 0x540C;
+pub const TIOCNXCL: ::c_ulong = 0x540D;
+pub const TIOCSCTTY: ::c_ulong = 0x540E;
+pub const TIOCSTI: ::c_ulong = 0x5412;
+pub const TIOCMGET: ::c_ulong = 0x5415;
+pub const TIOCMBIS: ::c_ulong = 0x5416;
+pub const TIOCMBIC: ::c_ulong = 0x5417;
+pub const TIOCMSET: ::c_ulong = 0x5418;
+pub const TIOCCONS: ::c_ulong = 0x541D;
+pub const TIOCSBRK: ::c_ulong = 0x5427;
+pub const TIOCCBRK: ::c_ulong = 0x5428;
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 512;
+
+pub const O_CLOEXEC: ::c_int = 0x80000;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+
+align_const! {
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+}
+
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_DIRECT: ::c_int = 0x20000;
+
+pub const MAP_LOCKED: ::c_int = 0x00080;
+pub const MAP_NORESERVE: ::c_int = 0x00040;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const EDEADLOCK: ::c_int = 58;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+
+pub const FIOCLEX: ::c_ulong = 0x20006601;
+pub const FIONCLEX: ::c_ulong = 0x20006602;
+pub const FIONBIO: ::c_ulong = 0x8004667e;
+
+pub const MCL_CURRENT: ::c_int = 0x2000;
+pub const MCL_FUTURE: ::c_int = 0x4000;
+
+pub const SIGSTKSZ: ::size_t = 0x4000;
+pub const MINSIGSTKSZ: ::size_t = 4096;
+pub const CBAUD: ::tcflag_t = 0xff;
+pub const TAB1: ::tcflag_t = 0x400;
+pub const TAB2: ::tcflag_t = 0x800;
+pub const TAB3: ::tcflag_t = 0xc00;
+pub const CR1: ::tcflag_t = 0x1000;
+pub const CR2: ::tcflag_t = 0x2000;
+pub const CR3: ::tcflag_t = 0x3000;
+pub const FF1: ::tcflag_t = 0x4000;
+pub const BS1: ::tcflag_t = 0x8000;
+pub const VT1: ::tcflag_t = 0x10000;
+pub const VWERASE: usize = 0xa;
+pub const VREPRINT: usize = 0xb;
+pub const VSUSP: usize = 0xc;
+pub const VSTART: usize = 0xd;
+pub const VSTOP: usize = 0xe;
+pub const VDISCARD: usize = 0x10;
+pub const VTIME: usize = 0x7;
+pub const IXON: ::tcflag_t = 0x200;
+pub const IXOFF: ::tcflag_t = 0x400;
+pub const ONLCR: ::tcflag_t = 0x2;
+pub const CSIZE: ::tcflag_t = 0x300;
+pub const CS6: ::tcflag_t = 0x100;
+pub const CS7: ::tcflag_t = 0x200;
+pub const CS8: ::tcflag_t = 0x300;
+pub const CSTOPB: ::tcflag_t = 0x400;
+pub const CREAD: ::tcflag_t = 0x800;
+pub const PARENB: ::tcflag_t = 0x1000;
+pub const PARODD: ::tcflag_t = 0x2000;
+pub const HUPCL: ::tcflag_t = 0x4000;
+pub const CLOCAL: ::tcflag_t = 0x8000;
+pub const ECHOKE: ::tcflag_t = 0x1;
+pub const ECHOE: ::tcflag_t = 0x2;
+pub const ECHOK: ::tcflag_t = 0x4;
+pub const ECHONL: ::tcflag_t = 0x10;
+pub const ECHOPRT: ::tcflag_t = 0x20;
+pub const ECHOCTL: ::tcflag_t = 0x40;
+pub const ISIG: ::tcflag_t = 0x80;
+pub const ICANON: ::tcflag_t = 0x100;
+pub const PENDIN: ::tcflag_t = 0x20000000;
+pub const NOFLSH: ::tcflag_t = 0x80000000;
+pub const VSWTC: usize = 9;
+pub const OLCUC: ::tcflag_t = 0o000004;
+pub const NLDLY: ::tcflag_t = 0o001400;
+pub const CRDLY: ::tcflag_t = 0o030000;
+pub const TABDLY: ::tcflag_t = 0o006000;
+pub const BSDLY: ::tcflag_t = 0o100000;
+pub const FFDLY: ::tcflag_t = 0o040000;
+pub const VTDLY: ::tcflag_t = 0o200000;
+pub const XTABS: ::tcflag_t = 0o006000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const CBAUDEX: ::speed_t = 0o000020;
+pub const B57600: ::speed_t = 0o0020;
+pub const B115200: ::speed_t = 0o0021;
+pub const B230400: ::speed_t = 0o0022;
+pub const B460800: ::speed_t = 0o0023;
+pub const B500000: ::speed_t = 0o0024;
+pub const B576000: ::speed_t = 0o0025;
+pub const B921600: ::speed_t = 0o0026;
+pub const B1000000: ::speed_t = 0o0027;
+pub const B1152000: ::speed_t = 0o0030;
+pub const B1500000: ::speed_t = 0o0031;
+pub const B2000000: ::speed_t = 0o0032;
+pub const B2500000: ::speed_t = 0o0033;
+pub const B3000000: ::speed_t = 0o0034;
+pub const B3500000: ::speed_t = 0o0035;
+pub const B4000000: ::speed_t = 0o0036;
+pub const BOTHER: ::speed_t = 0o0037;
+
+pub const VEOL: usize = 6;
+pub const VEOL2: usize = 8;
+pub const VMIN: usize = 5;
+pub const IEXTEN: ::tcflag_t = 0x400;
+pub const TOSTOP: ::tcflag_t = 0x400000;
+pub const FLUSHO: ::tcflag_t = 0x800000;
+pub const EXTPROC: ::tcflag_t = 0x10000000;
+pub const TCGETS: ::c_ulong = 0x403c7413;
+pub const TCSETS: ::c_ulong = 0x803c7414;
+pub const TCSETSW: ::c_ulong = 0x803c7415;
+pub const TCSETSF: ::c_ulong = 0x803c7416;
+pub const TCGETA: ::c_ulong = 0x40147417;
+pub const TCSETA: ::c_ulong = 0x80147418;
+pub const TCSETAW: ::c_ulong = 0x80147419;
+pub const TCSETAF: ::c_ulong = 0x8014741c;
+pub const TCSBRK: ::c_ulong = 0x2000741d;
+pub const TCXONC: ::c_ulong = 0x2000741e;
+pub const TCFLSH: ::c_ulong = 0x2000741f;
+pub const TIOCINQ: ::c_ulong = 0x4004667f;
+pub const TIOCGPGRP: ::c_ulong = 0x40047477;
+pub const TIOCSPGRP: ::c_ulong = 0x80047476;
+pub const TIOCOUTQ: ::c_ulong = 0x40047473;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const FIONREAD: ::c_ulong = 0x4004667f;
+
+// Syscall table
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_waitpid: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_time: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_break: ::c_long = 17;
+pub const SYS_oldstat: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_umount: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_stime: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_oldfstat: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_stty: ::c_long = 31;
+pub const SYS_gtty: ::c_long = 32;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_ftime: ::c_long = 35;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_prof: ::c_long = 44;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_lock: ::c_long = 53;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_mpx: ::c_long = 56;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_ulimit: ::c_long = 58;
+pub const SYS_oldolduname: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_sgetmask: ::c_long = 68;
+pub const SYS_ssetmask: ::c_long = 69;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrlimit: ::c_long = 76;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_select: ::c_long = 82;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_oldlstat: ::c_long = 84;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_readdir: ::c_long = 89;
+pub const SYS_mmap: ::c_long = 90;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_profil: ::c_long = 98;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_ioperm: ::c_long = 101;
+pub const SYS_socketcall: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_olduname: ::c_long = 109;
+pub const SYS_iopl: ::c_long = 110;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_idle: ::c_long = 112;
+pub const SYS_vm86: ::c_long = 113;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_ipc: ::c_long = 117;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_modify_ldt: ::c_long = 123;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_create_module: ::c_long = 127;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_get_kernel_syms: ::c_long = 130;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_afs_syscall: ::c_long = 137; /* Syscall for Andrew File System */
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_query_module: ::c_long = 166;
+pub const SYS_poll: ::c_long = 167;
+pub const SYS_nfsservctl: ::c_long = 168;
+pub const SYS_setresgid: ::c_long = 169;
+pub const SYS_getresgid: ::c_long = 170;
+pub const SYS_prctl: ::c_long = 171;
+pub const SYS_rt_sigreturn: ::c_long = 172;
+pub const SYS_rt_sigaction: ::c_long = 173;
+pub const SYS_rt_sigprocmask: ::c_long = 174;
+pub const SYS_rt_sigpending: ::c_long = 175;
+pub const SYS_rt_sigtimedwait: ::c_long = 176;
+pub const SYS_rt_sigqueueinfo: ::c_long = 177;
+pub const SYS_rt_sigsuspend: ::c_long = 178;
+pub const SYS_pread64: ::c_long = 179;
+pub const SYS_pwrite64: ::c_long = 180;
+pub const SYS_chown: ::c_long = 181;
+pub const SYS_getcwd: ::c_long = 182;
+pub const SYS_capget: ::c_long = 183;
+pub const SYS_capset: ::c_long = 184;
+pub const SYS_sigaltstack: ::c_long = 185;
+pub const SYS_sendfile: ::c_long = 186;
+pub const SYS_getpmsg: ::c_long = 187; /* some people actually want streams */
+pub const SYS_putpmsg: ::c_long = 188; /* some people actually want streams */
+pub const SYS_vfork: ::c_long = 189;
+pub const SYS_ugetrlimit: ::c_long = 190; /* SuS compliant getrlimit */
+pub const SYS_readahead: ::c_long = 191;
+pub const SYS_pciconfig_read: ::c_long = 198;
+pub const SYS_pciconfig_write: ::c_long = 199;
+pub const SYS_pciconfig_iobase: ::c_long = 200;
+pub const SYS_multiplexer: ::c_long = 201;
+pub const SYS_getdents64: ::c_long = 202;
+pub const SYS_pivot_root: ::c_long = 203;
+pub const SYS_madvise: ::c_long = 205;
+pub const SYS_mincore: ::c_long = 206;
+pub const SYS_gettid: ::c_long = 207;
+pub const SYS_tkill: ::c_long = 208;
+pub const SYS_setxattr: ::c_long = 209;
+pub const SYS_lsetxattr: ::c_long = 210;
+pub const SYS_fsetxattr: ::c_long = 211;
+pub const SYS_getxattr: ::c_long = 212;
+pub const SYS_lgetxattr: ::c_long = 213;
+pub const SYS_fgetxattr: ::c_long = 214;
+pub const SYS_listxattr: ::c_long = 215;
+pub const SYS_llistxattr: ::c_long = 216;
+pub const SYS_flistxattr: ::c_long = 217;
+pub const SYS_removexattr: ::c_long = 218;
+pub const SYS_lremovexattr: ::c_long = 219;
+pub const SYS_fremovexattr: ::c_long = 220;
+pub const SYS_futex: ::c_long = 221;
+pub const SYS_sched_setaffinity: ::c_long = 222;
+pub const SYS_sched_getaffinity: ::c_long = 223;
+pub const SYS_tuxcall: ::c_long = 225;
+pub const SYS_io_setup: ::c_long = 227;
+pub const SYS_io_destroy: ::c_long = 228;
+pub const SYS_io_getevents: ::c_long = 229;
+pub const SYS_io_submit: ::c_long = 230;
+pub const SYS_io_cancel: ::c_long = 231;
+pub const SYS_set_tid_address: ::c_long = 232;
+pub const SYS_exit_group: ::c_long = 234;
+pub const SYS_lookup_dcookie: ::c_long = 235;
+pub const SYS_epoll_create: ::c_long = 236;
+pub const SYS_epoll_ctl: ::c_long = 237;
+pub const SYS_epoll_wait: ::c_long = 238;
+pub const SYS_remap_file_pages: ::c_long = 239;
+pub const SYS_timer_create: ::c_long = 240;
+pub const SYS_timer_settime: ::c_long = 241;
+pub const SYS_timer_gettime: ::c_long = 242;
+pub const SYS_timer_getoverrun: ::c_long = 243;
+pub const SYS_timer_delete: ::c_long = 244;
+pub const SYS_clock_settime: ::c_long = 245;
+pub const SYS_clock_gettime: ::c_long = 246;
+pub const SYS_clock_getres: ::c_long = 247;
+pub const SYS_clock_nanosleep: ::c_long = 248;
+pub const SYS_swapcontext: ::c_long = 249;
+pub const SYS_tgkill: ::c_long = 250;
+pub const SYS_utimes: ::c_long = 251;
+pub const SYS_statfs64: ::c_long = 252;
+pub const SYS_fstatfs64: ::c_long = 253;
+pub const SYS_rtas: ::c_long = 255;
+pub const SYS_sys_debug_setcontext: ::c_long = 256;
+pub const SYS_migrate_pages: ::c_long = 258;
+pub const SYS_mbind: ::c_long = 259;
+pub const SYS_get_mempolicy: ::c_long = 260;
+pub const SYS_set_mempolicy: ::c_long = 261;
+pub const SYS_mq_open: ::c_long = 262;
+pub const SYS_mq_unlink: ::c_long = 263;
+pub const SYS_mq_timedsend: ::c_long = 264;
+pub const SYS_mq_timedreceive: ::c_long = 265;
+pub const SYS_mq_notify: ::c_long = 266;
+pub const SYS_mq_getsetattr: ::c_long = 267;
+pub const SYS_kexec_load: ::c_long = 268;
+pub const SYS_add_key: ::c_long = 269;
+pub const SYS_request_key: ::c_long = 270;
+pub const SYS_keyctl: ::c_long = 271;
+pub const SYS_waitid: ::c_long = 272;
+pub const SYS_ioprio_set: ::c_long = 273;
+pub const SYS_ioprio_get: ::c_long = 274;
+pub const SYS_inotify_init: ::c_long = 275;
+pub const SYS_inotify_add_watch: ::c_long = 276;
+pub const SYS_inotify_rm_watch: ::c_long = 277;
+pub const SYS_spu_run: ::c_long = 278;
+pub const SYS_spu_create: ::c_long = 279;
+pub const SYS_pselect6: ::c_long = 280;
+pub const SYS_ppoll: ::c_long = 281;
+pub const SYS_unshare: ::c_long = 282;
+pub const SYS_splice: ::c_long = 283;
+pub const SYS_tee: ::c_long = 284;
+pub const SYS_vmsplice: ::c_long = 285;
+pub const SYS_openat: ::c_long = 286;
+pub const SYS_mkdirat: ::c_long = 287;
+pub const SYS_mknodat: ::c_long = 288;
+pub const SYS_fchownat: ::c_long = 289;
+pub const SYS_futimesat: ::c_long = 290;
+pub const SYS_newfstatat: ::c_long = 291;
+pub const SYS_unlinkat: ::c_long = 292;
+pub const SYS_renameat: ::c_long = 293;
+pub const SYS_linkat: ::c_long = 294;
+pub const SYS_symlinkat: ::c_long = 295;
+pub const SYS_readlinkat: ::c_long = 296;
+pub const SYS_fchmodat: ::c_long = 297;
+pub const SYS_faccessat: ::c_long = 298;
+pub const SYS_get_robust_list: ::c_long = 299;
+pub const SYS_set_robust_list: ::c_long = 300;
+pub const SYS_move_pages: ::c_long = 301;
+pub const SYS_getcpu: ::c_long = 302;
+pub const SYS_epoll_pwait: ::c_long = 303;
+pub const SYS_utimensat: ::c_long = 304;
+pub const SYS_signalfd: ::c_long = 305;
+pub const SYS_timerfd_create: ::c_long = 306;
+pub const SYS_eventfd: ::c_long = 307;
+pub const SYS_sync_file_range2: ::c_long = 308;
+pub const SYS_fallocate: ::c_long = 309;
+pub const SYS_subpage_prot: ::c_long = 310;
+pub const SYS_timerfd_settime: ::c_long = 311;
+pub const SYS_timerfd_gettime: ::c_long = 312;
+pub const SYS_signalfd4: ::c_long = 313;
+pub const SYS_eventfd2: ::c_long = 314;
+pub const SYS_epoll_create1: ::c_long = 315;
+pub const SYS_dup3: ::c_long = 316;
+pub const SYS_pipe2: ::c_long = 317;
+pub const SYS_inotify_init1: ::c_long = 318;
+pub const SYS_perf_event_open: ::c_long = 319;
+pub const SYS_preadv: ::c_long = 320;
+pub const SYS_pwritev: ::c_long = 321;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 322;
+pub const SYS_fanotify_init: ::c_long = 323;
+pub const SYS_fanotify_mark: ::c_long = 324;
+pub const SYS_prlimit64: ::c_long = 325;
+pub const SYS_socket: ::c_long = 326;
+pub const SYS_bind: ::c_long = 327;
+pub const SYS_connect: ::c_long = 328;
+pub const SYS_listen: ::c_long = 329;
+pub const SYS_accept: ::c_long = 330;
+pub const SYS_getsockname: ::c_long = 331;
+pub const SYS_getpeername: ::c_long = 332;
+pub const SYS_socketpair: ::c_long = 333;
+pub const SYS_send: ::c_long = 334;
+pub const SYS_sendto: ::c_long = 335;
+pub const SYS_recv: ::c_long = 336;
+pub const SYS_recvfrom: ::c_long = 337;
+pub const SYS_shutdown: ::c_long = 338;
+pub const SYS_setsockopt: ::c_long = 339;
+pub const SYS_getsockopt: ::c_long = 340;
+pub const SYS_sendmsg: ::c_long = 341;
+pub const SYS_recvmsg: ::c_long = 342;
+pub const SYS_recvmmsg: ::c_long = 343;
+pub const SYS_accept4: ::c_long = 344;
+pub const SYS_name_to_handle_at: ::c_long = 345;
+pub const SYS_open_by_handle_at: ::c_long = 346;
+pub const SYS_clock_adjtime: ::c_long = 347;
+pub const SYS_syncfs: ::c_long = 348;
+pub const SYS_sendmmsg: ::c_long = 349;
+pub const SYS_setns: ::c_long = 350;
+pub const SYS_process_vm_readv: ::c_long = 351;
+pub const SYS_process_vm_writev: ::c_long = 352;
+pub const SYS_finit_module: ::c_long = 353;
+pub const SYS_kcmp: ::c_long = 354;
+pub const SYS_sched_setattr: ::c_long = 355;
+pub const SYS_sched_getattr: ::c_long = 356;
+pub const SYS_renameat2: ::c_long = 357;
+pub const SYS_seccomp: ::c_long = 358;
+pub const SYS_getrandom: ::c_long = 359;
+pub const SYS_memfd_create: ::c_long = 360;
+pub const SYS_bpf: ::c_long = 361;
+pub const SYS_execveat: ::c_long = 362;
+pub const SYS_switch_endian: ::c_long = 363;
+pub const SYS_userfaultfd: ::c_long = 364;
+pub const SYS_membarrier: ::c_long = 365;
+pub const SYS_mlock2: ::c_long = 378;
+pub const SYS_copy_file_range: ::c_long = 379;
+pub const SYS_preadv2: ::c_long = 380;
+pub const SYS_pwritev2: ::c_long = 381;
+pub const SYS_kexec_file_load: ::c_long = 382;
+pub const SYS_statx: ::c_long = 383;
+pub const SYS_pidfd_open: ::c_long = 434;
+pub const SYS_clone3: ::c_long = 435;
+
+extern "C" {
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_int,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/riscv64/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/riscv64/mod.rs
new file mode 100644
index 00000000..a297ac7f
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/riscv64/mod.rs
@@ -0,0 +1,867 @@
+//! RISC-V-specific definitions for 64-bit linux-like values
+
+pub type c_char = u8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type wchar_t = ::c_int;
+
+pub type nlink_t = ::c_uint;
+pub type blksize_t = ::c_int;
+pub type fsblkcnt64_t = ::c_ulong;
+pub type fsfilcnt64_t = ::c_ulong;
+pub type suseconds_t = i64;
+pub type __u64 = ::c_ulonglong;
+
+s! {
+    pub struct pthread_attr_t {
+        __size: [::c_ulong; 7],
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub __pad1: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub __pad2: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_int; 2usize],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub __pad1: ::dev_t,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub __pad2: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_int; 2],
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_flags: ::c_long,
+        pub f_spare: [::c_long; 4],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_blocks: ::fsblkcnt64_t,
+        pub f_bfree: ::fsblkcnt64_t,
+        pub f_bavail: ::fsblkcnt64_t,
+        pub f_files: ::fsfilcnt64_t,
+        pub f_ffree: ::fsfilcnt64_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_flags: ::c_long,
+        pub f_spare: [::c_long; 4],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        pub __f_spare: [::c_int; 6],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt64_t,
+        pub f_bfree: ::fsblkcnt64_t,
+        pub f_bavail: ::fsblkcnt64_t,
+        pub f_files: ::fsfilcnt64_t,
+        pub f_ffree: ::fsfilcnt64_t,
+        pub f_favail: ::fsfilcnt64_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        pub __f_spare: [::c_int; 6],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [u64; 0],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t,
+    }
+
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<unsafe extern "C" fn()>,
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_ushort,
+        __pad1: ::c_ushort,
+        pub __seq: ::c_ushort,
+        __pad2: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused5: ::c_ulong,
+        __unused6: ::c_ulong,
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct ip_mreqn {
+        pub imr_multiaddr: ::in_addr,
+        pub imr_address: ::in_addr,
+        pub imr_ifindex: ::c_int,
+    }
+}
+
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const TIOCGSOFTCAR: ::c_ulong = 21529;
+pub const TIOCSSOFTCAR: ::c_ulong = 21530;
+pub const TIOCGRS485: ::c_int = 21550;
+pub const TIOCSRS485: ::c_int = 21551;
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 1052672;
+pub const O_NOATIME: ::c_int = 262144;
+pub const O_PATH: ::c_int = 2097152;
+pub const O_TMPFILE: ::c_int = 4259840;
+pub const MAP_GROWSDOWN: ::c_int = 256;
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = 26;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PEERSEC: ::c_int = 31;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = 35;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = 41;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_BUSY_POLL: ::c_int = 46;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = 27;
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SA_ONSTACK: ::c_int = 134217728;
+pub const SA_SIGINFO: ::c_int = 4;
+pub const SA_NOCLDWAIT: ::c_int = 2;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0;
+pub const SIG_UNBLOCK: ::c_int = 1;
+pub const POLLWRNORM: ::c_short = 256;
+pub const POLLWRBAND: ::c_short = 512;
+pub const O_ASYNC: ::c_int = 8192;
+pub const O_NDELAY: ::c_int = 2048;
+pub const PTRACE_DETACH: ::c_uint = 17;
+pub const EFD_NONBLOCK: ::c_int = 2048;
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+pub const SFD_NONBLOCK: ::c_int = 2048;
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+pub const TIOCLINUX: ::c_ulong = 21532;
+pub const TIOCGSERIAL: ::c_ulong = 21534;
+pub const TIOCEXCL: ::c_ulong = 21516;
+pub const TIOCNXCL: ::c_ulong = 21517;
+pub const TIOCSCTTY: ::c_ulong = 21518;
+pub const TIOCSTI: ::c_ulong = 21522;
+pub const TIOCMGET: ::c_ulong = 21525;
+pub const TIOCMBIS: ::c_ulong = 21526;
+pub const TIOCMBIC: ::c_ulong = 21527;
+pub const TIOCMSET: ::c_ulong = 21528;
+pub const TIOCCONS: ::c_ulong = 21533;
+pub const TIOCM_ST: ::c_int = 8;
+pub const TIOCM_SR: ::c_int = 16;
+pub const TIOCM_CTS: ::c_int = 32;
+pub const TIOCM_CAR: ::c_int = 64;
+pub const TIOCM_RNG: ::c_int = 128;
+pub const TIOCM_DSR: ::c_int = 256;
+pub const SFD_CLOEXEC: ::c_int = 524288;
+pub const NCCS: usize = 32;
+pub const O_TRUNC: ::c_int = 512;
+pub const O_CLOEXEC: ::c_int = 524288;
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+pub const SA_NODEFER: ::c_int = 1073741824;
+pub const SA_RESETHAND: ::c_int = -2147483648;
+pub const SA_RESTART: ::c_int = 268435456;
+pub const SA_NOCLDSTOP: ::c_int = 1;
+pub const EPOLL_CLOEXEC: ::c_int = 524288;
+pub const EFD_CLOEXEC: ::c_int = 524288;
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const O_DIRECT: ::c_int = 16384;
+pub const O_DIRECTORY: ::c_int = 65536;
+pub const O_NOFOLLOW: ::c_int = 131072;
+pub const MAP_HUGETLB: ::c_int = 262144;
+pub const MAP_LOCKED: ::c_int = 8192;
+pub const MAP_NORESERVE: ::c_int = 16384;
+pub const MAP_ANON: ::c_int = 32;
+pub const MAP_ANONYMOUS: ::c_int = 32;
+pub const MAP_DENYWRITE: ::c_int = 2048;
+pub const MAP_EXECUTABLE: ::c_int = 4096;
+pub const MAP_POPULATE: ::c_int = 32768;
+pub const MAP_NONBLOCK: ::c_int = 65536;
+pub const MAP_STACK: ::c_int = 131072;
+pub const MAP_SYNC: ::c_int = 0x080000;
+pub const EDEADLOCK: ::c_int = 35;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const FIOCLEX: ::c_ulong = 21585;
+pub const FIONCLEX: ::c_ulong = 21584;
+pub const FIONBIO: ::c_ulong = 21537;
+pub const MCL_CURRENT: ::c_int = 1;
+pub const MCL_FUTURE: ::c_int = 2;
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const CBAUD: ::tcflag_t = 4111;
+pub const TAB1: ::tcflag_t = 2048;
+pub const TAB2: ::tcflag_t = 4096;
+pub const TAB3: ::tcflag_t = 6144;
+pub const CR1: ::tcflag_t = 512;
+pub const CR2: ::tcflag_t = 1024;
+pub const CR3: ::tcflag_t = 1536;
+pub const FF1: ::tcflag_t = 32768;
+pub const BS1: ::tcflag_t = 8192;
+pub const VT1: ::tcflag_t = 16384;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 1024;
+pub const IXOFF: ::tcflag_t = 4096;
+pub const ONLCR: ::tcflag_t = 4;
+pub const CSIZE: ::tcflag_t = 48;
+pub const CS6: ::tcflag_t = 16;
+pub const CS7: ::tcflag_t = 32;
+pub const CS8: ::tcflag_t = 48;
+pub const CSTOPB: ::tcflag_t = 64;
+pub const CREAD: ::tcflag_t = 128;
+pub const PARENB: ::tcflag_t = 256;
+pub const PARODD: ::tcflag_t = 512;
+pub const HUPCL: ::tcflag_t = 1024;
+pub const CLOCAL: ::tcflag_t = 2048;
+pub const ECHOKE: ::tcflag_t = 2048;
+pub const ECHOE: ::tcflag_t = 16;
+pub const ECHOK: ::tcflag_t = 32;
+pub const ECHONL: ::tcflag_t = 64;
+pub const ECHOPRT: ::tcflag_t = 1024;
+pub const ECHOCTL: ::tcflag_t = 512;
+pub const ISIG: ::tcflag_t = 1;
+pub const ICANON: ::tcflag_t = 2;
+pub const PENDIN: ::tcflag_t = 16384;
+pub const NOFLSH: ::tcflag_t = 128;
+pub const CIBAUD: ::tcflag_t = 269418496;
+pub const CBAUDEX: ::tcflag_t = 4096;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 2;
+pub const NLDLY: ::tcflag_t = 256;
+pub const CRDLY: ::tcflag_t = 1536;
+pub const TABDLY: ::tcflag_t = 6144;
+pub const BSDLY: ::tcflag_t = 8192;
+pub const FFDLY: ::tcflag_t = 32768;
+pub const VTDLY: ::tcflag_t = 16384;
+pub const XTABS: ::tcflag_t = 6144;
+pub const B0: ::speed_t = 0;
+pub const B50: ::speed_t = 1;
+pub const B75: ::speed_t = 2;
+pub const B110: ::speed_t = 3;
+pub const B134: ::speed_t = 4;
+pub const B150: ::speed_t = 5;
+pub const B200: ::speed_t = 6;
+pub const B300: ::speed_t = 7;
+pub const B600: ::speed_t = 8;
+pub const B1200: ::speed_t = 9;
+pub const B1800: ::speed_t = 10;
+pub const B2400: ::speed_t = 11;
+pub const B4800: ::speed_t = 12;
+pub const B9600: ::speed_t = 13;
+pub const B19200: ::speed_t = 14;
+pub const B38400: ::speed_t = 15;
+pub const EXTA: ::speed_t = 14;
+pub const EXTB: ::speed_t = 15;
+pub const B57600: ::speed_t = 4097;
+pub const B115200: ::speed_t = 4098;
+pub const B230400: ::speed_t = 4099;
+pub const B460800: ::speed_t = 4100;
+pub const B500000: ::speed_t = 4101;
+pub const B576000: ::speed_t = 4102;
+pub const B921600: ::speed_t = 4103;
+pub const B1000000: ::speed_t = 4104;
+pub const B1152000: ::speed_t = 4105;
+pub const B1500000: ::speed_t = 4106;
+pub const B2000000: ::speed_t = 4107;
+pub const B2500000: ::speed_t = 4108;
+pub const B3000000: ::speed_t = 4109;
+pub const B3500000: ::speed_t = 4110;
+pub const B4000000: ::speed_t = 4111;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 32768;
+pub const TOSTOP: ::tcflag_t = 256;
+pub const FLUSHO: ::tcflag_t = 4096;
+pub const EXTPROC: ::tcflag_t = 65536;
+pub const TCGETS: ::c_ulong = 21505;
+pub const TCSETS: ::c_ulong = 21506;
+pub const TCSETSW: ::c_ulong = 21507;
+pub const TCSETSF: ::c_ulong = 21508;
+pub const TCGETA: ::c_ulong = 21509;
+pub const TCSETA: ::c_ulong = 21510;
+pub const TCSETAW: ::c_ulong = 21511;
+pub const TCSETAF: ::c_ulong = 21512;
+pub const TCSBRK: ::c_ulong = 21513;
+pub const TCXONC: ::c_ulong = 21514;
+pub const TCFLSH: ::c_ulong = 21515;
+pub const TIOCINQ: ::c_ulong = 21531;
+pub const TIOCGPGRP: ::c_ulong = 21519;
+pub const TIOCSPGRP: ::c_ulong = 21520;
+pub const TIOCOUTQ: ::c_ulong = 21521;
+pub const TIOCGWINSZ: ::c_ulong = 21523;
+pub const TIOCSWINSZ: ::c_ulong = 21524;
+pub const FIONREAD: ::c_ulong = 21531;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+pub const SYS_read: ::c_long = 63;
+pub const SYS_write: ::c_long = 64;
+pub const SYS_close: ::c_long = 57;
+pub const SYS_fstat: ::c_long = 80;
+pub const SYS_lseek: ::c_long = 62;
+pub const SYS_mmap: ::c_long = 222;
+pub const SYS_mprotect: ::c_long = 226;
+pub const SYS_munmap: ::c_long = 215;
+pub const SYS_brk: ::c_long = 214;
+pub const SYS_rt_sigaction: ::c_long = 134;
+pub const SYS_rt_sigprocmask: ::c_long = 135;
+pub const SYS_rt_sigreturn: ::c_long = 139;
+pub const SYS_ioctl: ::c_long = 29;
+pub const SYS_pread64: ::c_long = 67;
+pub const SYS_pwrite64: ::c_long = 68;
+pub const SYS_readv: ::c_long = 65;
+pub const SYS_writev: ::c_long = 66;
+pub const SYS_sched_yield: ::c_long = 124;
+pub const SYS_mremap: ::c_long = 216;
+pub const SYS_msync: ::c_long = 227;
+pub const SYS_mincore: ::c_long = 232;
+pub const SYS_madvise: ::c_long = 233;
+pub const SYS_shmget: ::c_long = 194;
+pub const SYS_shmat: ::c_long = 196;
+pub const SYS_shmctl: ::c_long = 195;
+pub const SYS_dup: ::c_long = 23;
+pub const SYS_nanosleep: ::c_long = 101;
+pub const SYS_getitimer: ::c_long = 102;
+pub const SYS_setitimer: ::c_long = 103;
+pub const SYS_getpid: ::c_long = 172;
+pub const SYS_sendfile: ::c_long = 71;
+pub const SYS_socket: ::c_long = 198;
+pub const SYS_connect: ::c_long = 203;
+pub const SYS_accept: ::c_long = 202;
+pub const SYS_sendto: ::c_long = 206;
+pub const SYS_recvfrom: ::c_long = 207;
+pub const SYS_sendmsg: ::c_long = 211;
+pub const SYS_recvmsg: ::c_long = 212;
+pub const SYS_shutdown: ::c_long = 210;
+pub const SYS_bind: ::c_long = 200;
+pub const SYS_listen: ::c_long = 201;
+pub const SYS_getsockname: ::c_long = 204;
+pub const SYS_getpeername: ::c_long = 205;
+pub const SYS_socketpair: ::c_long = 199;
+pub const SYS_setsockopt: ::c_long = 208;
+pub const SYS_getsockopt: ::c_long = 209;
+pub const SYS_clone: ::c_long = 220;
+pub const SYS_execve: ::c_long = 221;
+pub const SYS_exit: ::c_long = 93;
+pub const SYS_wait4: ::c_long = 260;
+pub const SYS_kill: ::c_long = 129;
+pub const SYS_uname: ::c_long = 160;
+pub const SYS_semget: ::c_long = 190;
+pub const SYS_semop: ::c_long = 193;
+pub const SYS_semctl: ::c_long = 191;
+pub const SYS_shmdt: ::c_long = 197;
+pub const SYS_msgget: ::c_long = 186;
+pub const SYS_msgsnd: ::c_long = 189;
+pub const SYS_msgrcv: ::c_long = 188;
+pub const SYS_msgctl: ::c_long = 187;
+pub const SYS_fcntl: ::c_long = 25;
+pub const SYS_flock: ::c_long = 32;
+pub const SYS_fsync: ::c_long = 82;
+pub const SYS_fdatasync: ::c_long = 83;
+pub const SYS_truncate: ::c_long = 45;
+pub const SYS_ftruncate: ::c_long = 46;
+pub const SYS_getcwd: ::c_long = 17;
+pub const SYS_chdir: ::c_long = 49;
+pub const SYS_fchdir: ::c_long = 50;
+pub const SYS_fchmod: ::c_long = 52;
+pub const SYS_fchown: ::c_long = 55;
+pub const SYS_umask: ::c_long = 166;
+pub const SYS_gettimeofday: ::c_long = 169;
+pub const SYS_getrlimit: ::c_long = 163;
+pub const SYS_getrusage: ::c_long = 165;
+pub const SYS_sysinfo: ::c_long = 179;
+pub const SYS_times: ::c_long = 153;
+pub const SYS_ptrace: ::c_long = 117;
+pub const SYS_getuid: ::c_long = 174;
+pub const SYS_syslog: ::c_long = 116;
+pub const SYS_getgid: ::c_long = 176;
+pub const SYS_setuid: ::c_long = 146;
+pub const SYS_setgid: ::c_long = 144;
+pub const SYS_geteuid: ::c_long = 175;
+pub const SYS_getegid: ::c_long = 177;
+pub const SYS_setpgid: ::c_long = 154;
+pub const SYS_getppid: ::c_long = 173;
+pub const SYS_setsid: ::c_long = 157;
+pub const SYS_setreuid: ::c_long = 145;
+pub const SYS_setregid: ::c_long = 143;
+pub const SYS_getgroups: ::c_long = 158;
+pub const SYS_setgroups: ::c_long = 159;
+pub const SYS_setresuid: ::c_long = 147;
+pub const SYS_getresuid: ::c_long = 148;
+pub const SYS_setresgid: ::c_long = 149;
+pub const SYS_getresgid: ::c_long = 150;
+pub const SYS_getpgid: ::c_long = 155;
+pub const SYS_setfsuid: ::c_long = 151;
+pub const SYS_setfsgid: ::c_long = 152;
+pub const SYS_getsid: ::c_long = 156;
+pub const SYS_capget: ::c_long = 90;
+pub const SYS_capset: ::c_long = 91;
+pub const SYS_rt_sigpending: ::c_long = 136;
+pub const SYS_rt_sigtimedwait: ::c_long = 137;
+pub const SYS_rt_sigqueueinfo: ::c_long = 138;
+pub const SYS_rt_sigsuspend: ::c_long = 133;
+pub const SYS_sigaltstack: ::c_long = 132;
+pub const SYS_personality: ::c_long = 92;
+pub const SYS_statfs: ::c_long = 43;
+pub const SYS_fstatfs: ::c_long = 44;
+pub const SYS_getpriority: ::c_long = 141;
+pub const SYS_setpriority: ::c_long = 140;
+pub const SYS_sched_setparam: ::c_long = 118;
+pub const SYS_sched_getparam: ::c_long = 121;
+pub const SYS_sched_setscheduler: ::c_long = 119;
+pub const SYS_sched_getscheduler: ::c_long = 120;
+pub const SYS_sched_get_priority_max: ::c_long = 125;
+pub const SYS_sched_get_priority_min: ::c_long = 126;
+pub const SYS_sched_rr_get_interval: ::c_long = 127;
+pub const SYS_mlock: ::c_long = 228;
+pub const SYS_munlock: ::c_long = 229;
+pub const SYS_mlockall: ::c_long = 230;
+pub const SYS_munlockall: ::c_long = 231;
+pub const SYS_vhangup: ::c_long = 58;
+pub const SYS_pivot_root: ::c_long = 41;
+pub const SYS_prctl: ::c_long = 167;
+pub const SYS_adjtimex: ::c_long = 171;
+pub const SYS_setrlimit: ::c_long = 164;
+pub const SYS_chroot: ::c_long = 51;
+pub const SYS_sync: ::c_long = 81;
+pub const SYS_acct: ::c_long = 89;
+pub const SYS_settimeofday: ::c_long = 170;
+pub const SYS_mount: ::c_long = 40;
+pub const SYS_umount2: ::c_long = 39;
+pub const SYS_swapon: ::c_long = 224;
+pub const SYS_swapoff: ::c_long = 225;
+pub const SYS_reboot: ::c_long = 142;
+pub const SYS_sethostname: ::c_long = 161;
+pub const SYS_setdomainname: ::c_long = 162;
+pub const SYS_init_module: ::c_long = 105;
+pub const SYS_delete_module: ::c_long = 106;
+pub const SYS_quotactl: ::c_long = 60;
+pub const SYS_nfsservctl: ::c_long = 42;
+pub const SYS_gettid: ::c_long = 178;
+pub const SYS_readahead: ::c_long = 213;
+pub const SYS_setxattr: ::c_long = 5;
+pub const SYS_lsetxattr: ::c_long = 6;
+pub const SYS_fsetxattr: ::c_long = 7;
+pub const SYS_getxattr: ::c_long = 8;
+pub const SYS_lgetxattr: ::c_long = 9;
+pub const SYS_fgetxattr: ::c_long = 10;
+pub const SYS_listxattr: ::c_long = 11;
+pub const SYS_llistxattr: ::c_long = 12;
+pub const SYS_flistxattr: ::c_long = 13;
+pub const SYS_removexattr: ::c_long = 14;
+pub const SYS_lremovexattr: ::c_long = 15;
+pub const SYS_fremovexattr: ::c_long = 16;
+pub const SYS_tkill: ::c_long = 130;
+pub const SYS_futex: ::c_long = 98;
+pub const SYS_sched_setaffinity: ::c_long = 122;
+pub const SYS_sched_getaffinity: ::c_long = 123;
+pub const SYS_io_setup: ::c_long = 0;
+pub const SYS_io_destroy: ::c_long = 1;
+pub const SYS_io_getevents: ::c_long = 4;
+pub const SYS_io_submit: ::c_long = 2;
+pub const SYS_io_cancel: ::c_long = 3;
+pub const SYS_lookup_dcookie: ::c_long = 18;
+pub const SYS_remap_file_pages: ::c_long = 234;
+pub const SYS_getdents64: ::c_long = 61;
+pub const SYS_set_tid_address: ::c_long = 96;
+pub const SYS_restart_syscall: ::c_long = 128;
+pub const SYS_semtimedop: ::c_long = 192;
+pub const SYS_fadvise64: ::c_long = 223;
+pub const SYS_timer_create: ::c_long = 107;
+pub const SYS_timer_settime: ::c_long = 110;
+pub const SYS_timer_gettime: ::c_long = 108;
+pub const SYS_timer_getoverrun: ::c_long = 109;
+pub const SYS_timer_delete: ::c_long = 111;
+pub const SYS_clock_settime: ::c_long = 112;
+pub const SYS_clock_gettime: ::c_long = 113;
+pub const SYS_clock_getres: ::c_long = 114;
+pub const SYS_clock_nanosleep: ::c_long = 115;
+pub const SYS_exit_group: ::c_long = 94;
+pub const SYS_epoll_ctl: ::c_long = 21;
+pub const SYS_tgkill: ::c_long = 131;
+pub const SYS_mbind: ::c_long = 235;
+pub const SYS_set_mempolicy: ::c_long = 237;
+pub const SYS_get_mempolicy: ::c_long = 236;
+pub const SYS_mq_open: ::c_long = 180;
+pub const SYS_mq_unlink: ::c_long = 181;
+pub const SYS_mq_timedsend: ::c_long = 182;
+pub const SYS_mq_timedreceive: ::c_long = 183;
+pub const SYS_mq_notify: ::c_long = 184;
+pub const SYS_mq_getsetattr: ::c_long = 185;
+pub const SYS_kexec_load: ::c_long = 104;
+pub const SYS_waitid: ::c_long = 95;
+pub const SYS_add_key: ::c_long = 217;
+pub const SYS_request_key: ::c_long = 218;
+pub const SYS_keyctl: ::c_long = 219;
+pub const SYS_ioprio_set: ::c_long = 30;
+pub const SYS_ioprio_get: ::c_long = 31;
+pub const SYS_inotify_add_watch: ::c_long = 27;
+pub const SYS_inotify_rm_watch: ::c_long = 28;
+pub const SYS_migrate_pages: ::c_long = 238;
+pub const SYS_openat: ::c_long = 56;
+pub const SYS_mkdirat: ::c_long = 34;
+pub const SYS_mknodat: ::c_long = 33;
+pub const SYS_fchownat: ::c_long = 54;
+pub const SYS_newfstatat: ::c_long = 79;
+pub const SYS_unlinkat: ::c_long = 35;
+pub const SYS_linkat: ::c_long = 37;
+pub const SYS_symlinkat: ::c_long = 36;
+pub const SYS_readlinkat: ::c_long = 78;
+pub const SYS_fchmodat: ::c_long = 53;
+pub const SYS_faccessat: ::c_long = 48;
+pub const SYS_pselect6: ::c_long = 72;
+pub const SYS_ppoll: ::c_long = 73;
+pub const SYS_unshare: ::c_long = 97;
+pub const SYS_set_robust_list: ::c_long = 99;
+pub const SYS_get_robust_list: ::c_long = 100;
+pub const SYS_splice: ::c_long = 76;
+pub const SYS_tee: ::c_long = 77;
+pub const SYS_sync_file_range: ::c_long = 84;
+pub const SYS_vmsplice: ::c_long = 75;
+pub const SYS_move_pages: ::c_long = 239;
+pub const SYS_utimensat: ::c_long = 88;
+pub const SYS_epoll_pwait: ::c_long = 22;
+pub const SYS_timerfd_create: ::c_long = 85;
+pub const SYS_fallocate: ::c_long = 47;
+pub const SYS_timerfd_settime: ::c_long = 86;
+pub const SYS_timerfd_gettime: ::c_long = 87;
+pub const SYS_accept4: ::c_long = 242;
+pub const SYS_signalfd4: ::c_long = 74;
+pub const SYS_eventfd2: ::c_long = 19;
+pub const SYS_epoll_create1: ::c_long = 20;
+pub const SYS_dup3: ::c_long = 24;
+pub const SYS_pipe2: ::c_long = 59;
+pub const SYS_inotify_init1: ::c_long = 26;
+pub const SYS_preadv: ::c_long = 69;
+pub const SYS_pwritev: ::c_long = 70;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 240;
+pub const SYS_perf_event_open: ::c_long = 241;
+pub const SYS_recvmmsg: ::c_long = 243;
+pub const SYS_fanotify_init: ::c_long = 262;
+pub const SYS_fanotify_mark: ::c_long = 263;
+pub const SYS_prlimit64: ::c_long = 261;
+pub const SYS_name_to_handle_at: ::c_long = 264;
+pub const SYS_open_by_handle_at: ::c_long = 265;
+pub const SYS_clock_adjtime: ::c_long = 266;
+pub const SYS_syncfs: ::c_long = 267;
+pub const SYS_sendmmsg: ::c_long = 269;
+pub const SYS_setns: ::c_long = 268;
+pub const SYS_getcpu: ::c_long = 168;
+pub const SYS_process_vm_readv: ::c_long = 270;
+pub const SYS_process_vm_writev: ::c_long = 271;
+pub const SYS_kcmp: ::c_long = 272;
+pub const SYS_finit_module: ::c_long = 273;
+pub const SYS_sched_setattr: ::c_long = 274;
+pub const SYS_sched_getattr: ::c_long = 275;
+pub const SYS_renameat2: ::c_long = 276;
+pub const SYS_seccomp: ::c_long = 277;
+pub const SYS_getrandom: ::c_long = 278;
+pub const SYS_memfd_create: ::c_long = 279;
+pub const SYS_bpf: ::c_long = 280;
+pub const SYS_execveat: ::c_long = 281;
+pub const SYS_userfaultfd: ::c_long = 282;
+pub const SYS_membarrier: ::c_long = 283;
+pub const SYS_mlock2: ::c_long = 284;
+pub const SYS_copy_file_range: ::c_long = 285;
+pub const SYS_preadv2: ::c_long = 286;
+pub const SYS_pwritev2: ::c_long = 287;
+pub const SYS_pkey_mprotect: ::c_long = 288;
+pub const SYS_pkey_alloc: ::c_long = 289;
+pub const SYS_pkey_free: ::c_long = 290;
+pub const SYS_statx: ::c_long = 291;
+pub const SYS_pidfd_open: ::c_long = 434;
+pub const SYS_clone3: ::c_long = 435;
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/s390x.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/s390x.rs
new file mode 100644
index 00000000..fcd1f7b1
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/s390x.rs
@@ -0,0 +1,1035 @@
+//! s390x
+
+use pthread_mutex_t;
+
+pub type blksize_t = i64;
+pub type c_char = u8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type nlink_t = u64;
+pub type suseconds_t = i64;
+pub type wchar_t = i32;
+pub type greg_t = u64;
+pub type __u64 = u64;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        __glibc_reserved0: ::c_int,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+        pub sa_mask: ::sigset_t,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_uint,
+        pub f_bsize: ::c_uint,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_uint,
+        pub f_frsize: ::c_uint,
+        pub f_flags: ::c_uint,
+        f_spare: [::c_uint; 4],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        _pad: ::c_int,
+        _pad2: [::c_long; 14],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        st_pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        __glibc_reserved: [::c_long; 3],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        st_pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        __glibc_reserved: [::c_long; 3],
+    }
+
+    pub struct pthread_attr_t {
+        __size: [::c_ulong; 7]
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_ushort,
+        __pad1: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct __psw_t {
+        pub mask: u64,
+        pub addr: u64,
+    }
+
+    pub struct fpregset_t {
+        pub fpc: u32,
+        __pad: u32,
+        pub fprs: [fpreg_t; 16],
+    }
+
+    pub struct mcontext_t {
+        pub psw: __psw_t,
+        pub gregs: [u64; 16],
+        pub aregs: [u32; 16],
+        pub fpregs: fpregset_t,
+    }
+
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_mcontext: mcontext_t,
+        pub uc_sigmask: ::sigset_t,
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_uint,
+        pub f_bsize: ::c_uint,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_uint,
+        pub f_frsize: ::c_uint,
+        pub f_flags: ::c_uint,
+        pub f_spare: [::c_uint; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+}
+
+s_no_extra_traits! {
+    // FIXME: This is actually a union.
+    pub struct fpreg_t {
+        pub d: ::c_double,
+        // f: ::c_float,
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for fpreg_t {
+            fn eq(&self, other: &fpreg_t) -> bool {
+                self.d == other.d
+            }
+        }
+
+        impl Eq for fpreg_t {}
+
+        impl ::fmt::Debug for fpreg_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("fpreg_t")
+                    .field("d", &self.d)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for fpreg_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                let d: u64 = unsafe { ::mem::transmute(self.d) };
+                d.hash(state);
+            }
+        }
+    }
+}
+
+pub const POSIX_FADV_DONTNEED: ::c_int = 6;
+pub const POSIX_FADV_NOREUSE: ::c_int = 7;
+
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 512;
+pub const O_NOATIME: ::c_int = 0o1000000;
+pub const O_CLOEXEC: ::c_int = 0x80000;
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+align_const! {
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+}
+
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const ECONNRESET: ::c_int = 104;
+pub const EDEADLK: ::c_int = 35;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTCONN: ::c_int = 107;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const FIOCLEX: ::c_ulong = 0x5451;
+pub const FIONCLEX: ::c_ulong = 0x5450;
+pub const FIONBIO: ::c_ulong = 0x5421;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const SA_NOCLDWAIT: ::c_int = 2;
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 4;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGSTKSZ: ::size_t = 0x2000;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_BUSY_POLL: ::c_int = 46;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 0x101000;
+pub const O_DIRECT: ::c_int = 0x4000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+
+pub const EDEADLOCK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = 31;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_NDELAY: ::c_int = 0x800;
+
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+
+pub const PTRACE_DETACH: ::c_uint = 17;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const SFD_NONBLOCK: ::c_int = 0x0800;
+
+pub const TCGETS: ::c_ulong = 0x5401;
+pub const TCSETS: ::c_ulong = 0x5402;
+pub const TCSETSW: ::c_ulong = 0x5403;
+pub const TCSETSF: ::c_ulong = 0x5404;
+pub const TCGETA: ::c_ulong = 0x5405;
+pub const TCSETA: ::c_ulong = 0x5406;
+pub const TCSETAW: ::c_ulong = 0x5407;
+pub const TCSETAF: ::c_ulong = 0x5408;
+pub const TCSBRK: ::c_ulong = 0x5409;
+pub const TCXONC: ::c_ulong = 0x540A;
+pub const TCFLSH: ::c_ulong = 0x540B;
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5419;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x541A;
+pub const TIOCINQ: ::c_ulong = 0x541B;
+pub const TIOCEXCL: ::c_ulong = 0x540C;
+pub const TIOCNXCL: ::c_ulong = 0x540D;
+pub const TIOCSCTTY: ::c_ulong = 0x540E;
+pub const TIOCGPGRP: ::c_ulong = 0x540F;
+pub const TIOCSPGRP: ::c_ulong = 0x5410;
+pub const TIOCOUTQ: ::c_ulong = 0x5411;
+pub const TIOCSTI: ::c_ulong = 0x5412;
+pub const TIOCGWINSZ: ::c_ulong = 0x5413;
+pub const TIOCSWINSZ: ::c_ulong = 0x5414;
+pub const TIOCMGET: ::c_ulong = 0x5415;
+pub const TIOCMBIS: ::c_ulong = 0x5416;
+pub const TIOCMBIC: ::c_ulong = 0x5417;
+pub const TIOCMSET: ::c_ulong = 0x5418;
+pub const FIONREAD: ::c_ulong = 0x541B;
+pub const TIOCCONS: ::c_ulong = 0x541D;
+pub const TIOCSBRK: ::c_ulong = 0x5427;
+pub const TIOCCBRK: ::c_ulong = 0x5428;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+pub const VTIME: usize = 5;
+pub const VSWTC: usize = 7;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VSUSP: usize = 10;
+pub const VREPRINT: usize = 12;
+pub const VDISCARD: usize = 13;
+pub const VWERASE: usize = 14;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const ONLCR: ::tcflag_t = 0o000004;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const CBAUD: ::speed_t = 0o010017;
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const CSIZE: ::tcflag_t = 0o000060;
+pub const CS6: ::tcflag_t = 0o000020;
+pub const CS7: ::tcflag_t = 0o000040;
+pub const CS8: ::tcflag_t = 0o000060;
+pub const CSTOPB: ::tcflag_t = 0o000100;
+pub const CREAD: ::tcflag_t = 0o000200;
+pub const PARENB: ::tcflag_t = 0o000400;
+pub const PARODD: ::tcflag_t = 0o001000;
+pub const HUPCL: ::tcflag_t = 0o002000;
+pub const CLOCAL: ::tcflag_t = 0o004000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+
+pub const ISIG: ::tcflag_t = 0o000001;
+pub const ICANON: ::tcflag_t = 0o000002;
+pub const XCASE: ::tcflag_t = 0o000004;
+pub const ECHOE: ::tcflag_t = 0o000020;
+pub const ECHOK: ::tcflag_t = 0o000040;
+pub const ECHONL: ::tcflag_t = 0o000100;
+pub const NOFLSH: ::tcflag_t = 0o000200;
+pub const ECHOCTL: ::tcflag_t = 0o001000;
+pub const ECHOPRT: ::tcflag_t = 0o002000;
+pub const ECHOKE: ::tcflag_t = 0o004000;
+pub const PENDIN: ::tcflag_t = 0o040000;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const IXON: ::tcflag_t = 0o002000;
+pub const IXOFF: ::tcflag_t = 0o010000;
+
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_restart_syscall: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_umount: ::c_long = 22;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_readdir: ::c_long = 89;
+pub const SYS_mmap: ::c_long = 90;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_socketcall: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_lookup_dcookie: ::c_long = 110;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_idle: ::c_long = 112;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_ipc: ::c_long = 117;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_create_module: ::c_long = 127;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_get_kernel_syms: ::c_long = 130;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_afs_syscall: ::c_long = 137; /* Syscall for Andrew File System */
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_query_module: ::c_long = 167;
+pub const SYS_poll: ::c_long = 168;
+pub const SYS_nfsservctl: ::c_long = 169;
+pub const SYS_prctl: ::c_long = 172;
+pub const SYS_rt_sigreturn: ::c_long = 173;
+pub const SYS_rt_sigaction: ::c_long = 174;
+pub const SYS_rt_sigprocmask: ::c_long = 175;
+pub const SYS_rt_sigpending: ::c_long = 176;
+pub const SYS_rt_sigtimedwait: ::c_long = 177;
+pub const SYS_rt_sigqueueinfo: ::c_long = 178;
+pub const SYS_rt_sigsuspend: ::c_long = 179;
+pub const SYS_pread64: ::c_long = 180;
+pub const SYS_pwrite64: ::c_long = 181;
+pub const SYS_getcwd: ::c_long = 183;
+pub const SYS_capget: ::c_long = 184;
+pub const SYS_capset: ::c_long = 185;
+pub const SYS_sigaltstack: ::c_long = 186;
+pub const SYS_sendfile: ::c_long = 187;
+pub const SYS_getpmsg: ::c_long = 188;
+pub const SYS_putpmsg: ::c_long = 189;
+pub const SYS_vfork: ::c_long = 190;
+pub const SYS_pivot_root: ::c_long = 217;
+pub const SYS_mincore: ::c_long = 218;
+pub const SYS_madvise: ::c_long = 219;
+pub const SYS_getdents64: ::c_long = 220;
+pub const SYS_readahead: ::c_long = 222;
+pub const SYS_setxattr: ::c_long = 224;
+pub const SYS_lsetxattr: ::c_long = 225;
+pub const SYS_fsetxattr: ::c_long = 226;
+pub const SYS_getxattr: ::c_long = 227;
+pub const SYS_lgetxattr: ::c_long = 228;
+pub const SYS_fgetxattr: ::c_long = 229;
+pub const SYS_listxattr: ::c_long = 230;
+pub const SYS_llistxattr: ::c_long = 231;
+pub const SYS_flistxattr: ::c_long = 232;
+pub const SYS_removexattr: ::c_long = 233;
+pub const SYS_lremovexattr: ::c_long = 234;
+pub const SYS_fremovexattr: ::c_long = 235;
+pub const SYS_gettid: ::c_long = 236;
+pub const SYS_tkill: ::c_long = 237;
+pub const SYS_futex: ::c_long = 238;
+pub const SYS_sched_setaffinity: ::c_long = 239;
+pub const SYS_sched_getaffinity: ::c_long = 240;
+pub const SYS_tgkill: ::c_long = 241;
+pub const SYS_io_setup: ::c_long = 243;
+pub const SYS_io_destroy: ::c_long = 244;
+pub const SYS_io_getevents: ::c_long = 245;
+pub const SYS_io_submit: ::c_long = 246;
+pub const SYS_io_cancel: ::c_long = 247;
+pub const SYS_exit_group: ::c_long = 248;
+pub const SYS_epoll_create: ::c_long = 249;
+pub const SYS_epoll_ctl: ::c_long = 250;
+pub const SYS_epoll_wait: ::c_long = 251;
+pub const SYS_set_tid_address: ::c_long = 252;
+pub const SYS_fadvise64: ::c_long = 253;
+pub const SYS_timer_create: ::c_long = 254;
+pub const SYS_timer_settime: ::c_long = 255;
+pub const SYS_timer_gettime: ::c_long = 256;
+pub const SYS_timer_getoverrun: ::c_long = 257;
+pub const SYS_timer_delete: ::c_long = 258;
+pub const SYS_clock_settime: ::c_long = 259;
+pub const SYS_clock_gettime: ::c_long = 260;
+pub const SYS_clock_getres: ::c_long = 261;
+pub const SYS_clock_nanosleep: ::c_long = 262;
+pub const SYS_statfs64: ::c_long = 265;
+pub const SYS_fstatfs64: ::c_long = 266;
+pub const SYS_remap_file_pages: ::c_long = 267;
+pub const SYS_mbind: ::c_long = 268;
+pub const SYS_get_mempolicy: ::c_long = 269;
+pub const SYS_set_mempolicy: ::c_long = 270;
+pub const SYS_mq_open: ::c_long = 271;
+pub const SYS_mq_unlink: ::c_long = 272;
+pub const SYS_mq_timedsend: ::c_long = 273;
+pub const SYS_mq_timedreceive: ::c_long = 274;
+pub const SYS_mq_notify: ::c_long = 275;
+pub const SYS_mq_getsetattr: ::c_long = 276;
+pub const SYS_kexec_load: ::c_long = 277;
+pub const SYS_add_key: ::c_long = 278;
+pub const SYS_request_key: ::c_long = 279;
+pub const SYS_keyctl: ::c_long = 280;
+pub const SYS_waitid: ::c_long = 281;
+pub const SYS_ioprio_set: ::c_long = 282;
+pub const SYS_ioprio_get: ::c_long = 283;
+pub const SYS_inotify_init: ::c_long = 284;
+pub const SYS_inotify_add_watch: ::c_long = 285;
+pub const SYS_inotify_rm_watch: ::c_long = 286;
+pub const SYS_migrate_pages: ::c_long = 287;
+pub const SYS_openat: ::c_long = 288;
+pub const SYS_mkdirat: ::c_long = 289;
+pub const SYS_mknodat: ::c_long = 290;
+pub const SYS_fchownat: ::c_long = 291;
+pub const SYS_futimesat: ::c_long = 292;
+pub const SYS_unlinkat: ::c_long = 294;
+pub const SYS_renameat: ::c_long = 295;
+pub const SYS_linkat: ::c_long = 296;
+pub const SYS_symlinkat: ::c_long = 297;
+pub const SYS_readlinkat: ::c_long = 298;
+pub const SYS_fchmodat: ::c_long = 299;
+pub const SYS_faccessat: ::c_long = 300;
+pub const SYS_pselect6: ::c_long = 301;
+pub const SYS_ppoll: ::c_long = 302;
+pub const SYS_unshare: ::c_long = 303;
+pub const SYS_set_robust_list: ::c_long = 304;
+pub const SYS_get_robust_list: ::c_long = 305;
+pub const SYS_splice: ::c_long = 306;
+pub const SYS_sync_file_range: ::c_long = 307;
+pub const SYS_tee: ::c_long = 308;
+pub const SYS_vmsplice: ::c_long = 309;
+pub const SYS_move_pages: ::c_long = 310;
+pub const SYS_getcpu: ::c_long = 311;
+pub const SYS_epoll_pwait: ::c_long = 312;
+pub const SYS_utimes: ::c_long = 313;
+pub const SYS_fallocate: ::c_long = 314;
+pub const SYS_utimensat: ::c_long = 315;
+pub const SYS_signalfd: ::c_long = 316;
+pub const SYS_timerfd: ::c_long = 317;
+pub const SYS_eventfd: ::c_long = 318;
+pub const SYS_timerfd_create: ::c_long = 319;
+pub const SYS_timerfd_settime: ::c_long = 320;
+pub const SYS_timerfd_gettime: ::c_long = 321;
+pub const SYS_signalfd4: ::c_long = 322;
+pub const SYS_eventfd2: ::c_long = 323;
+pub const SYS_inotify_init1: ::c_long = 324;
+pub const SYS_pipe2: ::c_long = 325;
+pub const SYS_dup3: ::c_long = 326;
+pub const SYS_epoll_create1: ::c_long = 327;
+pub const SYS_preadv: ::c_long = 328;
+pub const SYS_pwritev: ::c_long = 329;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 330;
+pub const SYS_perf_event_open: ::c_long = 331;
+pub const SYS_fanotify_init: ::c_long = 332;
+pub const SYS_fanotify_mark: ::c_long = 333;
+pub const SYS_prlimit64: ::c_long = 334;
+pub const SYS_name_to_handle_at: ::c_long = 335;
+pub const SYS_open_by_handle_at: ::c_long = 336;
+pub const SYS_clock_adjtime: ::c_long = 337;
+pub const SYS_syncfs: ::c_long = 338;
+pub const SYS_setns: ::c_long = 339;
+pub const SYS_process_vm_readv: ::c_long = 340;
+pub const SYS_process_vm_writev: ::c_long = 341;
+pub const SYS_s390_runtime_instr: ::c_long = 342;
+pub const SYS_kcmp: ::c_long = 343;
+pub const SYS_finit_module: ::c_long = 344;
+pub const SYS_sched_setattr: ::c_long = 345;
+pub const SYS_sched_getattr: ::c_long = 346;
+pub const SYS_renameat2: ::c_long = 347;
+pub const SYS_seccomp: ::c_long = 348;
+pub const SYS_getrandom: ::c_long = 349;
+pub const SYS_memfd_create: ::c_long = 350;
+pub const SYS_bpf: ::c_long = 351;
+pub const SYS_s390_pci_mmio_write: ::c_long = 352;
+pub const SYS_s390_pci_mmio_read: ::c_long = 353;
+pub const SYS_execveat: ::c_long = 354;
+pub const SYS_userfaultfd: ::c_long = 355;
+pub const SYS_membarrier: ::c_long = 356;
+pub const SYS_recvmmsg: ::c_long = 357;
+pub const SYS_sendmmsg: ::c_long = 358;
+pub const SYS_socket: ::c_long = 359;
+pub const SYS_socketpair: ::c_long = 360;
+pub const SYS_bind: ::c_long = 361;
+pub const SYS_connect: ::c_long = 362;
+pub const SYS_listen: ::c_long = 363;
+pub const SYS_accept4: ::c_long = 364;
+pub const SYS_getsockopt: ::c_long = 365;
+pub const SYS_setsockopt: ::c_long = 366;
+pub const SYS_getsockname: ::c_long = 367;
+pub const SYS_getpeername: ::c_long = 368;
+pub const SYS_sendto: ::c_long = 369;
+pub const SYS_sendmsg: ::c_long = 370;
+pub const SYS_recvfrom: ::c_long = 371;
+pub const SYS_recvmsg: ::c_long = 372;
+pub const SYS_shutdown: ::c_long = 373;
+pub const SYS_mlock2: ::c_long = 374;
+pub const SYS_copy_file_range: ::c_long = 375;
+pub const SYS_preadv2: ::c_long = 376;
+pub const SYS_pwritev2: ::c_long = 377;
+pub const SYS_lchown: ::c_long = 198;
+pub const SYS_setuid: ::c_long = 213;
+pub const SYS_getuid: ::c_long = 199;
+pub const SYS_setgid: ::c_long = 214;
+pub const SYS_getgid: ::c_long = 200;
+pub const SYS_geteuid: ::c_long = 201;
+pub const SYS_setreuid: ::c_long = 203;
+pub const SYS_setregid: ::c_long = 204;
+pub const SYS_getrlimit: ::c_long = 191;
+pub const SYS_getgroups: ::c_long = 205;
+pub const SYS_fchown: ::c_long = 207;
+pub const SYS_setresuid: ::c_long = 208;
+pub const SYS_setresgid: ::c_long = 210;
+pub const SYS_getresgid: ::c_long = 211;
+pub const SYS_select: ::c_long = 142;
+pub const SYS_getegid: ::c_long = 202;
+pub const SYS_setgroups: ::c_long = 206;
+pub const SYS_getresuid: ::c_long = 209;
+pub const SYS_chown: ::c_long = 212;
+pub const SYS_setfsuid: ::c_long = 215;
+pub const SYS_setfsgid: ::c_long = 216;
+pub const SYS_newfstatat: ::c_long = 293;
+pub const SYS_statx: ::c_long = 379;
+pub const SYS_pidfd_open: ::c_long = 434;
+pub const SYS_clone3: ::c_long = 435;
+
+extern "C" {
+
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_int,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    pub fn getcontext(ucp: *mut ::ucontext_t) -> ::c_int;
+    pub fn setcontext(ucp: *const ::ucontext_t) -> ::c_int;
+    pub fn makecontext(
+        ucp: *mut ::ucontext_t,
+        func: extern "C" fn(),
+        argc: ::c_int,
+        ...
+    );
+    pub fn swapcontext(
+        uocp: *mut ::ucontext_t,
+        ucp: *const ::ucontext_t,
+    ) -> ::c_int;
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/sparc64/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/sparc64/align.rs
new file mode 100644
index 00000000..29d1e1c7
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/sparc64/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [i64; 4]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/sparc64/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/sparc64/mod.rs
new file mode 100644
index 00000000..bcf0fd62
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/sparc64/mod.rs
@@ -0,0 +1,996 @@
+//! SPARC64-specific definitions for 64-bit linux-like values
+
+use pthread_mutex_t;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type nlink_t = u32;
+pub type blksize_t = i64;
+pub type suseconds_t = i32;
+pub type __u64 = ::c_ulonglong;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        #[cfg(target_arch = "sparc64")]
+        __reserved0: ::c_int,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statfs {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        f_spare: [::__fsword_t; 5],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+        __reserved:  ::c_short,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        __pad0: u64,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad1: u64,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 2],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        __pad0: u64,
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad2: ::c_int,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __reserved: [::c_long; 2],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        pub f_flags: ::__fsword_t,
+        pub f_spare: [::__fsword_t; 4],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct pthread_attr_t {
+        __size: [u64; 7]
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        __pad0: u16,
+        pub __seq: ::c_ushort,
+        __unused1: ::c_ulonglong,
+        __unused2: ::c_ulonglong,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_segsz: ::size_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __reserved1: ::c_ulong,
+        __reserved2: ::c_ulong
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+}
+
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+pub const TIOCGSOFTCAR: ::c_ulong = 0x40047464;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x80047465;
+
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 6;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 7;
+
+pub const O_APPEND: ::c_int = 0x8;
+pub const O_CREAT: ::c_int = 0x200;
+pub const O_EXCL: ::c_int = 0x800;
+pub const O_NOCTTY: ::c_int = 0x8000;
+pub const O_NONBLOCK: ::c_int = 0x4000;
+pub const O_SYNC: ::c_int = 0x802000;
+pub const O_RSYNC: ::c_int = 0x802000;
+pub const O_DSYNC: ::c_int = 0x2000;
+pub const O_FSYNC: ::c_int = 0x802000;
+pub const O_NOATIME: ::c_int = 0x200000;
+pub const O_PATH: ::c_int = 0x1000000;
+pub const O_TMPFILE: ::c_int = 0x2000000 | O_DIRECTORY;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_GROWSDOWN: ::c_int = 0x0200;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const EDEADLK: ::c_int = 78;
+pub const ENAMETOOLONG: ::c_int = 63;
+pub const ENOLCK: ::c_int = 79;
+pub const ENOSYS: ::c_int = 90;
+pub const ENOTEMPTY: ::c_int = 66;
+pub const ELOOP: ::c_int = 62;
+pub const ENOMSG: ::c_int = 75;
+pub const EIDRM: ::c_int = 77;
+pub const ECHRNG: ::c_int = 94;
+pub const EL2NSYNC: ::c_int = 95;
+pub const EL3HLT: ::c_int = 96;
+pub const EL3RST: ::c_int = 97;
+pub const ELNRNG: ::c_int = 98;
+pub const EUNATCH: ::c_int = 99;
+pub const ENOCSI: ::c_int = 100;
+pub const EL2HLT: ::c_int = 101;
+pub const EBADE: ::c_int = 102;
+pub const EBADR: ::c_int = 103;
+pub const EXFULL: ::c_int = 104;
+pub const ENOANO: ::c_int = 105;
+pub const EBADRQC: ::c_int = 106;
+pub const EBADSLT: ::c_int = 107;
+pub const EMULTIHOP: ::c_int = 87;
+pub const EOVERFLOW: ::c_int = 92;
+pub const ENOTUNIQ: ::c_int = 115;
+pub const EBADFD: ::c_int = 93;
+pub const EBADMSG: ::c_int = 76;
+pub const EREMCHG: ::c_int = 89;
+pub const ELIBACC: ::c_int = 114;
+pub const ELIBBAD: ::c_int = 112;
+pub const ELIBSCN: ::c_int = 124;
+pub const ELIBMAX: ::c_int = 123;
+pub const ELIBEXEC: ::c_int = 110;
+pub const EILSEQ: ::c_int = 122;
+pub const ERESTART: ::c_int = 116;
+pub const ESTRPIPE: ::c_int = 91;
+pub const EUSERS: ::c_int = 68;
+pub const ENOTSOCK: ::c_int = 38;
+pub const EDESTADDRREQ: ::c_int = 39;
+pub const EMSGSIZE: ::c_int = 40;
+pub const EPROTOTYPE: ::c_int = 41;
+pub const ENOPROTOOPT: ::c_int = 42;
+pub const EPROTONOSUPPORT: ::c_int = 43;
+pub const ESOCKTNOSUPPORT: ::c_int = 44;
+pub const EOPNOTSUPP: ::c_int = 45;
+pub const EPFNOSUPPORT: ::c_int = 46;
+pub const EAFNOSUPPORT: ::c_int = 47;
+pub const EADDRINUSE: ::c_int = 48;
+pub const EADDRNOTAVAIL: ::c_int = 49;
+pub const ENETDOWN: ::c_int = 50;
+pub const ENETUNREACH: ::c_int = 51;
+pub const ENETRESET: ::c_int = 52;
+pub const ECONNABORTED: ::c_int = 53;
+pub const ECONNRESET: ::c_int = 54;
+pub const ENOBUFS: ::c_int = 55;
+pub const EISCONN: ::c_int = 56;
+pub const ENOTCONN: ::c_int = 57;
+pub const ESHUTDOWN: ::c_int = 58;
+pub const ETOOMANYREFS: ::c_int = 59;
+pub const ETIMEDOUT: ::c_int = 60;
+pub const ECONNREFUSED: ::c_int = 61;
+pub const EHOSTDOWN: ::c_int = 64;
+pub const EHOSTUNREACH: ::c_int = 65;
+pub const EALREADY: ::c_int = 37;
+pub const EINPROGRESS: ::c_int = 36;
+pub const ESTALE: ::c_int = 70;
+pub const EDQUOT: ::c_int = 69;
+pub const ENOMEDIUM: ::c_int = 125;
+pub const EMEDIUMTYPE: ::c_int = 126;
+pub const ECANCELED: ::c_int = 127;
+pub const ENOKEY: ::c_int = 128;
+pub const EKEYEXPIRED: ::c_int = 129;
+pub const EKEYREVOKED: ::c_int = 130;
+pub const EKEYREJECTED: ::c_int = 131;
+pub const EOWNERDEAD: ::c_int = 132;
+pub const ENOTRECOVERABLE: ::c_int = 133;
+pub const EHWPOISON: ::c_int = 135;
+pub const ERFKILL: ::c_int = 134;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+
+pub const SO_PASSCRED: ::c_int = 2;
+pub const SO_REUSEADDR: ::c_int = 4;
+pub const SO_BINDTODEVICE: ::c_int = 0x000d;
+pub const SO_TIMESTAMP: ::c_int = 0x001d;
+pub const SO_MARK: ::c_int = 0x0022;
+pub const SO_RXQ_OVFL: ::c_int = 0x0024;
+pub const SO_PEEK_OFF: ::c_int = 0x0026;
+pub const SO_BUSY_POLL: ::c_int = 0x0030;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_DONTROUTE: ::c_int = 16;
+pub const SO_BROADCAST: ::c_int = 32;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDBUFFORCE: ::c_int = 0x100a;
+pub const SO_RCVBUFFORCE: ::c_int = 0x100b;
+pub const SO_DOMAIN: ::c_int = 0x1029;
+pub const SO_KEEPALIVE: ::c_int = 8;
+pub const SO_OOBINLINE: ::c_int = 0x100;
+pub const SO_LINGER: ::c_int = 128;
+pub const SO_REUSEPORT: ::c_int = 0x200;
+pub const SO_ACCEPTCONN: ::c_int = 0x8000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const SA_ONSTACK: ::c_int = 1;
+pub const SA_SIGINFO: ::c_int = 0x200;
+pub const SA_NOCLDWAIT: ::c_int = 0x100;
+
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGCHLD: ::c_int = 20;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGUSR1: ::c_int = 30;
+pub const SIGUSR2: ::c_int = 31;
+pub const SIGCONT: ::c_int = 19;
+pub const SIGSTOP: ::c_int = 17;
+pub const SIGTSTP: ::c_int = 18;
+pub const SIGURG: ::c_int = 16;
+pub const SIGIO: ::c_int = 23;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGPOLL: ::c_int = 23;
+pub const SIGPWR: ::c_int = 29;
+pub const SIG_SETMASK: ::c_int = 4;
+pub const SIG_BLOCK: ::c_int = 1;
+pub const SIG_UNBLOCK: ::c_int = 2;
+
+pub const POLLWRNORM: ::c_short = 4;
+pub const POLLWRBAND: ::c_short = 0x100;
+
+pub const O_ASYNC: ::c_int = 0x40;
+pub const O_NDELAY: ::c_int = 0x4004;
+
+pub const PTRACE_DETACH: ::c_uint = 11;
+
+pub const EFD_NONBLOCK: ::c_int = 0x4000;
+
+pub const F_GETLK: ::c_int = 7;
+pub const F_GETOWN: ::c_int = 5;
+pub const F_SETOWN: ::c_int = 6;
+pub const F_SETLK: ::c_int = 8;
+pub const F_SETLKW: ::c_int = 9;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const F_RDLCK: ::c_int = 1;
+pub const F_WRLCK: ::c_int = 2;
+pub const F_UNLCK: ::c_int = 3;
+
+pub const SFD_NONBLOCK: ::c_int = 0x4000;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+pub const TIOCEXCL: ::c_ulong = 0x2000740d;
+pub const TIOCNXCL: ::c_ulong = 0x2000740e;
+pub const TIOCCONS: ::c_ulong = 0x20007424;
+pub const TIOCMGET: ::c_ulong = 0x4004746a;
+pub const TIOCMBIC: ::c_ulong = 0x8004746b;
+pub const TIOCMBIS: ::c_ulong = 0x8004746c;
+pub const TIOCMSET: ::c_ulong = 0x8004746d;
+pub const TIOCSTI: ::c_ulong = 0x80017472;
+pub const TIOCCBRK: ::c_ulong = 0x2000747a;
+pub const TIOCSBRK: ::c_ulong = 0x2000747b;
+pub const TIOCSCTTY: ::c_ulong = 0x20007484;
+
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+pub const SFD_CLOEXEC: ::c_int = 0x400000;
+
+pub const NCCS: usize = 17;
+pub const O_TRUNC: ::c_int = 0x400;
+
+pub const O_CLOEXEC: ::c_int = 0x400000;
+
+pub const EBFONT: ::c_int = 109;
+pub const ENOSTR: ::c_int = 72;
+pub const ENODATA: ::c_int = 111;
+pub const ETIME: ::c_int = 73;
+pub const ENOSR: ::c_int = 74;
+pub const ENONET: ::c_int = 80;
+pub const ENOPKG: ::c_int = 113;
+pub const EREMOTE: ::c_int = 71;
+pub const ENOLINK: ::c_int = 82;
+pub const EADV: ::c_int = 83;
+pub const ESRMNT: ::c_int = 84;
+pub const ECOMM: ::c_int = 85;
+pub const EPROTO: ::c_int = 86;
+pub const EDOTDOT: ::c_int = 88;
+
+pub const SA_NODEFER: ::c_int = 0x20;
+pub const SA_RESETHAND: ::c_int = 0x4;
+pub const SA_RESTART: ::c_int = 0x2;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000008;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x400000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x400000;
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+
+align_const! {
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+}
+
+pub const O_DIRECTORY: ::c_int = 0o200000;
+pub const O_NOFOLLOW: ::c_int = 0o400000;
+pub const O_DIRECT: ::c_int = 0x100000;
+
+pub const MAP_LOCKED: ::c_int = 0x0100;
+pub const MAP_NORESERVE: ::c_int = 0x00040;
+
+pub const EDEADLOCK: ::c_int = 108;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+
+pub const SO_PEERCRED: ::c_int = 0x40;
+pub const SO_RCVLOWAT: ::c_int = 0x800;
+pub const SO_SNDLOWAT: ::c_int = 0x1000;
+pub const SO_RCVTIMEO: ::c_int = 0x2000;
+pub const SO_SNDTIMEO: ::c_int = 0x4000;
+
+pub const FIOCLEX: ::c_ulong = 0x20006601;
+pub const FIONCLEX: ::c_ulong = 0x20006602;
+pub const FIONBIO: ::c_ulong = 0x8004667e;
+
+pub const MCL_CURRENT: ::c_int = 0x2000;
+pub const MCL_FUTURE: ::c_int = 0x4000;
+
+pub const SIGSTKSZ: ::size_t = 16384;
+pub const MINSIGSTKSZ: ::size_t = 4096;
+pub const CBAUD: ::tcflag_t = 0x0000100f;
+pub const TAB1: ::tcflag_t = 0x800;
+pub const TAB2: ::tcflag_t = 0x1000;
+pub const TAB3: ::tcflag_t = 0x1800;
+pub const CR1: ::tcflag_t = 0x200;
+pub const CR2: ::tcflag_t = 0x400;
+pub const CR3: ::tcflag_t = 0x600;
+pub const FF1: ::tcflag_t = 0x8000;
+pub const BS1: ::tcflag_t = 0x2000;
+pub const VT1: ::tcflag_t = 0x4000;
+pub const VWERASE: usize = 0xe;
+pub const VREPRINT: usize = 0xc;
+pub const VSUSP: usize = 0xa;
+pub const VSTART: usize = 0x8;
+pub const VSTOP: usize = 0x9;
+pub const VDISCARD: usize = 0xd;
+pub const VTIME: usize = 0x5;
+pub const IXON: ::tcflag_t = 0x400;
+pub const IXOFF: ::tcflag_t = 0x1000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x30;
+pub const CS6: ::tcflag_t = 0x10;
+pub const CS7: ::tcflag_t = 0x20;
+pub const CS8: ::tcflag_t = 0x30;
+pub const CSTOPB: ::tcflag_t = 0x40;
+pub const CREAD: ::tcflag_t = 0x80;
+pub const PARENB: ::tcflag_t = 0x100;
+pub const PARODD: ::tcflag_t = 0x200;
+pub const HUPCL: ::tcflag_t = 0x400;
+pub const CLOCAL: ::tcflag_t = 0x800;
+pub const ECHOKE: ::tcflag_t = 0x800;
+pub const ECHOE: ::tcflag_t = 0x10;
+pub const ECHOK: ::tcflag_t = 0x20;
+pub const ECHONL: ::tcflag_t = 0x40;
+pub const ECHOPRT: ::tcflag_t = 0x400;
+pub const ECHOCTL: ::tcflag_t = 0x200;
+pub const ISIG: ::tcflag_t = 0x1;
+pub const ICANON: ::tcflag_t = 0x2;
+pub const PENDIN: ::tcflag_t = 0x4000;
+pub const NOFLSH: ::tcflag_t = 0x80;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0x00001000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0x1000;
+pub const B57600: ::speed_t = 0x1001;
+pub const B115200: ::speed_t = 0x1002;
+pub const B230400: ::speed_t = 0x1003;
+pub const B460800: ::speed_t = 0x1004;
+pub const B76800: ::speed_t = 0x1005;
+pub const B153600: ::speed_t = 0x1006;
+pub const B307200: ::speed_t = 0x1007;
+pub const B614400: ::speed_t = 0x1008;
+pub const B921600: ::speed_t = 0x1009;
+pub const B500000: ::speed_t = 0x100a;
+pub const B576000: ::speed_t = 0x100b;
+pub const B1000000: ::speed_t = 0x100c;
+pub const B1152000: ::speed_t = 0x100d;
+pub const B1500000: ::speed_t = 0x100e;
+pub const B2000000: ::speed_t = 0x100f;
+
+pub const VEOL: usize = 5;
+pub const VEOL2: usize = 6;
+pub const VMIN: usize = 4;
+pub const IEXTEN: ::tcflag_t = 0x8000;
+pub const TOSTOP: ::tcflag_t = 0x100;
+pub const FLUSHO: ::tcflag_t = 0x1000;
+pub const EXTPROC: ::tcflag_t = 0x10000;
+pub const TCGETS: ::c_ulong = 0x40245408;
+pub const TCSETS: ::c_ulong = 0x80245409;
+pub const TCSETSW: ::c_ulong = 0x8024540a;
+pub const TCSETSF: ::c_ulong = 0x8024540b;
+pub const TCGETA: ::c_ulong = 0x40125401;
+pub const TCSETA: ::c_ulong = 0x80125402;
+pub const TCSETAW: ::c_ulong = 0x80125403;
+pub const TCSETAF: ::c_ulong = 0x80125404;
+pub const TCSBRK: ::c_ulong = 0x20005405;
+pub const TCXONC: ::c_ulong = 0x20005406;
+pub const TCFLSH: ::c_ulong = 0x20005407;
+pub const TIOCINQ: ::c_ulong = 0x4004667f;
+pub const TIOCGPGRP: ::c_ulong = 0x40047483;
+pub const TIOCSPGRP: ::c_ulong = 0x80047482;
+pub const TIOCOUTQ: ::c_ulong = 0x40047473;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const FIONREAD: ::c_ulong = 0x4004667f;
+
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_wait4: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execv: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_chown: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_brk: ::c_long = 17;
+pub const SYS_perfctr: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_capget: ::c_long = 21;
+pub const SYS_capset: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_vmsplice: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_sigaltstack: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_stat: ::c_long = 38;
+pub const SYS_sendfile: ::c_long = 39;
+pub const SYS_lstat: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_umount2: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_memory_ordering: ::c_long = 52;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_reboot: ::c_long = 55;
+pub const SYS_symlink: ::c_long = 57;
+pub const SYS_readlink: ::c_long = 58;
+pub const SYS_execve: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_fstat: ::c_long = 62;
+pub const SYS_fstat64: ::c_long = 63;
+pub const SYS_getpagesize: ::c_long = 64;
+pub const SYS_msync: ::c_long = 65;
+pub const SYS_vfork: ::c_long = 66;
+pub const SYS_pread64: ::c_long = 67;
+pub const SYS_pwrite64: ::c_long = 68;
+pub const SYS_mmap: ::c_long = 71;
+pub const SYS_munmap: ::c_long = 73;
+pub const SYS_mprotect: ::c_long = 74;
+pub const SYS_madvise: ::c_long = 75;
+pub const SYS_vhangup: ::c_long = 76;
+pub const SYS_mincore: ::c_long = 78;
+pub const SYS_getgroups: ::c_long = 79;
+pub const SYS_setgroups: ::c_long = 80;
+pub const SYS_getpgrp: ::c_long = 81;
+pub const SYS_setitimer: ::c_long = 83;
+pub const SYS_swapon: ::c_long = 85;
+pub const SYS_getitimer: ::c_long = 86;
+pub const SYS_sethostname: ::c_long = 88;
+pub const SYS_dup2: ::c_long = 90;
+pub const SYS_fcntl: ::c_long = 92;
+pub const SYS_select: ::c_long = 93;
+pub const SYS_fsync: ::c_long = 95;
+pub const SYS_setpriority: ::c_long = 96;
+pub const SYS_socket: ::c_long = 97;
+pub const SYS_connect: ::c_long = 98;
+pub const SYS_accept: ::c_long = 99;
+pub const SYS_getpriority: ::c_long = 100;
+pub const SYS_rt_sigreturn: ::c_long = 101;
+pub const SYS_rt_sigaction: ::c_long = 102;
+pub const SYS_rt_sigprocmask: ::c_long = 103;
+pub const SYS_rt_sigpending: ::c_long = 104;
+pub const SYS_rt_sigtimedwait: ::c_long = 105;
+pub const SYS_rt_sigqueueinfo: ::c_long = 106;
+pub const SYS_rt_sigsuspend: ::c_long = 107;
+pub const SYS_setresuid: ::c_long = 108;
+pub const SYS_getresuid: ::c_long = 109;
+pub const SYS_setresgid: ::c_long = 110;
+pub const SYS_getresgid: ::c_long = 111;
+pub const SYS_recvmsg: ::c_long = 113;
+pub const SYS_sendmsg: ::c_long = 114;
+pub const SYS_gettimeofday: ::c_long = 116;
+pub const SYS_getrusage: ::c_long = 117;
+pub const SYS_getsockopt: ::c_long = 118;
+pub const SYS_getcwd: ::c_long = 119;
+pub const SYS_readv: ::c_long = 120;
+pub const SYS_writev: ::c_long = 121;
+pub const SYS_settimeofday: ::c_long = 122;
+pub const SYS_fchown: ::c_long = 123;
+pub const SYS_fchmod: ::c_long = 124;
+pub const SYS_recvfrom: ::c_long = 125;
+pub const SYS_setreuid: ::c_long = 126;
+pub const SYS_setregid: ::c_long = 127;
+pub const SYS_rename: ::c_long = 128;
+pub const SYS_truncate: ::c_long = 129;
+pub const SYS_ftruncate: ::c_long = 130;
+pub const SYS_flock: ::c_long = 131;
+pub const SYS_lstat64: ::c_long = 132;
+pub const SYS_sendto: ::c_long = 133;
+pub const SYS_shutdown: ::c_long = 134;
+pub const SYS_socketpair: ::c_long = 135;
+pub const SYS_mkdir: ::c_long = 136;
+pub const SYS_rmdir: ::c_long = 137;
+pub const SYS_utimes: ::c_long = 138;
+pub const SYS_stat64: ::c_long = 139;
+pub const SYS_sendfile64: ::c_long = 140;
+pub const SYS_getpeername: ::c_long = 141;
+pub const SYS_futex: ::c_long = 142;
+pub const SYS_gettid: ::c_long = 143;
+pub const SYS_getrlimit: ::c_long = 144;
+pub const SYS_setrlimit: ::c_long = 145;
+pub const SYS_pivot_root: ::c_long = 146;
+pub const SYS_prctl: ::c_long = 147;
+pub const SYS_pciconfig_read: ::c_long = 148;
+pub const SYS_pciconfig_write: ::c_long = 149;
+pub const SYS_getsockname: ::c_long = 150;
+pub const SYS_inotify_init: ::c_long = 151;
+pub const SYS_inotify_add_watch: ::c_long = 152;
+pub const SYS_poll: ::c_long = 153;
+pub const SYS_getdents64: ::c_long = 154;
+pub const SYS_inotify_rm_watch: ::c_long = 156;
+pub const SYS_statfs: ::c_long = 157;
+pub const SYS_fstatfs: ::c_long = 158;
+pub const SYS_umount: ::c_long = 159;
+pub const SYS_sched_set_affinity: ::c_long = 160;
+pub const SYS_sched_get_affinity: ::c_long = 161;
+pub const SYS_getdomainname: ::c_long = 162;
+pub const SYS_setdomainname: ::c_long = 163;
+pub const SYS_utrap_install: ::c_long = 164;
+pub const SYS_quotactl: ::c_long = 165;
+pub const SYS_set_tid_address: ::c_long = 166;
+pub const SYS_mount: ::c_long = 167;
+pub const SYS_ustat: ::c_long = 168;
+pub const SYS_setxattr: ::c_long = 169;
+pub const SYS_lsetxattr: ::c_long = 170;
+pub const SYS_fsetxattr: ::c_long = 171;
+pub const SYS_getxattr: ::c_long = 172;
+pub const SYS_lgetxattr: ::c_long = 173;
+pub const SYS_getdents: ::c_long = 174;
+pub const SYS_setsid: ::c_long = 175;
+pub const SYS_fchdir: ::c_long = 176;
+pub const SYS_fgetxattr: ::c_long = 177;
+pub const SYS_listxattr: ::c_long = 178;
+pub const SYS_llistxattr: ::c_long = 179;
+pub const SYS_flistxattr: ::c_long = 180;
+pub const SYS_removexattr: ::c_long = 181;
+pub const SYS_lremovexattr: ::c_long = 182;
+pub const SYS_sigpending: ::c_long = 183;
+pub const SYS_query_module: ::c_long = 184;
+pub const SYS_setpgid: ::c_long = 185;
+pub const SYS_fremovexattr: ::c_long = 186;
+pub const SYS_tkill: ::c_long = 187;
+pub const SYS_exit_group: ::c_long = 188;
+pub const SYS_uname: ::c_long = 189;
+pub const SYS_init_module: ::c_long = 190;
+pub const SYS_personality: ::c_long = 191;
+pub const SYS_remap_file_pages: ::c_long = 192;
+pub const SYS_epoll_create: ::c_long = 193;
+pub const SYS_epoll_ctl: ::c_long = 194;
+pub const SYS_epoll_wait: ::c_long = 195;
+pub const SYS_ioprio_set: ::c_long = 196;
+pub const SYS_getppid: ::c_long = 197;
+pub const SYS_sigaction: ::c_long = 198;
+pub const SYS_sgetmask: ::c_long = 199;
+pub const SYS_ssetmask: ::c_long = 200;
+pub const SYS_sigsuspend: ::c_long = 201;
+pub const SYS_oldlstat: ::c_long = 202;
+pub const SYS_uselib: ::c_long = 203;
+pub const SYS_readdir: ::c_long = 204;
+pub const SYS_readahead: ::c_long = 205;
+pub const SYS_socketcall: ::c_long = 206;
+pub const SYS_syslog: ::c_long = 207;
+pub const SYS_lookup_dcookie: ::c_long = 208;
+pub const SYS_fadvise64: ::c_long = 209;
+pub const SYS_fadvise64_64: ::c_long = 210;
+pub const SYS_tgkill: ::c_long = 211;
+pub const SYS_waitpid: ::c_long = 212;
+pub const SYS_swapoff: ::c_long = 213;
+pub const SYS_sysinfo: ::c_long = 214;
+pub const SYS_ipc: ::c_long = 215;
+pub const SYS_sigreturn: ::c_long = 216;
+pub const SYS_clone: ::c_long = 217;
+pub const SYS_ioprio_get: ::c_long = 218;
+pub const SYS_adjtimex: ::c_long = 219;
+pub const SYS_sigprocmask: ::c_long = 220;
+pub const SYS_create_module: ::c_long = 221;
+pub const SYS_delete_module: ::c_long = 222;
+pub const SYS_get_kernel_syms: ::c_long = 223;
+pub const SYS_getpgid: ::c_long = 224;
+pub const SYS_bdflush: ::c_long = 225;
+pub const SYS_sysfs: ::c_long = 226;
+pub const SYS_afs_syscall: ::c_long = 227;
+pub const SYS_setfsuid: ::c_long = 228;
+pub const SYS_setfsgid: ::c_long = 229;
+pub const SYS__newselect: ::c_long = 230;
+pub const SYS_splice: ::c_long = 232;
+pub const SYS_stime: ::c_long = 233;
+pub const SYS_statfs64: ::c_long = 234;
+pub const SYS_fstatfs64: ::c_long = 235;
+pub const SYS__llseek: ::c_long = 236;
+pub const SYS_mlock: ::c_long = 237;
+pub const SYS_munlock: ::c_long = 238;
+pub const SYS_mlockall: ::c_long = 239;
+pub const SYS_munlockall: ::c_long = 240;
+pub const SYS_sched_setparam: ::c_long = 241;
+pub const SYS_sched_getparam: ::c_long = 242;
+pub const SYS_sched_setscheduler: ::c_long = 243;
+pub const SYS_sched_getscheduler: ::c_long = 244;
+pub const SYS_sched_yield: ::c_long = 245;
+pub const SYS_sched_get_priority_max: ::c_long = 246;
+pub const SYS_sched_get_priority_min: ::c_long = 247;
+pub const SYS_sched_rr_get_interval: ::c_long = 248;
+pub const SYS_nanosleep: ::c_long = 249;
+pub const SYS_mremap: ::c_long = 250;
+pub const SYS__sysctl: ::c_long = 251;
+pub const SYS_getsid: ::c_long = 252;
+pub const SYS_fdatasync: ::c_long = 253;
+pub const SYS_nfsservctl: ::c_long = 254;
+pub const SYS_sync_file_range: ::c_long = 255;
+pub const SYS_clock_settime: ::c_long = 256;
+pub const SYS_clock_gettime: ::c_long = 257;
+pub const SYS_clock_getres: ::c_long = 258;
+pub const SYS_clock_nanosleep: ::c_long = 259;
+pub const SYS_sched_getaffinity: ::c_long = 260;
+pub const SYS_sched_setaffinity: ::c_long = 261;
+pub const SYS_timer_settime: ::c_long = 262;
+pub const SYS_timer_gettime: ::c_long = 263;
+pub const SYS_timer_getoverrun: ::c_long = 264;
+pub const SYS_timer_delete: ::c_long = 265;
+pub const SYS_timer_create: ::c_long = 266;
+pub const SYS_io_setup: ::c_long = 268;
+pub const SYS_io_destroy: ::c_long = 269;
+pub const SYS_io_submit: ::c_long = 270;
+pub const SYS_io_cancel: ::c_long = 271;
+pub const SYS_io_getevents: ::c_long = 272;
+pub const SYS_mq_open: ::c_long = 273;
+pub const SYS_mq_unlink: ::c_long = 274;
+pub const SYS_mq_timedsend: ::c_long = 275;
+pub const SYS_mq_timedreceive: ::c_long = 276;
+pub const SYS_mq_notify: ::c_long = 277;
+pub const SYS_mq_getsetattr: ::c_long = 278;
+pub const SYS_waitid: ::c_long = 279;
+pub const SYS_tee: ::c_long = 280;
+pub const SYS_add_key: ::c_long = 281;
+pub const SYS_request_key: ::c_long = 282;
+pub const SYS_keyctl: ::c_long = 283;
+pub const SYS_openat: ::c_long = 284;
+pub const SYS_mkdirat: ::c_long = 285;
+pub const SYS_mknodat: ::c_long = 286;
+pub const SYS_fchownat: ::c_long = 287;
+pub const SYS_futimesat: ::c_long = 288;
+pub const SYS_fstatat64: ::c_long = 289;
+pub const SYS_unlinkat: ::c_long = 290;
+pub const SYS_renameat: ::c_long = 291;
+pub const SYS_linkat: ::c_long = 292;
+pub const SYS_symlinkat: ::c_long = 293;
+pub const SYS_readlinkat: ::c_long = 294;
+pub const SYS_fchmodat: ::c_long = 295;
+pub const SYS_faccessat: ::c_long = 296;
+pub const SYS_pselect6: ::c_long = 297;
+pub const SYS_ppoll: ::c_long = 298;
+pub const SYS_unshare: ::c_long = 299;
+pub const SYS_set_robust_list: ::c_long = 300;
+pub const SYS_get_robust_list: ::c_long = 301;
+pub const SYS_migrate_pages: ::c_long = 302;
+pub const SYS_mbind: ::c_long = 303;
+pub const SYS_get_mempolicy: ::c_long = 304;
+pub const SYS_set_mempolicy: ::c_long = 305;
+pub const SYS_kexec_load: ::c_long = 306;
+pub const SYS_move_pages: ::c_long = 307;
+pub const SYS_getcpu: ::c_long = 308;
+pub const SYS_epoll_pwait: ::c_long = 309;
+pub const SYS_utimensat: ::c_long = 310;
+pub const SYS_signalfd: ::c_long = 311;
+pub const SYS_timerfd_create: ::c_long = 312;
+pub const SYS_eventfd: ::c_long = 313;
+pub const SYS_fallocate: ::c_long = 314;
+pub const SYS_timerfd_settime: ::c_long = 315;
+pub const SYS_timerfd_gettime: ::c_long = 316;
+pub const SYS_signalfd4: ::c_long = 317;
+pub const SYS_eventfd2: ::c_long = 318;
+pub const SYS_epoll_create1: ::c_long = 319;
+pub const SYS_dup3: ::c_long = 320;
+pub const SYS_pipe2: ::c_long = 321;
+pub const SYS_inotify_init1: ::c_long = 322;
+pub const SYS_accept4: ::c_long = 323;
+pub const SYS_preadv: ::c_long = 324;
+pub const SYS_pwritev: ::c_long = 325;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 326;
+pub const SYS_perf_event_open: ::c_long = 327;
+pub const SYS_recvmmsg: ::c_long = 328;
+pub const SYS_fanotify_init: ::c_long = 329;
+pub const SYS_fanotify_mark: ::c_long = 330;
+pub const SYS_prlimit64: ::c_long = 331;
+pub const SYS_name_to_handle_at: ::c_long = 332;
+pub const SYS_open_by_handle_at: ::c_long = 333;
+pub const SYS_clock_adjtime: ::c_long = 334;
+pub const SYS_syncfs: ::c_long = 335;
+pub const SYS_sendmmsg: ::c_long = 336;
+pub const SYS_setns: ::c_long = 337;
+pub const SYS_process_vm_readv: ::c_long = 338;
+pub const SYS_process_vm_writev: ::c_long = 339;
+pub const SYS_kern_features: ::c_long = 340;
+pub const SYS_kcmp: ::c_long = 341;
+pub const SYS_finit_module: ::c_long = 342;
+pub const SYS_sched_setattr: ::c_long = 343;
+pub const SYS_sched_getattr: ::c_long = 344;
+pub const SYS_renameat2: ::c_long = 345;
+pub const SYS_seccomp: ::c_long = 346;
+pub const SYS_getrandom: ::c_long = 347;
+pub const SYS_memfd_create: ::c_long = 348;
+pub const SYS_bpf: ::c_long = 349;
+pub const SYS_execveat: ::c_long = 350;
+pub const SYS_membarrier: ::c_long = 351;
+pub const SYS_userfaultfd: ::c_long = 352;
+pub const SYS_bind: ::c_long = 353;
+pub const SYS_listen: ::c_long = 354;
+pub const SYS_setsockopt: ::c_long = 355;
+pub const SYS_mlock2: ::c_long = 356;
+pub const SYS_copy_file_range: ::c_long = 357;
+pub const SYS_preadv2: ::c_long = 358;
+pub const SYS_pwritev2: ::c_long = 359;
+pub const SYS_statx: ::c_long = 360;
+pub const SYS_pidfd_open: ::c_long = 434;
+// Reserved in the kernel, but not actually implemented yet
+pub const SYS_clone3: ::c_long = 435;
+
+extern "C" {
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_int,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/align.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/align.rs
new file mode 100644
index 00000000..7ca870fd
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 4]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/mod.rs
new file mode 100644
index 00000000..faad040e
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/mod.rs
@@ -0,0 +1,956 @@
+//! x86_64-specific definitions for 64-bit linux-like values
+
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type nlink_t = u64;
+pub type blksize_t = i64;
+pub type greg_t = i64;
+pub type suseconds_t = i64;
+pub type __u64 = ::c_ulonglong;
+
+s! {
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        #[cfg(target_arch = "sparc64")]
+        __reserved0: ::c_int,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statfs {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        f_spare: [::__fsword_t; 5],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct flock64 {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off64_t,
+        pub l_len: ::off64_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        #[doc(hidden)]
+        #[deprecated(
+            since="0.2.54",
+            note="Please leave a comment on \
+                  https://github.com/rust-lang/libc/pull/1316 if you're using \
+                  this field"
+        )]
+        pub _pad: [::c_int; 29],
+        _align: [u64; 0],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: i64,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: i64,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: i64,
+        __unused: [i64; 3],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: i64,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: i64,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: i64,
+        __reserved: [i64; 3],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::__fsword_t,
+        pub f_bsize: ::__fsword_t,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::__fsword_t,
+        pub f_frsize: ::__fsword_t,
+        pub f_flags: ::__fsword_t,
+        pub f_spare: [::__fsword_t; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct pthread_attr_t {
+        #[cfg(target_pointer_width = "32")]
+        __size: [u32; 8],
+        #[cfg(target_pointer_width = "64")]
+        __size: [u64; 7]
+    }
+
+    pub struct _libc_fpxreg {
+        pub significand: [u16; 4],
+        pub exponent: u16,
+        __private: [u16; 3],
+    }
+
+    pub struct _libc_xmmreg {
+        pub element: [u32; 4],
+    }
+
+    pub struct _libc_fpstate {
+        pub cwd: u16,
+        pub swd: u16,
+        pub ftw: u16,
+        pub fop: u16,
+        pub rip: u64,
+        pub rdp: u64,
+        pub mxcsr: u32,
+        pub mxcr_mask: u32,
+        pub _st: [_libc_fpxreg; 8],
+        pub _xmm: [_libc_xmmreg; 16],
+        __private: [u64; 12],
+    }
+
+    pub struct user_regs_struct {
+        pub r15: ::c_ulonglong,
+        pub r14: ::c_ulonglong,
+        pub r13: ::c_ulonglong,
+        pub r12: ::c_ulonglong,
+        pub rbp: ::c_ulonglong,
+        pub rbx: ::c_ulonglong,
+        pub r11: ::c_ulonglong,
+        pub r10: ::c_ulonglong,
+        pub r9: ::c_ulonglong,
+        pub r8: ::c_ulonglong,
+        pub rax: ::c_ulonglong,
+        pub rcx: ::c_ulonglong,
+        pub rdx: ::c_ulonglong,
+        pub rsi: ::c_ulonglong,
+        pub rdi: ::c_ulonglong,
+        pub orig_rax: ::c_ulonglong,
+        pub rip: ::c_ulonglong,
+        pub cs: ::c_ulonglong,
+        pub eflags: ::c_ulonglong,
+        pub rsp: ::c_ulonglong,
+        pub ss: ::c_ulonglong,
+        pub fs_base: ::c_ulonglong,
+        pub gs_base: ::c_ulonglong,
+        pub ds: ::c_ulonglong,
+        pub es: ::c_ulonglong,
+        pub fs: ::c_ulonglong,
+        pub gs: ::c_ulonglong,
+    }
+
+    pub struct user {
+        pub regs: user_regs_struct,
+        pub u_fpvalid: ::c_int,
+        pub i387: user_fpregs_struct,
+        pub u_tsize: ::c_ulonglong,
+        pub u_dsize: ::c_ulonglong,
+        pub u_ssize: ::c_ulonglong,
+        pub start_code: ::c_ulonglong,
+        pub start_stack: ::c_ulonglong,
+        pub signal: ::c_longlong,
+        __reserved: ::c_int,
+        #[cfg(target_pointer_width = "32")]
+        __pad1: u32,
+        pub u_ar0: *mut user_regs_struct,
+        #[cfg(target_pointer_width = "32")]
+        __pad2: u32,
+        pub u_fpstate: *mut user_fpregs_struct,
+        pub magic: ::c_ulonglong,
+        pub u_comm: [::c_char; 32],
+        pub u_debugreg: [::c_ulonglong; 8],
+    }
+
+    pub struct mcontext_t {
+        pub gregs: [greg_t; 23],
+        pub fpregs: *mut _libc_fpstate,
+        __private: [u64; 8],
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_ushort,
+        __pad1: ::c_ushort,
+        pub __seq: ::c_ushort,
+        __pad2: ::c_ushort,
+        __unused1: u64,
+        __unused2: u64
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: u64,
+        __unused5: u64
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct ip_mreqn {
+        pub imr_multiaddr: ::in_addr,
+        pub imr_address: ::in_addr,
+        pub imr_ifindex: ::c_int,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct user_fpregs_struct {
+        pub cwd: ::c_ushort,
+        pub swd: ::c_ushort,
+        pub ftw: ::c_ushort,
+        pub fop: ::c_ushort,
+        pub rip: ::c_ulonglong,
+        pub rdp: ::c_ulonglong,
+        pub mxcsr: ::c_uint,
+        pub mxcr_mask: ::c_uint,
+        pub st_space: [::c_uint; 32],
+        pub xmm_space: [::c_uint; 64],
+        padding: [::c_uint; 24],
+    }
+
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_mcontext: mcontext_t,
+        pub uc_sigmask: ::sigset_t,
+        __private: [u8; 512],
+        // FIXME: the shadow stack field requires glibc >= 2.28.
+        // Re-add once we drop compatibility with glibc versions older than
+        // 2.28.
+        //
+        // __ssp: [::c_ulonglong; 4],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for user_fpregs_struct {
+            fn eq(&self, other: &user_fpregs_struct) -> bool {
+                self.cwd == other.cwd
+                    && self.swd == other.swd
+                    && self.ftw == other.ftw
+                    && self.fop == other.fop
+                    && self.rip == other.rip
+                    && self.rdp == other.rdp
+                    && self.mxcsr == other.mxcsr
+                    && self.mxcr_mask == other.mxcr_mask
+                    && self.st_space == other.st_space
+                    && self
+                    .xmm_space
+                    .iter()
+                    .zip(other.xmm_space.iter())
+                    .all(|(a,b)| a == b)
+                // Ignore padding field
+            }
+        }
+
+        impl Eq for user_fpregs_struct {}
+
+        impl ::fmt::Debug for user_fpregs_struct {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("user_fpregs_struct")
+                    .field("cwd", &self.cwd)
+                    .field("ftw", &self.ftw)
+                    .field("fop", &self.fop)
+                    .field("rip", &self.rip)
+                    .field("rdp", &self.rdp)
+                    .field("mxcsr", &self.mxcsr)
+                    .field("mxcr_mask", &self.mxcr_mask)
+                    .field("st_space", &self.st_space)
+                // FIXME: .field("xmm_space", &self.xmm_space)
+                // Ignore padding field
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for user_fpregs_struct {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.cwd.hash(state);
+                self.ftw.hash(state);
+                self.fop.hash(state);
+                self.rip.hash(state);
+                self.rdp.hash(state);
+                self.mxcsr.hash(state);
+                self.mxcr_mask.hash(state);
+                self.st_space.hash(state);
+                self.xmm_space.hash(state);
+                // Ignore padding field
+            }
+        }
+
+        impl PartialEq for ucontext_t {
+            fn eq(&self, other: &ucontext_t) -> bool {
+                self.uc_flags == other.uc_flags
+                    && self.uc_link == other.uc_link
+                    && self.uc_stack == other.uc_stack
+                    && self.uc_mcontext == other.uc_mcontext
+                    && self.uc_sigmask == other.uc_sigmask
+                // Ignore __private field
+            }
+        }
+
+        impl Eq for ucontext_t {}
+
+        impl ::fmt::Debug for ucontext_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("ucontext_t")
+                    .field("uc_flags", &self.uc_flags)
+                    .field("uc_link", &self.uc_link)
+                    .field("uc_stack", &self.uc_stack)
+                    .field("uc_mcontext", &self.uc_mcontext)
+                    .field("uc_sigmask", &self.uc_sigmask)
+                // Ignore __private field
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for ucontext_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uc_flags.hash(state);
+                self.uc_link.hash(state);
+                self.uc_stack.hash(state);
+                self.uc_mcontext.hash(state);
+                self.uc_sigmask.hash(state);
+                // Ignore __private field
+            }
+        }
+    }
+}
+
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const VEOF: usize = 4;
+pub const RTLD_DEEPBIND: ::c_int = 0x8;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5419;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x541A;
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+
+pub const RLIMIT_RSS: ::__rlimit_resource_t = 5;
+pub const RLIMIT_AS: ::__rlimit_resource_t = 9;
+pub const RLIMIT_MEMLOCK: ::__rlimit_resource_t = 8;
+pub const RLIMIT_NOFILE: ::__rlimit_resource_t = 7;
+pub const RLIMIT_NPROC: ::__rlimit_resource_t = 6;
+
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_FSYNC: ::c_int = 0x101000;
+pub const O_NOATIME: ::c_int = 0o1000000;
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EBADMSG: ::c_int = 74;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const EHWPOISON: ::c_int = 133;
+pub const ERFKILL: ::c_int = 132;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PEERSEC: ::c_int = 31;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_BUSY_POLL: ::c_int = 46;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = SO_DETACH_FILTER;
+pub const SO_ATTACH_REUSEPORT_CBPF: ::c_int = 51;
+pub const SO_ATTACH_REUSEPORT_EBPF: ::c_int = 52;
+pub const SO_CNX_ADVICE: ::c_int = 53;
+pub const SCM_TIMESTAMPING_OPT_STATS: ::c_int = 54;
+pub const SO_MEMINFO: ::c_int = 55;
+pub const SO_INCOMING_NAPI_ID: ::c_int = 56;
+pub const SO_COOKIE: ::c_int = 57;
+pub const SCM_TIMESTAMPING_PKTINFO: ::c_int = 58;
+pub const SO_PEERGROUPS: ::c_int = 59;
+pub const SO_ZEROCOPY: ::c_int = 60;
+pub const SO_TXTIME: ::c_int = 61;
+pub const SCM_TXTIME: ::c_int = SO_TXTIME;
+pub const SO_BINDTOIFINDEX: ::c_int = 62;
+pub const SO_TIMESTAMP_NEW: ::c_int = 63;
+pub const SO_TIMESTAMPNS_NEW: ::c_int = 64;
+pub const SO_TIMESTAMPING_NEW: ::c_int = 65;
+pub const SO_RCVTIMEO_NEW: ::c_int = 66;
+pub const SO_SNDTIMEO_NEW: ::c_int = 67;
+pub const SO_DETACH_REUSEPORT_BPF: ::c_int = 68;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = 31;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_NDELAY: ::c_int = 0x800;
+
+pub const PTRACE_DETACH: ::c_uint = 17;
+
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+
+pub const SFD_NONBLOCK: ::c_int = 0x0800;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const TIOCLINUX: ::c_ulong = 0x541C;
+pub const TIOCGSERIAL: ::c_ulong = 0x541E;
+pub const TIOCEXCL: ::c_ulong = 0x540C;
+pub const TIOCNXCL: ::c_ulong = 0x540D;
+pub const TIOCSCTTY: ::c_ulong = 0x540E;
+pub const TIOCSTI: ::c_ulong = 0x5412;
+pub const TIOCMGET: ::c_ulong = 0x5415;
+pub const TIOCMBIS: ::c_ulong = 0x5416;
+pub const TIOCMBIC: ::c_ulong = 0x5417;
+pub const TIOCMSET: ::c_ulong = 0x5418;
+pub const TIOCCONS: ::c_ulong = 0x541D;
+
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 512;
+
+pub const O_CLOEXEC: ::c_int = 0x80000;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+
+pub const O_DIRECT: ::c_int = 0x4000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_32BIT: ::c_int = 0x0040;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = 0x0020;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const EDEADLOCK: ::c_int = 35;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+
+pub const FIOCLEX: ::c_ulong = 0x5451;
+pub const FIONCLEX: ::c_ulong = 0x5450;
+pub const FIONBIO: ::c_ulong = 0x5421;
+
+pub const PTRACE_GETFPREGS: ::c_uint = 14;
+pub const PTRACE_SETFPREGS: ::c_uint = 15;
+pub const PTRACE_GETFPXREGS: ::c_uint = 18;
+pub const PTRACE_SETFPXREGS: ::c_uint = 19;
+pub const PTRACE_GETREGS: ::c_uint = 12;
+pub const PTRACE_SETREGS: ::c_uint = 13;
+pub const PTRACE_PEEKSIGINFO_SHARED: ::c_uint = 1;
+pub const PTRACE_SYSEMU: ::c_uint = 31;
+pub const PTRACE_SYSEMU_SINGLESTEP: ::c_uint = 32;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+pub const TCGETS: ::c_ulong = 0x5401;
+pub const TCSETS: ::c_ulong = 0x5402;
+pub const TCSETSW: ::c_ulong = 0x5403;
+pub const TCSETSF: ::c_ulong = 0x5404;
+pub const TCGETA: ::c_ulong = 0x5405;
+pub const TCSETA: ::c_ulong = 0x5406;
+pub const TCSETAW: ::c_ulong = 0x5407;
+pub const TCSETAF: ::c_ulong = 0x5408;
+pub const TCSBRK: ::c_ulong = 0x5409;
+pub const TCXONC: ::c_ulong = 0x540A;
+pub const TCFLSH: ::c_ulong = 0x540B;
+pub const TIOCINQ: ::c_ulong = 0x541B;
+pub const TIOCGPGRP: ::c_ulong = 0x540F;
+pub const TIOCSPGRP: ::c_ulong = 0x5410;
+pub const TIOCOUTQ: ::c_ulong = 0x5411;
+pub const TIOCGWINSZ: ::c_ulong = 0x5413;
+pub const TIOCSWINSZ: ::c_ulong = 0x5414;
+pub const FIONREAD: ::c_ulong = 0x541B;
+pub const TIOCSBRK: ::c_ulong = 0x5427;
+pub const TIOCCBRK: ::c_ulong = 0x5428;
+
+// offsets in user_regs_structs, from sys/reg.h
+pub const R15: ::c_int = 0;
+pub const R14: ::c_int = 1;
+pub const R13: ::c_int = 2;
+pub const R12: ::c_int = 3;
+pub const RBP: ::c_int = 4;
+pub const RBX: ::c_int = 5;
+pub const R11: ::c_int = 6;
+pub const R10: ::c_int = 7;
+pub const R9: ::c_int = 8;
+pub const R8: ::c_int = 9;
+pub const RAX: ::c_int = 10;
+pub const RCX: ::c_int = 11;
+pub const RDX: ::c_int = 12;
+pub const RSI: ::c_int = 13;
+pub const RDI: ::c_int = 14;
+pub const ORIG_RAX: ::c_int = 15;
+pub const RIP: ::c_int = 16;
+pub const CS: ::c_int = 17;
+pub const EFLAGS: ::c_int = 18;
+pub const RSP: ::c_int = 19;
+pub const SS: ::c_int = 20;
+pub const FS_BASE: ::c_int = 21;
+pub const GS_BASE: ::c_int = 22;
+pub const DS: ::c_int = 23;
+pub const ES: ::c_int = 24;
+pub const FS: ::c_int = 25;
+pub const GS: ::c_int = 26;
+
+// offsets in mcontext_t.gregs from sys/ucontext.h
+pub const REG_R8: ::c_int = 0;
+pub const REG_R9: ::c_int = 1;
+pub const REG_R10: ::c_int = 2;
+pub const REG_R11: ::c_int = 3;
+pub const REG_R12: ::c_int = 4;
+pub const REG_R13: ::c_int = 5;
+pub const REG_R14: ::c_int = 6;
+pub const REG_R15: ::c_int = 7;
+pub const REG_RDI: ::c_int = 8;
+pub const REG_RSI: ::c_int = 9;
+pub const REG_RBP: ::c_int = 10;
+pub const REG_RBX: ::c_int = 11;
+pub const REG_RDX: ::c_int = 12;
+pub const REG_RAX: ::c_int = 13;
+pub const REG_RCX: ::c_int = 14;
+pub const REG_RSP: ::c_int = 15;
+pub const REG_RIP: ::c_int = 16;
+pub const REG_EFL: ::c_int = 17;
+pub const REG_CSGSFS: ::c_int = 18;
+pub const REG_ERR: ::c_int = 19;
+pub const REG_TRAPNO: ::c_int = 20;
+pub const REG_OLDMASK: ::c_int = 21;
+pub const REG_CR2: ::c_int = 22;
+
+extern "C" {
+    pub fn getcontext(ucp: *mut ucontext_t) -> ::c_int;
+    pub fn setcontext(ucp: *const ucontext_t) -> ::c_int;
+    pub fn makecontext(
+        ucp: *mut ucontext_t,
+        func: extern "C" fn(),
+        argc: ::c_int,
+        ...
+    );
+    pub fn swapcontext(
+        uocp: *mut ucontext_t,
+        ucp: *const ucontext_t,
+    ) -> ::c_int;
+    pub fn iopl(level: ::c_int) -> ::c_int;
+    pub fn ioperm(
+        from: ::c_ulong,
+        num: ::c_ulong,
+        turn_on: ::c_int,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "32")] {
+        mod x32;
+        pub use self::x32::*;
+    } else {
+        mod not_x32;
+        pub use self::not_x32::*;
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/not_x32.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/not_x32.rs
new file mode 100644
index 00000000..ab9b76ae
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/not_x32.rs
@@ -0,0 +1,424 @@
+use pthread_mutex_t;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+s! {
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+}
+
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+align_const! {
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "little")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    #[cfg(target_endian = "big")]
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+}
+
+// Syscall table
+
+pub const SYS_read: ::c_long = 0;
+pub const SYS_write: ::c_long = 1;
+pub const SYS_open: ::c_long = 2;
+pub const SYS_close: ::c_long = 3;
+pub const SYS_stat: ::c_long = 4;
+pub const SYS_fstat: ::c_long = 5;
+pub const SYS_lstat: ::c_long = 6;
+pub const SYS_poll: ::c_long = 7;
+pub const SYS_lseek: ::c_long = 8;
+pub const SYS_mmap: ::c_long = 9;
+pub const SYS_mprotect: ::c_long = 10;
+pub const SYS_munmap: ::c_long = 11;
+pub const SYS_brk: ::c_long = 12;
+pub const SYS_rt_sigaction: ::c_long = 13;
+pub const SYS_rt_sigprocmask: ::c_long = 14;
+pub const SYS_rt_sigreturn: ::c_long = 15;
+pub const SYS_ioctl: ::c_long = 16;
+pub const SYS_pread64: ::c_long = 17;
+pub const SYS_pwrite64: ::c_long = 18;
+pub const SYS_readv: ::c_long = 19;
+pub const SYS_writev: ::c_long = 20;
+pub const SYS_access: ::c_long = 21;
+pub const SYS_pipe: ::c_long = 22;
+pub const SYS_select: ::c_long = 23;
+pub const SYS_sched_yield: ::c_long = 24;
+pub const SYS_mremap: ::c_long = 25;
+pub const SYS_msync: ::c_long = 26;
+pub const SYS_mincore: ::c_long = 27;
+pub const SYS_madvise: ::c_long = 28;
+pub const SYS_shmget: ::c_long = 29;
+pub const SYS_shmat: ::c_long = 30;
+pub const SYS_shmctl: ::c_long = 31;
+pub const SYS_dup: ::c_long = 32;
+pub const SYS_dup2: ::c_long = 33;
+pub const SYS_pause: ::c_long = 34;
+pub const SYS_nanosleep: ::c_long = 35;
+pub const SYS_getitimer: ::c_long = 36;
+pub const SYS_alarm: ::c_long = 37;
+pub const SYS_setitimer: ::c_long = 38;
+pub const SYS_getpid: ::c_long = 39;
+pub const SYS_sendfile: ::c_long = 40;
+pub const SYS_socket: ::c_long = 41;
+pub const SYS_connect: ::c_long = 42;
+pub const SYS_accept: ::c_long = 43;
+pub const SYS_sendto: ::c_long = 44;
+pub const SYS_recvfrom: ::c_long = 45;
+pub const SYS_sendmsg: ::c_long = 46;
+pub const SYS_recvmsg: ::c_long = 47;
+pub const SYS_shutdown: ::c_long = 48;
+pub const SYS_bind: ::c_long = 49;
+pub const SYS_listen: ::c_long = 50;
+pub const SYS_getsockname: ::c_long = 51;
+pub const SYS_getpeername: ::c_long = 52;
+pub const SYS_socketpair: ::c_long = 53;
+pub const SYS_setsockopt: ::c_long = 54;
+pub const SYS_getsockopt: ::c_long = 55;
+pub const SYS_clone: ::c_long = 56;
+pub const SYS_fork: ::c_long = 57;
+pub const SYS_vfork: ::c_long = 58;
+pub const SYS_execve: ::c_long = 59;
+pub const SYS_exit: ::c_long = 60;
+pub const SYS_wait4: ::c_long = 61;
+pub const SYS_kill: ::c_long = 62;
+pub const SYS_uname: ::c_long = 63;
+pub const SYS_semget: ::c_long = 64;
+pub const SYS_semop: ::c_long = 65;
+pub const SYS_semctl: ::c_long = 66;
+pub const SYS_shmdt: ::c_long = 67;
+pub const SYS_msgget: ::c_long = 68;
+pub const SYS_msgsnd: ::c_long = 69;
+pub const SYS_msgrcv: ::c_long = 70;
+pub const SYS_msgctl: ::c_long = 71;
+pub const SYS_fcntl: ::c_long = 72;
+pub const SYS_flock: ::c_long = 73;
+pub const SYS_fsync: ::c_long = 74;
+pub const SYS_fdatasync: ::c_long = 75;
+pub const SYS_truncate: ::c_long = 76;
+pub const SYS_ftruncate: ::c_long = 77;
+pub const SYS_getdents: ::c_long = 78;
+pub const SYS_getcwd: ::c_long = 79;
+pub const SYS_chdir: ::c_long = 80;
+pub const SYS_fchdir: ::c_long = 81;
+pub const SYS_rename: ::c_long = 82;
+pub const SYS_mkdir: ::c_long = 83;
+pub const SYS_rmdir: ::c_long = 84;
+pub const SYS_creat: ::c_long = 85;
+pub const SYS_link: ::c_long = 86;
+pub const SYS_unlink: ::c_long = 87;
+pub const SYS_symlink: ::c_long = 88;
+pub const SYS_readlink: ::c_long = 89;
+pub const SYS_chmod: ::c_long = 90;
+pub const SYS_fchmod: ::c_long = 91;
+pub const SYS_chown: ::c_long = 92;
+pub const SYS_fchown: ::c_long = 93;
+pub const SYS_lchown: ::c_long = 94;
+pub const SYS_umask: ::c_long = 95;
+pub const SYS_gettimeofday: ::c_long = 96;
+pub const SYS_getrlimit: ::c_long = 97;
+pub const SYS_getrusage: ::c_long = 98;
+pub const SYS_sysinfo: ::c_long = 99;
+pub const SYS_times: ::c_long = 100;
+pub const SYS_ptrace: ::c_long = 101;
+pub const SYS_getuid: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_getgid: ::c_long = 104;
+pub const SYS_setuid: ::c_long = 105;
+pub const SYS_setgid: ::c_long = 106;
+pub const SYS_geteuid: ::c_long = 107;
+pub const SYS_getegid: ::c_long = 108;
+pub const SYS_setpgid: ::c_long = 109;
+pub const SYS_getppid: ::c_long = 110;
+pub const SYS_getpgrp: ::c_long = 111;
+pub const SYS_setsid: ::c_long = 112;
+pub const SYS_setreuid: ::c_long = 113;
+pub const SYS_setregid: ::c_long = 114;
+pub const SYS_getgroups: ::c_long = 115;
+pub const SYS_setgroups: ::c_long = 116;
+pub const SYS_setresuid: ::c_long = 117;
+pub const SYS_getresuid: ::c_long = 118;
+pub const SYS_setresgid: ::c_long = 119;
+pub const SYS_getresgid: ::c_long = 120;
+pub const SYS_getpgid: ::c_long = 121;
+pub const SYS_setfsuid: ::c_long = 122;
+pub const SYS_setfsgid: ::c_long = 123;
+pub const SYS_getsid: ::c_long = 124;
+pub const SYS_capget: ::c_long = 125;
+pub const SYS_capset: ::c_long = 126;
+pub const SYS_rt_sigpending: ::c_long = 127;
+pub const SYS_rt_sigtimedwait: ::c_long = 128;
+pub const SYS_rt_sigqueueinfo: ::c_long = 129;
+pub const SYS_rt_sigsuspend: ::c_long = 130;
+pub const SYS_sigaltstack: ::c_long = 131;
+pub const SYS_utime: ::c_long = 132;
+pub const SYS_mknod: ::c_long = 133;
+pub const SYS_uselib: ::c_long = 134;
+pub const SYS_personality: ::c_long = 135;
+pub const SYS_ustat: ::c_long = 136;
+pub const SYS_statfs: ::c_long = 137;
+pub const SYS_fstatfs: ::c_long = 138;
+pub const SYS_sysfs: ::c_long = 139;
+pub const SYS_getpriority: ::c_long = 140;
+pub const SYS_setpriority: ::c_long = 141;
+pub const SYS_sched_setparam: ::c_long = 142;
+pub const SYS_sched_getparam: ::c_long = 143;
+pub const SYS_sched_setscheduler: ::c_long = 144;
+pub const SYS_sched_getscheduler: ::c_long = 145;
+pub const SYS_sched_get_priority_max: ::c_long = 146;
+pub const SYS_sched_get_priority_min: ::c_long = 147;
+pub const SYS_sched_rr_get_interval: ::c_long = 148;
+pub const SYS_mlock: ::c_long = 149;
+pub const SYS_munlock: ::c_long = 150;
+pub const SYS_mlockall: ::c_long = 151;
+pub const SYS_munlockall: ::c_long = 152;
+pub const SYS_vhangup: ::c_long = 153;
+pub const SYS_modify_ldt: ::c_long = 154;
+pub const SYS_pivot_root: ::c_long = 155;
+pub const SYS__sysctl: ::c_long = 156;
+pub const SYS_prctl: ::c_long = 157;
+pub const SYS_arch_prctl: ::c_long = 158;
+pub const SYS_adjtimex: ::c_long = 159;
+pub const SYS_setrlimit: ::c_long = 160;
+pub const SYS_chroot: ::c_long = 161;
+pub const SYS_sync: ::c_long = 162;
+pub const SYS_acct: ::c_long = 163;
+pub const SYS_settimeofday: ::c_long = 164;
+pub const SYS_mount: ::c_long = 165;
+pub const SYS_umount2: ::c_long = 166;
+pub const SYS_swapon: ::c_long = 167;
+pub const SYS_swapoff: ::c_long = 168;
+pub const SYS_reboot: ::c_long = 169;
+pub const SYS_sethostname: ::c_long = 170;
+pub const SYS_setdomainname: ::c_long = 171;
+pub const SYS_iopl: ::c_long = 172;
+pub const SYS_ioperm: ::c_long = 173;
+pub const SYS_create_module: ::c_long = 174;
+pub const SYS_init_module: ::c_long = 175;
+pub const SYS_delete_module: ::c_long = 176;
+pub const SYS_get_kernel_syms: ::c_long = 177;
+pub const SYS_query_module: ::c_long = 178;
+pub const SYS_quotactl: ::c_long = 179;
+pub const SYS_nfsservctl: ::c_long = 180;
+pub const SYS_getpmsg: ::c_long = 181;
+pub const SYS_putpmsg: ::c_long = 182;
+pub const SYS_afs_syscall: ::c_long = 183;
+pub const SYS_tuxcall: ::c_long = 184;
+pub const SYS_security: ::c_long = 185;
+pub const SYS_gettid: ::c_long = 186;
+pub const SYS_readahead: ::c_long = 187;
+pub const SYS_setxattr: ::c_long = 188;
+pub const SYS_lsetxattr: ::c_long = 189;
+pub const SYS_fsetxattr: ::c_long = 190;
+pub const SYS_getxattr: ::c_long = 191;
+pub const SYS_lgetxattr: ::c_long = 192;
+pub const SYS_fgetxattr: ::c_long = 193;
+pub const SYS_listxattr: ::c_long = 194;
+pub const SYS_llistxattr: ::c_long = 195;
+pub const SYS_flistxattr: ::c_long = 196;
+pub const SYS_removexattr: ::c_long = 197;
+pub const SYS_lremovexattr: ::c_long = 198;
+pub const SYS_fremovexattr: ::c_long = 199;
+pub const SYS_tkill: ::c_long = 200;
+pub const SYS_time: ::c_long = 201;
+pub const SYS_futex: ::c_long = 202;
+pub const SYS_sched_setaffinity: ::c_long = 203;
+pub const SYS_sched_getaffinity: ::c_long = 204;
+pub const SYS_set_thread_area: ::c_long = 205;
+pub const SYS_io_setup: ::c_long = 206;
+pub const SYS_io_destroy: ::c_long = 207;
+pub const SYS_io_getevents: ::c_long = 208;
+pub const SYS_io_submit: ::c_long = 209;
+pub const SYS_io_cancel: ::c_long = 210;
+pub const SYS_get_thread_area: ::c_long = 211;
+pub const SYS_lookup_dcookie: ::c_long = 212;
+pub const SYS_epoll_create: ::c_long = 213;
+pub const SYS_epoll_ctl_old: ::c_long = 214;
+pub const SYS_epoll_wait_old: ::c_long = 215;
+pub const SYS_remap_file_pages: ::c_long = 216;
+pub const SYS_getdents64: ::c_long = 217;
+pub const SYS_set_tid_address: ::c_long = 218;
+pub const SYS_restart_syscall: ::c_long = 219;
+pub const SYS_semtimedop: ::c_long = 220;
+pub const SYS_fadvise64: ::c_long = 221;
+pub const SYS_timer_create: ::c_long = 222;
+pub const SYS_timer_settime: ::c_long = 223;
+pub const SYS_timer_gettime: ::c_long = 224;
+pub const SYS_timer_getoverrun: ::c_long = 225;
+pub const SYS_timer_delete: ::c_long = 226;
+pub const SYS_clock_settime: ::c_long = 227;
+pub const SYS_clock_gettime: ::c_long = 228;
+pub const SYS_clock_getres: ::c_long = 229;
+pub const SYS_clock_nanosleep: ::c_long = 230;
+pub const SYS_exit_group: ::c_long = 231;
+pub const SYS_epoll_wait: ::c_long = 232;
+pub const SYS_epoll_ctl: ::c_long = 233;
+pub const SYS_tgkill: ::c_long = 234;
+pub const SYS_utimes: ::c_long = 235;
+pub const SYS_vserver: ::c_long = 236;
+pub const SYS_mbind: ::c_long = 237;
+pub const SYS_set_mempolicy: ::c_long = 238;
+pub const SYS_get_mempolicy: ::c_long = 239;
+pub const SYS_mq_open: ::c_long = 240;
+pub const SYS_mq_unlink: ::c_long = 241;
+pub const SYS_mq_timedsend: ::c_long = 242;
+pub const SYS_mq_timedreceive: ::c_long = 243;
+pub const SYS_mq_notify: ::c_long = 244;
+pub const SYS_mq_getsetattr: ::c_long = 245;
+pub const SYS_kexec_load: ::c_long = 246;
+pub const SYS_waitid: ::c_long = 247;
+pub const SYS_add_key: ::c_long = 248;
+pub const SYS_request_key: ::c_long = 249;
+pub const SYS_keyctl: ::c_long = 250;
+pub const SYS_ioprio_set: ::c_long = 251;
+pub const SYS_ioprio_get: ::c_long = 252;
+pub const SYS_inotify_init: ::c_long = 253;
+pub const SYS_inotify_add_watch: ::c_long = 254;
+pub const SYS_inotify_rm_watch: ::c_long = 255;
+pub const SYS_migrate_pages: ::c_long = 256;
+pub const SYS_openat: ::c_long = 257;
+pub const SYS_mkdirat: ::c_long = 258;
+pub const SYS_mknodat: ::c_long = 259;
+pub const SYS_fchownat: ::c_long = 260;
+pub const SYS_futimesat: ::c_long = 261;
+pub const SYS_newfstatat: ::c_long = 262;
+pub const SYS_unlinkat: ::c_long = 263;
+pub const SYS_renameat: ::c_long = 264;
+pub const SYS_linkat: ::c_long = 265;
+pub const SYS_symlinkat: ::c_long = 266;
+pub const SYS_readlinkat: ::c_long = 267;
+pub const SYS_fchmodat: ::c_long = 268;
+pub const SYS_faccessat: ::c_long = 269;
+pub const SYS_pselect6: ::c_long = 270;
+pub const SYS_ppoll: ::c_long = 271;
+pub const SYS_unshare: ::c_long = 272;
+pub const SYS_set_robust_list: ::c_long = 273;
+pub const SYS_get_robust_list: ::c_long = 274;
+pub const SYS_splice: ::c_long = 275;
+pub const SYS_tee: ::c_long = 276;
+pub const SYS_sync_file_range: ::c_long = 277;
+pub const SYS_vmsplice: ::c_long = 278;
+pub const SYS_move_pages: ::c_long = 279;
+pub const SYS_utimensat: ::c_long = 280;
+pub const SYS_epoll_pwait: ::c_long = 281;
+pub const SYS_signalfd: ::c_long = 282;
+pub const SYS_timerfd_create: ::c_long = 283;
+pub const SYS_eventfd: ::c_long = 284;
+pub const SYS_fallocate: ::c_long = 285;
+pub const SYS_timerfd_settime: ::c_long = 286;
+pub const SYS_timerfd_gettime: ::c_long = 287;
+pub const SYS_accept4: ::c_long = 288;
+pub const SYS_signalfd4: ::c_long = 289;
+pub const SYS_eventfd2: ::c_long = 290;
+pub const SYS_epoll_create1: ::c_long = 291;
+pub const SYS_dup3: ::c_long = 292;
+pub const SYS_pipe2: ::c_long = 293;
+pub const SYS_inotify_init1: ::c_long = 294;
+pub const SYS_preadv: ::c_long = 295;
+pub const SYS_pwritev: ::c_long = 296;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 297;
+pub const SYS_perf_event_open: ::c_long = 298;
+pub const SYS_recvmmsg: ::c_long = 299;
+pub const SYS_fanotify_init: ::c_long = 300;
+pub const SYS_fanotify_mark: ::c_long = 301;
+pub const SYS_prlimit64: ::c_long = 302;
+pub const SYS_name_to_handle_at: ::c_long = 303;
+pub const SYS_open_by_handle_at: ::c_long = 304;
+pub const SYS_clock_adjtime: ::c_long = 305;
+pub const SYS_syncfs: ::c_long = 306;
+pub const SYS_sendmmsg: ::c_long = 307;
+pub const SYS_setns: ::c_long = 308;
+pub const SYS_getcpu: ::c_long = 309;
+pub const SYS_process_vm_readv: ::c_long = 310;
+pub const SYS_process_vm_writev: ::c_long = 311;
+pub const SYS_kcmp: ::c_long = 312;
+pub const SYS_finit_module: ::c_long = 313;
+pub const SYS_sched_setattr: ::c_long = 314;
+pub const SYS_sched_getattr: ::c_long = 315;
+pub const SYS_renameat2: ::c_long = 316;
+pub const SYS_seccomp: ::c_long = 317;
+pub const SYS_getrandom: ::c_long = 318;
+pub const SYS_memfd_create: ::c_long = 319;
+pub const SYS_kexec_file_load: ::c_long = 320;
+pub const SYS_bpf: ::c_long = 321;
+pub const SYS_execveat: ::c_long = 322;
+pub const SYS_userfaultfd: ::c_long = 323;
+pub const SYS_membarrier: ::c_long = 324;
+pub const SYS_mlock2: ::c_long = 325;
+pub const SYS_copy_file_range: ::c_long = 326;
+pub const SYS_preadv2: ::c_long = 327;
+pub const SYS_pwritev2: ::c_long = 328;
+pub const SYS_pkey_mprotect: ::c_long = 329;
+pub const SYS_pkey_alloc: ::c_long = 330;
+pub const SYS_pkey_free: ::c_long = 331;
+pub const SYS_statx: ::c_long = 332;
+pub const SYS_pidfd_open: ::c_long = 434;
+pub const SYS_clone3: ::c_long = 435;
+
+extern "C" {
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_int,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/x32.rs b/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/x32.rs
new file mode 100644
index 00000000..82b71c1a
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/b64/x86_64/x32.rs
@@ -0,0 +1,377 @@
+use pthread_mutex_t;
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+
+s! {
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+}
+
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 32;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 44;
+
+align_const! {
+    pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+    pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP: ::pthread_mutex_t =
+        pthread_mutex_t {
+            size: [
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+        };
+}
+
+// Syscall table
+
+pub const __X32_SYSCALL_BIT: ::c_long = 0x40000000;
+
+pub const SYS_read: ::c_long = __X32_SYSCALL_BIT + 0;
+pub const SYS_write: ::c_long = __X32_SYSCALL_BIT + 1;
+pub const SYS_open: ::c_long = __X32_SYSCALL_BIT + 2;
+pub const SYS_close: ::c_long = __X32_SYSCALL_BIT + 3;
+pub const SYS_stat: ::c_long = __X32_SYSCALL_BIT + 4;
+pub const SYS_fstat: ::c_long = __X32_SYSCALL_BIT + 5;
+pub const SYS_lstat: ::c_long = __X32_SYSCALL_BIT + 6;
+pub const SYS_poll: ::c_long = __X32_SYSCALL_BIT + 7;
+pub const SYS_lseek: ::c_long = __X32_SYSCALL_BIT + 8;
+pub const SYS_mmap: ::c_long = __X32_SYSCALL_BIT + 9;
+pub const SYS_mprotect: ::c_long = __X32_SYSCALL_BIT + 10;
+pub const SYS_munmap: ::c_long = __X32_SYSCALL_BIT + 11;
+pub const SYS_brk: ::c_long = __X32_SYSCALL_BIT + 12;
+pub const SYS_rt_sigprocmask: ::c_long = __X32_SYSCALL_BIT + 14;
+pub const SYS_pread64: ::c_long = __X32_SYSCALL_BIT + 17;
+pub const SYS_pwrite64: ::c_long = __X32_SYSCALL_BIT + 18;
+pub const SYS_access: ::c_long = __X32_SYSCALL_BIT + 21;
+pub const SYS_pipe: ::c_long = __X32_SYSCALL_BIT + 22;
+pub const SYS_select: ::c_long = __X32_SYSCALL_BIT + 23;
+pub const SYS_sched_yield: ::c_long = __X32_SYSCALL_BIT + 24;
+pub const SYS_mremap: ::c_long = __X32_SYSCALL_BIT + 25;
+pub const SYS_msync: ::c_long = __X32_SYSCALL_BIT + 26;
+pub const SYS_mincore: ::c_long = __X32_SYSCALL_BIT + 27;
+pub const SYS_madvise: ::c_long = __X32_SYSCALL_BIT + 28;
+pub const SYS_shmget: ::c_long = __X32_SYSCALL_BIT + 29;
+pub const SYS_shmat: ::c_long = __X32_SYSCALL_BIT + 30;
+pub const SYS_shmctl: ::c_long = __X32_SYSCALL_BIT + 31;
+pub const SYS_dup: ::c_long = __X32_SYSCALL_BIT + 32;
+pub const SYS_dup2: ::c_long = __X32_SYSCALL_BIT + 33;
+pub const SYS_pause: ::c_long = __X32_SYSCALL_BIT + 34;
+pub const SYS_nanosleep: ::c_long = __X32_SYSCALL_BIT + 35;
+pub const SYS_getitimer: ::c_long = __X32_SYSCALL_BIT + 36;
+pub const SYS_alarm: ::c_long = __X32_SYSCALL_BIT + 37;
+pub const SYS_setitimer: ::c_long = __X32_SYSCALL_BIT + 38;
+pub const SYS_getpid: ::c_long = __X32_SYSCALL_BIT + 39;
+pub const SYS_sendfile: ::c_long = __X32_SYSCALL_BIT + 40;
+pub const SYS_socket: ::c_long = __X32_SYSCALL_BIT + 41;
+pub const SYS_connect: ::c_long = __X32_SYSCALL_BIT + 42;
+pub const SYS_accept: ::c_long = __X32_SYSCALL_BIT + 43;
+pub const SYS_sendto: ::c_long = __X32_SYSCALL_BIT + 44;
+pub const SYS_shutdown: ::c_long = __X32_SYSCALL_BIT + 48;
+pub const SYS_bind: ::c_long = __X32_SYSCALL_BIT + 49;
+pub const SYS_listen: ::c_long = __X32_SYSCALL_BIT + 50;
+pub const SYS_getsockname: ::c_long = __X32_SYSCALL_BIT + 51;
+pub const SYS_getpeername: ::c_long = __X32_SYSCALL_BIT + 52;
+pub const SYS_socketpair: ::c_long = __X32_SYSCALL_BIT + 53;
+pub const SYS_clone: ::c_long = __X32_SYSCALL_BIT + 56;
+pub const SYS_fork: ::c_long = __X32_SYSCALL_BIT + 57;
+pub const SYS_vfork: ::c_long = __X32_SYSCALL_BIT + 58;
+pub const SYS_exit: ::c_long = __X32_SYSCALL_BIT + 60;
+pub const SYS_wait4: ::c_long = __X32_SYSCALL_BIT + 61;
+pub const SYS_kill: ::c_long = __X32_SYSCALL_BIT + 62;
+pub const SYS_uname: ::c_long = __X32_SYSCALL_BIT + 63;
+pub const SYS_semget: ::c_long = __X32_SYSCALL_BIT + 64;
+pub const SYS_semop: ::c_long = __X32_SYSCALL_BIT + 65;
+pub const SYS_semctl: ::c_long = __X32_SYSCALL_BIT + 66;
+pub const SYS_shmdt: ::c_long = __X32_SYSCALL_BIT + 67;
+pub const SYS_msgget: ::c_long = __X32_SYSCALL_BIT + 68;
+pub const SYS_msgsnd: ::c_long = __X32_SYSCALL_BIT + 69;
+pub const SYS_msgrcv: ::c_long = __X32_SYSCALL_BIT + 70;
+pub const SYS_msgctl: ::c_long = __X32_SYSCALL_BIT + 71;
+pub const SYS_fcntl: ::c_long = __X32_SYSCALL_BIT + 72;
+pub const SYS_flock: ::c_long = __X32_SYSCALL_BIT + 73;
+pub const SYS_fsync: ::c_long = __X32_SYSCALL_BIT + 74;
+pub const SYS_fdatasync: ::c_long = __X32_SYSCALL_BIT + 75;
+pub const SYS_truncate: ::c_long = __X32_SYSCALL_BIT + 76;
+pub const SYS_ftruncate: ::c_long = __X32_SYSCALL_BIT + 77;
+pub const SYS_getdents: ::c_long = __X32_SYSCALL_BIT + 78;
+pub const SYS_getcwd: ::c_long = __X32_SYSCALL_BIT + 79;
+pub const SYS_chdir: ::c_long = __X32_SYSCALL_BIT + 80;
+pub const SYS_fchdir: ::c_long = __X32_SYSCALL_BIT + 81;
+pub const SYS_rename: ::c_long = __X32_SYSCALL_BIT + 82;
+pub const SYS_mkdir: ::c_long = __X32_SYSCALL_BIT + 83;
+pub const SYS_rmdir: ::c_long = __X32_SYSCALL_BIT + 84;
+pub const SYS_creat: ::c_long = __X32_SYSCALL_BIT + 85;
+pub const SYS_link: ::c_long = __X32_SYSCALL_BIT + 86;
+pub const SYS_unlink: ::c_long = __X32_SYSCALL_BIT + 87;
+pub const SYS_symlink: ::c_long = __X32_SYSCALL_BIT + 88;
+pub const SYS_readlink: ::c_long = __X32_SYSCALL_BIT + 89;
+pub const SYS_chmod: ::c_long = __X32_SYSCALL_BIT + 90;
+pub const SYS_fchmod: ::c_long = __X32_SYSCALL_BIT + 91;
+pub const SYS_chown: ::c_long = __X32_SYSCALL_BIT + 92;
+pub const SYS_fchown: ::c_long = __X32_SYSCALL_BIT + 93;
+pub const SYS_lchown: ::c_long = __X32_SYSCALL_BIT + 94;
+pub const SYS_umask: ::c_long = __X32_SYSCALL_BIT + 95;
+pub const SYS_gettimeofday: ::c_long = __X32_SYSCALL_BIT + 96;
+pub const SYS_getrlimit: ::c_long = __X32_SYSCALL_BIT + 97;
+pub const SYS_getrusage: ::c_long = __X32_SYSCALL_BIT + 98;
+pub const SYS_sysinfo: ::c_long = __X32_SYSCALL_BIT + 99;
+pub const SYS_times: ::c_long = __X32_SYSCALL_BIT + 100;
+pub const SYS_getuid: ::c_long = __X32_SYSCALL_BIT + 102;
+pub const SYS_syslog: ::c_long = __X32_SYSCALL_BIT + 103;
+pub const SYS_getgid: ::c_long = __X32_SYSCALL_BIT + 104;
+pub const SYS_setuid: ::c_long = __X32_SYSCALL_BIT + 105;
+pub const SYS_setgid: ::c_long = __X32_SYSCALL_BIT + 106;
+pub const SYS_geteuid: ::c_long = __X32_SYSCALL_BIT + 107;
+pub const SYS_getegid: ::c_long = __X32_SYSCALL_BIT + 108;
+pub const SYS_setpgid: ::c_long = __X32_SYSCALL_BIT + 109;
+pub const SYS_getppid: ::c_long = __X32_SYSCALL_BIT + 110;
+pub const SYS_getpgrp: ::c_long = __X32_SYSCALL_BIT + 111;
+pub const SYS_setsid: ::c_long = __X32_SYSCALL_BIT + 112;
+pub const SYS_setreuid: ::c_long = __X32_SYSCALL_BIT + 113;
+pub const SYS_setregid: ::c_long = __X32_SYSCALL_BIT + 114;
+pub const SYS_getgroups: ::c_long = __X32_SYSCALL_BIT + 115;
+pub const SYS_setgroups: ::c_long = __X32_SYSCALL_BIT + 116;
+pub const SYS_setresuid: ::c_long = __X32_SYSCALL_BIT + 117;
+pub const SYS_getresuid: ::c_long = __X32_SYSCALL_BIT + 118;
+pub const SYS_setresgid: ::c_long = __X32_SYSCALL_BIT + 119;
+pub const SYS_getresgid: ::c_long = __X32_SYSCALL_BIT + 120;
+pub const SYS_getpgid: ::c_long = __X32_SYSCALL_BIT + 121;
+pub const SYS_setfsuid: ::c_long = __X32_SYSCALL_BIT + 122;
+pub const SYS_setfsgid: ::c_long = __X32_SYSCALL_BIT + 123;
+pub const SYS_getsid: ::c_long = __X32_SYSCALL_BIT + 124;
+pub const SYS_capget: ::c_long = __X32_SYSCALL_BIT + 125;
+pub const SYS_capset: ::c_long = __X32_SYSCALL_BIT + 126;
+pub const SYS_rt_sigsuspend: ::c_long = __X32_SYSCALL_BIT + 130;
+pub const SYS_utime: ::c_long = __X32_SYSCALL_BIT + 132;
+pub const SYS_mknod: ::c_long = __X32_SYSCALL_BIT + 133;
+pub const SYS_personality: ::c_long = __X32_SYSCALL_BIT + 135;
+pub const SYS_ustat: ::c_long = __X32_SYSCALL_BIT + 136;
+pub const SYS_statfs: ::c_long = __X32_SYSCALL_BIT + 137;
+pub const SYS_fstatfs: ::c_long = __X32_SYSCALL_BIT + 138;
+pub const SYS_sysfs: ::c_long = __X32_SYSCALL_BIT + 139;
+pub const SYS_getpriority: ::c_long = __X32_SYSCALL_BIT + 140;
+pub const SYS_setpriority: ::c_long = __X32_SYSCALL_BIT + 141;
+pub const SYS_sched_setparam: ::c_long = __X32_SYSCALL_BIT + 142;
+pub const SYS_sched_getparam: ::c_long = __X32_SYSCALL_BIT + 143;
+pub const SYS_sched_setscheduler: ::c_long = __X32_SYSCALL_BIT + 144;
+pub const SYS_sched_getscheduler: ::c_long = __X32_SYSCALL_BIT + 145;
+pub const SYS_sched_get_priority_max: ::c_long = __X32_SYSCALL_BIT + 146;
+pub const SYS_sched_get_priority_min: ::c_long = __X32_SYSCALL_BIT + 147;
+pub const SYS_sched_rr_get_interval: ::c_long = __X32_SYSCALL_BIT + 148;
+pub const SYS_mlock: ::c_long = __X32_SYSCALL_BIT + 149;
+pub const SYS_munlock: ::c_long = __X32_SYSCALL_BIT + 150;
+pub const SYS_mlockall: ::c_long = __X32_SYSCALL_BIT + 151;
+pub const SYS_munlockall: ::c_long = __X32_SYSCALL_BIT + 152;
+pub const SYS_vhangup: ::c_long = __X32_SYSCALL_BIT + 153;
+pub const SYS_modify_ldt: ::c_long = __X32_SYSCALL_BIT + 154;
+pub const SYS_pivot_root: ::c_long = __X32_SYSCALL_BIT + 155;
+pub const SYS_prctl: ::c_long = __X32_SYSCALL_BIT + 157;
+pub const SYS_arch_prctl: ::c_long = __X32_SYSCALL_BIT + 158;
+pub const SYS_adjtimex: ::c_long = __X32_SYSCALL_BIT + 159;
+pub const SYS_setrlimit: ::c_long = __X32_SYSCALL_BIT + 160;
+pub const SYS_chroot: ::c_long = __X32_SYSCALL_BIT + 161;
+pub const SYS_sync: ::c_long = __X32_SYSCALL_BIT + 162;
+pub const SYS_acct: ::c_long = __X32_SYSCALL_BIT + 163;
+pub const SYS_settimeofday: ::c_long = __X32_SYSCALL_BIT + 164;
+pub const SYS_mount: ::c_long = __X32_SYSCALL_BIT + 165;
+pub const SYS_umount2: ::c_long = __X32_SYSCALL_BIT + 166;
+pub const SYS_swapon: ::c_long = __X32_SYSCALL_BIT + 167;
+pub const SYS_swapoff: ::c_long = __X32_SYSCALL_BIT + 168;
+pub const SYS_reboot: ::c_long = __X32_SYSCALL_BIT + 169;
+pub const SYS_sethostname: ::c_long = __X32_SYSCALL_BIT + 170;
+pub const SYS_setdomainname: ::c_long = __X32_SYSCALL_BIT + 171;
+pub const SYS_iopl: ::c_long = __X32_SYSCALL_BIT + 172;
+pub const SYS_ioperm: ::c_long = __X32_SYSCALL_BIT + 173;
+pub const SYS_init_module: ::c_long = __X32_SYSCALL_BIT + 175;
+pub const SYS_delete_module: ::c_long = __X32_SYSCALL_BIT + 176;
+pub const SYS_quotactl: ::c_long = __X32_SYSCALL_BIT + 179;
+pub const SYS_getpmsg: ::c_long = __X32_SYSCALL_BIT + 181;
+pub const SYS_putpmsg: ::c_long = __X32_SYSCALL_BIT + 182;
+pub const SYS_afs_syscall: ::c_long = __X32_SYSCALL_BIT + 183;
+pub const SYS_tuxcall: ::c_long = __X32_SYSCALL_BIT + 184;
+pub const SYS_security: ::c_long = __X32_SYSCALL_BIT + 185;
+pub const SYS_gettid: ::c_long = __X32_SYSCALL_BIT + 186;
+pub const SYS_readahead: ::c_long = __X32_SYSCALL_BIT + 187;
+pub const SYS_setxattr: ::c_long = __X32_SYSCALL_BIT + 188;
+pub const SYS_lsetxattr: ::c_long = __X32_SYSCALL_BIT + 189;
+pub const SYS_fsetxattr: ::c_long = __X32_SYSCALL_BIT + 190;
+pub const SYS_getxattr: ::c_long = __X32_SYSCALL_BIT + 191;
+pub const SYS_lgetxattr: ::c_long = __X32_SYSCALL_BIT + 192;
+pub const SYS_fgetxattr: ::c_long = __X32_SYSCALL_BIT + 193;
+pub const SYS_listxattr: ::c_long = __X32_SYSCALL_BIT + 194;
+pub const SYS_llistxattr: ::c_long = __X32_SYSCALL_BIT + 195;
+pub const SYS_flistxattr: ::c_long = __X32_SYSCALL_BIT + 196;
+pub const SYS_removexattr: ::c_long = __X32_SYSCALL_BIT + 197;
+pub const SYS_lremovexattr: ::c_long = __X32_SYSCALL_BIT + 198;
+pub const SYS_fremovexattr: ::c_long = __X32_SYSCALL_BIT + 199;
+pub const SYS_tkill: ::c_long = __X32_SYSCALL_BIT + 200;
+pub const SYS_time: ::c_long = __X32_SYSCALL_BIT + 201;
+pub const SYS_futex: ::c_long = __X32_SYSCALL_BIT + 202;
+pub const SYS_sched_setaffinity: ::c_long = __X32_SYSCALL_BIT + 203;
+pub const SYS_sched_getaffinity: ::c_long = __X32_SYSCALL_BIT + 204;
+pub const SYS_io_destroy: ::c_long = __X32_SYSCALL_BIT + 207;
+pub const SYS_io_getevents: ::c_long = __X32_SYSCALL_BIT + 208;
+pub const SYS_io_cancel: ::c_long = __X32_SYSCALL_BIT + 210;
+pub const SYS_lookup_dcookie: ::c_long = __X32_SYSCALL_BIT + 212;
+pub const SYS_epoll_create: ::c_long = __X32_SYSCALL_BIT + 213;
+pub const SYS_remap_file_pages: ::c_long = __X32_SYSCALL_BIT + 216;
+pub const SYS_getdents64: ::c_long = __X32_SYSCALL_BIT + 217;
+pub const SYS_set_tid_address: ::c_long = __X32_SYSCALL_BIT + 218;
+pub const SYS_restart_syscall: ::c_long = __X32_SYSCALL_BIT + 219;
+pub const SYS_semtimedop: ::c_long = __X32_SYSCALL_BIT + 220;
+pub const SYS_fadvise64: ::c_long = __X32_SYSCALL_BIT + 221;
+pub const SYS_timer_settime: ::c_long = __X32_SYSCALL_BIT + 223;
+pub const SYS_timer_gettime: ::c_long = __X32_SYSCALL_BIT + 224;
+pub const SYS_timer_getoverrun: ::c_long = __X32_SYSCALL_BIT + 225;
+pub const SYS_timer_delete: ::c_long = __X32_SYSCALL_BIT + 226;
+pub const SYS_clock_settime: ::c_long = __X32_SYSCALL_BIT + 227;
+pub const SYS_clock_gettime: ::c_long = __X32_SYSCALL_BIT + 228;
+pub const SYS_clock_getres: ::c_long = __X32_SYSCALL_BIT + 229;
+pub const SYS_clock_nanosleep: ::c_long = __X32_SYSCALL_BIT + 230;
+pub const SYS_exit_group: ::c_long = __X32_SYSCALL_BIT + 231;
+pub const SYS_epoll_wait: ::c_long = __X32_SYSCALL_BIT + 232;
+pub const SYS_epoll_ctl: ::c_long = __X32_SYSCALL_BIT + 233;
+pub const SYS_tgkill: ::c_long = __X32_SYSCALL_BIT + 234;
+pub const SYS_utimes: ::c_long = __X32_SYSCALL_BIT + 235;
+pub const SYS_mbind: ::c_long = __X32_SYSCALL_BIT + 237;
+pub const SYS_set_mempolicy: ::c_long = __X32_SYSCALL_BIT + 238;
+pub const SYS_get_mempolicy: ::c_long = __X32_SYSCALL_BIT + 239;
+pub const SYS_mq_open: ::c_long = __X32_SYSCALL_BIT + 240;
+pub const SYS_mq_unlink: ::c_long = __X32_SYSCALL_BIT + 241;
+pub const SYS_mq_timedsend: ::c_long = __X32_SYSCALL_BIT + 242;
+pub const SYS_mq_timedreceive: ::c_long = __X32_SYSCALL_BIT + 243;
+pub const SYS_mq_getsetattr: ::c_long = __X32_SYSCALL_BIT + 245;
+pub const SYS_add_key: ::c_long = __X32_SYSCALL_BIT + 248;
+pub const SYS_request_key: ::c_long = __X32_SYSCALL_BIT + 249;
+pub const SYS_keyctl: ::c_long = __X32_SYSCALL_BIT + 250;
+pub const SYS_ioprio_set: ::c_long = __X32_SYSCALL_BIT + 251;
+pub const SYS_ioprio_get: ::c_long = __X32_SYSCALL_BIT + 252;
+pub const SYS_inotify_init: ::c_long = __X32_SYSCALL_BIT + 253;
+pub const SYS_inotify_add_watch: ::c_long = __X32_SYSCALL_BIT + 254;
+pub const SYS_inotify_rm_watch: ::c_long = __X32_SYSCALL_BIT + 255;
+pub const SYS_migrate_pages: ::c_long = __X32_SYSCALL_BIT + 256;
+pub const SYS_openat: ::c_long = __X32_SYSCALL_BIT + 257;
+pub const SYS_mkdirat: ::c_long = __X32_SYSCALL_BIT + 258;
+pub const SYS_mknodat: ::c_long = __X32_SYSCALL_BIT + 259;
+pub const SYS_fchownat: ::c_long = __X32_SYSCALL_BIT + 260;
+pub const SYS_futimesat: ::c_long = __X32_SYSCALL_BIT + 261;
+pub const SYS_newfstatat: ::c_long = __X32_SYSCALL_BIT + 262;
+pub const SYS_unlinkat: ::c_long = __X32_SYSCALL_BIT + 263;
+pub const SYS_renameat: ::c_long = __X32_SYSCALL_BIT + 264;
+pub const SYS_linkat: ::c_long = __X32_SYSCALL_BIT + 265;
+pub const SYS_symlinkat: ::c_long = __X32_SYSCALL_BIT + 266;
+pub const SYS_readlinkat: ::c_long = __X32_SYSCALL_BIT + 267;
+pub const SYS_fchmodat: ::c_long = __X32_SYSCALL_BIT + 268;
+pub const SYS_faccessat: ::c_long = __X32_SYSCALL_BIT + 269;
+pub const SYS_pselect6: ::c_long = __X32_SYSCALL_BIT + 270;
+pub const SYS_ppoll: ::c_long = __X32_SYSCALL_BIT + 271;
+pub const SYS_unshare: ::c_long = __X32_SYSCALL_BIT + 272;
+pub const SYS_splice: ::c_long = __X32_SYSCALL_BIT + 275;
+pub const SYS_tee: ::c_long = __X32_SYSCALL_BIT + 276;
+pub const SYS_sync_file_range: ::c_long = __X32_SYSCALL_BIT + 277;
+pub const SYS_utimensat: ::c_long = __X32_SYSCALL_BIT + 280;
+pub const SYS_epoll_pwait: ::c_long = __X32_SYSCALL_BIT + 281;
+pub const SYS_signalfd: ::c_long = __X32_SYSCALL_BIT + 282;
+pub const SYS_timerfd_create: ::c_long = __X32_SYSCALL_BIT + 283;
+pub const SYS_eventfd: ::c_long = __X32_SYSCALL_BIT + 284;
+pub const SYS_fallocate: ::c_long = __X32_SYSCALL_BIT + 285;
+pub const SYS_timerfd_settime: ::c_long = __X32_SYSCALL_BIT + 286;
+pub const SYS_timerfd_gettime: ::c_long = __X32_SYSCALL_BIT + 287;
+pub const SYS_accept4: ::c_long = __X32_SYSCALL_BIT + 288;
+pub const SYS_signalfd4: ::c_long = __X32_SYSCALL_BIT + 289;
+pub const SYS_eventfd2: ::c_long = __X32_SYSCALL_BIT + 290;
+pub const SYS_epoll_create1: ::c_long = __X32_SYSCALL_BIT + 291;
+pub const SYS_dup3: ::c_long = __X32_SYSCALL_BIT + 292;
+pub const SYS_pipe2: ::c_long = __X32_SYSCALL_BIT + 293;
+pub const SYS_inotify_init1: ::c_long = __X32_SYSCALL_BIT + 294;
+pub const SYS_perf_event_open: ::c_long = __X32_SYSCALL_BIT + 298;
+pub const SYS_fanotify_init: ::c_long = __X32_SYSCALL_BIT + 300;
+pub const SYS_fanotify_mark: ::c_long = __X32_SYSCALL_BIT + 301;
+pub const SYS_prlimit64: ::c_long = __X32_SYSCALL_BIT + 302;
+pub const SYS_name_to_handle_at: ::c_long = __X32_SYSCALL_BIT + 303;
+pub const SYS_open_by_handle_at: ::c_long = __X32_SYSCALL_BIT + 304;
+pub const SYS_clock_adjtime: ::c_long = __X32_SYSCALL_BIT + 305;
+pub const SYS_syncfs: ::c_long = __X32_SYSCALL_BIT + 306;
+pub const SYS_setns: ::c_long = __X32_SYSCALL_BIT + 308;
+pub const SYS_getcpu: ::c_long = __X32_SYSCALL_BIT + 309;
+pub const SYS_kcmp: ::c_long = __X32_SYSCALL_BIT + 312;
+pub const SYS_finit_module: ::c_long = __X32_SYSCALL_BIT + 313;
+pub const SYS_sched_setattr: ::c_long = __X32_SYSCALL_BIT + 314;
+pub const SYS_sched_getattr: ::c_long = __X32_SYSCALL_BIT + 315;
+pub const SYS_renameat2: ::c_long = __X32_SYSCALL_BIT + 316;
+pub const SYS_seccomp: ::c_long = __X32_SYSCALL_BIT + 317;
+pub const SYS_getrandom: ::c_long = __X32_SYSCALL_BIT + 318;
+pub const SYS_memfd_create: ::c_long = __X32_SYSCALL_BIT + 319;
+pub const SYS_kexec_file_load: ::c_long = __X32_SYSCALL_BIT + 320;
+pub const SYS_bpf: ::c_long = __X32_SYSCALL_BIT + 321;
+pub const SYS_userfaultfd: ::c_long = __X32_SYSCALL_BIT + 323;
+pub const SYS_membarrier: ::c_long = __X32_SYSCALL_BIT + 324;
+pub const SYS_mlock2: ::c_long = __X32_SYSCALL_BIT + 325;
+pub const SYS_copy_file_range: ::c_long = __X32_SYSCALL_BIT + 326;
+pub const SYS_pkey_mprotect: ::c_long = __X32_SYSCALL_BIT + 329;
+pub const SYS_pkey_alloc: ::c_long = __X32_SYSCALL_BIT + 330;
+pub const SYS_pkey_free: ::c_long = __X32_SYSCALL_BIT + 331;
+pub const SYS_statx: ::c_long = __X32_SYSCALL_BIT + 332;
+pub const SYS_pidfd_open: ::c_long = __X32_SYSCALL_BIT + 434;
+pub const SYS_clone3: ::c_long = __X32_SYSCALL_BIT + 435;
+pub const SYS_rt_sigaction: ::c_long = __X32_SYSCALL_BIT + 512;
+pub const SYS_rt_sigreturn: ::c_long = __X32_SYSCALL_BIT + 513;
+pub const SYS_ioctl: ::c_long = __X32_SYSCALL_BIT + 514;
+pub const SYS_readv: ::c_long = __X32_SYSCALL_BIT + 515;
+pub const SYS_writev: ::c_long = __X32_SYSCALL_BIT + 516;
+pub const SYS_recvfrom: ::c_long = __X32_SYSCALL_BIT + 517;
+pub const SYS_sendmsg: ::c_long = __X32_SYSCALL_BIT + 518;
+pub const SYS_recvmsg: ::c_long = __X32_SYSCALL_BIT + 519;
+pub const SYS_execve: ::c_long = __X32_SYSCALL_BIT + 520;
+pub const SYS_ptrace: ::c_long = __X32_SYSCALL_BIT + 521;
+pub const SYS_rt_sigpending: ::c_long = __X32_SYSCALL_BIT + 522;
+pub const SYS_rt_sigtimedwait: ::c_long = __X32_SYSCALL_BIT + 523;
+pub const SYS_rt_sigqueueinfo: ::c_long = __X32_SYSCALL_BIT + 524;
+pub const SYS_sigaltstack: ::c_long = __X32_SYSCALL_BIT + 525;
+pub const SYS_timer_create: ::c_long = __X32_SYSCALL_BIT + 526;
+pub const SYS_mq_notify: ::c_long = __X32_SYSCALL_BIT + 527;
+pub const SYS_kexec_load: ::c_long = __X32_SYSCALL_BIT + 528;
+pub const SYS_waitid: ::c_long = __X32_SYSCALL_BIT + 529;
+pub const SYS_set_robust_list: ::c_long = __X32_SYSCALL_BIT + 530;
+pub const SYS_get_robust_list: ::c_long = __X32_SYSCALL_BIT + 531;
+pub const SYS_vmsplice: ::c_long = __X32_SYSCALL_BIT + 532;
+pub const SYS_move_pages: ::c_long = __X32_SYSCALL_BIT + 533;
+pub const SYS_preadv: ::c_long = __X32_SYSCALL_BIT + 534;
+pub const SYS_pwritev: ::c_long = __X32_SYSCALL_BIT + 535;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = __X32_SYSCALL_BIT + 536;
+pub const SYS_recvmmsg: ::c_long = __X32_SYSCALL_BIT + 537;
+pub const SYS_sendmmsg: ::c_long = __X32_SYSCALL_BIT + 538;
+pub const SYS_process_vm_readv: ::c_long = __X32_SYSCALL_BIT + 539;
+pub const SYS_process_vm_writev: ::c_long = __X32_SYSCALL_BIT + 540;
+pub const SYS_setsockopt: ::c_long = __X32_SYSCALL_BIT + 541;
+pub const SYS_getsockopt: ::c_long = __X32_SYSCALL_BIT + 542;
+pub const SYS_io_setup: ::c_long = __X32_SYSCALL_BIT + 543;
+pub const SYS_io_submit: ::c_long = __X32_SYSCALL_BIT + 544;
+pub const SYS_execveat: ::c_long = __X32_SYSCALL_BIT + 545;
+pub const SYS_preadv2: ::c_long = __X32_SYSCALL_BIT + 546;
+pub const SYS_pwritev2: ::c_long = __X32_SYSCALL_BIT + 547;
diff --git a/library/libc/src/unix/linux_like/linux/gnu/mod.rs b/library/libc/src/unix/linux_like/linux/gnu/mod.rs
new file mode 100644
index 00000000..e07c677f
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/mod.rs
@@ -0,0 +1,1542 @@
+pub type pthread_t = c_ulong;
+pub type __priority_which_t = ::c_uint;
+pub type __rlimit_resource_t = ::c_uint;
+pub type Lmid_t = ::c_long;
+pub type regoff_t = ::c_int;
+
+s! {
+    pub struct statx {
+        pub stx_mask: u32,
+        pub stx_blksize: u32,
+        pub stx_attributes: u64,
+        pub stx_nlink: u32,
+        pub stx_uid: u32,
+        pub stx_gid: u32,
+        pub stx_mode: u16,
+        pub __statx_pad1: [u16; 1],
+        pub stx_ino: u64,
+        pub stx_size: u64,
+        pub stx_blocks: u64,
+        pub stx_attributes_mask: u64,
+        pub stx_atime: ::statx_timestamp,
+        pub stx_btime: ::statx_timestamp,
+        pub stx_ctime: ::statx_timestamp,
+        pub stx_mtime: ::statx_timestamp,
+        pub stx_rdev_major: u32,
+        pub stx_rdev_minor: u32,
+        pub stx_dev_major: u32,
+        pub stx_dev_minor: u32,
+        pub __statx_pad2: [u64; 14],
+    }
+
+    pub struct statx_timestamp {
+        pub tv_sec: i64,
+        pub tv_nsec: u32,
+        pub __statx_timestamp_pad1: [i32; 1],
+    }
+
+    pub struct aiocb {
+        pub aio_fildes: ::c_int,
+        pub aio_lio_opcode: ::c_int,
+        pub aio_reqprio: ::c_int,
+        pub aio_buf: *mut ::c_void,
+        pub aio_nbytes: ::size_t,
+        pub aio_sigevent: ::sigevent,
+        __next_prio: *mut aiocb,
+        __abs_prio: ::c_int,
+        __policy: ::c_int,
+        __error_code: ::c_int,
+        __return_value: ::ssize_t,
+        pub aio_offset: off_t,
+        #[cfg(all(not(target_arch = "x86_64"), target_pointer_width = "32"))]
+        __unused1: [::c_char; 4],
+        __glibc_reserved: [::c_char; 32]
+    }
+
+    pub struct __exit_status {
+        pub e_termination: ::c_short,
+        pub e_exit: ::c_short,
+    }
+
+    pub struct __timeval {
+        pub tv_sec: i32,
+        pub tv_usec: i32,
+    }
+
+    pub struct glob64_t {
+        pub gl_pathc: ::size_t,
+        pub gl_pathv: *mut *mut ::c_char,
+        pub gl_offs: ::size_t,
+        pub gl_flags: ::c_int,
+
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::size_t,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::size_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::size_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        #[cfg(not(any(
+            target_arch = "sparc",
+            target_arch = "sparc64",
+            target_arch = "mips",
+            target_arch = "mips64")))]
+        pub c_ispeed: ::speed_t,
+        #[cfg(not(any(
+            target_arch = "sparc",
+            target_arch = "sparc64",
+            target_arch = "mips",
+            target_arch = "mips64")))]
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct mallinfo {
+        pub arena: ::c_int,
+        pub ordblks: ::c_int,
+        pub smblks: ::c_int,
+        pub hblks: ::c_int,
+        pub hblkhd: ::c_int,
+        pub usmblks: ::c_int,
+        pub fsmblks: ::c_int,
+        pub uordblks: ::c_int,
+        pub fordblks: ::c_int,
+        pub keepcost: ::c_int,
+    }
+
+    pub struct nlmsghdr {
+        pub nlmsg_len: u32,
+        pub nlmsg_type: u16,
+        pub nlmsg_flags: u16,
+        pub nlmsg_seq: u32,
+        pub nlmsg_pid: u32,
+    }
+
+    pub struct nlmsgerr {
+        pub error: ::c_int,
+        pub msg: nlmsghdr,
+    }
+
+    pub struct nl_pktinfo {
+        pub group: u32,
+    }
+
+    pub struct nl_mmap_req {
+        pub nm_block_size: ::c_uint,
+        pub nm_block_nr: ::c_uint,
+        pub nm_frame_size: ::c_uint,
+        pub nm_frame_nr: ::c_uint,
+    }
+
+    pub struct nl_mmap_hdr {
+        pub nm_status: ::c_uint,
+        pub nm_len: ::c_uint,
+        pub nm_group: u32,
+        pub nm_pid: u32,
+        pub nm_uid: u32,
+        pub nm_gid: u32,
+    }
+
+    pub struct nlattr {
+        pub nla_len: u16,
+        pub nla_type: u16,
+    }
+
+    pub struct rtentry {
+        pub rt_pad1: ::c_ulong,
+        pub rt_dst: ::sockaddr,
+        pub rt_gateway: ::sockaddr,
+        pub rt_genmask: ::sockaddr,
+        pub rt_flags: ::c_ushort,
+        pub rt_pad2: ::c_short,
+        pub rt_pad3: ::c_ulong,
+        pub rt_tos: ::c_uchar,
+        pub rt_class: ::c_uchar,
+        #[cfg(target_pointer_width = "64")]
+        pub rt_pad4: [::c_short; 3usize],
+        #[cfg(not(target_pointer_width = "64"))]
+        pub rt_pad4: ::c_short,
+        pub rt_metric: ::c_short,
+        pub rt_dev: *mut ::c_char,
+        pub rt_mtu: ::c_ulong,
+        pub rt_window: ::c_ulong,
+        pub rt_irtt: ::c_ushort,
+    }
+
+    pub struct timex {
+        pub modes: ::c_uint,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub offset: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub offset: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub freq: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub freq: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub maxerror: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub maxerror: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub esterror: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub esterror: ::c_long,
+        pub status: ::c_int,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub constant: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub constant: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub precision: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub precision: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub tolerance: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub tolerance: ::c_long,
+        pub time: ::timeval,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub tick: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub tick: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub ppsfreq: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub ppsfreq: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub jitter: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub jitter: ::c_long,
+        pub shift: ::c_int,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub stabil: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub stabil: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub jitcnt: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub jitcnt: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub calcnt: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub calcnt: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub errcnt: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub errcnt: ::c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub stbcnt: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub stbcnt: ::c_long,
+        pub tai: ::c_int,
+        pub __unused1: i32,
+        pub __unused2: i32,
+        pub __unused3: i32,
+        pub __unused4: i32,
+        pub __unused5: i32,
+        pub __unused6: i32,
+        pub __unused7: i32,
+        pub __unused8: i32,
+        pub __unused9: i32,
+        pub __unused10: i32,
+        pub __unused11: i32,
+    }
+
+    pub struct ntptimeval {
+        pub time: ::timeval,
+        pub maxerror: ::c_long,
+        pub esterror: ::c_long,
+        pub tai: ::c_long,
+        pub __glibc_reserved1: ::c_long,
+        pub __glibc_reserved2: ::c_long,
+        pub __glibc_reserved3: ::c_long,
+        pub __glibc_reserved4: ::c_long,
+    }
+
+    pub struct regex_t {
+        __buffer: *mut ::c_void,
+        __allocated: ::size_t,
+        __used: ::size_t,
+        __syntax: ::c_ulong,
+        __fastmap: *mut ::c_char,
+        __translate: *mut ::c_char,
+        __re_nsub: ::size_t,
+        __bitfield: u8,
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_addr(&self) -> *mut ::c_void {
+        #[repr(C)]
+        struct siginfo_sigfault {
+            _si_signo: ::c_int,
+            _si_errno: ::c_int,
+            _si_code: ::c_int,
+            si_addr: *mut ::c_void,
+        }
+        (*(self as *const siginfo_t as *const siginfo_sigfault)).si_addr
+    }
+
+    pub unsafe fn si_value(&self) -> ::sigval {
+        #[repr(C)]
+        struct siginfo_timer {
+            _si_signo: ::c_int,
+            _si_errno: ::c_int,
+            _si_code: ::c_int,
+            _si_tid: ::c_int,
+            _si_overrun: ::c_int,
+            si_sigval: ::sigval,
+        }
+        (*(self as *const siginfo_t as *const siginfo_timer)).si_sigval
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        // Internal, for casts to access union fields
+        #[repr(C)]
+        struct sifields_sigchld {
+            si_pid: ::pid_t,
+            si_uid: ::uid_t,
+            si_status: ::c_int,
+            si_utime: ::c_long,
+            si_stime: ::c_long,
+        }
+        impl ::Copy for sifields_sigchld {}
+        impl ::Clone for sifields_sigchld {
+            fn clone(&self) -> sifields_sigchld {
+                *self
+            }
+        }
+
+        // Internal, for casts to access union fields
+        #[repr(C)]
+        union sifields {
+            _align_pointer: *mut ::c_void,
+            sigchld: sifields_sigchld,
+        }
+
+        // Internal, for casts to access union fields. Note that some variants
+        // of sifields start with a pointer, which makes the alignment of
+        // sifields vary on 32-bit and 64-bit architectures.
+        #[repr(C)]
+        struct siginfo_f {
+            _siginfo_base: [::c_int; 3],
+            sifields: sifields,
+        }
+
+        impl siginfo_t {
+            unsafe fn sifields(&self) -> &sifields {
+                &(*(self as *const siginfo_t as *const siginfo_f)).sifields
+            }
+
+            pub unsafe fn si_pid(&self) -> ::pid_t {
+                self.sifields().sigchld.si_pid
+            }
+
+            pub unsafe fn si_uid(&self) -> ::uid_t {
+                self.sifields().sigchld.si_uid
+            }
+
+            pub unsafe fn si_status(&self) -> ::c_int {
+                self.sifields().sigchld.si_status
+            }
+
+            pub unsafe fn si_utime(&self) -> ::c_long {
+                self.sifields().sigchld.si_utime
+            }
+
+            pub unsafe fn si_stime(&self) -> ::c_long {
+                self.sifields().sigchld.si_stime
+            }
+        }
+    }
+}
+
+s_no_extra_traits! {
+    pub struct utmpx {
+        pub ut_type: ::c_short,
+        pub ut_pid: ::pid_t,
+        pub ut_line: [::c_char; __UT_LINESIZE],
+        pub ut_id: [::c_char; 4],
+
+        pub ut_user: [::c_char; __UT_NAMESIZE],
+        pub ut_host: [::c_char; __UT_HOSTSIZE],
+        pub ut_exit: __exit_status,
+
+        #[cfg(any(target_arch = "aarch64",
+                  target_arch = "s390x",
+                  all(target_pointer_width = "32",
+                      not(target_arch = "x86_64"))))]
+        pub ut_session: ::c_long,
+        #[cfg(any(target_arch = "aarch64",
+                  target_arch = "s390x",
+                  all(target_pointer_width = "32",
+                      not(target_arch = "x86_64"))))]
+        pub ut_tv: ::timeval,
+
+        #[cfg(not(any(target_arch = "aarch64",
+                      target_arch = "s390x",
+                      all(target_pointer_width = "32",
+                          not(target_arch = "x86_64")))))]
+        pub ut_session: i32,
+        #[cfg(not(any(target_arch = "aarch64",
+                      target_arch = "s390x",
+                      all(target_pointer_width = "32",
+                          not(target_arch = "x86_64")))))]
+        pub ut_tv: __timeval,
+
+        pub ut_addr_v6: [i32; 4],
+        __glibc_reserved: [::c_char; 20],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for utmpx {
+            fn eq(&self, other: &utmpx) -> bool {
+                self.ut_type == other.ut_type
+                    && self.ut_pid == other.ut_pid
+                    && self.ut_line == other.ut_line
+                    && self.ut_id == other.ut_id
+                    && self.ut_user == other.ut_user
+                    && self
+                    .ut_host
+                    .iter()
+                    .zip(other.ut_host.iter())
+                    .all(|(a,b)| a == b)
+                    && self.ut_exit == other.ut_exit
+                    && self.ut_session == other.ut_session
+                    && self.ut_tv == other.ut_tv
+                    && self.ut_addr_v6 == other.ut_addr_v6
+                    && self.__glibc_reserved == other.__glibc_reserved
+            }
+        }
+
+        impl Eq for utmpx {}
+
+        impl ::fmt::Debug for utmpx {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmpx")
+                    .field("ut_type", &self.ut_type)
+                    .field("ut_pid", &self.ut_pid)
+                    .field("ut_line", &self.ut_line)
+                    .field("ut_id", &self.ut_id)
+                    .field("ut_user", &self.ut_user)
+                // FIXME: .field("ut_host", &self.ut_host)
+                    .field("ut_exit", &self.ut_exit)
+                    .field("ut_session", &self.ut_session)
+                    .field("ut_tv", &self.ut_tv)
+                    .field("ut_addr_v6", &self.ut_addr_v6)
+                    .field("__glibc_reserved", &self.__glibc_reserved)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utmpx {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_type.hash(state);
+                self.ut_pid.hash(state);
+                self.ut_line.hash(state);
+                self.ut_id.hash(state);
+                self.ut_user.hash(state);
+                self.ut_host.hash(state);
+                self.ut_exit.hash(state);
+                self.ut_session.hash(state);
+                self.ut_tv.hash(state);
+                self.ut_addr_v6.hash(state);
+                self.__glibc_reserved.hash(state);
+            }
+        }
+    }
+}
+
+// include/uapi/asm-generic/hugetlb_encode.h
+pub const HUGETLB_FLAG_ENCODE_SHIFT: ::c_int = 26;
+pub const HUGETLB_FLAG_ENCODE_MASK: ::c_int = 0x3f;
+
+pub const HUGETLB_FLAG_ENCODE_64KB: ::c_int = 16 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_512KB: ::c_int = 19 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_1MB: ::c_int = 20 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_2MB: ::c_int = 21 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_8MB: ::c_int = 23 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_16MB: ::c_int = 24 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_32MB: ::c_int = 25 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_256MB: ::c_int = 28 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_512MB: ::c_int = 29 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_1GB: ::c_int = 30 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_2GB: ::c_int = 31 << HUGETLB_FLAG_ENCODE_SHIFT;
+pub const HUGETLB_FLAG_ENCODE_16GB: ::c_int = 34 << HUGETLB_FLAG_ENCODE_SHIFT;
+
+// include/uapi/linux/mman.h
+/*
+ * Huge page size encoding when MAP_HUGETLB is specified, and a huge page
+ * size other than the default is desired.  See hugetlb_encode.h.
+ * All known huge page size encodings are provided here.  It is the
+ * responsibility of the application to know which sizes are supported on
+ * the running system.  See mmap(2) man page for details.
+ */
+pub const MAP_HUGE_SHIFT: ::c_int = HUGETLB_FLAG_ENCODE_SHIFT;
+pub const MAP_HUGE_MASK: ::c_int = HUGETLB_FLAG_ENCODE_MASK;
+
+pub const MAP_HUGE_64KB: ::c_int = HUGETLB_FLAG_ENCODE_64KB;
+pub const MAP_HUGE_512KB: ::c_int = HUGETLB_FLAG_ENCODE_512KB;
+pub const MAP_HUGE_1MB: ::c_int = HUGETLB_FLAG_ENCODE_1MB;
+pub const MAP_HUGE_2MB: ::c_int = HUGETLB_FLAG_ENCODE_2MB;
+pub const MAP_HUGE_8MB: ::c_int = HUGETLB_FLAG_ENCODE_8MB;
+pub const MAP_HUGE_16MB: ::c_int = HUGETLB_FLAG_ENCODE_16MB;
+pub const MAP_HUGE_32MB: ::c_int = HUGETLB_FLAG_ENCODE_32MB;
+pub const MAP_HUGE_256MB: ::c_int = HUGETLB_FLAG_ENCODE_256MB;
+pub const MAP_HUGE_512MB: ::c_int = HUGETLB_FLAG_ENCODE_512MB;
+pub const MAP_HUGE_1GB: ::c_int = HUGETLB_FLAG_ENCODE_1GB;
+pub const MAP_HUGE_2GB: ::c_int = HUGETLB_FLAG_ENCODE_2GB;
+pub const MAP_HUGE_16GB: ::c_int = HUGETLB_FLAG_ENCODE_16GB;
+
+pub const RLIMIT_CPU: ::__rlimit_resource_t = 0;
+pub const RLIMIT_FSIZE: ::__rlimit_resource_t = 1;
+pub const RLIMIT_DATA: ::__rlimit_resource_t = 2;
+pub const RLIMIT_STACK: ::__rlimit_resource_t = 3;
+pub const RLIMIT_CORE: ::__rlimit_resource_t = 4;
+pub const RLIMIT_LOCKS: ::__rlimit_resource_t = 10;
+pub const RLIMIT_SIGPENDING: ::__rlimit_resource_t = 11;
+pub const RLIMIT_MSGQUEUE: ::__rlimit_resource_t = 12;
+pub const RLIMIT_NICE: ::__rlimit_resource_t = 13;
+pub const RLIMIT_RTPRIO: ::__rlimit_resource_t = 14;
+pub const RLIMIT_RTTIME: ::__rlimit_resource_t = 15;
+pub const RLIMIT_NLIMITS: ::__rlimit_resource_t = 16;
+
+pub const PRIO_PROCESS: ::__priority_which_t = 0;
+pub const PRIO_PGRP: ::__priority_which_t = 1;
+pub const PRIO_USER: ::__priority_which_t = 2;
+
+pub const MS_RMT_MASK: ::c_ulong = 0x02800051;
+
+pub const __UT_LINESIZE: usize = 32;
+pub const __UT_NAMESIZE: usize = 32;
+pub const __UT_HOSTSIZE: usize = 256;
+pub const EMPTY: ::c_short = 0;
+pub const RUN_LVL: ::c_short = 1;
+pub const BOOT_TIME: ::c_short = 2;
+pub const NEW_TIME: ::c_short = 3;
+pub const OLD_TIME: ::c_short = 4;
+pub const INIT_PROCESS: ::c_short = 5;
+pub const LOGIN_PROCESS: ::c_short = 6;
+pub const USER_PROCESS: ::c_short = 7;
+pub const DEAD_PROCESS: ::c_short = 8;
+pub const ACCOUNTING: ::c_short = 9;
+
+// dlfcn.h
+pub const LM_ID_BASE: ::c_long = 0;
+pub const LM_ID_NEWLM: ::c_long = -1;
+
+pub const RTLD_DI_LMID: ::c_int = 1;
+pub const RTLD_DI_LINKMAP: ::c_int = 2;
+pub const RTLD_DI_CONFIGADDR: ::c_int = 3;
+pub const RTLD_DI_SERINFO: ::c_int = 4;
+pub const RTLD_DI_SERINFOSIZE: ::c_int = 5;
+pub const RTLD_DI_ORIGIN: ::c_int = 6;
+pub const RTLD_DI_PROFILENAME: ::c_int = 7;
+pub const RTLD_DI_PROFILEOUT: ::c_int = 8;
+pub const RTLD_DI_TLS_MODID: ::c_int = 9;
+pub const RTLD_DI_TLS_DATA: ::c_int = 10;
+
+pub const SOCK_NONBLOCK: ::c_int = O_NONBLOCK;
+
+pub const SOL_RXRPC: ::c_int = 272;
+pub const SOL_PPPOL2TP: ::c_int = 273;
+pub const SOL_PNPIPE: ::c_int = 275;
+pub const SOL_RDS: ::c_int = 276;
+pub const SOL_IUCV: ::c_int = 277;
+pub const SOL_CAIF: ::c_int = 278;
+pub const SOL_NFC: ::c_int = 280;
+pub const SOL_XDP: ::c_int = 283;
+
+pub const MSG_TRYHARD: ::c_int = 4;
+
+pub const LC_PAPER: ::c_int = 7;
+pub const LC_NAME: ::c_int = 8;
+pub const LC_ADDRESS: ::c_int = 9;
+pub const LC_TELEPHONE: ::c_int = 10;
+pub const LC_MEASUREMENT: ::c_int = 11;
+pub const LC_IDENTIFICATION: ::c_int = 12;
+pub const LC_PAPER_MASK: ::c_int = 1 << LC_PAPER;
+pub const LC_NAME_MASK: ::c_int = 1 << LC_NAME;
+pub const LC_ADDRESS_MASK: ::c_int = 1 << LC_ADDRESS;
+pub const LC_TELEPHONE_MASK: ::c_int = 1 << LC_TELEPHONE;
+pub const LC_MEASUREMENT_MASK: ::c_int = 1 << LC_MEASUREMENT;
+pub const LC_IDENTIFICATION_MASK: ::c_int = 1 << LC_IDENTIFICATION;
+pub const LC_ALL_MASK: ::c_int = ::LC_CTYPE_MASK
+    | ::LC_NUMERIC_MASK
+    | ::LC_TIME_MASK
+    | ::LC_COLLATE_MASK
+    | ::LC_MONETARY_MASK
+    | ::LC_MESSAGES_MASK
+    | LC_PAPER_MASK
+    | LC_NAME_MASK
+    | LC_ADDRESS_MASK
+    | LC_TELEPHONE_MASK
+    | LC_MEASUREMENT_MASK
+    | LC_IDENTIFICATION_MASK;
+
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const SOCK_DCCP: ::c_int = 6;
+pub const SOCK_PACKET: ::c_int = 10;
+
+pub const TCP_COOKIE_TRANSACTIONS: ::c_int = 15;
+pub const TCP_THIN_LINEAR_TIMEOUTS: ::c_int = 16;
+pub const TCP_THIN_DUPACK: ::c_int = 17;
+pub const TCP_USER_TIMEOUT: ::c_int = 18;
+pub const TCP_REPAIR: ::c_int = 19;
+pub const TCP_REPAIR_QUEUE: ::c_int = 20;
+pub const TCP_QUEUE_SEQ: ::c_int = 21;
+pub const TCP_REPAIR_OPTIONS: ::c_int = 22;
+pub const TCP_FASTOPEN: ::c_int = 23;
+pub const TCP_TIMESTAMP: ::c_int = 24;
+pub const TCP_FASTOPEN_CONNECT: ::c_int = 30;
+
+/* DCCP socket options */
+pub const DCCP_SOCKOPT_PACKET_SIZE: ::c_int = 1;
+pub const DCCP_SOCKOPT_SERVICE: ::c_int = 2;
+pub const DCCP_SOCKOPT_CHANGE_L: ::c_int = 3;
+pub const DCCP_SOCKOPT_CHANGE_R: ::c_int = 4;
+pub const DCCP_SOCKOPT_GET_CUR_MPS: ::c_int = 5;
+pub const DCCP_SOCKOPT_SERVER_TIMEWAIT: ::c_int = 6;
+pub const DCCP_SOCKOPT_SEND_CSCOV: ::c_int = 10;
+pub const DCCP_SOCKOPT_RECV_CSCOV: ::c_int = 11;
+pub const DCCP_SOCKOPT_AVAILABLE_CCIDS: ::c_int = 12;
+pub const DCCP_SOCKOPT_CCID: ::c_int = 13;
+pub const DCCP_SOCKOPT_TX_CCID: ::c_int = 14;
+pub const DCCP_SOCKOPT_RX_CCID: ::c_int = 15;
+pub const DCCP_SOCKOPT_QPOLICY_ID: ::c_int = 16;
+pub const DCCP_SOCKOPT_QPOLICY_TXQLEN: ::c_int = 17;
+pub const DCCP_SOCKOPT_CCID_RX_INFO: ::c_int = 128;
+pub const DCCP_SOCKOPT_CCID_TX_INFO: ::c_int = 192;
+
+/// maximum number of services provided on the same listening port
+pub const DCCP_SERVICE_LIST_MAX_LEN: ::c_int = 32;
+
+pub const SIGEV_THREAD_ID: ::c_int = 4;
+
+pub const BUFSIZ: ::c_uint = 8192;
+pub const TMP_MAX: ::c_uint = 238328;
+pub const FOPEN_MAX: ::c_uint = 16;
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+pub const _SC_EQUIV_CLASS_MAX: ::c_int = 41;
+pub const _SC_CHARCLASS_NAME_MAX: ::c_int = 45;
+pub const _SC_PII: ::c_int = 53;
+pub const _SC_PII_XTI: ::c_int = 54;
+pub const _SC_PII_SOCKET: ::c_int = 55;
+pub const _SC_PII_INTERNET: ::c_int = 56;
+pub const _SC_PII_OSI: ::c_int = 57;
+pub const _SC_POLL: ::c_int = 58;
+pub const _SC_SELECT: ::c_int = 59;
+pub const _SC_PII_INTERNET_STREAM: ::c_int = 61;
+pub const _SC_PII_INTERNET_DGRAM: ::c_int = 62;
+pub const _SC_PII_OSI_COTS: ::c_int = 63;
+pub const _SC_PII_OSI_CLTS: ::c_int = 64;
+pub const _SC_PII_OSI_M: ::c_int = 65;
+pub const _SC_T_IOV_MAX: ::c_int = 66;
+pub const _SC_2_C_VERSION: ::c_int = 96;
+pub const _SC_CHAR_BIT: ::c_int = 101;
+pub const _SC_CHAR_MAX: ::c_int = 102;
+pub const _SC_CHAR_MIN: ::c_int = 103;
+pub const _SC_INT_MAX: ::c_int = 104;
+pub const _SC_INT_MIN: ::c_int = 105;
+pub const _SC_LONG_BIT: ::c_int = 106;
+pub const _SC_WORD_BIT: ::c_int = 107;
+pub const _SC_MB_LEN_MAX: ::c_int = 108;
+pub const _SC_SSIZE_MAX: ::c_int = 110;
+pub const _SC_SCHAR_MAX: ::c_int = 111;
+pub const _SC_SCHAR_MIN: ::c_int = 112;
+pub const _SC_SHRT_MAX: ::c_int = 113;
+pub const _SC_SHRT_MIN: ::c_int = 114;
+pub const _SC_UCHAR_MAX: ::c_int = 115;
+pub const _SC_UINT_MAX: ::c_int = 116;
+pub const _SC_ULONG_MAX: ::c_int = 117;
+pub const _SC_USHRT_MAX: ::c_int = 118;
+pub const _SC_NL_ARGMAX: ::c_int = 119;
+pub const _SC_NL_LANGMAX: ::c_int = 120;
+pub const _SC_NL_MSGMAX: ::c_int = 121;
+pub const _SC_NL_NMAX: ::c_int = 122;
+pub const _SC_NL_SETMAX: ::c_int = 123;
+pub const _SC_NL_TEXTMAX: ::c_int = 124;
+pub const _SC_BASE: ::c_int = 134;
+pub const _SC_C_LANG_SUPPORT: ::c_int = 135;
+pub const _SC_C_LANG_SUPPORT_R: ::c_int = 136;
+pub const _SC_DEVICE_IO: ::c_int = 140;
+pub const _SC_DEVICE_SPECIFIC: ::c_int = 141;
+pub const _SC_DEVICE_SPECIFIC_R: ::c_int = 142;
+pub const _SC_FD_MGMT: ::c_int = 143;
+pub const _SC_FIFO: ::c_int = 144;
+pub const _SC_PIPE: ::c_int = 145;
+pub const _SC_FILE_ATTRIBUTES: ::c_int = 146;
+pub const _SC_FILE_LOCKING: ::c_int = 147;
+pub const _SC_FILE_SYSTEM: ::c_int = 148;
+pub const _SC_MULTI_PROCESS: ::c_int = 150;
+pub const _SC_SINGLE_PROCESS: ::c_int = 151;
+pub const _SC_NETWORKING: ::c_int = 152;
+pub const _SC_REGEX_VERSION: ::c_int = 156;
+pub const _SC_SIGNALS: ::c_int = 158;
+pub const _SC_SYSTEM_DATABASE: ::c_int = 162;
+pub const _SC_SYSTEM_DATABASE_R: ::c_int = 163;
+pub const _SC_USER_GROUPS: ::c_int = 166;
+pub const _SC_USER_GROUPS_R: ::c_int = 167;
+pub const _SC_LEVEL1_ICACHE_SIZE: ::c_int = 185;
+pub const _SC_LEVEL1_ICACHE_ASSOC: ::c_int = 186;
+pub const _SC_LEVEL1_ICACHE_LINESIZE: ::c_int = 187;
+pub const _SC_LEVEL1_DCACHE_SIZE: ::c_int = 188;
+pub const _SC_LEVEL1_DCACHE_ASSOC: ::c_int = 189;
+pub const _SC_LEVEL1_DCACHE_LINESIZE: ::c_int = 190;
+pub const _SC_LEVEL2_CACHE_SIZE: ::c_int = 191;
+pub const _SC_LEVEL2_CACHE_ASSOC: ::c_int = 192;
+pub const _SC_LEVEL2_CACHE_LINESIZE: ::c_int = 193;
+pub const _SC_LEVEL3_CACHE_SIZE: ::c_int = 194;
+pub const _SC_LEVEL3_CACHE_ASSOC: ::c_int = 195;
+pub const _SC_LEVEL3_CACHE_LINESIZE: ::c_int = 196;
+pub const _SC_LEVEL4_CACHE_SIZE: ::c_int = 197;
+pub const _SC_LEVEL4_CACHE_ASSOC: ::c_int = 198;
+pub const _SC_LEVEL4_CACHE_LINESIZE: ::c_int = 199;
+pub const O_ACCMODE: ::c_int = 3;
+pub const ST_RELATIME: ::c_ulong = 4096;
+pub const NI_MAXHOST: ::socklen_t = 1025;
+
+cfg_if! {
+    if #[cfg(not(target_arch = "s390x"))] {
+        pub const ADFS_SUPER_MAGIC: ::c_long = 0x0000adf5;
+        pub const AFFS_SUPER_MAGIC: ::c_long = 0x0000adff;
+        pub const AFS_SUPER_MAGIC: ::c_long = 0x5346414f;
+        pub const AUTOFS_SUPER_MAGIC: ::c_long = 0x0187;
+        pub const BINDERFS_SUPER_MAGIC: ::c_long = 0x6c6f6f70;
+        pub const BPF_FS_MAGIC: ::c_long = 0xcafe4a11;
+        pub const BTRFS_SUPER_MAGIC: ::c_long = 0x9123683e;
+        pub const CGROUP2_SUPER_MAGIC: ::c_long = 0x63677270;
+        pub const CGROUP_SUPER_MAGIC: ::c_long = 0x27e0eb;
+        pub const CODA_SUPER_MAGIC: ::c_long = 0x73757245;
+        pub const CRAMFS_MAGIC: ::c_long = 0x28cd3d45;
+        pub const DEBUGFS_MAGIC: ::c_long = 0x64626720;
+        pub const DEVPTS_SUPER_MAGIC: ::c_long = 0x1cd1;
+        pub const ECRYPTFS_SUPER_MAGIC: ::c_long = 0xf15f;
+        pub const EFS_SUPER_MAGIC: ::c_long = 0x00414a53;
+        pub const EXT2_SUPER_MAGIC: ::c_long = 0x0000ef53;
+        pub const EXT3_SUPER_MAGIC: ::c_long = 0x0000ef53;
+        pub const EXT4_SUPER_MAGIC: ::c_long = 0x0000ef53;
+        pub const F2FS_SUPER_MAGIC: ::c_long = 0xf2f52010;
+        pub const FUTEXFS_SUPER_MAGIC: ::c_long = 0xbad1dea;
+        pub const HOSTFS_SUPER_MAGIC: ::c_long = 0x00c0ffee;
+        pub const HPFS_SUPER_MAGIC: ::c_long = 0xf995e849;
+        pub const HUGETLBFS_MAGIC: ::c_long = 0x958458f6;
+        pub const ISOFS_SUPER_MAGIC: ::c_long = 0x00009660;
+        pub const JFFS2_SUPER_MAGIC: ::c_long = 0x000072b6;
+        pub const MINIX2_SUPER_MAGIC2: ::c_long = 0x00002478;
+        pub const MINIX2_SUPER_MAGIC: ::c_long = 0x00002468;
+        pub const MINIX3_SUPER_MAGIC: ::c_long = 0x4d5a;
+        pub const MINIX_SUPER_MAGIC2: ::c_long = 0x0000138f;
+        pub const MINIX_SUPER_MAGIC: ::c_long = 0x0000137f;
+        pub const MSDOS_SUPER_MAGIC: ::c_long = 0x00004d44;
+        pub const NCP_SUPER_MAGIC: ::c_long = 0x0000564c;
+        pub const NFS_SUPER_MAGIC: ::c_long = 0x00006969;
+        pub const NILFS_SUPER_MAGIC: ::c_long = 0x3434;
+        pub const OCFS2_SUPER_MAGIC: ::c_long = 0x7461636f;
+        pub const OPENPROM_SUPER_MAGIC: ::c_long = 0x00009fa1;
+        pub const OVERLAYFS_SUPER_MAGIC: ::c_long = 0x794c7630;
+        pub const PROC_SUPER_MAGIC: ::c_long = 0x00009fa0;
+        pub const QNX4_SUPER_MAGIC: ::c_long = 0x0000002f;
+        pub const QNX6_SUPER_MAGIC: ::c_long = 0x68191122;
+        pub const RDTGROUP_SUPER_MAGIC: ::c_long = 0x7655821;
+        pub const REISERFS_SUPER_MAGIC: ::c_long = 0x52654973;
+        pub const SMB_SUPER_MAGIC: ::c_long = 0x0000517b;
+        pub const SYSFS_MAGIC: ::c_long = 0x62656572;
+        pub const TMPFS_MAGIC: ::c_long = 0x01021994;
+        pub const TRACEFS_MAGIC: ::c_long = 0x74726163;
+        pub const UDF_SUPER_MAGIC: ::c_long = 0x15013346;
+        pub const USBDEVICE_SUPER_MAGIC: ::c_long = 0x00009fa2;
+        pub const XENFS_SUPER_MAGIC: ::c_long = 0xabba1974;
+        pub const XFS_SUPER_MAGIC: ::c_long = 0x58465342;
+    } else if #[cfg(target_arch = "s390x")] {
+        pub const ADFS_SUPER_MAGIC: ::c_uint = 0x0000adf5;
+        pub const AFFS_SUPER_MAGIC: ::c_uint = 0x0000adff;
+        pub const AFS_SUPER_MAGIC: ::c_uint = 0x5346414f;
+        pub const AUTOFS_SUPER_MAGIC: ::c_uint = 0x0187;
+        pub const BINDERFS_SUPER_MAGIC: ::c_uint = 0x6c6f6f70;
+        pub const BPF_FS_MAGIC: ::c_uint = 0xcafe4a11;
+        pub const BTRFS_SUPER_MAGIC: ::c_uint = 0x9123683e;
+        pub const CGROUP2_SUPER_MAGIC: ::c_uint = 0x63677270;
+        pub const CGROUP_SUPER_MAGIC: ::c_uint = 0x27e0eb;
+        pub const CODA_SUPER_MAGIC: ::c_uint = 0x73757245;
+        pub const CRAMFS_MAGIC: ::c_uint = 0x28cd3d45;
+        pub const DEBUGFS_MAGIC: ::c_uint = 0x64626720;
+        pub const DEVPTS_SUPER_MAGIC: ::c_uint = 0x1cd1;
+        pub const ECRYPTFS_SUPER_MAGIC: ::c_uint = 0xf15f;
+        pub const EFS_SUPER_MAGIC: ::c_uint = 0x00414a53;
+        pub const EXT2_SUPER_MAGIC: ::c_uint = 0x0000ef53;
+        pub const EXT3_SUPER_MAGIC: ::c_uint = 0x0000ef53;
+        pub const EXT4_SUPER_MAGIC: ::c_uint = 0x0000ef53;
+        pub const F2FS_SUPER_MAGIC: ::c_uint = 0xf2f52010;
+        pub const FUTEXFS_SUPER_MAGIC: ::c_uint = 0xbad1dea;
+        pub const HOSTFS_SUPER_MAGIC: ::c_uint = 0x00c0ffee;
+        pub const HPFS_SUPER_MAGIC: ::c_uint = 0xf995e849;
+        pub const HUGETLBFS_MAGIC: ::c_uint = 0x958458f6;
+        pub const ISOFS_SUPER_MAGIC: ::c_uint = 0x00009660;
+        pub const JFFS2_SUPER_MAGIC: ::c_uint = 0x000072b6;
+        pub const MINIX2_SUPER_MAGIC2: ::c_uint = 0x00002478;
+        pub const MINIX2_SUPER_MAGIC: ::c_uint = 0x00002468;
+        pub const MINIX3_SUPER_MAGIC: ::c_uint = 0x4d5a;
+        pub const MINIX_SUPER_MAGIC2: ::c_uint = 0x0000138f;
+        pub const MINIX_SUPER_MAGIC: ::c_uint = 0x0000137f;
+        pub const MSDOS_SUPER_MAGIC: ::c_uint = 0x00004d44;
+        pub const NCP_SUPER_MAGIC: ::c_uint = 0x0000564c;
+        pub const NFS_SUPER_MAGIC: ::c_uint = 0x00006969;
+        pub const NILFS_SUPER_MAGIC: ::c_uint = 0x3434;
+        pub const OCFS2_SUPER_MAGIC: ::c_uint = 0x7461636f;
+        pub const OPENPROM_SUPER_MAGIC: ::c_uint = 0x00009fa1;
+        pub const OVERLAYFS_SUPER_MAGIC: ::c_uint = 0x794c7630;
+        pub const PROC_SUPER_MAGIC: ::c_uint = 0x00009fa0;
+        pub const QNX4_SUPER_MAGIC: ::c_uint = 0x0000002f;
+        pub const QNX6_SUPER_MAGIC: ::c_uint = 0x68191122;
+        pub const RDTGROUP_SUPER_MAGIC: ::c_uint = 0x7655821;
+        pub const REISERFS_SUPER_MAGIC: ::c_uint = 0x52654973;
+        pub const SMB_SUPER_MAGIC: ::c_uint = 0x0000517b;
+        pub const SYSFS_MAGIC: ::c_uint = 0x62656572;
+        pub const TMPFS_MAGIC: ::c_uint = 0x01021994;
+        pub const TRACEFS_MAGIC: ::c_uint = 0x74726163;
+        pub const UDF_SUPER_MAGIC: ::c_uint = 0x15013346;
+        pub const USBDEVICE_SUPER_MAGIC: ::c_uint = 0x00009fa2;
+        pub const XENFS_SUPER_MAGIC: ::c_uint = 0xabba1974;
+        pub const XFS_SUPER_MAGIC: ::c_uint = 0x58465342;
+    }
+}
+
+pub const CPU_SETSIZE: ::c_int = 0x400;
+
+pub const PTRACE_TRACEME: ::c_uint = 0;
+pub const PTRACE_PEEKTEXT: ::c_uint = 1;
+pub const PTRACE_PEEKDATA: ::c_uint = 2;
+pub const PTRACE_PEEKUSER: ::c_uint = 3;
+pub const PTRACE_POKETEXT: ::c_uint = 4;
+pub const PTRACE_POKEDATA: ::c_uint = 5;
+pub const PTRACE_POKEUSER: ::c_uint = 6;
+pub const PTRACE_CONT: ::c_uint = 7;
+pub const PTRACE_KILL: ::c_uint = 8;
+pub const PTRACE_SINGLESTEP: ::c_uint = 9;
+pub const PTRACE_ATTACH: ::c_uint = 16;
+pub const PTRACE_SYSCALL: ::c_uint = 24;
+pub const PTRACE_SETOPTIONS: ::c_uint = 0x4200;
+pub const PTRACE_GETEVENTMSG: ::c_uint = 0x4201;
+pub const PTRACE_GETSIGINFO: ::c_uint = 0x4202;
+pub const PTRACE_SETSIGINFO: ::c_uint = 0x4203;
+pub const PTRACE_GETREGSET: ::c_uint = 0x4204;
+pub const PTRACE_SETREGSET: ::c_uint = 0x4205;
+pub const PTRACE_SEIZE: ::c_uint = 0x4206;
+pub const PTRACE_INTERRUPT: ::c_uint = 0x4207;
+pub const PTRACE_LISTEN: ::c_uint = 0x4208;
+pub const PTRACE_PEEKSIGINFO: ::c_uint = 0x4209;
+
+pub const EPOLLWAKEUP: ::c_int = 0x20000000;
+
+pub const SEEK_DATA: ::c_int = 3;
+pub const SEEK_HOLE: ::c_int = 4;
+
+// linux/rtnetlink.h
+pub const TCA_PAD: ::c_ushort = 9;
+pub const TCA_DUMP_INVISIBLE: ::c_ushort = 10;
+pub const TCA_CHAIN: ::c_ushort = 11;
+pub const TCA_HW_OFFLOAD: ::c_ushort = 12;
+
+pub const RTM_DELNETCONF: u16 = 81;
+pub const RTM_NEWSTATS: u16 = 92;
+pub const RTM_GETSTATS: u16 = 94;
+pub const RTM_NEWCACHEREPORT: u16 = 96;
+
+pub const RTM_F_LOOKUP_TABLE: ::c_uint = 0x1000;
+pub const RTM_F_FIB_MATCH: ::c_uint = 0x2000;
+
+pub const RTA_VIA: ::c_ushort = 18;
+pub const RTA_NEWDST: ::c_ushort = 19;
+pub const RTA_PREF: ::c_ushort = 20;
+pub const RTA_ENCAP_TYPE: ::c_ushort = 21;
+pub const RTA_ENCAP: ::c_ushort = 22;
+pub const RTA_EXPIRES: ::c_ushort = 23;
+pub const RTA_PAD: ::c_ushort = 24;
+pub const RTA_UID: ::c_ushort = 25;
+pub const RTA_TTL_PROPAGATE: ::c_ushort = 26;
+
+// linux/neighbor.h
+pub const NTF_EXT_LEARNED: u8 = 0x10;
+pub const NTF_OFFLOADED: u8 = 0x20;
+
+pub const NDA_MASTER: ::c_ushort = 9;
+pub const NDA_LINK_NETNSID: ::c_ushort = 10;
+pub const NDA_SRC_VNI: ::c_ushort = 11;
+
+// linux/personality.h
+pub const UNAME26: ::c_int = 0x0020000;
+pub const FDPIC_FUNCPTRS: ::c_int = 0x0080000;
+
+// linux/if_addr.h
+pub const IFA_FLAGS: ::c_ushort = 8;
+
+pub const IFA_F_MANAGETEMPADDR: u32 = 0x100;
+pub const IFA_F_NOPREFIXROUTE: u32 = 0x200;
+pub const IFA_F_MCAUTOJOIN: u32 = 0x400;
+pub const IFA_F_STABLE_PRIVACY: u32 = 0x800;
+
+pub const MAX_LINKS: ::c_int = 32;
+
+pub const GENL_UNS_ADMIN_PERM: ::c_int = 0x10;
+
+pub const GENL_ID_VFS_DQUOT: ::c_int = ::NLMSG_MIN_TYPE + 1;
+pub const GENL_ID_PMCRAID: ::c_int = ::NLMSG_MIN_TYPE + 2;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+pub const NF_NETDEV_INGRESS: ::c_int = 0;
+pub const NF_NETDEV_NUMHOOKS: ::c_int = 1;
+
+pub const NFPROTO_INET: ::c_int = 1;
+pub const NFPROTO_NETDEV: ::c_int = 5;
+
+// linux/keyctl.h
+pub const KEYCTL_DH_COMPUTE: u32 = 23;
+pub const KEYCTL_PKEY_QUERY: u32 = 24;
+pub const KEYCTL_PKEY_ENCRYPT: u32 = 25;
+pub const KEYCTL_PKEY_DECRYPT: u32 = 26;
+pub const KEYCTL_PKEY_SIGN: u32 = 27;
+pub const KEYCTL_PKEY_VERIFY: u32 = 28;
+pub const KEYCTL_RESTRICT_KEYRING: u32 = 29;
+
+pub const KEYCTL_SUPPORTS_ENCRYPT: u32 = 0x01;
+pub const KEYCTL_SUPPORTS_DECRYPT: u32 = 0x02;
+pub const KEYCTL_SUPPORTS_SIGN: u32 = 0x04;
+pub const KEYCTL_SUPPORTS_VERIFY: u32 = 0x08;
+cfg_if! {
+    if #[cfg(not(any(target_arch="mips", target_arch="mips64")))] {
+        pub const KEYCTL_MOVE: u32 = 30;
+        pub const KEYCTL_CAPABILITIES: u32 = 31;
+
+        pub const KEYCTL_CAPS0_CAPABILITIES: u32 = 0x01;
+        pub const KEYCTL_CAPS0_PERSISTENT_KEYRINGS: u32 = 0x02;
+        pub const KEYCTL_CAPS0_DIFFIE_HELLMAN: u32 = 0x04;
+        pub const KEYCTL_CAPS0_PUBLIC_KEY: u32 = 0x08;
+        pub const KEYCTL_CAPS0_BIG_KEY: u32 = 0x10;
+        pub const KEYCTL_CAPS0_INVALIDATE: u32 = 0x20;
+        pub const KEYCTL_CAPS0_RESTRICT_KEYRING: u32 = 0x40;
+        pub const KEYCTL_CAPS0_MOVE: u32 = 0x80;
+        pub const KEYCTL_CAPS1_NS_KEYRING_NAME: u32 = 0x01;
+        pub const KEYCTL_CAPS1_NS_KEY_TAG: u32 = 0x02;
+    }
+}
+
+// linux/netfilter/nf_tables.h
+pub const NFT_TABLE_MAXNAMELEN: ::c_int = 256;
+pub const NFT_CHAIN_MAXNAMELEN: ::c_int = 256;
+pub const NFT_SET_MAXNAMELEN: ::c_int = 256;
+pub const NFT_OBJ_MAXNAMELEN: ::c_int = 256;
+pub const NFT_USERDATA_MAXLEN: ::c_int = 256;
+
+pub const NFT_REG_VERDICT: ::c_int = 0;
+pub const NFT_REG_1: ::c_int = 1;
+pub const NFT_REG_2: ::c_int = 2;
+pub const NFT_REG_3: ::c_int = 3;
+pub const NFT_REG_4: ::c_int = 4;
+pub const __NFT_REG_MAX: ::c_int = 5;
+pub const NFT_REG32_00: ::c_int = 8;
+pub const NFT_REG32_01: ::c_int = 9;
+pub const NFT_REG32_02: ::c_int = 10;
+pub const NFT_REG32_03: ::c_int = 11;
+pub const NFT_REG32_04: ::c_int = 12;
+pub const NFT_REG32_05: ::c_int = 13;
+pub const NFT_REG32_06: ::c_int = 14;
+pub const NFT_REG32_07: ::c_int = 15;
+pub const NFT_REG32_08: ::c_int = 16;
+pub const NFT_REG32_09: ::c_int = 17;
+pub const NFT_REG32_10: ::c_int = 18;
+pub const NFT_REG32_11: ::c_int = 19;
+pub const NFT_REG32_12: ::c_int = 20;
+pub const NFT_REG32_13: ::c_int = 21;
+pub const NFT_REG32_14: ::c_int = 22;
+pub const NFT_REG32_15: ::c_int = 23;
+
+pub const NFT_REG_SIZE: ::c_int = 16;
+pub const NFT_REG32_SIZE: ::c_int = 4;
+
+pub const NFT_CONTINUE: ::c_int = -1;
+pub const NFT_BREAK: ::c_int = -2;
+pub const NFT_JUMP: ::c_int = -3;
+pub const NFT_GOTO: ::c_int = -4;
+pub const NFT_RETURN: ::c_int = -5;
+
+pub const NFT_MSG_NEWTABLE: ::c_int = 0;
+pub const NFT_MSG_GETTABLE: ::c_int = 1;
+pub const NFT_MSG_DELTABLE: ::c_int = 2;
+pub const NFT_MSG_NEWCHAIN: ::c_int = 3;
+pub const NFT_MSG_GETCHAIN: ::c_int = 4;
+pub const NFT_MSG_DELCHAIN: ::c_int = 5;
+pub const NFT_MSG_NEWRULE: ::c_int = 6;
+pub const NFT_MSG_GETRULE: ::c_int = 7;
+pub const NFT_MSG_DELRULE: ::c_int = 8;
+pub const NFT_MSG_NEWSET: ::c_int = 9;
+pub const NFT_MSG_GETSET: ::c_int = 10;
+pub const NFT_MSG_DELSET: ::c_int = 11;
+pub const NFT_MSG_NEWSETELEM: ::c_int = 12;
+pub const NFT_MSG_GETSETELEM: ::c_int = 13;
+pub const NFT_MSG_DELSETELEM: ::c_int = 14;
+pub const NFT_MSG_NEWGEN: ::c_int = 15;
+pub const NFT_MSG_GETGEN: ::c_int = 16;
+pub const NFT_MSG_TRACE: ::c_int = 17;
+cfg_if! {
+    if #[cfg(not(target_arch = "sparc64"))] {
+        pub const NFT_MSG_NEWOBJ: ::c_int = 18;
+        pub const NFT_MSG_GETOBJ: ::c_int = 19;
+        pub const NFT_MSG_DELOBJ: ::c_int = 20;
+        pub const NFT_MSG_GETOBJ_RESET: ::c_int = 21;
+    }
+}
+pub const NFT_MSG_MAX: ::c_int = 25;
+
+pub const NFT_SET_ANONYMOUS: ::c_int = 0x1;
+pub const NFT_SET_CONSTANT: ::c_int = 0x2;
+pub const NFT_SET_INTERVAL: ::c_int = 0x4;
+pub const NFT_SET_MAP: ::c_int = 0x8;
+pub const NFT_SET_TIMEOUT: ::c_int = 0x10;
+pub const NFT_SET_EVAL: ::c_int = 0x20;
+
+pub const NFT_SET_POL_PERFORMANCE: ::c_int = 0;
+pub const NFT_SET_POL_MEMORY: ::c_int = 1;
+
+pub const NFT_SET_ELEM_INTERVAL_END: ::c_int = 0x1;
+
+pub const NFT_DATA_VALUE: ::c_uint = 0;
+pub const NFT_DATA_VERDICT: ::c_uint = 0xffffff00;
+
+pub const NFT_DATA_RESERVED_MASK: ::c_uint = 0xffffff00;
+
+pub const NFT_DATA_VALUE_MAXLEN: ::c_int = 64;
+
+pub const NFT_BYTEORDER_NTOH: ::c_int = 0;
+pub const NFT_BYTEORDER_HTON: ::c_int = 1;
+
+pub const NFT_CMP_EQ: ::c_int = 0;
+pub const NFT_CMP_NEQ: ::c_int = 1;
+pub const NFT_CMP_LT: ::c_int = 2;
+pub const NFT_CMP_LTE: ::c_int = 3;
+pub const NFT_CMP_GT: ::c_int = 4;
+pub const NFT_CMP_GTE: ::c_int = 5;
+
+pub const NFT_RANGE_EQ: ::c_int = 0;
+pub const NFT_RANGE_NEQ: ::c_int = 1;
+
+pub const NFT_LOOKUP_F_INV: ::c_int = 1 << 0;
+
+pub const NFT_DYNSET_OP_ADD: ::c_int = 0;
+pub const NFT_DYNSET_OP_UPDATE: ::c_int = 1;
+
+pub const NFT_DYNSET_F_INV: ::c_int = 1 << 0;
+
+pub const NFT_PAYLOAD_LL_HEADER: ::c_int = 0;
+pub const NFT_PAYLOAD_NETWORK_HEADER: ::c_int = 1;
+pub const NFT_PAYLOAD_TRANSPORT_HEADER: ::c_int = 2;
+
+pub const NFT_PAYLOAD_CSUM_NONE: ::c_int = 0;
+pub const NFT_PAYLOAD_CSUM_INET: ::c_int = 1;
+
+pub const NFT_META_LEN: ::c_int = 0;
+pub const NFT_META_PROTOCOL: ::c_int = 1;
+pub const NFT_META_PRIORITY: ::c_int = 2;
+pub const NFT_META_MARK: ::c_int = 3;
+pub const NFT_META_IIF: ::c_int = 4;
+pub const NFT_META_OIF: ::c_int = 5;
+pub const NFT_META_IIFNAME: ::c_int = 6;
+pub const NFT_META_OIFNAME: ::c_int = 7;
+pub const NFT_META_IIFTYPE: ::c_int = 8;
+pub const NFT_META_OIFTYPE: ::c_int = 9;
+pub const NFT_META_SKUID: ::c_int = 10;
+pub const NFT_META_SKGID: ::c_int = 11;
+pub const NFT_META_NFTRACE: ::c_int = 12;
+pub const NFT_META_RTCLASSID: ::c_int = 13;
+pub const NFT_META_SECMARK: ::c_int = 14;
+pub const NFT_META_NFPROTO: ::c_int = 15;
+pub const NFT_META_L4PROTO: ::c_int = 16;
+pub const NFT_META_BRI_IIFNAME: ::c_int = 17;
+pub const NFT_META_BRI_OIFNAME: ::c_int = 18;
+pub const NFT_META_PKTTYPE: ::c_int = 19;
+pub const NFT_META_CPU: ::c_int = 20;
+pub const NFT_META_IIFGROUP: ::c_int = 21;
+pub const NFT_META_OIFGROUP: ::c_int = 22;
+pub const NFT_META_CGROUP: ::c_int = 23;
+pub const NFT_META_PRANDOM: ::c_int = 24;
+
+pub const NFT_CT_STATE: ::c_int = 0;
+pub const NFT_CT_DIRECTION: ::c_int = 1;
+pub const NFT_CT_STATUS: ::c_int = 2;
+pub const NFT_CT_MARK: ::c_int = 3;
+pub const NFT_CT_SECMARK: ::c_int = 4;
+pub const NFT_CT_EXPIRATION: ::c_int = 5;
+pub const NFT_CT_HELPER: ::c_int = 6;
+pub const NFT_CT_L3PROTOCOL: ::c_int = 7;
+pub const NFT_CT_SRC: ::c_int = 8;
+pub const NFT_CT_DST: ::c_int = 9;
+pub const NFT_CT_PROTOCOL: ::c_int = 10;
+pub const NFT_CT_PROTO_SRC: ::c_int = 11;
+pub const NFT_CT_PROTO_DST: ::c_int = 12;
+pub const NFT_CT_LABELS: ::c_int = 13;
+pub const NFT_CT_PKTS: ::c_int = 14;
+pub const NFT_CT_BYTES: ::c_int = 15;
+
+pub const NFT_LIMIT_PKTS: ::c_int = 0;
+pub const NFT_LIMIT_PKT_BYTES: ::c_int = 1;
+
+pub const NFT_LIMIT_F_INV: ::c_int = 1 << 0;
+
+pub const NFT_QUEUE_FLAG_BYPASS: ::c_int = 0x01;
+pub const NFT_QUEUE_FLAG_CPU_FANOUT: ::c_int = 0x02;
+pub const NFT_QUEUE_FLAG_MASK: ::c_int = 0x03;
+
+pub const NFT_QUOTA_F_INV: ::c_int = 1 << 0;
+
+pub const NFT_REJECT_ICMP_UNREACH: ::c_int = 0;
+pub const NFT_REJECT_TCP_RST: ::c_int = 1;
+pub const NFT_REJECT_ICMPX_UNREACH: ::c_int = 2;
+
+pub const NFT_REJECT_ICMPX_NO_ROUTE: ::c_int = 0;
+pub const NFT_REJECT_ICMPX_PORT_UNREACH: ::c_int = 1;
+pub const NFT_REJECT_ICMPX_HOST_UNREACH: ::c_int = 2;
+pub const NFT_REJECT_ICMPX_ADMIN_PROHIBITED: ::c_int = 3;
+
+pub const NFT_NAT_SNAT: ::c_int = 0;
+pub const NFT_NAT_DNAT: ::c_int = 1;
+
+pub const NFT_TRACETYPE_UNSPEC: ::c_int = 0;
+pub const NFT_TRACETYPE_POLICY: ::c_int = 1;
+pub const NFT_TRACETYPE_RETURN: ::c_int = 2;
+pub const NFT_TRACETYPE_RULE: ::c_int = 3;
+
+pub const NFT_NG_INCREMENTAL: ::c_int = 0;
+pub const NFT_NG_RANDOM: ::c_int = 1;
+
+pub const M_MXFAST: ::c_int = 1;
+pub const M_NLBLKS: ::c_int = 2;
+pub const M_GRAIN: ::c_int = 3;
+pub const M_KEEP: ::c_int = 4;
+pub const M_TRIM_THRESHOLD: ::c_int = -1;
+pub const M_TOP_PAD: ::c_int = -2;
+pub const M_MMAP_THRESHOLD: ::c_int = -3;
+pub const M_MMAP_MAX: ::c_int = -4;
+pub const M_CHECK_ACTION: ::c_int = -5;
+pub const M_PERTURB: ::c_int = -6;
+pub const M_ARENA_TEST: ::c_int = -7;
+pub const M_ARENA_MAX: ::c_int = -8;
+
+pub const AT_STATX_SYNC_TYPE: ::c_int = 0x6000;
+pub const AT_STATX_SYNC_AS_STAT: ::c_int = 0x0000;
+pub const AT_STATX_FORCE_SYNC: ::c_int = 0x2000;
+pub const AT_STATX_DONT_SYNC: ::c_int = 0x4000;
+pub const STATX_TYPE: ::c_uint = 0x0001;
+pub const STATX_MODE: ::c_uint = 0x0002;
+pub const STATX_NLINK: ::c_uint = 0x0004;
+pub const STATX_UID: ::c_uint = 0x0008;
+pub const STATX_GID: ::c_uint = 0x0010;
+pub const STATX_ATIME: ::c_uint = 0x0020;
+pub const STATX_MTIME: ::c_uint = 0x0040;
+pub const STATX_CTIME: ::c_uint = 0x0080;
+pub const STATX_INO: ::c_uint = 0x0100;
+pub const STATX_SIZE: ::c_uint = 0x0200;
+pub const STATX_BLOCKS: ::c_uint = 0x0400;
+pub const STATX_BASIC_STATS: ::c_uint = 0x07ff;
+pub const STATX_BTIME: ::c_uint = 0x0800;
+pub const STATX_ALL: ::c_uint = 0x0fff;
+pub const STATX__RESERVED: ::c_int = 0x80000000;
+pub const STATX_ATTR_COMPRESSED: ::c_int = 0x0004;
+pub const STATX_ATTR_IMMUTABLE: ::c_int = 0x0010;
+pub const STATX_ATTR_APPEND: ::c_int = 0x0020;
+pub const STATX_ATTR_NODUMP: ::c_int = 0x0040;
+pub const STATX_ATTR_ENCRYPTED: ::c_int = 0x0800;
+pub const STATX_ATTR_AUTOMOUNT: ::c_int = 0x1000;
+
+// sys/auxv.h
+pub const AT_NULL: ::c_ulong = 0;
+pub const AT_IGNORE: ::c_ulong = 1;
+pub const AT_EXECFD: ::c_ulong = 2;
+pub const AT_PHDR: ::c_ulong = 3;
+pub const AT_PHENT: ::c_ulong = 4;
+pub const AT_PHNUM: ::c_ulong = 5;
+pub const AT_PAGESZ: ::c_ulong = 6;
+pub const AT_BASE: ::c_ulong = 7;
+pub const AT_FLAGS: ::c_ulong = 8;
+pub const AT_ENTRY: ::c_ulong = 9;
+pub const AT_NOTELF: ::c_ulong = 10;
+pub const AT_UID: ::c_ulong = 11;
+pub const AT_EUID: ::c_ulong = 12;
+pub const AT_GID: ::c_ulong = 13;
+pub const AT_EGID: ::c_ulong = 14;
+pub const AT_PLATFORM: ::c_ulong = 15;
+pub const AT_HWCAP: ::c_ulong = 16;
+pub const AT_CLKTCK: ::c_ulong = 17;
+// AT_* values 18 through 22 are reserved
+pub const AT_SECURE: ::c_ulong = 23;
+pub const AT_BASE_PLATFORM: ::c_ulong = 24;
+pub const AT_RANDOM: ::c_ulong = 25;
+pub const AT_HWCAP2: ::c_ulong = 26;
+
+pub const AT_EXECFN: ::c_ulong = 31;
+
+//sys/timex.h
+pub const ADJ_OFFSET: ::c_uint = 0x0001;
+pub const ADJ_FREQUENCY: ::c_uint = 0x0002;
+pub const ADJ_MAXERROR: ::c_uint = 0x0004;
+pub const ADJ_ESTERROR: ::c_uint = 0x0008;
+pub const ADJ_STATUS: ::c_uint = 0x0010;
+pub const ADJ_TIMECONST: ::c_uint = 0x0020;
+pub const ADJ_TAI: ::c_uint = 0x0080;
+pub const ADJ_SETOFFSET: ::c_uint = 0x0100;
+pub const ADJ_MICRO: ::c_uint = 0x1000;
+pub const ADJ_NANO: ::c_uint = 0x2000;
+pub const ADJ_TICK: ::c_uint = 0x4000;
+pub const ADJ_OFFSET_SINGLESHOT: ::c_uint = 0x8001;
+pub const ADJ_OFFSET_SS_READ: ::c_uint = 0xa001;
+pub const MOD_OFFSET: ::c_uint = ADJ_OFFSET;
+pub const MOD_FREQUENCY: ::c_uint = ADJ_FREQUENCY;
+pub const MOD_MAXERROR: ::c_uint = ADJ_MAXERROR;
+pub const MOD_ESTERROR: ::c_uint = ADJ_ESTERROR;
+pub const MOD_STATUS: ::c_uint = ADJ_STATUS;
+pub const MOD_TIMECONST: ::c_uint = ADJ_TIMECONST;
+pub const MOD_CLKB: ::c_uint = ADJ_TICK;
+pub const MOD_CLKA: ::c_uint = ADJ_OFFSET_SINGLESHOT;
+pub const MOD_TAI: ::c_uint = ADJ_TAI;
+pub const MOD_MICRO: ::c_uint = ADJ_MICRO;
+pub const MOD_NANO: ::c_uint = ADJ_NANO;
+pub const STA_PLL: ::c_int = 0x0001;
+pub const STA_PPSFREQ: ::c_int = 0x0002;
+pub const STA_PPSTIME: ::c_int = 0x0004;
+pub const STA_FLL: ::c_int = 0x0008;
+pub const STA_INS: ::c_int = 0x0010;
+pub const STA_DEL: ::c_int = 0x0020;
+pub const STA_UNSYNC: ::c_int = 0x0040;
+pub const STA_FREQHOLD: ::c_int = 0x0080;
+pub const STA_PPSSIGNAL: ::c_int = 0x0100;
+pub const STA_PPSJITTER: ::c_int = 0x0200;
+pub const STA_PPSWANDER: ::c_int = 0x0400;
+pub const STA_PPSERROR: ::c_int = 0x0800;
+pub const STA_CLOCKERR: ::c_int = 0x1000;
+pub const STA_NANO: ::c_int = 0x2000;
+pub const STA_MODE: ::c_int = 0x4000;
+pub const STA_CLK: ::c_int = 0x8000;
+pub const STA_RONLY: ::c_int = STA_PPSSIGNAL
+    | STA_PPSJITTER
+    | STA_PPSWANDER
+    | STA_PPSERROR
+    | STA_CLOCKERR
+    | STA_NANO
+    | STA_MODE
+    | STA_CLK;
+pub const NTP_API: ::c_int = 4;
+pub const TIME_OK: ::c_int = 0;
+pub const TIME_INS: ::c_int = 1;
+pub const TIME_DEL: ::c_int = 2;
+pub const TIME_OOP: ::c_int = 3;
+pub const TIME_WAIT: ::c_int = 4;
+pub const TIME_ERROR: ::c_int = 5;
+pub const TIME_BAD: ::c_int = TIME_ERROR;
+pub const MAXTC: ::c_long = 6;
+
+cfg_if! {
+    if #[cfg(any(
+        target_arch = "arm",
+        target_arch = "x86",
+        target_arch = "x86_64",
+        target_arch = "s390x",
+        target_arch = "riscv64",
+        target_arch = "riscv32"
+    ))] {
+        pub const PTHREAD_STACK_MIN: ::size_t = 16384;
+    } else if #[cfg(any(
+               target_arch = "sparc",
+               target_arch = "sparc64"
+           ))] {
+        pub const PTHREAD_STACK_MIN: ::size_t = 0x6000;
+    } else {
+        pub const PTHREAD_STACK_MIN: ::size_t = 131072;
+    }
+}
+pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::c_int = 3;
+
+pub const REG_STARTEND: ::c_int = 4;
+
+pub const REG_EEND: ::c_int = 14;
+pub const REG_ESIZE: ::c_int = 15;
+pub const REG_ERPAREN: ::c_int = 16;
+
+extern "C" {
+    pub fn fgetspent_r(
+        fp: *mut ::FILE,
+        spbuf: *mut ::spwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        spbufp: *mut *mut ::spwd,
+    ) -> ::c_int;
+    pub fn sgetspent_r(
+        s: *const ::c_char,
+        spbuf: *mut ::spwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        spbufp: *mut *mut ::spwd,
+    ) -> ::c_int;
+    pub fn getspent_r(
+        spbuf: *mut ::spwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        spbufp: *mut *mut ::spwd,
+    ) -> ::c_int;
+    pub fn qsort_r(
+        base: *mut ::c_void,
+        num: ::size_t,
+        size: ::size_t,
+        compar: ::Option<
+            unsafe extern "C" fn(
+                *const ::c_void,
+                *const ::c_void,
+                *mut ::c_void,
+            ) -> ::c_int,
+        >,
+        arg: *mut ::c_void,
+    );
+    pub fn sendmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn recvmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+
+    pub fn getrlimit64(
+        resource: ::__rlimit_resource_t,
+        rlim: *mut ::rlimit64,
+    ) -> ::c_int;
+    pub fn setrlimit64(
+        resource: ::__rlimit_resource_t,
+        rlim: *const ::rlimit64,
+    ) -> ::c_int;
+    pub fn getrlimit(
+        resource: ::__rlimit_resource_t,
+        rlim: *mut ::rlimit,
+    ) -> ::c_int;
+    pub fn setrlimit(
+        resource: ::__rlimit_resource_t,
+        rlim: *const ::rlimit,
+    ) -> ::c_int;
+    pub fn prlimit(
+        pid: ::pid_t,
+        resource: ::__rlimit_resource_t,
+        new_limit: *const ::rlimit,
+        old_limit: *mut ::rlimit,
+    ) -> ::c_int;
+    pub fn prlimit64(
+        pid: ::pid_t,
+        resource: ::__rlimit_resource_t,
+        new_limit: *const ::rlimit64,
+        old_limit: *mut ::rlimit64,
+    ) -> ::c_int;
+    pub fn utmpname(file: *const ::c_char) -> ::c_int;
+    pub fn utmpxname(file: *const ::c_char) -> ::c_int;
+    pub fn getutxent() -> *mut utmpx;
+    pub fn getutxid(ut: *const utmpx) -> *mut utmpx;
+    pub fn getutxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn pututxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn setutxent();
+    pub fn endutxent();
+    pub fn getpt() -> ::c_int;
+    pub fn mallopt(param: ::c_int, value: ::c_int) -> ::c_int;
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;
+    pub fn statx(
+        dirfd: ::c_int,
+        pathname: *const c_char,
+        flags: ::c_int,
+        mask: ::c_uint,
+        statxbuf: *mut statx,
+    ) -> ::c_int;
+    pub fn getrandom(
+        buf: *mut ::c_void,
+        buflen: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+
+    pub fn memmem(
+        haystack: *const ::c_void,
+        haystacklen: ::size_t,
+        needle: *const ::c_void,
+        needlelen: ::size_t,
+    ) -> *mut ::c_void;
+    pub fn getauxval(type_: ::c_ulong) -> ::c_ulong;
+
+    pub fn adjtimex(buf: *mut timex) -> ::c_int;
+    pub fn ntp_adjtime(buf: *mut timex) -> ::c_int;
+    #[link_name = "ntp_gettimex"]
+    pub fn ntp_gettime(buf: *mut ntptimeval) -> ::c_int;
+    pub fn copy_file_range(
+        fd_in: ::c_int,
+        off_in: *mut ::off64_t,
+        fd_out: ::c_int,
+        off_out: *mut ::off64_t,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn fanotify_mark(
+        fd: ::c_int,
+        flags: ::c_uint,
+        mask: u64,
+        dirfd: ::c_int,
+        path: *const ::c_char,
+    ) -> ::c_int;
+}
+
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;
+    pub fn backtrace(buf: *mut *mut ::c_void, sz: ::c_int) -> ::c_int;
+    pub fn glob64(
+        pattern: *const ::c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut glob64_t,
+    ) -> ::c_int;
+    pub fn globfree64(pglob: *mut glob64_t);
+    pub fn ptrace(request: ::c_uint, ...) -> ::c_long;
+    pub fn pthread_attr_getaffinity_np(
+        attr: *const ::pthread_attr_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_setaffinity_np(
+        attr: *mut ::pthread_attr_t,
+        cpusetsize: ::size_t,
+        cpuset: *const ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn getpriority(which: ::__priority_which_t, who: ::id_t) -> ::c_int;
+    pub fn setpriority(
+        which: ::__priority_which_t,
+        who: ::id_t,
+        prio: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_getaffinity_np(
+        thread: ::pthread_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_setaffinity_np(
+        thread: ::pthread_t,
+        cpusetsize: ::size_t,
+        cpuset: *const ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_getkind_np(
+        attr: *const ::pthread_rwlockattr_t,
+        val: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_setkind_np(
+        attr: *mut ::pthread_rwlockattr_t,
+        val: ::c_int,
+    ) -> ::c_int;
+    pub fn sched_getcpu() -> ::c_int;
+    pub fn mallinfo() -> ::mallinfo;
+    pub fn malloc_usable_size(ptr: *mut ::c_void) -> ::size_t;
+    pub fn getpwent_r(
+        pwd: *mut ::passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::passwd,
+    ) -> ::c_int;
+    pub fn getgrent_r(
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn pthread_getname_np(
+        thread: ::pthread_t,
+        name: *mut ::c_char,
+        len: ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_setname_np(
+        thread: ::pthread_t,
+        name: *const ::c_char,
+    ) -> ::c_int;
+}
+
+extern "C" {
+    pub fn dlmopen(
+        lmid: Lmid_t,
+        filename: *const ::c_char,
+        flag: ::c_int,
+    ) -> *mut ::c_void;
+    pub fn dlinfo(
+        handle: *mut ::c_void,
+        request: ::c_int,
+        info: *mut ::c_void,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(any(target_arch = "x86",
+                 target_arch = "arm",
+                 target_arch = "mips",
+                 target_arch = "powerpc",
+                 target_arch = "sparc",
+                 target_arch = "riscv32"))] {
+        mod b32;
+        pub use self::b32::*;
+    } else if #[cfg(any(target_arch = "x86_64",
+                        target_arch = "aarch64",
+                        target_arch = "powerpc64",
+                        target_arch = "mips64",
+                        target_arch = "s390x",
+                        target_arch = "sparc64",
+                        target_arch = "riscv64"))] {
+        mod b64;
+        pub use self::b64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    } else {
+        mod no_align;
+        pub use self::no_align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/gnu/no_align.rs b/library/libc/src/unix/linux_like/linux/gnu/no_align.rs
new file mode 100644
index 00000000..e32bf673
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/gnu/no_align.rs
@@ -0,0 +1,10 @@
+s! {
+    // FIXME this is actually a union
+    pub struct sem_t {
+        #[cfg(target_pointer_width = "32")]
+        __size: [::c_char; 16],
+        #[cfg(target_pointer_width = "64")]
+        __size: [::c_char; 32],
+        __align: [::c_long; 0],
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/mod.rs b/library/libc/src/unix/linux_like/linux/mod.rs
new file mode 100644
index 00000000..60f78dfe
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/mod.rs
@@ -0,0 +1,3600 @@
+//! Linux-specific definitions for linux-like values
+
+pub type useconds_t = u32;
+pub type dev_t = u64;
+pub type socklen_t = u32;
+pub type mode_t = u32;
+pub type ino64_t = u64;
+pub type off64_t = i64;
+pub type blkcnt64_t = i64;
+pub type rlim64_t = u64;
+pub type mqd_t = ::c_int;
+pub type nfds_t = ::c_ulong;
+pub type nl_item = ::c_int;
+pub type idtype_t = ::c_uint;
+pub type loff_t = ::c_longlong;
+pub type pthread_key_t = ::c_uint;
+
+pub type __u8 = ::c_uchar;
+pub type __u16 = ::c_ushort;
+pub type __s16 = ::c_short;
+pub type __u32 = ::c_uint;
+pub type __s32 = ::c_int;
+
+pub type Elf32_Half = u16;
+pub type Elf32_Word = u32;
+pub type Elf32_Off = u32;
+pub type Elf32_Addr = u32;
+
+pub type Elf64_Half = u16;
+pub type Elf64_Word = u32;
+pub type Elf64_Off = u64;
+pub type Elf64_Addr = u64;
+pub type Elf64_Xword = u64;
+pub type Elf64_Sxword = i64;
+
+pub type Elf32_Section = u16;
+pub type Elf64_Section = u16;
+
+// linux/can.h
+pub type canid_t = u32;
+pub type can_err_mask_t = u32;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum fpos64_t {} // FIXME: fill this out with a struct
+impl ::Copy for fpos64_t {}
+impl ::Clone for fpos64_t {
+    fn clone(&self) -> fpos64_t {
+        *self
+    }
+}
+
+s! {
+    pub struct rlimit64 {
+        pub rlim_cur: rlim64_t,
+        pub rlim_max: rlim64_t,
+    }
+
+    pub struct glob_t {
+        pub gl_pathc: ::size_t,
+        pub gl_pathv: *mut *mut c_char,
+        pub gl_offs: ::size_t,
+        pub gl_flags: ::c_int,
+
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct spwd {
+        pub sp_namp: *mut ::c_char,
+        pub sp_pwdp: *mut ::c_char,
+        pub sp_lstchg: ::c_long,
+        pub sp_min: ::c_long,
+        pub sp_max: ::c_long,
+        pub sp_warn: ::c_long,
+        pub sp_inact: ::c_long,
+        pub sp_expire: ::c_long,
+        pub sp_flag: ::c_ulong,
+    }
+
+    pub struct dqblk {
+        pub dqb_bhardlimit: u64,
+        pub dqb_bsoftlimit: u64,
+        pub dqb_curspace: u64,
+        pub dqb_ihardlimit: u64,
+        pub dqb_isoftlimit: u64,
+        pub dqb_curinodes: u64,
+        pub dqb_btime: u64,
+        pub dqb_itime: u64,
+        pub dqb_valid: u32,
+    }
+
+    pub struct signalfd_siginfo {
+        pub ssi_signo: u32,
+        pub ssi_errno: i32,
+        pub ssi_code: i32,
+        pub ssi_pid: u32,
+        pub ssi_uid: u32,
+        pub ssi_fd: i32,
+        pub ssi_tid: u32,
+        pub ssi_band: u32,
+        pub ssi_overrun: u32,
+        pub ssi_trapno: u32,
+        pub ssi_status: i32,
+        pub ssi_int: i32,
+        pub ssi_ptr: u64,
+        pub ssi_utime: u64,
+        pub ssi_stime: u64,
+        pub ssi_addr: u64,
+        pub ssi_addr_lsb: u16,
+        _pad2: u16,
+        pub ssi_syscall: i32,
+        pub ssi_call_addr: u64,
+        pub ssi_arch: u32,
+        _pad: [u8; 28],
+    }
+
+    pub struct itimerspec {
+        pub it_interval: ::timespec,
+        pub it_value: ::timespec,
+    }
+
+    pub struct fsid_t {
+        __val: [::c_int; 2],
+    }
+
+    pub struct packet_mreq {
+        pub mr_ifindex: ::c_int,
+        pub mr_type: ::c_ushort,
+        pub mr_alen: ::c_ushort,
+        pub mr_address: [::c_uchar; 8],
+    }
+
+    pub struct cpu_set_t {
+        #[cfg(all(target_pointer_width = "32",
+                  not(target_arch = "x86_64")))]
+        bits: [u32; 32],
+        #[cfg(not(all(target_pointer_width = "32",
+                      not(target_arch = "x86_64"))))]
+        bits: [u64; 16],
+    }
+
+    pub struct if_nameindex {
+        pub if_index: ::c_uint,
+        pub if_name: *mut ::c_char,
+    }
+
+    // System V IPC
+    pub struct msginfo {
+        pub msgpool: ::c_int,
+        pub msgmap: ::c_int,
+        pub msgmax: ::c_int,
+        pub msgmnb: ::c_int,
+        pub msgmni: ::c_int,
+        pub msgssz: ::c_int,
+        pub msgtql: ::c_int,
+        pub msgseg: ::c_ushort,
+    }
+
+    pub struct sembuf {
+        pub sem_num: ::c_ushort,
+        pub sem_op: ::c_short,
+        pub sem_flg: ::c_short,
+    }
+
+    pub struct input_event {
+        pub time: ::timeval,
+        pub type_: ::__u16,
+        pub code: ::__u16,
+        pub value: ::__s32,
+    }
+
+    pub struct input_id {
+        pub bustype: ::__u16,
+        pub vendor: ::__u16,
+        pub product: ::__u16,
+        pub version: ::__u16,
+    }
+
+    pub struct input_absinfo {
+        pub value: ::__s32,
+        pub minimum: ::__s32,
+        pub maximum: ::__s32,
+        pub fuzz: ::__s32,
+        pub flat: ::__s32,
+        pub resolution: ::__s32,
+    }
+
+    pub struct input_keymap_entry {
+        pub flags: ::__u8,
+        pub len: ::__u8,
+        pub index: ::__u16,
+        pub keycode: ::__u32,
+        pub scancode: [::__u8; 32],
+    }
+
+    pub struct input_mask {
+        pub type_: ::__u32,
+        pub codes_size: ::__u32,
+        pub codes_ptr: ::__u64,
+    }
+
+    pub struct ff_replay {
+        pub length: ::__u16,
+        pub delay: ::__u16,
+    }
+
+    pub struct ff_trigger {
+        pub button: ::__u16,
+        pub interval: ::__u16,
+    }
+
+    pub struct ff_envelope {
+        pub attack_length: ::__u16,
+        pub attack_level: ::__u16,
+        pub fade_length: ::__u16,
+        pub fade_level: ::__u16,
+    }
+
+    pub struct ff_constant_effect {
+        pub level: ::__s16,
+        pub envelope: ff_envelope,
+    }
+
+    pub struct ff_ramp_effect {
+        pub start_level: ::__s16,
+        pub end_level: ::__s16,
+        pub envelope: ff_envelope,
+    }
+
+    pub struct ff_condition_effect {
+        pub right_saturation: ::__u16,
+        pub left_saturation: ::__u16,
+
+        pub right_coeff: ::__s16,
+        pub left_coeff: ::__s16,
+
+        pub deadband: ::__u16,
+        pub center: ::__s16,
+    }
+
+    pub struct ff_periodic_effect {
+        pub waveform: ::__u16,
+        pub period: ::__u16,
+        pub magnitude: ::__s16,
+        pub offset: ::__s16,
+        pub phase: ::__u16,
+
+        pub envelope: ff_envelope,
+
+        pub custom_len: ::__u32,
+        pub custom_data: *mut ::__s16,
+    }
+
+    pub struct ff_rumble_effect {
+        pub strong_magnitude: ::__u16,
+        pub weak_magnitude: ::__u16,
+    }
+
+    pub struct ff_effect {
+        pub type_: ::__u16,
+        pub id: ::__s16,
+        pub direction: ::__u16,
+        pub trigger: ff_trigger,
+        pub replay: ff_replay,
+        // FIXME this is actually a union
+        #[cfg(target_pointer_width = "64")]
+        pub u: [u64; 4],
+        #[cfg(target_pointer_width = "32")]
+        pub u: [u32; 7],
+    }
+
+    pub struct dl_phdr_info {
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_addr: Elf64_Addr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_addr: Elf32_Addr,
+
+        pub dlpi_name: *const ::c_char,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phdr: *const Elf64_Phdr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phdr: *const Elf32_Phdr,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phnum: Elf64_Half,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phnum: Elf32_Half,
+
+        pub dlpi_adds: ::c_ulonglong,
+        pub dlpi_subs: ::c_ulonglong,
+        pub dlpi_tls_modid: ::size_t,
+        pub dlpi_tls_data: *mut ::c_void,
+    }
+
+    pub struct Elf32_Ehdr {
+        pub e_ident: [::c_uchar; 16],
+        pub e_type: Elf32_Half,
+        pub e_machine: Elf32_Half,
+        pub e_version: Elf32_Word,
+        pub e_entry: Elf32_Addr,
+        pub e_phoff: Elf32_Off,
+        pub e_shoff: Elf32_Off,
+        pub e_flags: Elf32_Word,
+        pub e_ehsize: Elf32_Half,
+        pub e_phentsize: Elf32_Half,
+        pub e_phnum: Elf32_Half,
+        pub e_shentsize: Elf32_Half,
+        pub e_shnum: Elf32_Half,
+        pub e_shstrndx: Elf32_Half,
+    }
+
+    pub struct Elf64_Ehdr {
+        pub e_ident: [::c_uchar; 16],
+        pub e_type: Elf64_Half,
+        pub e_machine: Elf64_Half,
+        pub e_version: Elf64_Word,
+        pub e_entry: Elf64_Addr,
+        pub e_phoff: Elf64_Off,
+        pub e_shoff: Elf64_Off,
+        pub e_flags: Elf64_Word,
+        pub e_ehsize: Elf64_Half,
+        pub e_phentsize: Elf64_Half,
+        pub e_phnum: Elf64_Half,
+        pub e_shentsize: Elf64_Half,
+        pub e_shnum: Elf64_Half,
+        pub e_shstrndx: Elf64_Half,
+    }
+
+    pub struct Elf32_Sym {
+        pub st_name: Elf32_Word,
+        pub st_value: Elf32_Addr,
+        pub st_size: Elf32_Word,
+        pub st_info: ::c_uchar,
+        pub st_other: ::c_uchar,
+        pub st_shndx: Elf32_Section,
+    }
+
+    pub struct Elf64_Sym {
+        pub st_name: Elf64_Word,
+        pub st_info: ::c_uchar,
+        pub st_other: ::c_uchar,
+        pub st_shndx: Elf64_Section,
+        pub st_value: Elf64_Addr,
+        pub st_size: Elf64_Xword,
+    }
+
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    pub struct Elf32_Shdr {
+        pub sh_name: Elf32_Word,
+        pub sh_type: Elf32_Word,
+        pub sh_flags: Elf32_Word,
+        pub sh_addr: Elf32_Addr,
+        pub sh_offset: Elf32_Off,
+        pub sh_size: Elf32_Word,
+        pub sh_link: Elf32_Word,
+        pub sh_info: Elf32_Word,
+        pub sh_addralign: Elf32_Word,
+        pub sh_entsize: Elf32_Word,
+    }
+
+    pub struct Elf64_Shdr {
+        pub sh_name: Elf64_Word,
+        pub sh_type: Elf64_Word,
+        pub sh_flags: Elf64_Xword,
+        pub sh_addr: Elf64_Addr,
+        pub sh_offset: Elf64_Off,
+        pub sh_size: Elf64_Xword,
+        pub sh_link: Elf64_Word,
+        pub sh_info: Elf64_Word,
+        pub sh_addralign: Elf64_Xword,
+        pub sh_entsize: Elf64_Xword,
+    }
+
+    pub struct Elf32_Chdr {
+        pub ch_type: Elf32_Word,
+        pub ch_size: Elf32_Word,
+        pub ch_addralign: Elf32_Word,
+    }
+
+    pub struct Elf64_Chdr {
+        pub ch_type: Elf64_Word,
+        pub ch_reserved: Elf64_Word,
+        pub ch_size: Elf64_Xword,
+        pub ch_addralign: Elf64_Xword,
+    }
+
+    pub struct ucred {
+        pub pid: ::pid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+    }
+
+    pub struct mntent {
+        pub mnt_fsname: *mut ::c_char,
+        pub mnt_dir: *mut ::c_char,
+        pub mnt_type: *mut ::c_char,
+        pub mnt_opts: *mut ::c_char,
+        pub mnt_freq: ::c_int,
+        pub mnt_passno: ::c_int,
+    }
+
+    pub struct posix_spawn_file_actions_t {
+        __allocated: ::c_int,
+        __used: ::c_int,
+        __actions: *mut ::c_int,
+        __pad: [::c_int; 16],
+    }
+
+    pub struct posix_spawnattr_t {
+        __flags: ::c_short,
+        __pgrp: ::pid_t,
+        __sd: ::sigset_t,
+        __ss: ::sigset_t,
+        #[cfg(target_env = "musl")]
+        __prio: ::c_int,
+        #[cfg(not(target_env = "musl"))]
+        __sp: ::sched_param,
+        __policy: ::c_int,
+        __pad: [::c_int; 16],
+    }
+
+    pub struct genlmsghdr {
+        pub cmd: u8,
+        pub version: u8,
+        pub reserved: u16,
+    }
+
+    pub struct in6_pktinfo {
+        pub ipi6_addr: ::in6_addr,
+        pub ipi6_ifindex: ::c_uint,
+    }
+
+    pub struct arpd_request {
+        pub req: ::c_ushort,
+        pub ip: u32,
+        pub dev: ::c_ulong,
+        pub stamp: ::c_ulong,
+        pub updated: ::c_ulong,
+        pub ha: [::c_uchar; ::MAX_ADDR_LEN],
+    }
+
+    pub struct inotify_event {
+        pub wd: ::c_int,
+        pub mask: u32,
+        pub cookie: u32,
+        pub len: u32
+    }
+
+    pub struct fanotify_response {
+        pub fd: ::c_int,
+        pub response: __u32,
+    }
+
+    pub struct sockaddr_vm {
+        pub svm_family: ::sa_family_t,
+        pub svm_reserved1: ::c_ushort,
+        pub svm_port: ::c_uint,
+        pub svm_cid: ::c_uint,
+        pub svm_zero: [u8; 4]
+    }
+
+    pub struct regmatch_t {
+        pub rm_so: regoff_t,
+        pub rm_eo: regoff_t,
+    }
+
+    pub struct sock_extended_err {
+        pub ee_errno: u32,
+        pub ee_origin: u8,
+        pub ee_type: u8,
+        pub ee_code: u8,
+        pub ee_pad: u8,
+        pub ee_info: u32,
+        pub ee_data: u32,
+    }
+
+    // linux/can.h
+    pub struct __c_anonymous_sockaddr_can_tp {
+        pub rx_id: canid_t,
+        pub tx_id: canid_t,
+    }
+
+    pub struct __c_anonymous_sockaddr_can_j1939 {
+        pub name: u64,
+        pub pgn: u32,
+        pub addr: u8,
+    }
+
+    pub struct can_filter {
+        pub can_id: canid_t,
+        pub can_mask: canid_t,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct sockaddr_nl {
+        pub nl_family: ::sa_family_t,
+        nl_pad: ::c_ushort,
+        pub nl_pid: u32,
+        pub nl_groups: u32
+    }
+
+    pub struct dirent {
+        pub d_ino: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct dirent64 {
+        pub d_ino: ::ino64_t,
+        pub d_off: ::off64_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct sockaddr_alg {
+        pub salg_family: ::sa_family_t,
+        pub salg_type: [::c_uchar; 14],
+        pub salg_feat: u32,
+        pub salg_mask: u32,
+        pub salg_name: [::c_uchar; 64],
+    }
+
+    /// WARNING: The `PartialEq`, `Eq` and `Hash` implementations of this
+    /// type are unsound and will be removed in the future.
+    #[deprecated(
+        note = "this struct has unsafe trait implementations that will be \
+                removed in the future",
+        since = "0.2.80"
+    )]
+    pub struct af_alg_iv {
+        pub ivlen: u32,
+        pub iv: [::c_uchar; 0],
+    }
+
+    // x32 compatibility
+    // See https://sourceware.org/bugzilla/show_bug.cgi?id=21279
+    pub struct mq_attr {
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub mq_flags: i64,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub mq_maxmsg: i64,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub mq_msgsize: i64,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub mq_curmsgs: i64,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pad: [i64; 4],
+
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub mq_flags: ::c_long,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub mq_maxmsg: ::c_long,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub mq_msgsize: ::c_long,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub mq_curmsgs: ::c_long,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pad: [::c_long; 4],
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        s_no_extra_traits! {
+            // linux/can.h
+            #[allow(missing_debug_implementations)]
+            pub union __c_anonymous_sockaddr_can_can_addr {
+                pub tp: __c_anonymous_sockaddr_can_tp,
+                pub j1939: __c_anonymous_sockaddr_can_j1939,
+            }
+
+            #[allow(missing_debug_implementations)]
+            pub struct sockaddr_can {
+                pub can_family: ::sa_family_t,
+                pub can_ifindex: ::c_int,
+                pub can_addr: __c_anonymous_sockaddr_can_can_addr,
+            }
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for sockaddr_nl {
+            fn eq(&self, other: &sockaddr_nl) -> bool {
+                self.nl_family == other.nl_family &&
+                    self.nl_pid == other.nl_pid &&
+                    self.nl_groups == other.nl_groups
+            }
+        }
+        impl Eq for sockaddr_nl {}
+        impl ::fmt::Debug for sockaddr_nl {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_nl")
+                    .field("nl_family", &self.nl_family)
+                    .field("nl_pid", &self.nl_pid)
+                    .field("nl_groups", &self.nl_groups)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_nl {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.nl_family.hash(state);
+                self.nl_pid.hash(state);
+                self.nl_groups.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for dirent {}
+
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for dirent64 {
+            fn eq(&self, other: &dirent64) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for dirent64 {}
+
+        impl ::fmt::Debug for dirent64 {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent64")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for dirent64 {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_cond_t {
+            fn eq(&self, other: &pthread_cond_t) -> bool {
+                self.size.iter().zip(other.size.iter()).all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_cond_t {}
+
+        impl ::fmt::Debug for pthread_cond_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_cond_t")
+                // FIXME: .field("size", &self.size)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for pthread_cond_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.size.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_mutex_t {
+            fn eq(&self, other: &pthread_mutex_t) -> bool {
+                self.size.iter().zip(other.size.iter()).all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_mutex_t {}
+
+        impl ::fmt::Debug for pthread_mutex_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_mutex_t")
+                // FIXME: .field("size", &self.size)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for pthread_mutex_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.size.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_rwlock_t {
+            fn eq(&self, other: &pthread_rwlock_t) -> bool {
+                self.size.iter().zip(other.size.iter()).all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_rwlock_t {}
+
+        impl ::fmt::Debug for pthread_rwlock_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("pthread_rwlock_t")
+                // FIXME: .field("size", &self.size)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for pthread_rwlock_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.size.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_alg {
+            fn eq(&self, other: &sockaddr_alg) -> bool {
+                self.salg_family == other.salg_family
+                    && self
+                    .salg_type
+                    .iter()
+                    .zip(other.salg_type.iter())
+                    .all(|(a, b)| a == b)
+                    && self.salg_feat == other.salg_feat
+                    && self.salg_mask == other.salg_mask
+                    && self
+                    .salg_name
+                    .iter()
+                    .zip(other.salg_name.iter())
+                    .all(|(a, b)| a == b)
+           }
+        }
+
+        impl Eq for sockaddr_alg {}
+
+        impl ::fmt::Debug for sockaddr_alg {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_alg")
+                    .field("salg_family", &self.salg_family)
+                    .field("salg_type", &self.salg_type)
+                    .field("salg_feat", &self.salg_feat)
+                    .field("salg_mask", &self.salg_mask)
+                    .field("salg_name", &&self.salg_name[..])
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sockaddr_alg {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.salg_family.hash(state);
+                self.salg_type.hash(state);
+                self.salg_feat.hash(state);
+                self.salg_mask.hash(state);
+                self.salg_name.hash(state);
+            }
+        }
+
+        #[allow(deprecated)]
+        impl af_alg_iv {
+            fn as_slice(&self) -> &[u8] {
+                unsafe {
+                    ::core::slice::from_raw_parts(
+                        self.iv.as_ptr(),
+                        self.ivlen as usize
+                    )
+                }
+            }
+        }
+
+        #[allow(deprecated)]
+        impl PartialEq for af_alg_iv {
+            fn eq(&self, other: &af_alg_iv) -> bool {
+                *self.as_slice() == *other.as_slice()
+           }
+        }
+
+        #[allow(deprecated)]
+        impl Eq for af_alg_iv {}
+
+        #[allow(deprecated)]
+        impl ::fmt::Debug for af_alg_iv {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("af_alg_iv")
+                    .field("ivlen", &self.ivlen)
+                    .finish()
+            }
+        }
+
+        #[allow(deprecated)]
+        impl ::hash::Hash for af_alg_iv {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.as_slice().hash(state);
+            }
+        }
+
+        impl PartialEq for mq_attr {
+            fn eq(&self, other: &mq_attr) -> bool {
+                self.mq_flags == other.mq_flags &&
+                self.mq_maxmsg == other.mq_maxmsg &&
+                self.mq_msgsize == other.mq_msgsize &&
+                self.mq_curmsgs == other.mq_curmsgs
+            }
+        }
+        impl Eq for mq_attr {}
+        impl ::fmt::Debug for mq_attr {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("mq_attr")
+                    .field("mq_flags", &self.mq_flags)
+                    .field("mq_maxmsg", &self.mq_maxmsg)
+                    .field("mq_msgsize", &self.mq_msgsize)
+                    .field("mq_curmsgs", &self.mq_curmsgs)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for mq_attr {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.mq_flags.hash(state);
+                self.mq_maxmsg.hash(state);
+                self.mq_msgsize.hash(state);
+                self.mq_curmsgs.hash(state);
+            }
+        }
+    }
+}
+
+pub const ABDAY_1: ::nl_item = 0x20000;
+pub const ABDAY_2: ::nl_item = 0x20001;
+pub const ABDAY_3: ::nl_item = 0x20002;
+pub const ABDAY_4: ::nl_item = 0x20003;
+pub const ABDAY_5: ::nl_item = 0x20004;
+pub const ABDAY_6: ::nl_item = 0x20005;
+pub const ABDAY_7: ::nl_item = 0x20006;
+
+pub const DAY_1: ::nl_item = 0x20007;
+pub const DAY_2: ::nl_item = 0x20008;
+pub const DAY_3: ::nl_item = 0x20009;
+pub const DAY_4: ::nl_item = 0x2000A;
+pub const DAY_5: ::nl_item = 0x2000B;
+pub const DAY_6: ::nl_item = 0x2000C;
+pub const DAY_7: ::nl_item = 0x2000D;
+
+pub const ABMON_1: ::nl_item = 0x2000E;
+pub const ABMON_2: ::nl_item = 0x2000F;
+pub const ABMON_3: ::nl_item = 0x20010;
+pub const ABMON_4: ::nl_item = 0x20011;
+pub const ABMON_5: ::nl_item = 0x20012;
+pub const ABMON_6: ::nl_item = 0x20013;
+pub const ABMON_7: ::nl_item = 0x20014;
+pub const ABMON_8: ::nl_item = 0x20015;
+pub const ABMON_9: ::nl_item = 0x20016;
+pub const ABMON_10: ::nl_item = 0x20017;
+pub const ABMON_11: ::nl_item = 0x20018;
+pub const ABMON_12: ::nl_item = 0x20019;
+
+pub const MON_1: ::nl_item = 0x2001A;
+pub const MON_2: ::nl_item = 0x2001B;
+pub const MON_3: ::nl_item = 0x2001C;
+pub const MON_4: ::nl_item = 0x2001D;
+pub const MON_5: ::nl_item = 0x2001E;
+pub const MON_6: ::nl_item = 0x2001F;
+pub const MON_7: ::nl_item = 0x20020;
+pub const MON_8: ::nl_item = 0x20021;
+pub const MON_9: ::nl_item = 0x20022;
+pub const MON_10: ::nl_item = 0x20023;
+pub const MON_11: ::nl_item = 0x20024;
+pub const MON_12: ::nl_item = 0x20025;
+
+pub const AM_STR: ::nl_item = 0x20026;
+pub const PM_STR: ::nl_item = 0x20027;
+
+pub const D_T_FMT: ::nl_item = 0x20028;
+pub const D_FMT: ::nl_item = 0x20029;
+pub const T_FMT: ::nl_item = 0x2002A;
+pub const T_FMT_AMPM: ::nl_item = 0x2002B;
+
+pub const ERA: ::nl_item = 0x2002C;
+pub const ERA_D_FMT: ::nl_item = 0x2002E;
+pub const ALT_DIGITS: ::nl_item = 0x2002F;
+pub const ERA_D_T_FMT: ::nl_item = 0x20030;
+pub const ERA_T_FMT: ::nl_item = 0x20031;
+
+pub const CODESET: ::nl_item = 14;
+
+pub const CRNCYSTR: ::nl_item = 0x4000F;
+
+pub const RUSAGE_THREAD: ::c_int = 1;
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const RADIXCHAR: ::nl_item = 0x10000;
+pub const THOUSEP: ::nl_item = 0x10001;
+
+pub const YESEXPR: ::nl_item = 0x50000;
+pub const NOEXPR: ::nl_item = 0x50001;
+pub const YESSTR: ::nl_item = 0x50002;
+pub const NOSTR: ::nl_item = 0x50003;
+
+pub const FILENAME_MAX: ::c_uint = 4096;
+pub const L_tmpnam: ::c_uint = 20;
+pub const _PC_LINK_MAX: ::c_int = 0;
+pub const _PC_MAX_CANON: ::c_int = 1;
+pub const _PC_MAX_INPUT: ::c_int = 2;
+pub const _PC_NAME_MAX: ::c_int = 3;
+pub const _PC_PATH_MAX: ::c_int = 4;
+pub const _PC_PIPE_BUF: ::c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 6;
+pub const _PC_NO_TRUNC: ::c_int = 7;
+pub const _PC_VDISABLE: ::c_int = 8;
+pub const _PC_SYNC_IO: ::c_int = 9;
+pub const _PC_ASYNC_IO: ::c_int = 10;
+pub const _PC_PRIO_IO: ::c_int = 11;
+pub const _PC_SOCK_MAXBUF: ::c_int = 12;
+pub const _PC_FILESIZEBITS: ::c_int = 13;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 17;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 18;
+pub const _PC_SYMLINK_MAX: ::c_int = 19;
+pub const _PC_2_SYMLINKS: ::c_int = 20;
+
+pub const MS_NOUSER: ::c_ulong = 0xffffffff80000000;
+
+pub const _SC_ARG_MAX: ::c_int = 0;
+pub const _SC_CHILD_MAX: ::c_int = 1;
+pub const _SC_CLK_TCK: ::c_int = 2;
+pub const _SC_NGROUPS_MAX: ::c_int = 3;
+pub const _SC_OPEN_MAX: ::c_int = 4;
+pub const _SC_STREAM_MAX: ::c_int = 5;
+pub const _SC_TZNAME_MAX: ::c_int = 6;
+pub const _SC_JOB_CONTROL: ::c_int = 7;
+pub const _SC_SAVED_IDS: ::c_int = 8;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 9;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 10;
+pub const _SC_TIMERS: ::c_int = 11;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 12;
+pub const _SC_PRIORITIZED_IO: ::c_int = 13;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 14;
+pub const _SC_FSYNC: ::c_int = 15;
+pub const _SC_MAPPED_FILES: ::c_int = 16;
+pub const _SC_MEMLOCK: ::c_int = 17;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 18;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 19;
+pub const _SC_MESSAGE_PASSING: ::c_int = 20;
+pub const _SC_SEMAPHORES: ::c_int = 21;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 22;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 23;
+pub const _SC_AIO_MAX: ::c_int = 24;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 25;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 26;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 27;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 28;
+pub const _SC_VERSION: ::c_int = 29;
+pub const _SC_PAGESIZE: ::c_int = 30;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_RTSIG_MAX: ::c_int = 31;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 32;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 33;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 34;
+pub const _SC_TIMER_MAX: ::c_int = 35;
+pub const _SC_BC_BASE_MAX: ::c_int = 36;
+pub const _SC_BC_DIM_MAX: ::c_int = 37;
+pub const _SC_BC_SCALE_MAX: ::c_int = 38;
+pub const _SC_BC_STRING_MAX: ::c_int = 39;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 40;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 42;
+pub const _SC_LINE_MAX: ::c_int = 43;
+pub const _SC_RE_DUP_MAX: ::c_int = 44;
+pub const _SC_2_VERSION: ::c_int = 46;
+pub const _SC_2_C_BIND: ::c_int = 47;
+pub const _SC_2_C_DEV: ::c_int = 48;
+pub const _SC_2_FORT_DEV: ::c_int = 49;
+pub const _SC_2_FORT_RUN: ::c_int = 50;
+pub const _SC_2_SW_DEV: ::c_int = 51;
+pub const _SC_2_LOCALEDEF: ::c_int = 52;
+pub const _SC_UIO_MAXIOV: ::c_int = 60;
+pub const _SC_IOV_MAX: ::c_int = 60;
+pub const _SC_THREADS: ::c_int = 67;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 68;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 69;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 70;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 71;
+pub const _SC_TTY_NAME_MAX: ::c_int = 72;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 73;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 74;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 75;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 79;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 80;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 81;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 82;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 83;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 84;
+pub const _SC_PHYS_PAGES: ::c_int = 85;
+pub const _SC_AVPHYS_PAGES: ::c_int = 86;
+pub const _SC_ATEXIT_MAX: ::c_int = 87;
+pub const _SC_PASS_MAX: ::c_int = 88;
+pub const _SC_XOPEN_VERSION: ::c_int = 89;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 90;
+pub const _SC_XOPEN_UNIX: ::c_int = 91;
+pub const _SC_XOPEN_CRYPT: ::c_int = 92;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 93;
+pub const _SC_XOPEN_SHM: ::c_int = 94;
+pub const _SC_2_CHAR_TERM: ::c_int = 95;
+pub const _SC_2_UPE: ::c_int = 97;
+pub const _SC_XOPEN_XPG2: ::c_int = 98;
+pub const _SC_XOPEN_XPG3: ::c_int = 99;
+pub const _SC_XOPEN_XPG4: ::c_int = 100;
+pub const _SC_NZERO: ::c_int = 109;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 125;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 126;
+pub const _SC_XBS5_LP64_OFF64: ::c_int = 127;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 128;
+pub const _SC_XOPEN_LEGACY: ::c_int = 129;
+pub const _SC_XOPEN_REALTIME: ::c_int = 130;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 131;
+pub const _SC_ADVISORY_INFO: ::c_int = 132;
+pub const _SC_BARRIERS: ::c_int = 133;
+pub const _SC_CLOCK_SELECTION: ::c_int = 137;
+pub const _SC_CPUTIME: ::c_int = 138;
+pub const _SC_THREAD_CPUTIME: ::c_int = 139;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 149;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 153;
+pub const _SC_SPIN_LOCKS: ::c_int = 154;
+pub const _SC_REGEXP: ::c_int = 155;
+pub const _SC_SHELL: ::c_int = 157;
+pub const _SC_SPAWN: ::c_int = 159;
+pub const _SC_SPORADIC_SERVER: ::c_int = 160;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 161;
+pub const _SC_TIMEOUTS: ::c_int = 164;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 165;
+pub const _SC_2_PBS: ::c_int = 168;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 169;
+pub const _SC_2_PBS_LOCATE: ::c_int = 170;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 171;
+pub const _SC_2_PBS_TRACK: ::c_int = 172;
+pub const _SC_SYMLOOP_MAX: ::c_int = 173;
+pub const _SC_STREAMS: ::c_int = 174;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 175;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 176;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 177;
+pub const _SC_V6_LP64_OFF64: ::c_int = 178;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 179;
+pub const _SC_HOST_NAME_MAX: ::c_int = 180;
+pub const _SC_TRACE: ::c_int = 181;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 182;
+pub const _SC_TRACE_INHERIT: ::c_int = 183;
+pub const _SC_TRACE_LOG: ::c_int = 184;
+pub const _SC_IPV6: ::c_int = 235;
+pub const _SC_RAW_SOCKETS: ::c_int = 236;
+pub const _SC_V7_ILP32_OFF32: ::c_int = 237;
+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 238;
+pub const _SC_V7_LP64_OFF64: ::c_int = 239;
+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 240;
+pub const _SC_SS_REPL_MAX: ::c_int = 241;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 242;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 243;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 244;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 245;
+pub const _SC_XOPEN_STREAMS: ::c_int = 246;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 247;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 248;
+
+pub const RLIM_SAVED_MAX: ::rlim_t = RLIM_INFINITY;
+pub const RLIM_SAVED_CUR: ::rlim_t = RLIM_INFINITY;
+
+pub const GLOB_ERR: ::c_int = 1 << 0;
+pub const GLOB_MARK: ::c_int = 1 << 1;
+pub const GLOB_NOSORT: ::c_int = 1 << 2;
+pub const GLOB_DOOFFS: ::c_int = 1 << 3;
+pub const GLOB_NOCHECK: ::c_int = 1 << 4;
+pub const GLOB_APPEND: ::c_int = 1 << 5;
+pub const GLOB_NOESCAPE: ::c_int = 1 << 6;
+
+pub const GLOB_NOSPACE: ::c_int = 1;
+pub const GLOB_ABORTED: ::c_int = 2;
+pub const GLOB_NOMATCH: ::c_int = 3;
+
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+
+pub const S_IEXEC: mode_t = 64;
+pub const S_IWRITE: mode_t = 128;
+pub const S_IREAD: mode_t = 256;
+
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+
+pub const F_SEAL_FUTURE_WRITE: ::c_int = 0x0010;
+
+pub const IFF_LOWER_UP: ::c_int = 0x10000;
+pub const IFF_DORMANT: ::c_int = 0x20000;
+pub const IFF_ECHO: ::c_int = 0x40000;
+
+// linux/if_addr.h
+pub const IFA_UNSPEC: ::c_ushort = 0;
+pub const IFA_ADDRESS: ::c_ushort = 1;
+pub const IFA_LOCAL: ::c_ushort = 2;
+pub const IFA_LABEL: ::c_ushort = 3;
+pub const IFA_BROADCAST: ::c_ushort = 4;
+pub const IFA_ANYCAST: ::c_ushort = 5;
+pub const IFA_CACHEINFO: ::c_ushort = 6;
+pub const IFA_MULTICAST: ::c_ushort = 7;
+
+pub const IFA_F_SECONDARY: u32 = 0x01;
+pub const IFA_F_TEMPORARY: u32 = 0x01;
+pub const IFA_F_NODAD: u32 = 0x02;
+pub const IFA_F_OPTIMISTIC: u32 = 0x04;
+pub const IFA_F_DADFAILED: u32 = 0x08;
+pub const IFA_F_HOMEADDRESS: u32 = 0x10;
+pub const IFA_F_DEPRECATED: u32 = 0x20;
+pub const IFA_F_TENTATIVE: u32 = 0x40;
+pub const IFA_F_PERMANENT: u32 = 0x80;
+
+// linux/if_link.h
+pub const IFLA_UNSPEC: ::c_ushort = 0;
+pub const IFLA_ADDRESS: ::c_ushort = 1;
+pub const IFLA_BROADCAST: ::c_ushort = 2;
+pub const IFLA_IFNAME: ::c_ushort = 3;
+pub const IFLA_MTU: ::c_ushort = 4;
+pub const IFLA_LINK: ::c_ushort = 5;
+pub const IFLA_QDISC: ::c_ushort = 6;
+pub const IFLA_STATS: ::c_ushort = 7;
+pub const IFLA_COST: ::c_ushort = 8;
+pub const IFLA_PRIORITY: ::c_ushort = 9;
+pub const IFLA_MASTER: ::c_ushort = 10;
+pub const IFLA_WIRELESS: ::c_ushort = 11;
+pub const IFLA_PROTINFO: ::c_ushort = 12;
+pub const IFLA_TXQLEN: ::c_ushort = 13;
+pub const IFLA_MAP: ::c_ushort = 14;
+pub const IFLA_WEIGHT: ::c_ushort = 15;
+pub const IFLA_OPERSTATE: ::c_ushort = 16;
+pub const IFLA_LINKMODE: ::c_ushort = 17;
+pub const IFLA_LINKINFO: ::c_ushort = 18;
+pub const IFLA_NET_NS_PID: ::c_ushort = 19;
+pub const IFLA_IFALIAS: ::c_ushort = 20;
+pub const IFLA_NUM_VF: ::c_ushort = 21;
+pub const IFLA_VFINFO_LIST: ::c_ushort = 22;
+pub const IFLA_STATS64: ::c_ushort = 23;
+pub const IFLA_VF_PORTS: ::c_ushort = 24;
+pub const IFLA_PORT_SELF: ::c_ushort = 25;
+pub const IFLA_AF_SPEC: ::c_ushort = 26;
+pub const IFLA_GROUP: ::c_ushort = 27;
+pub const IFLA_NET_NS_FD: ::c_ushort = 28;
+pub const IFLA_EXT_MASK: ::c_ushort = 29;
+pub const IFLA_PROMISCUITY: ::c_ushort = 30;
+pub const IFLA_NUM_TX_QUEUES: ::c_ushort = 31;
+pub const IFLA_NUM_RX_QUEUES: ::c_ushort = 32;
+pub const IFLA_CARRIER: ::c_ushort = 33;
+pub const IFLA_PHYS_PORT_ID: ::c_ushort = 34;
+pub const IFLA_CARRIER_CHANGES: ::c_ushort = 35;
+pub const IFLA_PHYS_SWITCH_ID: ::c_ushort = 36;
+pub const IFLA_LINK_NETNSID: ::c_ushort = 37;
+pub const IFLA_PHYS_PORT_NAME: ::c_ushort = 38;
+pub const IFLA_PROTO_DOWN: ::c_ushort = 39;
+pub const IFLA_GSO_MAX_SEGS: ::c_ushort = 40;
+pub const IFLA_GSO_MAX_SIZE: ::c_ushort = 41;
+pub const IFLA_PAD: ::c_ushort = 42;
+pub const IFLA_XDP: ::c_ushort = 43;
+pub const IFLA_EVENT: ::c_ushort = 44;
+pub const IFLA_NEW_NETNSID: ::c_ushort = 45;
+pub const IFLA_IF_NETNSID: ::c_ushort = 46;
+pub const IFLA_TARGET_NETNSID: ::c_ushort = IFLA_IF_NETNSID;
+pub const IFLA_CARRIER_UP_COUNT: ::c_ushort = 47;
+pub const IFLA_CARRIER_DOWN_COUNT: ::c_ushort = 48;
+pub const IFLA_NEW_IFINDEX: ::c_ushort = 49;
+pub const IFLA_MIN_MTU: ::c_ushort = 50;
+pub const IFLA_MAX_MTU: ::c_ushort = 51;
+pub const IFLA_PROP_LIST: ::c_ushort = 52;
+pub const IFLA_ALT_IFNAME: ::c_ushort = 53;
+pub const IFLA_PERM_ADDRESS: ::c_ushort = 54;
+pub const IFLA_PROTO_DOWN_REASON: ::c_ushort = 55;
+
+pub const IFLA_INFO_UNSPEC: ::c_ushort = 0;
+pub const IFLA_INFO_KIND: ::c_ushort = 1;
+pub const IFLA_INFO_DATA: ::c_ushort = 2;
+pub const IFLA_INFO_XSTATS: ::c_ushort = 3;
+pub const IFLA_INFO_SLAVE_KIND: ::c_ushort = 4;
+pub const IFLA_INFO_SLAVE_DATA: ::c_ushort = 5;
+
+// linux/if_tun.h
+pub const IFF_TUN: ::c_int = 0x0001;
+pub const IFF_TAP: ::c_int = 0x0002;
+pub const IFF_NO_PI: ::c_int = 0x1000;
+// Read queue size
+pub const TUN_READQ_SIZE: ::c_short = 500;
+// TUN device type flags: deprecated. Use IFF_TUN/IFF_TAP instead.
+pub const TUN_TUN_DEV: ::c_short = ::IFF_TUN as ::c_short;
+pub const TUN_TAP_DEV: ::c_short = ::IFF_TAP as ::c_short;
+pub const TUN_TYPE_MASK: ::c_short = 0x000f;
+// This flag has no real effect
+pub const IFF_ONE_QUEUE: ::c_int = 0x2000;
+pub const IFF_VNET_HDR: ::c_int = 0x4000;
+pub const IFF_TUN_EXCL: ::c_int = 0x8000;
+pub const IFF_MULTI_QUEUE: ::c_int = 0x0100;
+pub const IFF_ATTACH_QUEUE: ::c_int = 0x0200;
+pub const IFF_DETACH_QUEUE: ::c_int = 0x0400;
+// read-only flag
+pub const IFF_PERSIST: ::c_int = 0x0800;
+pub const IFF_NOFILTER: ::c_int = 0x1000;
+
+pub const ST_RDONLY: ::c_ulong = 1;
+pub const ST_NOSUID: ::c_ulong = 2;
+pub const ST_NODEV: ::c_ulong = 4;
+pub const ST_NOEXEC: ::c_ulong = 8;
+pub const ST_SYNCHRONOUS: ::c_ulong = 16;
+pub const ST_MANDLOCK: ::c_ulong = 64;
+pub const ST_WRITE: ::c_ulong = 128;
+pub const ST_APPEND: ::c_ulong = 256;
+pub const ST_IMMUTABLE: ::c_ulong = 512;
+pub const ST_NOATIME: ::c_ulong = 1024;
+pub const ST_NODIRATIME: ::c_ulong = 2048;
+
+pub const RTLD_NEXT: *mut ::c_void = -1i64 as *mut ::c_void;
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+pub const RTLD_NODELETE: ::c_int = 0x1000;
+pub const RTLD_NOW: ::c_int = 0x2;
+
+pub const AT_EACCESS: ::c_int = 0x200;
+
+pub const TCP_MD5SIG: ::c_int = 14;
+pub const TCP_ULP: ::c_int = 31;
+
+align_const! {
+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+        size: [0; __SIZEOF_PTHREAD_MUTEX_T],
+    };
+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+        size: [0; __SIZEOF_PTHREAD_COND_T],
+    };
+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+        size: [0; __SIZEOF_PTHREAD_RWLOCK_T],
+    };
+}
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+pub const PTHREAD_PROCESS_PRIVATE: ::c_int = 0;
+pub const PTHREAD_PROCESS_SHARED: ::c_int = 1;
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+
+pub const RENAME_NOREPLACE: ::c_int = 1;
+pub const RENAME_EXCHANGE: ::c_int = 2;
+pub const RENAME_WHITEOUT: ::c_int = 4;
+
+pub const SCHED_OTHER: ::c_int = 0;
+pub const SCHED_FIFO: ::c_int = 1;
+pub const SCHED_RR: ::c_int = 2;
+pub const SCHED_BATCH: ::c_int = 3;
+pub const SCHED_IDLE: ::c_int = 5;
+
+pub const SCHED_RESET_ON_FORK: ::c_int = 0x40000000;
+
+// netinet/in.h
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+/// Multipath TCP
+pub const IPPROTO_MPTCP: ::c_int = 262;
+#[deprecated(
+    since = "0.2.80",
+    note = "This value was increased in the newer kernel \
+            and we'll change this following upstream in the future release. \
+            See #1896 for more info."
+)]
+pub const IPPROTO_MAX: ::c_int = 256;
+
+pub const AF_IB: ::c_int = 27;
+pub const AF_MPLS: ::c_int = 28;
+pub const AF_NFC: ::c_int = 39;
+pub const AF_VSOCK: ::c_int = 40;
+pub const AF_XDP: ::c_int = 44;
+pub const PF_IB: ::c_int = AF_IB;
+pub const PF_MPLS: ::c_int = AF_MPLS;
+pub const PF_NFC: ::c_int = AF_NFC;
+pub const PF_VSOCK: ::c_int = AF_VSOCK;
+pub const PF_XDP: ::c_int = AF_XDP;
+
+// System V IPC
+pub const IPC_PRIVATE: ::key_t = 0;
+
+pub const IPC_CREAT: ::c_int = 0o1000;
+pub const IPC_EXCL: ::c_int = 0o2000;
+pub const IPC_NOWAIT: ::c_int = 0o4000;
+
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+pub const IPC_INFO: ::c_int = 3;
+pub const MSG_STAT: ::c_int = 11;
+pub const MSG_INFO: ::c_int = 12;
+
+pub const MSG_NOERROR: ::c_int = 0o10000;
+pub const MSG_EXCEPT: ::c_int = 0o20000;
+pub const MSG_COPY: ::c_int = 0o40000;
+
+pub const SHM_R: ::c_int = 0o400;
+pub const SHM_W: ::c_int = 0o200;
+
+pub const SHM_RDONLY: ::c_int = 0o10000;
+pub const SHM_RND: ::c_int = 0o20000;
+pub const SHM_REMAP: ::c_int = 0o40000;
+pub const SHM_EXEC: ::c_int = 0o100000;
+
+pub const SHM_LOCK: ::c_int = 11;
+pub const SHM_UNLOCK: ::c_int = 12;
+
+pub const SHM_HUGETLB: ::c_int = 0o4000;
+pub const SHM_NORESERVE: ::c_int = 0o10000;
+
+pub const EPOLLRDHUP: ::c_int = 0x2000;
+pub const EPOLLEXCLUSIVE: ::c_int = 0x10000000;
+pub const EPOLLONESHOT: ::c_int = 0x40000000;
+
+pub const QFMT_VFS_OLD: ::c_int = 1;
+pub const QFMT_VFS_V0: ::c_int = 2;
+pub const QFMT_VFS_V1: ::c_int = 4;
+
+pub const EFD_SEMAPHORE: ::c_int = 0x1;
+
+pub const LOG_NFACILITIES: ::c_int = 24;
+
+pub const SEM_FAILED: *mut ::sem_t = 0 as *mut sem_t;
+
+pub const RB_AUTOBOOT: ::c_int = 0x01234567u32 as i32;
+pub const RB_HALT_SYSTEM: ::c_int = 0xcdef0123u32 as i32;
+pub const RB_ENABLE_CAD: ::c_int = 0x89abcdefu32 as i32;
+pub const RB_DISABLE_CAD: ::c_int = 0x00000000u32 as i32;
+pub const RB_POWER_OFF: ::c_int = 0x4321fedcu32 as i32;
+pub const RB_SW_SUSPEND: ::c_int = 0xd000fce2u32 as i32;
+pub const RB_KEXEC: ::c_int = 0x45584543u32 as i32;
+
+pub const AI_PASSIVE: ::c_int = 0x0001;
+pub const AI_CANONNAME: ::c_int = 0x0002;
+pub const AI_NUMERICHOST: ::c_int = 0x0004;
+pub const AI_V4MAPPED: ::c_int = 0x0008;
+pub const AI_ALL: ::c_int = 0x0010;
+pub const AI_ADDRCONFIG: ::c_int = 0x0020;
+
+pub const AI_NUMERICSERV: ::c_int = 0x0400;
+
+pub const EAI_BADFLAGS: ::c_int = -1;
+pub const EAI_NONAME: ::c_int = -2;
+pub const EAI_AGAIN: ::c_int = -3;
+pub const EAI_FAIL: ::c_int = -4;
+pub const EAI_NODATA: ::c_int = -5;
+pub const EAI_FAMILY: ::c_int = -6;
+pub const EAI_SOCKTYPE: ::c_int = -7;
+pub const EAI_SERVICE: ::c_int = -8;
+pub const EAI_MEMORY: ::c_int = -10;
+pub const EAI_SYSTEM: ::c_int = -11;
+pub const EAI_OVERFLOW: ::c_int = -12;
+
+pub const NI_NUMERICHOST: ::c_int = 1;
+pub const NI_NUMERICSERV: ::c_int = 2;
+pub const NI_NOFQDN: ::c_int = 4;
+pub const NI_NAMEREQD: ::c_int = 8;
+pub const NI_DGRAM: ::c_int = 16;
+
+pub const SYNC_FILE_RANGE_WAIT_BEFORE: ::c_uint = 1;
+pub const SYNC_FILE_RANGE_WRITE: ::c_uint = 2;
+pub const SYNC_FILE_RANGE_WAIT_AFTER: ::c_uint = 4;
+
+pub const AIO_CANCELED: ::c_int = 0;
+pub const AIO_NOTCANCELED: ::c_int = 1;
+pub const AIO_ALLDONE: ::c_int = 2;
+pub const LIO_READ: ::c_int = 0;
+pub const LIO_WRITE: ::c_int = 1;
+pub const LIO_NOP: ::c_int = 2;
+pub const LIO_WAIT: ::c_int = 0;
+pub const LIO_NOWAIT: ::c_int = 1;
+
+pub const MREMAP_MAYMOVE: ::c_int = 1;
+pub const MREMAP_FIXED: ::c_int = 2;
+
+pub const PR_SET_PDEATHSIG: ::c_int = 1;
+pub const PR_GET_PDEATHSIG: ::c_int = 2;
+
+pub const PR_GET_DUMPABLE: ::c_int = 3;
+pub const PR_SET_DUMPABLE: ::c_int = 4;
+
+pub const PR_GET_UNALIGN: ::c_int = 5;
+pub const PR_SET_UNALIGN: ::c_int = 6;
+pub const PR_UNALIGN_NOPRINT: ::c_int = 1;
+pub const PR_UNALIGN_SIGBUS: ::c_int = 2;
+
+pub const PR_GET_KEEPCAPS: ::c_int = 7;
+pub const PR_SET_KEEPCAPS: ::c_int = 8;
+
+pub const PR_GET_FPEMU: ::c_int = 9;
+pub const PR_SET_FPEMU: ::c_int = 10;
+pub const PR_FPEMU_NOPRINT: ::c_int = 1;
+pub const PR_FPEMU_SIGFPE: ::c_int = 2;
+
+pub const PR_GET_FPEXC: ::c_int = 11;
+pub const PR_SET_FPEXC: ::c_int = 12;
+pub const PR_FP_EXC_SW_ENABLE: ::c_int = 0x80;
+pub const PR_FP_EXC_DIV: ::c_int = 0x010000;
+pub const PR_FP_EXC_OVF: ::c_int = 0x020000;
+pub const PR_FP_EXC_UND: ::c_int = 0x040000;
+pub const PR_FP_EXC_RES: ::c_int = 0x080000;
+pub const PR_FP_EXC_INV: ::c_int = 0x100000;
+pub const PR_FP_EXC_DISABLED: ::c_int = 0;
+pub const PR_FP_EXC_NONRECOV: ::c_int = 1;
+pub const PR_FP_EXC_ASYNC: ::c_int = 2;
+pub const PR_FP_EXC_PRECISE: ::c_int = 3;
+
+pub const PR_GET_TIMING: ::c_int = 13;
+pub const PR_SET_TIMING: ::c_int = 14;
+pub const PR_TIMING_STATISTICAL: ::c_int = 0;
+pub const PR_TIMING_TIMESTAMP: ::c_int = 1;
+
+pub const PR_SET_NAME: ::c_int = 15;
+pub const PR_GET_NAME: ::c_int = 16;
+
+pub const PR_GET_ENDIAN: ::c_int = 19;
+pub const PR_SET_ENDIAN: ::c_int = 20;
+pub const PR_ENDIAN_BIG: ::c_int = 0;
+pub const PR_ENDIAN_LITTLE: ::c_int = 1;
+pub const PR_ENDIAN_PPC_LITTLE: ::c_int = 2;
+
+pub const PR_GET_SECCOMP: ::c_int = 21;
+pub const PR_SET_SECCOMP: ::c_int = 22;
+
+pub const PR_CAPBSET_READ: ::c_int = 23;
+pub const PR_CAPBSET_DROP: ::c_int = 24;
+
+pub const PR_GET_TSC: ::c_int = 25;
+pub const PR_SET_TSC: ::c_int = 26;
+pub const PR_TSC_ENABLE: ::c_int = 1;
+pub const PR_TSC_SIGSEGV: ::c_int = 2;
+
+pub const PR_GET_SECUREBITS: ::c_int = 27;
+pub const PR_SET_SECUREBITS: ::c_int = 28;
+
+pub const PR_SET_TIMERSLACK: ::c_int = 29;
+pub const PR_GET_TIMERSLACK: ::c_int = 30;
+
+pub const PR_TASK_PERF_EVENTS_DISABLE: ::c_int = 31;
+pub const PR_TASK_PERF_EVENTS_ENABLE: ::c_int = 32;
+
+pub const PR_MCE_KILL: ::c_int = 33;
+pub const PR_MCE_KILL_CLEAR: ::c_int = 0;
+pub const PR_MCE_KILL_SET: ::c_int = 1;
+
+pub const PR_MCE_KILL_LATE: ::c_int = 0;
+pub const PR_MCE_KILL_EARLY: ::c_int = 1;
+pub const PR_MCE_KILL_DEFAULT: ::c_int = 2;
+
+pub const PR_MCE_KILL_GET: ::c_int = 34;
+
+pub const PR_SET_MM: ::c_int = 35;
+pub const PR_SET_MM_START_CODE: ::c_int = 1;
+pub const PR_SET_MM_END_CODE: ::c_int = 2;
+pub const PR_SET_MM_START_DATA: ::c_int = 3;
+pub const PR_SET_MM_END_DATA: ::c_int = 4;
+pub const PR_SET_MM_START_STACK: ::c_int = 5;
+pub const PR_SET_MM_START_BRK: ::c_int = 6;
+pub const PR_SET_MM_BRK: ::c_int = 7;
+pub const PR_SET_MM_ARG_START: ::c_int = 8;
+pub const PR_SET_MM_ARG_END: ::c_int = 9;
+pub const PR_SET_MM_ENV_START: ::c_int = 10;
+pub const PR_SET_MM_ENV_END: ::c_int = 11;
+pub const PR_SET_MM_AUXV: ::c_int = 12;
+pub const PR_SET_MM_EXE_FILE: ::c_int = 13;
+pub const PR_SET_MM_MAP: ::c_int = 14;
+pub const PR_SET_MM_MAP_SIZE: ::c_int = 15;
+
+pub const PR_SET_PTRACER: ::c_int = 0x59616d61;
+
+pub const PR_SET_CHILD_SUBREAPER: ::c_int = 36;
+pub const PR_GET_CHILD_SUBREAPER: ::c_int = 37;
+
+pub const PR_SET_NO_NEW_PRIVS: ::c_int = 38;
+pub const PR_GET_NO_NEW_PRIVS: ::c_int = 39;
+
+pub const PR_GET_TID_ADDRESS: ::c_int = 40;
+
+pub const PR_SET_THP_DISABLE: ::c_int = 41;
+pub const PR_GET_THP_DISABLE: ::c_int = 42;
+
+pub const PR_MPX_ENABLE_MANAGEMENT: ::c_int = 43;
+pub const PR_MPX_DISABLE_MANAGEMENT: ::c_int = 44;
+
+pub const PR_SET_FP_MODE: ::c_int = 45;
+pub const PR_GET_FP_MODE: ::c_int = 46;
+pub const PR_FP_MODE_FR: ::c_int = 1 << 0;
+pub const PR_FP_MODE_FRE: ::c_int = 1 << 1;
+
+pub const PR_CAP_AMBIENT: ::c_int = 47;
+pub const PR_CAP_AMBIENT_IS_SET: ::c_int = 1;
+pub const PR_CAP_AMBIENT_RAISE: ::c_int = 2;
+pub const PR_CAP_AMBIENT_LOWER: ::c_int = 3;
+pub const PR_CAP_AMBIENT_CLEAR_ALL: ::c_int = 4;
+
+pub const GRND_NONBLOCK: ::c_uint = 0x0001;
+pub const GRND_RANDOM: ::c_uint = 0x0002;
+
+pub const SECCOMP_MODE_DISABLED: ::c_uint = 0;
+pub const SECCOMP_MODE_STRICT: ::c_uint = 1;
+pub const SECCOMP_MODE_FILTER: ::c_uint = 2;
+
+pub const ITIMER_REAL: ::c_int = 0;
+pub const ITIMER_VIRTUAL: ::c_int = 1;
+pub const ITIMER_PROF: ::c_int = 2;
+
+pub const TFD_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const TFD_NONBLOCK: ::c_int = O_NONBLOCK;
+pub const TFD_TIMER_ABSTIME: ::c_int = 1;
+
+pub const XATTR_CREATE: ::c_int = 0x1;
+pub const XATTR_REPLACE: ::c_int = 0x2;
+
+pub const _POSIX_VDISABLE: ::cc_t = 0;
+
+pub const FALLOC_FL_KEEP_SIZE: ::c_int = 0x01;
+pub const FALLOC_FL_PUNCH_HOLE: ::c_int = 0x02;
+pub const FALLOC_FL_COLLAPSE_RANGE: ::c_int = 0x08;
+pub const FALLOC_FL_ZERO_RANGE: ::c_int = 0x10;
+pub const FALLOC_FL_INSERT_RANGE: ::c_int = 0x20;
+pub const FALLOC_FL_UNSHARE_RANGE: ::c_int = 0x40;
+
+#[deprecated(
+    since = "0.2.55",
+    note = "ENOATTR is not available on Linux; use ENODATA instead"
+)]
+pub const ENOATTR: ::c_int = ::ENODATA;
+
+pub const SO_ORIGINAL_DST: ::c_int = 80;
+
+pub const IP_RECVFRAGSIZE: ::c_int = 25;
+
+pub const IPV6_FLOWINFO: ::c_int = 11;
+pub const IPV6_MULTICAST_ALL: ::c_int = 29;
+pub const IPV6_ROUTER_ALERT_ISOLATE: ::c_int = 30;
+pub const IPV6_FLOWLABEL_MGR: ::c_int = 32;
+pub const IPV6_FLOWINFO_SEND: ::c_int = 33;
+pub const IPV6_RECVFRAGSIZE: ::c_int = 77;
+pub const IPV6_FREEBIND: ::c_int = 78;
+pub const IPV6_FLOWINFO_FLOWLABEL: ::c_int = 0x000fffff;
+pub const IPV6_FLOWINFO_PRIORITY: ::c_int = 0x0ff00000;
+
+pub const IPV6_RTHDR_LOOSE: ::c_int = 0;
+pub const IPV6_RTHDR_STRICT: ::c_int = 1;
+
+pub const IUTF8: ::tcflag_t = 0x00004000;
+pub const CMSPAR: ::tcflag_t = 0o10000000000;
+
+pub const MFD_CLOEXEC: ::c_uint = 0x0001;
+pub const MFD_ALLOW_SEALING: ::c_uint = 0x0002;
+pub const MFD_HUGETLB: ::c_uint = 0x0004;
+
+// these are used in the p_type field of Elf32_Phdr and Elf64_Phdr, which has
+// the type Elf32Word and Elf64Word respectively. Luckily, both of those are u32
+// so we can use that type here to avoid having to cast.
+pub const PT_NULL: u32 = 0;
+pub const PT_LOAD: u32 = 1;
+pub const PT_DYNAMIC: u32 = 2;
+pub const PT_INTERP: u32 = 3;
+pub const PT_NOTE: u32 = 4;
+pub const PT_SHLIB: u32 = 5;
+pub const PT_PHDR: u32 = 6;
+pub const PT_TLS: u32 = 7;
+pub const PT_NUM: u32 = 8;
+pub const PT_LOOS: u32 = 0x60000000;
+pub const PT_GNU_EH_FRAME: u32 = 0x6474e550;
+pub const PT_GNU_STACK: u32 = 0x6474e551;
+pub const PT_GNU_RELRO: u32 = 0x6474e552;
+
+// linux/if_ether.h
+pub const ETH_ALEN: ::c_int = 6;
+pub const ETH_HLEN: ::c_int = 14;
+pub const ETH_ZLEN: ::c_int = 60;
+pub const ETH_DATA_LEN: ::c_int = 1500;
+pub const ETH_FRAME_LEN: ::c_int = 1514;
+pub const ETH_FCS_LEN: ::c_int = 4;
+
+// These are the defined Ethernet Protocol ID's.
+pub const ETH_P_LOOP: ::c_int = 0x0060;
+pub const ETH_P_PUP: ::c_int = 0x0200;
+pub const ETH_P_PUPAT: ::c_int = 0x0201;
+pub const ETH_P_IP: ::c_int = 0x0800;
+pub const ETH_P_X25: ::c_int = 0x0805;
+pub const ETH_P_ARP: ::c_int = 0x0806;
+pub const ETH_P_BPQ: ::c_int = 0x08FF;
+pub const ETH_P_IEEEPUP: ::c_int = 0x0a00;
+pub const ETH_P_IEEEPUPAT: ::c_int = 0x0a01;
+pub const ETH_P_BATMAN: ::c_int = 0x4305;
+pub const ETH_P_DEC: ::c_int = 0x6000;
+pub const ETH_P_DNA_DL: ::c_int = 0x6001;
+pub const ETH_P_DNA_RC: ::c_int = 0x6002;
+pub const ETH_P_DNA_RT: ::c_int = 0x6003;
+pub const ETH_P_LAT: ::c_int = 0x6004;
+pub const ETH_P_DIAG: ::c_int = 0x6005;
+pub const ETH_P_CUST: ::c_int = 0x6006;
+pub const ETH_P_SCA: ::c_int = 0x6007;
+pub const ETH_P_TEB: ::c_int = 0x6558;
+pub const ETH_P_RARP: ::c_int = 0x8035;
+pub const ETH_P_ATALK: ::c_int = 0x809B;
+pub const ETH_P_AARP: ::c_int = 0x80F3;
+pub const ETH_P_8021Q: ::c_int = 0x8100;
+pub const ETH_P_IPX: ::c_int = 0x8137;
+pub const ETH_P_IPV6: ::c_int = 0x86DD;
+pub const ETH_P_PAUSE: ::c_int = 0x8808;
+pub const ETH_P_SLOW: ::c_int = 0x8809;
+pub const ETH_P_WCCP: ::c_int = 0x883E;
+pub const ETH_P_MPLS_UC: ::c_int = 0x8847;
+pub const ETH_P_MPLS_MC: ::c_int = 0x8848;
+pub const ETH_P_ATMMPOA: ::c_int = 0x884c;
+pub const ETH_P_PPP_DISC: ::c_int = 0x8863;
+pub const ETH_P_PPP_SES: ::c_int = 0x8864;
+pub const ETH_P_LINK_CTL: ::c_int = 0x886c;
+pub const ETH_P_ATMFATE: ::c_int = 0x8884;
+pub const ETH_P_PAE: ::c_int = 0x888E;
+pub const ETH_P_AOE: ::c_int = 0x88A2;
+pub const ETH_P_8021AD: ::c_int = 0x88A8;
+pub const ETH_P_802_EX1: ::c_int = 0x88B5;
+pub const ETH_P_TIPC: ::c_int = 0x88CA;
+pub const ETH_P_MACSEC: ::c_int = 0x88E5;
+pub const ETH_P_8021AH: ::c_int = 0x88E7;
+pub const ETH_P_MVRP: ::c_int = 0x88F5;
+pub const ETH_P_1588: ::c_int = 0x88F7;
+pub const ETH_P_PRP: ::c_int = 0x88FB;
+pub const ETH_P_FCOE: ::c_int = 0x8906;
+pub const ETH_P_TDLS: ::c_int = 0x890D;
+pub const ETH_P_FIP: ::c_int = 0x8914;
+pub const ETH_P_80221: ::c_int = 0x8917;
+pub const ETH_P_LOOPBACK: ::c_int = 0x9000;
+pub const ETH_P_QINQ1: ::c_int = 0x9100;
+pub const ETH_P_QINQ2: ::c_int = 0x9200;
+pub const ETH_P_QINQ3: ::c_int = 0x9300;
+pub const ETH_P_EDSA: ::c_int = 0xDADA;
+pub const ETH_P_AF_IUCV: ::c_int = 0xFBFB;
+
+pub const ETH_P_802_3_MIN: ::c_int = 0x0600;
+
+// Non DIX types. Won't clash for 1500 types.
+pub const ETH_P_802_3: ::c_int = 0x0001;
+pub const ETH_P_AX25: ::c_int = 0x0002;
+pub const ETH_P_ALL: ::c_int = 0x0003;
+pub const ETH_P_802_2: ::c_int = 0x0004;
+pub const ETH_P_SNAP: ::c_int = 0x0005;
+pub const ETH_P_DDCMP: ::c_int = 0x0006;
+pub const ETH_P_WAN_PPP: ::c_int = 0x0007;
+pub const ETH_P_PPP_MP: ::c_int = 0x0008;
+pub const ETH_P_LOCALTALK: ::c_int = 0x0009;
+pub const ETH_P_CANFD: ::c_int = 0x000D;
+pub const ETH_P_PPPTALK: ::c_int = 0x0010;
+pub const ETH_P_TR_802_2: ::c_int = 0x0011;
+pub const ETH_P_MOBITEX: ::c_int = 0x0015;
+pub const ETH_P_CONTROL: ::c_int = 0x0016;
+pub const ETH_P_IRDA: ::c_int = 0x0017;
+pub const ETH_P_ECONET: ::c_int = 0x0018;
+pub const ETH_P_HDLC: ::c_int = 0x0019;
+pub const ETH_P_ARCNET: ::c_int = 0x001A;
+pub const ETH_P_DSA: ::c_int = 0x001B;
+pub const ETH_P_TRAILER: ::c_int = 0x001C;
+pub const ETH_P_PHONET: ::c_int = 0x00F5;
+pub const ETH_P_IEEE802154: ::c_int = 0x00F6;
+pub const ETH_P_CAIF: ::c_int = 0x00F7;
+
+pub const POSIX_SPAWN_RESETIDS: ::c_int = 0x01;
+pub const POSIX_SPAWN_SETPGROUP: ::c_int = 0x02;
+pub const POSIX_SPAWN_SETSIGDEF: ::c_int = 0x04;
+pub const POSIX_SPAWN_SETSIGMASK: ::c_int = 0x08;
+pub const POSIX_SPAWN_SETSCHEDPARAM: ::c_int = 0x10;
+pub const POSIX_SPAWN_SETSCHEDULER: ::c_int = 0x20;
+
+pub const NLMSG_NOOP: ::c_int = 0x1;
+pub const NLMSG_ERROR: ::c_int = 0x2;
+pub const NLMSG_DONE: ::c_int = 0x3;
+pub const NLMSG_OVERRUN: ::c_int = 0x4;
+pub const NLMSG_MIN_TYPE: ::c_int = 0x10;
+
+// linux/netfilter/nfnetlink.h
+pub const NFNLGRP_NONE: ::c_int = 0;
+pub const NFNLGRP_CONNTRACK_NEW: ::c_int = 1;
+pub const NFNLGRP_CONNTRACK_UPDATE: ::c_int = 2;
+pub const NFNLGRP_CONNTRACK_DESTROY: ::c_int = 3;
+pub const NFNLGRP_CONNTRACK_EXP_NEW: ::c_int = 4;
+pub const NFNLGRP_CONNTRACK_EXP_UPDATE: ::c_int = 5;
+pub const NFNLGRP_CONNTRACK_EXP_DESTROY: ::c_int = 6;
+pub const NFNLGRP_NFTABLES: ::c_int = 7;
+pub const NFNLGRP_ACCT_QUOTA: ::c_int = 8;
+
+pub const NFNETLINK_V0: ::c_int = 0;
+
+pub const NFNL_SUBSYS_NONE: ::c_int = 0;
+pub const NFNL_SUBSYS_CTNETLINK: ::c_int = 1;
+pub const NFNL_SUBSYS_CTNETLINK_EXP: ::c_int = 2;
+pub const NFNL_SUBSYS_QUEUE: ::c_int = 3;
+pub const NFNL_SUBSYS_ULOG: ::c_int = 4;
+pub const NFNL_SUBSYS_OSF: ::c_int = 5;
+pub const NFNL_SUBSYS_IPSET: ::c_int = 6;
+pub const NFNL_SUBSYS_ACCT: ::c_int = 7;
+pub const NFNL_SUBSYS_CTNETLINK_TIMEOUT: ::c_int = 8;
+pub const NFNL_SUBSYS_CTHELPER: ::c_int = 9;
+pub const NFNL_SUBSYS_NFTABLES: ::c_int = 10;
+pub const NFNL_SUBSYS_NFT_COMPAT: ::c_int = 11;
+pub const NFNL_SUBSYS_COUNT: ::c_int = 12;
+
+pub const NFNL_MSG_BATCH_BEGIN: ::c_int = NLMSG_MIN_TYPE;
+pub const NFNL_MSG_BATCH_END: ::c_int = NLMSG_MIN_TYPE + 1;
+
+// linux/netfilter/nfnetlink_log.h
+pub const NFULNL_MSG_PACKET: ::c_int = 0;
+pub const NFULNL_MSG_CONFIG: ::c_int = 1;
+
+pub const NFULA_UNSPEC: ::c_int = 0;
+pub const NFULA_PACKET_HDR: ::c_int = 1;
+pub const NFULA_MARK: ::c_int = 2;
+pub const NFULA_TIMESTAMP: ::c_int = 3;
+pub const NFULA_IFINDEX_INDEV: ::c_int = 4;
+pub const NFULA_IFINDEX_OUTDEV: ::c_int = 5;
+pub const NFULA_IFINDEX_PHYSINDEV: ::c_int = 6;
+pub const NFULA_IFINDEX_PHYSOUTDEV: ::c_int = 7;
+pub const NFULA_HWADDR: ::c_int = 8;
+pub const NFULA_PAYLOAD: ::c_int = 9;
+pub const NFULA_PREFIX: ::c_int = 10;
+pub const NFULA_UID: ::c_int = 11;
+pub const NFULA_SEQ: ::c_int = 12;
+pub const NFULA_SEQ_GLOBAL: ::c_int = 13;
+pub const NFULA_GID: ::c_int = 14;
+pub const NFULA_HWTYPE: ::c_int = 15;
+pub const NFULA_HWHEADER: ::c_int = 16;
+pub const NFULA_HWLEN: ::c_int = 17;
+pub const NFULA_CT: ::c_int = 18;
+pub const NFULA_CT_INFO: ::c_int = 19;
+
+pub const NFULNL_CFG_CMD_NONE: ::c_int = 0;
+pub const NFULNL_CFG_CMD_BIND: ::c_int = 1;
+pub const NFULNL_CFG_CMD_UNBIND: ::c_int = 2;
+pub const NFULNL_CFG_CMD_PF_BIND: ::c_int = 3;
+pub const NFULNL_CFG_CMD_PF_UNBIND: ::c_int = 4;
+
+pub const NFULA_CFG_UNSPEC: ::c_int = 0;
+pub const NFULA_CFG_CMD: ::c_int = 1;
+pub const NFULA_CFG_MODE: ::c_int = 2;
+pub const NFULA_CFG_NLBUFSIZ: ::c_int = 3;
+pub const NFULA_CFG_TIMEOUT: ::c_int = 4;
+pub const NFULA_CFG_QTHRESH: ::c_int = 5;
+pub const NFULA_CFG_FLAGS: ::c_int = 6;
+
+pub const NFULNL_COPY_NONE: ::c_int = 0x00;
+pub const NFULNL_COPY_META: ::c_int = 0x01;
+pub const NFULNL_COPY_PACKET: ::c_int = 0x02;
+
+pub const NFULNL_CFG_F_SEQ: ::c_int = 0x0001;
+pub const NFULNL_CFG_F_SEQ_GLOBAL: ::c_int = 0x0002;
+pub const NFULNL_CFG_F_CONNTRACK: ::c_int = 0x0004;
+
+// linux/netfilter/nfnetlink_log.h
+pub const NFQNL_MSG_PACKET: ::c_int = 0;
+pub const NFQNL_MSG_VERDICT: ::c_int = 1;
+pub const NFQNL_MSG_CONFIG: ::c_int = 2;
+pub const NFQNL_MSG_VERDICT_BATCH: ::c_int = 3;
+
+pub const NFQA_UNSPEC: ::c_int = 0;
+pub const NFQA_PACKET_HDR: ::c_int = 1;
+pub const NFQA_VERDICT_HDR: ::c_int = 2;
+pub const NFQA_MARK: ::c_int = 3;
+pub const NFQA_TIMESTAMP: ::c_int = 4;
+pub const NFQA_IFINDEX_INDEV: ::c_int = 5;
+pub const NFQA_IFINDEX_OUTDEV: ::c_int = 6;
+pub const NFQA_IFINDEX_PHYSINDEV: ::c_int = 7;
+pub const NFQA_IFINDEX_PHYSOUTDEV: ::c_int = 8;
+pub const NFQA_HWADDR: ::c_int = 9;
+pub const NFQA_PAYLOAD: ::c_int = 10;
+pub const NFQA_CT: ::c_int = 11;
+pub const NFQA_CT_INFO: ::c_int = 12;
+pub const NFQA_CAP_LEN: ::c_int = 13;
+pub const NFQA_SKB_INFO: ::c_int = 14;
+pub const NFQA_EXP: ::c_int = 15;
+pub const NFQA_UID: ::c_int = 16;
+pub const NFQA_GID: ::c_int = 17;
+pub const NFQA_SECCTX: ::c_int = 18;
+/*
+ FIXME: These are not yet available in musl sanitized kernel headers and
+ make the tests fail. Enable them once musl has them.
+
+ See https://github.com/rust-lang/libc/pull/1628 for more details.
+pub const NFQA_VLAN: ::c_int = 19;
+pub const NFQA_L2HDR: ::c_int = 20;
+
+pub const NFQA_VLAN_UNSPEC: ::c_int = 0;
+pub const NFQA_VLAN_PROTO: ::c_int = 1;
+pub const NFQA_VLAN_TCI: ::c_int = 2;
+*/
+
+pub const NFQNL_CFG_CMD_NONE: ::c_int = 0;
+pub const NFQNL_CFG_CMD_BIND: ::c_int = 1;
+pub const NFQNL_CFG_CMD_UNBIND: ::c_int = 2;
+pub const NFQNL_CFG_CMD_PF_BIND: ::c_int = 3;
+pub const NFQNL_CFG_CMD_PF_UNBIND: ::c_int = 4;
+
+pub const NFQNL_COPY_NONE: ::c_int = 0;
+pub const NFQNL_COPY_META: ::c_int = 1;
+pub const NFQNL_COPY_PACKET: ::c_int = 2;
+
+pub const NFQA_CFG_UNSPEC: ::c_int = 0;
+pub const NFQA_CFG_CMD: ::c_int = 1;
+pub const NFQA_CFG_PARAMS: ::c_int = 2;
+pub const NFQA_CFG_QUEUE_MAXLEN: ::c_int = 3;
+pub const NFQA_CFG_MASK: ::c_int = 4;
+pub const NFQA_CFG_FLAGS: ::c_int = 5;
+
+pub const NFQA_CFG_F_FAIL_OPEN: ::c_int = 0x0001;
+pub const NFQA_CFG_F_CONNTRACK: ::c_int = 0x0002;
+pub const NFQA_CFG_F_GSO: ::c_int = 0x0004;
+pub const NFQA_CFG_F_UID_GID: ::c_int = 0x0008;
+pub const NFQA_CFG_F_SECCTX: ::c_int = 0x0010;
+pub const NFQA_CFG_F_MAX: ::c_int = 0x0020;
+
+pub const NFQA_SKB_CSUMNOTREADY: ::c_int = 0x0001;
+pub const NFQA_SKB_GSO: ::c_int = 0x0002;
+pub const NFQA_SKB_CSUM_NOTVERIFIED: ::c_int = 0x0004;
+
+pub const GENL_NAMSIZ: ::c_int = 16;
+
+pub const GENL_MIN_ID: ::c_int = NLMSG_MIN_TYPE;
+pub const GENL_MAX_ID: ::c_int = 1023;
+
+pub const GENL_ADMIN_PERM: ::c_int = 0x01;
+pub const GENL_CMD_CAP_DO: ::c_int = 0x02;
+pub const GENL_CMD_CAP_DUMP: ::c_int = 0x04;
+pub const GENL_CMD_CAP_HASPOL: ::c_int = 0x08;
+
+pub const GENL_ID_CTRL: ::c_int = NLMSG_MIN_TYPE;
+
+pub const CTRL_CMD_UNSPEC: ::c_int = 0;
+pub const CTRL_CMD_NEWFAMILY: ::c_int = 1;
+pub const CTRL_CMD_DELFAMILY: ::c_int = 2;
+pub const CTRL_CMD_GETFAMILY: ::c_int = 3;
+pub const CTRL_CMD_NEWOPS: ::c_int = 4;
+pub const CTRL_CMD_DELOPS: ::c_int = 5;
+pub const CTRL_CMD_GETOPS: ::c_int = 6;
+pub const CTRL_CMD_NEWMCAST_GRP: ::c_int = 7;
+pub const CTRL_CMD_DELMCAST_GRP: ::c_int = 8;
+pub const CTRL_CMD_GETMCAST_GRP: ::c_int = 9;
+
+pub const CTRL_ATTR_UNSPEC: ::c_int = 0;
+pub const CTRL_ATTR_FAMILY_ID: ::c_int = 1;
+pub const CTRL_ATTR_FAMILY_NAME: ::c_int = 2;
+pub const CTRL_ATTR_VERSION: ::c_int = 3;
+pub const CTRL_ATTR_HDRSIZE: ::c_int = 4;
+pub const CTRL_ATTR_MAXATTR: ::c_int = 5;
+pub const CTRL_ATTR_OPS: ::c_int = 6;
+pub const CTRL_ATTR_MCAST_GROUPS: ::c_int = 7;
+
+pub const CTRL_ATTR_OP_UNSPEC: ::c_int = 0;
+pub const CTRL_ATTR_OP_ID: ::c_int = 1;
+pub const CTRL_ATTR_OP_FLAGS: ::c_int = 2;
+
+pub const CTRL_ATTR_MCAST_GRP_UNSPEC: ::c_int = 0;
+pub const CTRL_ATTR_MCAST_GRP_NAME: ::c_int = 1;
+pub const CTRL_ATTR_MCAST_GRP_ID: ::c_int = 2;
+
+// linux/if_packet.h
+pub const PACKET_ADD_MEMBERSHIP: ::c_int = 1;
+pub const PACKET_DROP_MEMBERSHIP: ::c_int = 2;
+
+pub const PACKET_MR_MULTICAST: ::c_int = 0;
+pub const PACKET_MR_PROMISC: ::c_int = 1;
+pub const PACKET_MR_ALLMULTI: ::c_int = 2;
+pub const PACKET_MR_UNICAST: ::c_int = 3;
+
+// linux/netfilter.h
+pub const NF_DROP: ::c_int = 0;
+pub const NF_ACCEPT: ::c_int = 1;
+pub const NF_STOLEN: ::c_int = 2;
+pub const NF_QUEUE: ::c_int = 3;
+pub const NF_REPEAT: ::c_int = 4;
+pub const NF_STOP: ::c_int = 5;
+pub const NF_MAX_VERDICT: ::c_int = NF_STOP;
+
+pub const NF_VERDICT_MASK: ::c_int = 0x000000ff;
+pub const NF_VERDICT_FLAG_QUEUE_BYPASS: ::c_int = 0x00008000;
+
+pub const NF_VERDICT_QMASK: ::c_int = 0xffff0000;
+pub const NF_VERDICT_QBITS: ::c_int = 16;
+
+pub const NF_VERDICT_BITS: ::c_int = 16;
+
+pub const NF_INET_PRE_ROUTING: ::c_int = 0;
+pub const NF_INET_LOCAL_IN: ::c_int = 1;
+pub const NF_INET_FORWARD: ::c_int = 2;
+pub const NF_INET_LOCAL_OUT: ::c_int = 3;
+pub const NF_INET_POST_ROUTING: ::c_int = 4;
+pub const NF_INET_NUMHOOKS: ::c_int = 5;
+
+// Some NFPROTO are not compatible with musl and are defined in submodules.
+pub const NFPROTO_UNSPEC: ::c_int = 0;
+pub const NFPROTO_IPV4: ::c_int = 2;
+pub const NFPROTO_ARP: ::c_int = 3;
+pub const NFPROTO_BRIDGE: ::c_int = 7;
+pub const NFPROTO_IPV6: ::c_int = 10;
+pub const NFPROTO_DECNET: ::c_int = 12;
+pub const NFPROTO_NUMPROTO: ::c_int = 13;
+
+// linux/netfilter_ipv4.h
+pub const NF_IP_PRE_ROUTING: ::c_int = 0;
+pub const NF_IP_LOCAL_IN: ::c_int = 1;
+pub const NF_IP_FORWARD: ::c_int = 2;
+pub const NF_IP_LOCAL_OUT: ::c_int = 3;
+pub const NF_IP_POST_ROUTING: ::c_int = 4;
+pub const NF_IP_NUMHOOKS: ::c_int = 5;
+
+pub const NF_IP_PRI_FIRST: ::c_int = ::INT_MIN;
+pub const NF_IP_PRI_CONNTRACK_DEFRAG: ::c_int = -400;
+pub const NF_IP_PRI_RAW: ::c_int = -300;
+pub const NF_IP_PRI_SELINUX_FIRST: ::c_int = -225;
+pub const NF_IP_PRI_CONNTRACK: ::c_int = -200;
+pub const NF_IP_PRI_MANGLE: ::c_int = -150;
+pub const NF_IP_PRI_NAT_DST: ::c_int = -100;
+pub const NF_IP_PRI_FILTER: ::c_int = 0;
+pub const NF_IP_PRI_SECURITY: ::c_int = 50;
+pub const NF_IP_PRI_NAT_SRC: ::c_int = 100;
+pub const NF_IP_PRI_SELINUX_LAST: ::c_int = 225;
+pub const NF_IP_PRI_CONNTRACK_HELPER: ::c_int = 300;
+pub const NF_IP_PRI_CONNTRACK_CONFIRM: ::c_int = ::INT_MAX;
+pub const NF_IP_PRI_LAST: ::c_int = ::INT_MAX;
+
+// linux/netfilter_ipv6.h
+pub const NF_IP6_PRE_ROUTING: ::c_int = 0;
+pub const NF_IP6_LOCAL_IN: ::c_int = 1;
+pub const NF_IP6_FORWARD: ::c_int = 2;
+pub const NF_IP6_LOCAL_OUT: ::c_int = 3;
+pub const NF_IP6_POST_ROUTING: ::c_int = 4;
+pub const NF_IP6_NUMHOOKS: ::c_int = 5;
+
+pub const NF_IP6_PRI_FIRST: ::c_int = ::INT_MIN;
+pub const NF_IP6_PRI_CONNTRACK_DEFRAG: ::c_int = -400;
+pub const NF_IP6_PRI_RAW: ::c_int = -300;
+pub const NF_IP6_PRI_SELINUX_FIRST: ::c_int = -225;
+pub const NF_IP6_PRI_CONNTRACK: ::c_int = -200;
+pub const NF_IP6_PRI_MANGLE: ::c_int = -150;
+pub const NF_IP6_PRI_NAT_DST: ::c_int = -100;
+pub const NF_IP6_PRI_FILTER: ::c_int = 0;
+pub const NF_IP6_PRI_SECURITY: ::c_int = 50;
+pub const NF_IP6_PRI_NAT_SRC: ::c_int = 100;
+pub const NF_IP6_PRI_SELINUX_LAST: ::c_int = 225;
+pub const NF_IP6_PRI_CONNTRACK_HELPER: ::c_int = 300;
+pub const NF_IP6_PRI_LAST: ::c_int = ::INT_MAX;
+
+// linux/netfilter_ipv6/ip6_tables.h
+pub const IP6T_SO_ORIGINAL_DST: ::c_int = 80;
+
+pub const SIOCADDRT: ::c_ulong = 0x0000890B;
+pub const SIOCDELRT: ::c_ulong = 0x0000890C;
+pub const SIOCGIFNAME: ::c_ulong = 0x00008910;
+pub const SIOCSIFLINK: ::c_ulong = 0x00008911;
+pub const SIOCGIFCONF: ::c_ulong = 0x00008912;
+pub const SIOCGIFFLAGS: ::c_ulong = 0x00008913;
+pub const SIOCSIFFLAGS: ::c_ulong = 0x00008914;
+pub const SIOCGIFADDR: ::c_ulong = 0x00008915;
+pub const SIOCSIFADDR: ::c_ulong = 0x00008916;
+pub const SIOCGIFDSTADDR: ::c_ulong = 0x00008917;
+pub const SIOCSIFDSTADDR: ::c_ulong = 0x00008918;
+pub const SIOCGIFBRDADDR: ::c_ulong = 0x00008919;
+pub const SIOCSIFBRDADDR: ::c_ulong = 0x0000891A;
+pub const SIOCGIFNETMASK: ::c_ulong = 0x0000891B;
+pub const SIOCSIFNETMASK: ::c_ulong = 0x0000891C;
+pub const SIOCGIFMETRIC: ::c_ulong = 0x0000891D;
+pub const SIOCSIFMETRIC: ::c_ulong = 0x0000891E;
+pub const SIOCGIFMEM: ::c_ulong = 0x0000891F;
+pub const SIOCSIFMEM: ::c_ulong = 0x00008920;
+pub const SIOCGIFMTU: ::c_ulong = 0x00008921;
+pub const SIOCSIFMTU: ::c_ulong = 0x00008922;
+pub const SIOCSIFHWADDR: ::c_ulong = 0x00008924;
+pub const SIOCGIFENCAP: ::c_ulong = 0x00008925;
+pub const SIOCSIFENCAP: ::c_ulong = 0x00008926;
+pub const SIOCGIFHWADDR: ::c_ulong = 0x00008927;
+pub const SIOCGIFSLAVE: ::c_ulong = 0x00008929;
+pub const SIOCSIFSLAVE: ::c_ulong = 0x00008930;
+pub const SIOCADDMULTI: ::c_ulong = 0x00008931;
+pub const SIOCDELMULTI: ::c_ulong = 0x00008932;
+pub const SIOCDARP: ::c_ulong = 0x00008953;
+pub const SIOCGARP: ::c_ulong = 0x00008954;
+pub const SIOCSARP: ::c_ulong = 0x00008955;
+pub const SIOCDRARP: ::c_ulong = 0x00008960;
+pub const SIOCGRARP: ::c_ulong = 0x00008961;
+pub const SIOCSRARP: ::c_ulong = 0x00008962;
+pub const SIOCGIFMAP: ::c_ulong = 0x00008970;
+pub const SIOCSIFMAP: ::c_ulong = 0x00008971;
+
+pub const PTRACE_EVENT_STOP: ::c_int = 128;
+
+pub const IPTOS_TOS_MASK: u8 = 0x1E;
+pub const IPTOS_PREC_MASK: u8 = 0xE0;
+
+pub const IPTOS_ECN_NOT_ECT: u8 = 0x00;
+
+pub const RTF_UP: ::c_ushort = 0x0001;
+pub const RTF_GATEWAY: ::c_ushort = 0x0002;
+
+pub const RTF_HOST: ::c_ushort = 0x0004;
+pub const RTF_REINSTATE: ::c_ushort = 0x0008;
+pub const RTF_DYNAMIC: ::c_ushort = 0x0010;
+pub const RTF_MODIFIED: ::c_ushort = 0x0020;
+pub const RTF_MTU: ::c_ushort = 0x0040;
+pub const RTF_MSS: ::c_ushort = RTF_MTU;
+pub const RTF_WINDOW: ::c_ushort = 0x0080;
+pub const RTF_IRTT: ::c_ushort = 0x0100;
+pub const RTF_REJECT: ::c_ushort = 0x0200;
+pub const RTF_STATIC: ::c_ushort = 0x0400;
+pub const RTF_XRESOLVE: ::c_ushort = 0x0800;
+pub const RTF_NOFORWARD: ::c_ushort = 0x1000;
+pub const RTF_THROW: ::c_ushort = 0x2000;
+pub const RTF_NOPMTUDISC: ::c_ushort = 0x4000;
+
+pub const RTF_DEFAULT: u32 = 0x00010000;
+pub const RTF_ALLONLINK: u32 = 0x00020000;
+pub const RTF_ADDRCONF: u32 = 0x00040000;
+pub const RTF_LINKRT: u32 = 0x00100000;
+pub const RTF_NONEXTHOP: u32 = 0x00200000;
+pub const RTF_CACHE: u32 = 0x01000000;
+pub const RTF_FLOW: u32 = 0x02000000;
+pub const RTF_POLICY: u32 = 0x04000000;
+
+pub const RTCF_VALVE: u32 = 0x00200000;
+pub const RTCF_MASQ: u32 = 0x00400000;
+pub const RTCF_NAT: u32 = 0x00800000;
+pub const RTCF_DOREDIRECT: u32 = 0x01000000;
+pub const RTCF_LOG: u32 = 0x02000000;
+pub const RTCF_DIRECTSRC: u32 = 0x04000000;
+
+pub const RTF_LOCAL: u32 = 0x80000000;
+pub const RTF_INTERFACE: u32 = 0x40000000;
+pub const RTF_MULTICAST: u32 = 0x20000000;
+pub const RTF_BROADCAST: u32 = 0x10000000;
+pub const RTF_NAT: u32 = 0x08000000;
+pub const RTF_ADDRCLASSMASK: u32 = 0xF8000000;
+
+pub const RT_CLASS_UNSPEC: u8 = 0;
+pub const RT_CLASS_DEFAULT: u8 = 253;
+pub const RT_CLASS_MAIN: u8 = 254;
+pub const RT_CLASS_LOCAL: u8 = 255;
+pub const RT_CLASS_MAX: u8 = 255;
+
+// linux/neighbor.h
+pub const NUD_NONE: u16 = 0x00;
+pub const NUD_INCOMPLETE: u16 = 0x01;
+pub const NUD_REACHABLE: u16 = 0x02;
+pub const NUD_STALE: u16 = 0x04;
+pub const NUD_DELAY: u16 = 0x08;
+pub const NUD_PROBE: u16 = 0x10;
+pub const NUD_FAILED: u16 = 0x20;
+pub const NUD_NOARP: u16 = 0x40;
+pub const NUD_PERMANENT: u16 = 0x80;
+
+pub const NTF_USE: u8 = 0x01;
+pub const NTF_SELF: u8 = 0x02;
+pub const NTF_MASTER: u8 = 0x04;
+pub const NTF_PROXY: u8 = 0x08;
+pub const NTF_ROUTER: u8 = 0x80;
+
+pub const NDA_UNSPEC: ::c_ushort = 0;
+pub const NDA_DST: ::c_ushort = 1;
+pub const NDA_LLADDR: ::c_ushort = 2;
+pub const NDA_CACHEINFO: ::c_ushort = 3;
+pub const NDA_PROBES: ::c_ushort = 4;
+pub const NDA_VLAN: ::c_ushort = 5;
+pub const NDA_PORT: ::c_ushort = 6;
+pub const NDA_VNI: ::c_ushort = 7;
+pub const NDA_IFINDEX: ::c_ushort = 8;
+
+// linux/netlink.h
+pub const NLA_ALIGNTO: ::c_int = 4;
+
+pub const NETLINK_ROUTE: ::c_int = 0;
+pub const NETLINK_UNUSED: ::c_int = 1;
+pub const NETLINK_USERSOCK: ::c_int = 2;
+pub const NETLINK_FIREWALL: ::c_int = 3;
+pub const NETLINK_SOCK_DIAG: ::c_int = 4;
+pub const NETLINK_NFLOG: ::c_int = 5;
+pub const NETLINK_XFRM: ::c_int = 6;
+pub const NETLINK_SELINUX: ::c_int = 7;
+pub const NETLINK_ISCSI: ::c_int = 8;
+pub const NETLINK_AUDIT: ::c_int = 9;
+pub const NETLINK_FIB_LOOKUP: ::c_int = 10;
+pub const NETLINK_CONNECTOR: ::c_int = 11;
+pub const NETLINK_NETFILTER: ::c_int = 12;
+pub const NETLINK_IP6_FW: ::c_int = 13;
+pub const NETLINK_DNRTMSG: ::c_int = 14;
+pub const NETLINK_KOBJECT_UEVENT: ::c_int = 15;
+pub const NETLINK_GENERIC: ::c_int = 16;
+pub const NETLINK_SCSITRANSPORT: ::c_int = 18;
+pub const NETLINK_ECRYPTFS: ::c_int = 19;
+pub const NETLINK_RDMA: ::c_int = 20;
+pub const NETLINK_CRYPTO: ::c_int = 21;
+pub const NETLINK_INET_DIAG: ::c_int = NETLINK_SOCK_DIAG;
+
+pub const NLM_F_REQUEST: ::c_int = 1;
+pub const NLM_F_MULTI: ::c_int = 2;
+pub const NLM_F_ACK: ::c_int = 4;
+pub const NLM_F_ECHO: ::c_int = 8;
+pub const NLM_F_DUMP_INTR: ::c_int = 16;
+pub const NLM_F_DUMP_FILTERED: ::c_int = 32;
+
+pub const NLM_F_ROOT: ::c_int = 0x100;
+pub const NLM_F_MATCH: ::c_int = 0x200;
+pub const NLM_F_ATOMIC: ::c_int = 0x400;
+pub const NLM_F_DUMP: ::c_int = NLM_F_ROOT | NLM_F_MATCH;
+
+pub const NLM_F_REPLACE: ::c_int = 0x100;
+pub const NLM_F_EXCL: ::c_int = 0x200;
+pub const NLM_F_CREATE: ::c_int = 0x400;
+pub const NLM_F_APPEND: ::c_int = 0x800;
+
+pub const NETLINK_ADD_MEMBERSHIP: ::c_int = 1;
+pub const NETLINK_DROP_MEMBERSHIP: ::c_int = 2;
+pub const NETLINK_PKTINFO: ::c_int = 3;
+pub const NETLINK_BROADCAST_ERROR: ::c_int = 4;
+pub const NETLINK_NO_ENOBUFS: ::c_int = 5;
+pub const NETLINK_RX_RING: ::c_int = 6;
+pub const NETLINK_TX_RING: ::c_int = 7;
+pub const NETLINK_LISTEN_ALL_NSID: ::c_int = 8;
+pub const NETLINK_LIST_MEMBERSHIPS: ::c_int = 9;
+pub const NETLINK_CAP_ACK: ::c_int = 10;
+
+pub const NLA_F_NESTED: ::c_int = 1 << 15;
+pub const NLA_F_NET_BYTEORDER: ::c_int = 1 << 14;
+pub const NLA_TYPE_MASK: ::c_int = !(NLA_F_NESTED | NLA_F_NET_BYTEORDER);
+
+// linux/rtnetlink.h
+pub const TCA_UNSPEC: ::c_ushort = 0;
+pub const TCA_KIND: ::c_ushort = 1;
+pub const TCA_OPTIONS: ::c_ushort = 2;
+pub const TCA_STATS: ::c_ushort = 3;
+pub const TCA_XSTATS: ::c_ushort = 4;
+pub const TCA_RATE: ::c_ushort = 5;
+pub const TCA_FCNT: ::c_ushort = 6;
+pub const TCA_STATS2: ::c_ushort = 7;
+pub const TCA_STAB: ::c_ushort = 8;
+
+pub const RTM_NEWLINK: u16 = 16;
+pub const RTM_DELLINK: u16 = 17;
+pub const RTM_GETLINK: u16 = 18;
+pub const RTM_SETLINK: u16 = 19;
+pub const RTM_NEWADDR: u16 = 20;
+pub const RTM_DELADDR: u16 = 21;
+pub const RTM_GETADDR: u16 = 22;
+pub const RTM_NEWROUTE: u16 = 24;
+pub const RTM_DELROUTE: u16 = 25;
+pub const RTM_GETROUTE: u16 = 26;
+pub const RTM_NEWNEIGH: u16 = 28;
+pub const RTM_DELNEIGH: u16 = 29;
+pub const RTM_GETNEIGH: u16 = 30;
+pub const RTM_NEWRULE: u16 = 32;
+pub const RTM_DELRULE: u16 = 33;
+pub const RTM_GETRULE: u16 = 34;
+pub const RTM_NEWQDISC: u16 = 36;
+pub const RTM_DELQDISC: u16 = 37;
+pub const RTM_GETQDISC: u16 = 38;
+pub const RTM_NEWTCLASS: u16 = 40;
+pub const RTM_DELTCLASS: u16 = 41;
+pub const RTM_GETTCLASS: u16 = 42;
+pub const RTM_NEWTFILTER: u16 = 44;
+pub const RTM_DELTFILTER: u16 = 45;
+pub const RTM_GETTFILTER: u16 = 46;
+pub const RTM_NEWACTION: u16 = 48;
+pub const RTM_DELACTION: u16 = 49;
+pub const RTM_GETACTION: u16 = 50;
+pub const RTM_NEWPREFIX: u16 = 52;
+pub const RTM_GETMULTICAST: u16 = 58;
+pub const RTM_GETANYCAST: u16 = 62;
+pub const RTM_NEWNEIGHTBL: u16 = 64;
+pub const RTM_GETNEIGHTBL: u16 = 66;
+pub const RTM_SETNEIGHTBL: u16 = 67;
+pub const RTM_NEWNDUSEROPT: u16 = 68;
+pub const RTM_NEWADDRLABEL: u16 = 72;
+pub const RTM_DELADDRLABEL: u16 = 73;
+pub const RTM_GETADDRLABEL: u16 = 74;
+pub const RTM_GETDCB: u16 = 78;
+pub const RTM_SETDCB: u16 = 79;
+pub const RTM_NEWNETCONF: u16 = 80;
+pub const RTM_GETNETCONF: u16 = 82;
+pub const RTM_NEWMDB: u16 = 84;
+pub const RTM_DELMDB: u16 = 85;
+pub const RTM_GETMDB: u16 = 86;
+pub const RTM_NEWNSID: u16 = 88;
+pub const RTM_DELNSID: u16 = 89;
+pub const RTM_GETNSID: u16 = 90;
+
+pub const RTM_F_NOTIFY: ::c_uint = 0x100;
+pub const RTM_F_CLONED: ::c_uint = 0x200;
+pub const RTM_F_EQUALIZE: ::c_uint = 0x400;
+pub const RTM_F_PREFIX: ::c_uint = 0x800;
+
+pub const RTA_UNSPEC: ::c_ushort = 0;
+pub const RTA_DST: ::c_ushort = 1;
+pub const RTA_SRC: ::c_ushort = 2;
+pub const RTA_IIF: ::c_ushort = 3;
+pub const RTA_OIF: ::c_ushort = 4;
+pub const RTA_GATEWAY: ::c_ushort = 5;
+pub const RTA_PRIORITY: ::c_ushort = 6;
+pub const RTA_PREFSRC: ::c_ushort = 7;
+pub const RTA_METRICS: ::c_ushort = 8;
+pub const RTA_MULTIPATH: ::c_ushort = 9;
+pub const RTA_PROTOINFO: ::c_ushort = 10; // No longer used
+pub const RTA_FLOW: ::c_ushort = 11;
+pub const RTA_CACHEINFO: ::c_ushort = 12;
+pub const RTA_SESSION: ::c_ushort = 13; // No longer used
+pub const RTA_MP_ALGO: ::c_ushort = 14; // No longer used
+pub const RTA_TABLE: ::c_ushort = 15;
+pub const RTA_MARK: ::c_ushort = 16;
+pub const RTA_MFC_STATS: ::c_ushort = 17;
+
+pub const RTN_UNSPEC: ::c_uchar = 0;
+pub const RTN_UNICAST: ::c_uchar = 1;
+pub const RTN_LOCAL: ::c_uchar = 2;
+pub const RTN_BROADCAST: ::c_uchar = 3;
+pub const RTN_ANYCAST: ::c_uchar = 4;
+pub const RTN_MULTICAST: ::c_uchar = 5;
+pub const RTN_BLACKHOLE: ::c_uchar = 6;
+pub const RTN_UNREACHABLE: ::c_uchar = 7;
+pub const RTN_PROHIBIT: ::c_uchar = 8;
+pub const RTN_THROW: ::c_uchar = 9;
+pub const RTN_NAT: ::c_uchar = 10;
+pub const RTN_XRESOLVE: ::c_uchar = 11;
+
+pub const RTPROT_UNSPEC: ::c_uchar = 0;
+pub const RTPROT_REDIRECT: ::c_uchar = 1;
+pub const RTPROT_KERNEL: ::c_uchar = 2;
+pub const RTPROT_BOOT: ::c_uchar = 3;
+pub const RTPROT_STATIC: ::c_uchar = 4;
+
+pub const RT_SCOPE_UNIVERSE: ::c_uchar = 0;
+pub const RT_SCOPE_SITE: ::c_uchar = 200;
+pub const RT_SCOPE_LINK: ::c_uchar = 253;
+pub const RT_SCOPE_HOST: ::c_uchar = 254;
+pub const RT_SCOPE_NOWHERE: ::c_uchar = 255;
+
+pub const RT_TABLE_UNSPEC: ::c_uchar = 0;
+pub const RT_TABLE_COMPAT: ::c_uchar = 252;
+pub const RT_TABLE_DEFAULT: ::c_uchar = 253;
+pub const RT_TABLE_MAIN: ::c_uchar = 254;
+pub const RT_TABLE_LOCAL: ::c_uchar = 255;
+
+pub const RTMSG_OVERRUN: u32 = ::NLMSG_OVERRUN as u32;
+pub const RTMSG_NEWDEVICE: u32 = 0x11;
+pub const RTMSG_DELDEVICE: u32 = 0x12;
+pub const RTMSG_NEWROUTE: u32 = 0x21;
+pub const RTMSG_DELROUTE: u32 = 0x22;
+pub const RTMSG_NEWRULE: u32 = 0x31;
+pub const RTMSG_DELRULE: u32 = 0x32;
+pub const RTMSG_CONTROL: u32 = 0x40;
+pub const RTMSG_AR_FAILED: u32 = 0x51;
+
+pub const MAX_ADDR_LEN: usize = 7;
+pub const ARPD_UPDATE: ::c_ushort = 0x01;
+pub const ARPD_LOOKUP: ::c_ushort = 0x02;
+pub const ARPD_FLUSH: ::c_ushort = 0x03;
+pub const ATF_MAGIC: ::c_int = 0x80;
+
+#[cfg(not(target_arch = "sparc64"))]
+pub const SO_TIMESTAMPING: ::c_int = 37;
+#[cfg(target_arch = "sparc64")]
+pub const SO_TIMESTAMPING: ::c_int = 35;
+pub const SCM_TIMESTAMPING: ::c_int = SO_TIMESTAMPING;
+
+// linux/module.h
+pub const MODULE_INIT_IGNORE_MODVERSIONS: ::c_uint = 0x0001;
+pub const MODULE_INIT_IGNORE_VERMAGIC: ::c_uint = 0x0002;
+
+// linux/net_tstamp.h
+pub const SOF_TIMESTAMPING_TX_HARDWARE: ::c_uint = 1 << 0;
+pub const SOF_TIMESTAMPING_TX_SOFTWARE: ::c_uint = 1 << 1;
+pub const SOF_TIMESTAMPING_RX_HARDWARE: ::c_uint = 1 << 2;
+pub const SOF_TIMESTAMPING_RX_SOFTWARE: ::c_uint = 1 << 3;
+pub const SOF_TIMESTAMPING_SOFTWARE: ::c_uint = 1 << 4;
+pub const SOF_TIMESTAMPING_SYS_HARDWARE: ::c_uint = 1 << 5;
+pub const SOF_TIMESTAMPING_RAW_HARDWARE: ::c_uint = 1 << 6;
+
+// linux/if_alg.h
+pub const ALG_SET_KEY: ::c_int = 1;
+pub const ALG_SET_IV: ::c_int = 2;
+pub const ALG_SET_OP: ::c_int = 3;
+pub const ALG_SET_AEAD_ASSOCLEN: ::c_int = 4;
+pub const ALG_SET_AEAD_AUTHSIZE: ::c_int = 5;
+
+pub const ALG_OP_DECRYPT: ::c_int = 0;
+pub const ALG_OP_ENCRYPT: ::c_int = 1;
+
+// include/uapi/linux/udp.h
+pub const UDP_CORK: ::c_int = 1;
+pub const UDP_ENCAP: ::c_int = 100;
+pub const UDP_NO_CHECK6_TX: ::c_int = 101;
+pub const UDP_NO_CHECK6_RX: ::c_int = 102;
+pub const UDP_SEGMENT: ::c_int = 103;
+pub const UDP_GRO: ::c_int = 104;
+
+// include/uapi/linux/mman.h
+pub const MAP_SHARED_VALIDATE: ::c_int = 0x3;
+
+// include/uapi/asm-generic/mman-common.h
+pub const MAP_FIXED_NOREPLACE: ::c_int = 0x100000;
+
+// uapi/linux/vm_sockets.h
+pub const VMADDR_CID_ANY: ::c_uint = 0xFFFFFFFF;
+pub const VMADDR_CID_HYPERVISOR: ::c_uint = 0;
+#[deprecated(
+    since = "0.2.74",
+    note = "VMADDR_CID_RESERVED is removed since Linux v5.6 and \
+            replaced with VMADDR_CID_LOCAL"
+)]
+pub const VMADDR_CID_RESERVED: ::c_uint = 1;
+pub const VMADDR_CID_LOCAL: ::c_uint = 1;
+pub const VMADDR_CID_HOST: ::c_uint = 2;
+pub const VMADDR_PORT_ANY: ::c_uint = 0xFFFFFFFF;
+
+// uapi/linux/inotify.h
+pub const IN_ACCESS: u32 = 0x0000_0001;
+pub const IN_MODIFY: u32 = 0x0000_0002;
+pub const IN_ATTRIB: u32 = 0x0000_0004;
+pub const IN_CLOSE_WRITE: u32 = 0x0000_0008;
+pub const IN_CLOSE_NOWRITE: u32 = 0x0000_0010;
+pub const IN_CLOSE: u32 = IN_CLOSE_WRITE | IN_CLOSE_NOWRITE;
+pub const IN_OPEN: u32 = 0x0000_0020;
+pub const IN_MOVED_FROM: u32 = 0x0000_0040;
+pub const IN_MOVED_TO: u32 = 0x0000_0080;
+pub const IN_MOVE: u32 = IN_MOVED_FROM | IN_MOVED_TO;
+pub const IN_CREATE: u32 = 0x0000_0100;
+pub const IN_DELETE: u32 = 0x0000_0200;
+pub const IN_DELETE_SELF: u32 = 0x0000_0400;
+pub const IN_MOVE_SELF: u32 = 0x0000_0800;
+pub const IN_UNMOUNT: u32 = 0x0000_2000;
+pub const IN_Q_OVERFLOW: u32 = 0x0000_4000;
+pub const IN_IGNORED: u32 = 0x0000_8000;
+pub const IN_ONLYDIR: u32 = 0x0100_0000;
+pub const IN_DONT_FOLLOW: u32 = 0x0200_0000;
+// pub const IN_EXCL_UNLINK:   u32 = 0x0400_0000;
+
+// linux/keyctl.h
+pub const KEY_SPEC_THREAD_KEYRING: i32 = -1;
+pub const KEY_SPEC_PROCESS_KEYRING: i32 = -2;
+pub const KEY_SPEC_SESSION_KEYRING: i32 = -3;
+pub const KEY_SPEC_USER_KEYRING: i32 = -4;
+pub const KEY_SPEC_USER_SESSION_KEYRING: i32 = -5;
+pub const KEY_SPEC_GROUP_KEYRING: i32 = -6;
+pub const KEY_SPEC_REQKEY_AUTH_KEY: i32 = -7;
+pub const KEY_SPEC_REQUESTOR_KEYRING: i32 = -8;
+
+pub const KEY_REQKEY_DEFL_NO_CHANGE: i32 = -1;
+pub const KEY_REQKEY_DEFL_DEFAULT: i32 = 0;
+pub const KEY_REQKEY_DEFL_THREAD_KEYRING: i32 = 1;
+pub const KEY_REQKEY_DEFL_PROCESS_KEYRING: i32 = 2;
+pub const KEY_REQKEY_DEFL_SESSION_KEYRING: i32 = 3;
+pub const KEY_REQKEY_DEFL_USER_KEYRING: i32 = 4;
+pub const KEY_REQKEY_DEFL_USER_SESSION_KEYRING: i32 = 5;
+pub const KEY_REQKEY_DEFL_GROUP_KEYRING: i32 = 6;
+pub const KEY_REQKEY_DEFL_REQUESTOR_KEYRING: i32 = 7;
+
+pub const KEYCTL_GET_KEYRING_ID: u32 = 0;
+pub const KEYCTL_JOIN_SESSION_KEYRING: u32 = 1;
+pub const KEYCTL_UPDATE: u32 = 2;
+pub const KEYCTL_REVOKE: u32 = 3;
+pub const KEYCTL_CHOWN: u32 = 4;
+pub const KEYCTL_SETPERM: u32 = 5;
+pub const KEYCTL_DESCRIBE: u32 = 6;
+pub const KEYCTL_CLEAR: u32 = 7;
+pub const KEYCTL_LINK: u32 = 8;
+pub const KEYCTL_UNLINK: u32 = 9;
+pub const KEYCTL_SEARCH: u32 = 10;
+pub const KEYCTL_READ: u32 = 11;
+pub const KEYCTL_INSTANTIATE: u32 = 12;
+pub const KEYCTL_NEGATE: u32 = 13;
+pub const KEYCTL_SET_REQKEY_KEYRING: u32 = 14;
+pub const KEYCTL_SET_TIMEOUT: u32 = 15;
+pub const KEYCTL_ASSUME_AUTHORITY: u32 = 16;
+pub const KEYCTL_GET_SECURITY: u32 = 17;
+pub const KEYCTL_SESSION_TO_PARENT: u32 = 18;
+pub const KEYCTL_REJECT: u32 = 19;
+pub const KEYCTL_INSTANTIATE_IOV: u32 = 20;
+pub const KEYCTL_INVALIDATE: u32 = 21;
+pub const KEYCTL_GET_PERSISTENT: u32 = 22;
+
+// pub const IN_MASK_CREATE:   u32 = 0x1000_0000;
+// pub const IN_MASK_ADD:      u32 = 0x2000_0000;
+pub const IN_ISDIR: u32 = 0x4000_0000;
+pub const IN_ONESHOT: u32 = 0x8000_0000;
+
+pub const IN_ALL_EVENTS: u32 = IN_ACCESS
+    | IN_MODIFY
+    | IN_ATTRIB
+    | IN_CLOSE_WRITE
+    | IN_CLOSE_NOWRITE
+    | IN_OPEN
+    | IN_MOVED_FROM
+    | IN_MOVED_TO
+    | IN_DELETE
+    | IN_CREATE
+    | IN_DELETE_SELF
+    | IN_MOVE_SELF;
+
+pub const IN_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const IN_NONBLOCK: ::c_int = O_NONBLOCK;
+
+// uapi/linux/fanotify.h
+pub const FAN_ACCESS: u64 = 0x0000_0001;
+pub const FAN_MODIFY: u64 = 0x0000_0002;
+pub const FAN_CLOSE_WRITE: u64 = 0x0000_0008;
+pub const FAN_CLOSE_NOWRITE: u64 = 0x0000_0010;
+pub const FAN_OPEN: u64 = 0x0000_0020;
+
+pub const FAN_Q_OVERFLOW: u64 = 0x0000_4000;
+
+pub const FAN_OPEN_PERM: u64 = 0x0001_0000;
+pub const FAN_ACCESS_PERM: u64 = 0x0002_0000;
+
+pub const FAN_ONDIR: u64 = 0x4000_0000;
+
+pub const FAN_EVENT_ON_CHILD: u64 = 0x0800_0000;
+
+pub const FAN_CLOSE: u64 = FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE;
+
+pub const FAN_CLOEXEC: ::c_uint = 0x0000_0001;
+pub const FAN_NONBLOCK: ::c_uint = 0x0000_0002;
+
+pub const FAN_CLASS_NOTIF: ::c_uint = 0x0000_0000;
+pub const FAN_CLASS_CONTENT: ::c_uint = 0x0000_0004;
+pub const FAN_CLASS_PRE_CONTENT: ::c_uint = 0x0000_0008;
+
+pub const FAN_UNLIMITED_QUEUE: ::c_uint = 0x0000_0010;
+pub const FAN_UNLIMITED_MARKS: ::c_uint = 0x0000_0020;
+
+pub const FAN_MARK_ADD: ::c_uint = 0x0000_0001;
+pub const FAN_MARK_REMOVE: ::c_uint = 0x0000_0002;
+pub const FAN_MARK_DONT_FOLLOW: ::c_uint = 0x0000_0004;
+pub const FAN_MARK_ONLYDIR: ::c_uint = 0x0000_0008;
+pub const FAN_MARK_INODE: ::c_uint = 0x0000_0000;
+pub const FAN_MARK_MOUNT: ::c_uint = 0x0000_0010;
+// NOTE: FAN_MARK_FILESYSTEM requires Linux Kernel >= 4.20.0
+pub const FAN_MARK_FILESYSTEM: ::c_uint = 0x0000_0100;
+pub const FAN_MARK_IGNORED_MASK: ::c_uint = 0x0000_0020;
+pub const FAN_MARK_IGNORED_SURV_MODIFY: ::c_uint = 0x0000_0040;
+pub const FAN_MARK_FLUSH: ::c_uint = 0x0000_0080;
+
+pub const FANOTIFY_METADATA_VERSION: u8 = 3;
+
+pub const FAN_ALLOW: u32 = 0x01;
+pub const FAN_DENY: u32 = 0x02;
+
+pub const FAN_NOFD: ::c_int = -1;
+
+pub const FUTEX_WAIT: ::c_int = 0;
+pub const FUTEX_WAKE: ::c_int = 1;
+pub const FUTEX_FD: ::c_int = 2;
+pub const FUTEX_REQUEUE: ::c_int = 3;
+pub const FUTEX_CMP_REQUEUE: ::c_int = 4;
+pub const FUTEX_WAKE_OP: ::c_int = 5;
+pub const FUTEX_LOCK_PI: ::c_int = 6;
+pub const FUTEX_UNLOCK_PI: ::c_int = 7;
+pub const FUTEX_TRYLOCK_PI: ::c_int = 8;
+pub const FUTEX_WAIT_BITSET: ::c_int = 9;
+pub const FUTEX_WAKE_BITSET: ::c_int = 10;
+pub const FUTEX_WAIT_REQUEUE_PI: ::c_int = 11;
+pub const FUTEX_CMP_REQUEUE_PI: ::c_int = 12;
+
+pub const FUTEX_PRIVATE_FLAG: ::c_int = 128;
+pub const FUTEX_CLOCK_REALTIME: ::c_int = 256;
+pub const FUTEX_CMD_MASK: ::c_int =
+    !(FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME);
+
+// linux/reboot.h
+pub const LINUX_REBOOT_MAGIC1: ::c_int = 0xfee1dead;
+pub const LINUX_REBOOT_MAGIC2: ::c_int = 672274793;
+pub const LINUX_REBOOT_MAGIC2A: ::c_int = 85072278;
+pub const LINUX_REBOOT_MAGIC2B: ::c_int = 369367448;
+pub const LINUX_REBOOT_MAGIC2C: ::c_int = 537993216;
+
+pub const LINUX_REBOOT_CMD_RESTART: ::c_int = 0x01234567;
+pub const LINUX_REBOOT_CMD_HALT: ::c_int = 0xCDEF0123;
+pub const LINUX_REBOOT_CMD_CAD_ON: ::c_int = 0x89ABCDEF;
+pub const LINUX_REBOOT_CMD_CAD_OFF: ::c_int = 0x00000000;
+pub const LINUX_REBOOT_CMD_POWER_OFF: ::c_int = 0x4321FEDC;
+pub const LINUX_REBOOT_CMD_RESTART2: ::c_int = 0xA1B2C3D4;
+pub const LINUX_REBOOT_CMD_SW_SUSPEND: ::c_int = 0xD000FCE2;
+pub const LINUX_REBOOT_CMD_KEXEC: ::c_int = 0x45584543;
+
+pub const REG_EXTENDED: ::c_int = 1;
+pub const REG_ICASE: ::c_int = 2;
+pub const REG_NEWLINE: ::c_int = 4;
+pub const REG_NOSUB: ::c_int = 8;
+
+pub const REG_NOTBOL: ::c_int = 1;
+pub const REG_NOTEOL: ::c_int = 2;
+
+pub const REG_ENOSYS: ::c_int = -1;
+pub const REG_NOMATCH: ::c_int = 1;
+pub const REG_BADPAT: ::c_int = 2;
+pub const REG_ECOLLATE: ::c_int = 3;
+pub const REG_ECTYPE: ::c_int = 4;
+pub const REG_EESCAPE: ::c_int = 5;
+pub const REG_ESUBREG: ::c_int = 6;
+pub const REG_EBRACK: ::c_int = 7;
+pub const REG_EPAREN: ::c_int = 8;
+pub const REG_EBRACE: ::c_int = 9;
+pub const REG_BADBR: ::c_int = 10;
+pub const REG_ERANGE: ::c_int = 11;
+pub const REG_ESPACE: ::c_int = 12;
+pub const REG_BADRPT: ::c_int = 13;
+
+// linux/errqueue.h
+pub const SO_EE_ORIGIN_NONE: u8 = 0;
+pub const SO_EE_ORIGIN_LOCAL: u8 = 1;
+pub const SO_EE_ORIGIN_ICMP: u8 = 2;
+pub const SO_EE_ORIGIN_ICMP6: u8 = 3;
+pub const SO_EE_ORIGIN_TXSTATUS: u8 = 4;
+pub const SO_EE_ORIGIN_TIMESTAMPING: u8 = SO_EE_ORIGIN_TXSTATUS;
+
+// errno.h
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+
+// linux/can.h
+pub const CAN_EFF_FLAG: canid_t = 0x80000000;
+pub const CAN_RTR_FLAG: canid_t = 0x40000000;
+pub const CAN_ERR_FLAG: canid_t = 0x20000000;
+pub const CAN_SFF_MASK: canid_t = 0x000007FF;
+pub const CAN_EFF_MASK: canid_t = 0x1FFFFFFF;
+pub const CAN_ERR_MASK: canid_t = 0x1FFFFFFF;
+
+pub const CAN_SFF_ID_BITS: ::c_int = 11;
+pub const CAN_EFF_ID_BITS: ::c_int = 29;
+
+pub const CAN_MAX_DLC: ::c_int = 8;
+pub const CAN_MAX_DLEN: usize = 8;
+pub const CANFD_MAX_DLC: ::c_int = 15;
+pub const CANFD_MAX_DLEN: usize = 64;
+
+pub const CANFD_BRS: ::c_int = 0x01;
+pub const CANFD_ESI: ::c_int = 0x02;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        pub const CAN_MTU: usize = ::mem::size_of::<can_frame>();
+        pub const CANFD_MTU: usize = ::mem::size_of::<canfd_frame>();
+    }
+}
+
+pub const CAN_RAW: ::c_int = 1;
+pub const CAN_BCM: ::c_int = 2;
+pub const CAN_TP16: ::c_int = 3;
+pub const CAN_TP20: ::c_int = 4;
+pub const CAN_MCNET: ::c_int = 5;
+pub const CAN_ISOTP: ::c_int = 6;
+pub const CAN_J1939: ::c_int = 7;
+pub const CAN_NPROTO: ::c_int = 8;
+
+pub const SOL_CAN_BASE: ::c_int = 100;
+
+pub const CAN_INV_FILTER: canid_t = 0x20000000;
+pub const CAN_RAW_FILTER_MAX: ::c_int = 512;
+
+f! {
+    pub fn NLA_ALIGN(len: ::c_int) -> ::c_int {
+        return ((len) + NLA_ALIGNTO - 1) & !(NLA_ALIGNTO - 1)
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr,
+                       cmsg: *const cmsghdr) -> *mut cmsghdr {
+        if ((*cmsg).cmsg_len as usize) < ::mem::size_of::<cmsghdr>() {
+            return 0 as *mut cmsghdr;
+        };
+        let next = (cmsg as usize +
+                    super::CMSG_ALIGN((*cmsg).cmsg_len as usize))
+            as *mut cmsghdr;
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if (next.offset(1)) as usize > max ||
+            next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max
+        {
+            0 as *mut cmsghdr
+        } else {
+            next as *mut cmsghdr
+        }
+    }
+
+    pub fn CPU_ALLOC_SIZE(count: ::c_int) -> ::size_t {
+        let _dummy: cpu_set_t = ::mem::zeroed();
+        let size_in_bits = 8 * ::mem::size_of_val(&_dummy.bits[0]);
+        ((count as ::size_t + size_in_bits - 1) / 8) as ::size_t
+    }
+
+    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {
+        for slot in cpuset.bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+
+    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits
+            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] |= 1 << offset;
+        ()
+    }
+
+    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits
+            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] &= !(1 << offset);
+        ()
+    }
+
+    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {
+        let size_in_bits = 8 * ::mem::size_of_val(&cpuset.bits[0]);
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        0 != (cpuset.bits[idx] & (1 << offset))
+    }
+
+    pub fn CPU_COUNT_S(size: usize, cpuset: &cpu_set_t) -> ::c_int {
+        let mut s: u32 = 0;
+        let size_of_mask = ::mem::size_of_val(&cpuset.bits[0]);
+        for i in cpuset.bits[..(size / size_of_mask)].iter() {
+            s += i.count_ones();
+        };
+        s as ::c_int
+    }
+
+    pub fn CPU_COUNT(cpuset: &cpu_set_t) -> ::c_int {
+        CPU_COUNT_S(::mem::size_of::<cpu_set_t>(), cpuset)
+    }
+
+    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {
+        set1.bits == set2.bits
+    }
+
+    pub fn major(dev: ::dev_t) -> ::c_uint {
+        let mut major = 0;
+        major |= (dev & 0x00000000000fff00) >> 8;
+        major |= (dev & 0xfffff00000000000) >> 32;
+        major as ::c_uint
+    }
+
+    pub fn minor(dev: ::dev_t) -> ::c_uint {
+        let mut minor = 0;
+        minor |= (dev & 0x00000000000000ff) >> 0;
+        minor |= (dev & 0x00000ffffff00000) >> 12;
+        minor as ::c_uint
+    }
+
+    pub fn makedev(major: ::c_uint, minor: ::c_uint) -> ::dev_t {
+        let major = major as ::dev_t;
+        let minor = minor as ::dev_t;
+        let mut dev = 0;
+        dev |= (major & 0x00000fff) << 8;
+        dev |= (major & 0xfffff000) << 32;
+        dev |= (minor & 0x000000ff) << 0;
+        dev |= (minor & 0xffffff00) << 12;
+        dev
+    }
+
+    pub fn IPTOS_TOS(tos: u8) -> u8 {
+        tos & IPTOS_TOS_MASK
+    }
+
+    pub fn IPTOS_PREC(tos: u8) -> u8 {
+        tos & IPTOS_PREC_MASK
+    }
+
+    pub fn RT_TOS(tos: u8) -> u8 {
+        tos & ::IPTOS_TOS_MASK
+    }
+
+    pub fn RT_ADDRCLASS(flags: u32) -> u32 {
+        flags >> 23
+    }
+
+    pub fn RT_LOCALADDR(flags: u32) -> bool {
+        (flags & RTF_ADDRCLASSMASK) == (RTF_LOCAL | RTF_INTERFACE)
+    }
+
+    pub fn SO_EE_OFFENDER(ee: *const ::sock_extended_err) -> *mut ::sockaddr {
+        ee.offset(1) as *mut ::sockaddr
+    }
+}
+
+extern "C" {
+    #[cfg_attr(not(target_env = "musl"), link_name = "__xpg_strerror_r")]
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn abs(i: ::c_int) -> ::c_int;
+    pub fn atof(s: *const ::c_char) -> ::c_double;
+    pub fn labs(i: ::c_long) -> ::c_long;
+    pub fn rand() -> ::c_int;
+    pub fn srand(seed: ::c_uint);
+
+    pub fn aio_read(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_write(aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_fsync(op: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn aio_error(aiocbp: *const aiocb) -> ::c_int;
+    pub fn aio_return(aiocbp: *mut aiocb) -> ::ssize_t;
+    pub fn aio_suspend(
+        aiocb_list: *const *const aiocb,
+        nitems: ::c_int,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn aio_cancel(fd: ::c_int, aiocbp: *mut aiocb) -> ::c_int;
+    pub fn lio_listio(
+        mode: ::c_int,
+        aiocb_list: *const *mut aiocb,
+        nitems: ::c_int,
+        sevp: *mut ::sigevent,
+    ) -> ::c_int;
+
+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;
+
+    pub fn setpwent();
+    pub fn endpwent();
+    pub fn getpwent() -> *mut passwd;
+    pub fn setgrent();
+    pub fn endgrent();
+    pub fn getgrent() -> *mut ::group;
+    pub fn setspent();
+    pub fn endspent();
+    pub fn getspent() -> *mut spwd;
+
+    pub fn getspnam(name: *const ::c_char) -> *mut spwd;
+    // Only `getspnam_r` is implemented for musl, out of all of the reenterant
+    // functions from `shadow.h`.
+    // https://git.musl-libc.org/cgit/musl/tree/include/shadow.h
+    pub fn getspnam_r(
+        name: *const ::c_char,
+        spbuf: *mut spwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        spbufp: *mut *mut spwd,
+    ) -> ::c_int;
+
+    pub fn shm_open(
+        name: *const c_char,
+        oflag: ::c_int,
+        mode: mode_t,
+    ) -> ::c_int;
+
+    // System V IPC
+    pub fn shmget(key: ::key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;
+    pub fn shmat(
+        shmid: ::c_int,
+        shmaddr: *const ::c_void,
+        shmflg: ::c_int,
+    ) -> *mut ::c_void;
+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;
+    pub fn shmctl(
+        shmid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::shmid_ds,
+    ) -> ::c_int;
+    pub fn ftok(pathname: *const ::c_char, proj_id: ::c_int) -> ::key_t;
+    pub fn semget(key: ::key_t, nsems: ::c_int, semflag: ::c_int) -> ::c_int;
+    pub fn semop(
+        semid: ::c_int,
+        sops: *mut ::sembuf,
+        nsops: ::size_t,
+    ) -> ::c_int;
+    pub fn semctl(
+        semid: ::c_int,
+        semnum: ::c_int,
+        cmd: ::c_int,
+        ...
+    ) -> ::c_int;
+    pub fn msgctl(msqid: ::c_int, cmd: ::c_int, buf: *mut msqid_ds)
+        -> ::c_int;
+    pub fn msgget(key: ::key_t, msgflg: ::c_int) -> ::c_int;
+    pub fn msgrcv(
+        msqid: ::c_int,
+        msgp: *mut ::c_void,
+        msgsz: ::size_t,
+        msgtyp: ::c_long,
+        msgflg: ::c_int,
+    ) -> ::ssize_t;
+    pub fn msgsnd(
+        msqid: ::c_int,
+        msgp: *const ::c_void,
+        msgsz: ::size_t,
+        msgflg: ::c_int,
+    ) -> ::c_int;
+
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn __errno_location() -> *mut ::c_int;
+
+    pub fn fopen64(
+        filename: *const c_char,
+        mode: *const c_char,
+    ) -> *mut ::FILE;
+    pub fn freopen64(
+        filename: *const c_char,
+        mode: *const c_char,
+        file: *mut ::FILE,
+    ) -> *mut ::FILE;
+    pub fn tmpfile64() -> *mut ::FILE;
+    pub fn fgetpos64(stream: *mut ::FILE, ptr: *mut fpos64_t) -> ::c_int;
+    pub fn fsetpos64(stream: *mut ::FILE, ptr: *const fpos64_t) -> ::c_int;
+    pub fn fseeko64(
+        stream: *mut ::FILE,
+        offset: ::off64_t,
+        whence: ::c_int,
+    ) -> ::c_int;
+    pub fn ftello64(stream: *mut ::FILE) -> ::off64_t;
+    pub fn fallocate(
+        fd: ::c_int,
+        mode: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+    pub fn fallocate64(
+        fd: ::c_int,
+        mode: ::c_int,
+        offset: ::off64_t,
+        len: ::off64_t,
+    ) -> ::c_int;
+    pub fn posix_fallocate(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+    pub fn posix_fallocate64(
+        fd: ::c_int,
+        offset: ::off64_t,
+        len: ::off64_t,
+    ) -> ::c_int;
+    pub fn readahead(
+        fd: ::c_int,
+        offset: ::off64_t,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    pub fn getxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn lgetxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn fgetxattr(
+        filedes: ::c_int,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn setxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn lsetxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn fsetxattr(
+        filedes: ::c_int,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn listxattr(
+        path: *const c_char,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn llistxattr(
+        path: *const c_char,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn flistxattr(
+        filedes: ::c_int,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn removexattr(path: *const c_char, name: *const c_char) -> ::c_int;
+    pub fn lremovexattr(path: *const c_char, name: *const c_char) -> ::c_int;
+    pub fn fremovexattr(filedes: ::c_int, name: *const c_char) -> ::c_int;
+    pub fn signalfd(
+        fd: ::c_int,
+        mask: *const ::sigset_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn timerfd_create(clockid: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn timerfd_gettime(
+        fd: ::c_int,
+        curr_value: *mut itimerspec,
+    ) -> ::c_int;
+    pub fn timerfd_settime(
+        fd: ::c_int,
+        flags: ::c_int,
+        new_value: *const itimerspec,
+        old_value: *mut itimerspec,
+    ) -> ::c_int;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn quotactl(
+        cmd: ::c_int,
+        special: *const ::c_char,
+        id: ::c_int,
+        data: *mut ::c_char,
+    ) -> ::c_int;
+    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;
+    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;
+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn mq_receive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mq_timedreceive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::ssize_t;
+    pub fn mq_send(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+    ) -> ::c_int;
+    pub fn mq_timedsend(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;
+    pub fn mq_setattr(
+        mqd: ::mqd_t,
+        newattr: *const ::mq_attr,
+        oldattr: *mut ::mq_attr,
+    ) -> ::c_int;
+    pub fn epoll_pwait(
+        epfd: ::c_int,
+        events: *mut ::epoll_event,
+        maxevents: ::c_int,
+        timeout: ::c_int,
+        sigmask: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn dup3(oldfd: ::c_int, newfd: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn mkostemps(
+        template: *mut ::c_char,
+        suffixlen: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn sigtimedwait(
+        set: *const sigset_t,
+        info: *mut siginfo_t,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> ::c_int;
+    pub fn nl_langinfo_l(item: ::nl_item, locale: ::locale_t)
+        -> *mut ::c_char;
+    pub fn accept4(
+        fd: ::c_int,
+        addr: *mut ::sockaddr,
+        len: *mut ::socklen_t,
+        flg: ::c_int,
+    ) -> ::c_int;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::socklen_t,
+        serv: *mut ::c_char,
+        sevlen: ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_setschedprio(
+        native: ::pthread_t,
+        priority: ::c_int,
+    ) -> ::c_int;
+    pub fn getloadavg(loadavg: *mut ::c_double, nelem: ::c_int) -> ::c_int;
+    pub fn process_vm_readv(
+        pid: ::pid_t,
+        local_iov: *const ::iovec,
+        liovcnt: ::c_ulong,
+        remote_iov: *const ::iovec,
+        riovcnt: ::c_ulong,
+        flags: ::c_ulong,
+    ) -> isize;
+    pub fn process_vm_writev(
+        pid: ::pid_t,
+        local_iov: *const ::iovec,
+        liovcnt: ::c_ulong,
+        remote_iov: *const ::iovec,
+        riovcnt: ::c_ulong,
+        flags: ::c_ulong,
+    ) -> isize;
+    pub fn reboot(how_to: ::c_int) -> ::c_int;
+    pub fn setfsgid(gid: ::gid_t) -> ::c_int;
+    pub fn setfsuid(uid: ::uid_t) -> ::c_int;
+
+    // Not available now on Android
+    pub fn mkfifoat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn if_nameindex() -> *mut if_nameindex;
+    pub fn if_freenameindex(ptr: *mut if_nameindex);
+    pub fn sync_file_range(
+        fd: ::c_int,
+        offset: ::off64_t,
+        nbytes: ::off64_t,
+        flags: ::c_uint,
+    ) -> ::c_int;
+    pub fn mremap(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        new_len: ::size_t,
+        flags: ::c_int,
+        ...
+    ) -> *mut ::c_void;
+
+    pub fn glob(
+        pattern: *const c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut ::glob_t,
+    ) -> ::c_int;
+    pub fn globfree(pglob: *mut ::glob_t);
+
+    pub fn posix_madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;
+
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+    pub fn madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn remap_file_pages(
+        addr: *mut ::c_void,
+        size: ::size_t,
+        prot: ::c_int,
+        pgoff: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;
+    pub fn futimes(fd: ::c_int, times: *const ::timeval) -> ::c_int;
+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;
+
+    pub fn getdomainname(name: *mut ::c_char, len: ::size_t) -> ::c_int;
+    pub fn setdomainname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn vhangup() -> ::c_int;
+    pub fn sync();
+    pub fn syscall(num: ::c_long, ...) -> ::c_long;
+    pub fn sched_getaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut cpu_set_t,
+    ) -> ::c_int;
+    pub fn sched_setaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        cpuset: *const cpu_set_t,
+    ) -> ::c_int;
+    pub fn epoll_create(size: ::c_int) -> ::c_int;
+    pub fn epoll_create1(flags: ::c_int) -> ::c_int;
+    pub fn epoll_wait(
+        epfd: ::c_int,
+        events: *mut ::epoll_event,
+        maxevents: ::c_int,
+        timeout: ::c_int,
+    ) -> ::c_int;
+    pub fn epoll_ctl(
+        epfd: ::c_int,
+        op: ::c_int,
+        fd: ::c_int,
+        event: *mut ::epoll_event,
+    ) -> ::c_int;
+    pub fn pthread_getschedparam(
+        native: ::pthread_t,
+        policy: *mut ::c_int,
+        param: *mut ::sched_param,
+    ) -> ::c_int;
+    pub fn unshare(flags: ::c_int) -> ::c_int;
+    pub fn umount(target: *const ::c_char) -> ::c_int;
+    pub fn sched_get_priority_max(policy: ::c_int) -> ::c_int;
+    pub fn tee(
+        fd_in: ::c_int,
+        fd_out: ::c_int,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn settimeofday(
+        tv: *const ::timeval,
+        tz: *const ::timezone,
+    ) -> ::c_int;
+    pub fn splice(
+        fd_in: ::c_int,
+        off_in: *mut ::loff_t,
+        fd_out: ::c_int,
+        off_out: *mut ::loff_t,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn eventfd(init: ::c_uint, flags: ::c_int) -> ::c_int;
+    pub fn sched_rr_get_interval(pid: ::pid_t, tp: *mut ::timespec)
+        -> ::c_int;
+    pub fn sem_timedwait(
+        sem: *mut sem_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;
+    pub fn sched_setparam(
+        pid: ::pid_t,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn setns(fd: ::c_int, nstype: ::c_int) -> ::c_int;
+    pub fn swapoff(puath: *const ::c_char) -> ::c_int;
+    pub fn vmsplice(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        nr_segs: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mount(
+        src: *const ::c_char,
+        target: *const ::c_char,
+        fstype: *const ::c_char,
+        flags: ::c_ulong,
+        data: *const ::c_void,
+    ) -> ::c_int;
+    pub fn personality(persona: ::c_ulong) -> ::c_int;
+    pub fn prctl(option: ::c_int, ...) -> ::c_int;
+    pub fn sched_getparam(pid: ::pid_t, param: *mut ::sched_param) -> ::c_int;
+    pub fn ppoll(
+        fds: *mut ::pollfd,
+        nfds: nfds_t,
+        timeout: *const ::timespec,
+        sigmask: *const sigset_t,
+    ) -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn clone(
+        cb: extern "C" fn(*mut ::c_void) -> ::c_int,
+        child_stack: *mut ::c_void,
+        flags: ::c_int,
+        arg: *mut ::c_void,
+        ...
+    ) -> ::c_int;
+    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;
+    pub fn clock_nanosleep(
+        clk_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const ::pthread_attr_t,
+        guardsize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn sched_get_priority_min(policy: ::c_int) -> ::c_int;
+    pub fn pthread_condattr_getpshared(
+        attr: *const pthread_condattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn sysinfo(info: *mut ::sysinfo) -> ::c_int;
+    pub fn umount2(target: *const ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn pthread_setschedparam(
+        native: ::pthread_t,
+        policy: ::c_int,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn swapon(path: *const ::c_char, swapflags: ::c_int) -> ::c_int;
+    pub fn sched_setscheduler(
+        pid: ::pid_t,
+        policy: ::c_int,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn sendfile(
+        out_fd: ::c_int,
+        in_fd: ::c_int,
+        offset: *mut off_t,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    pub fn sendfile64(
+        out_fd: ::c_int,
+        in_fd: ::c_int,
+        offset: *mut off64_t,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    pub fn sigsuspend(mask: *const ::sigset_t) -> ::c_int;
+    pub fn getgrgid_r(
+        gid: ::gid_t,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;
+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;
+    pub fn getdtablesize() -> ::c_int;
+    pub fn getgrnam_r(
+        name: *const ::c_char,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn initgroups(user: *const ::c_char, group: ::gid_t) -> ::c_int;
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;
+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;
+    pub fn pthread_cancel(thread: ::pthread_t) -> ::c_int;
+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;
+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    pub fn getpwnam_r(
+        name: *const ::c_char,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;
+    pub fn getgrouplist(
+        user: *const ::c_char,
+        group: ::gid_t,
+        groups: *mut ::gid_t,
+        ngroups: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_getpshared(
+        attr: *const pthread_mutexattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+    pub fn faccessat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_create(
+        native: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        f: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn dl_iterate_phdr(
+        callback: ::Option<
+            unsafe extern "C" fn(
+                info: *mut ::dl_phdr_info,
+                size: ::size_t,
+                data: *mut ::c_void,
+            ) -> ::c_int,
+        >,
+        data: *mut ::c_void,
+    ) -> ::c_int;
+
+    pub fn setmntent(
+        filename: *const ::c_char,
+        ty: *const ::c_char,
+    ) -> *mut ::FILE;
+    pub fn getmntent(stream: *mut ::FILE) -> *mut ::mntent;
+    pub fn addmntent(stream: *mut ::FILE, mnt: *const ::mntent) -> ::c_int;
+    pub fn endmntent(streamp: *mut ::FILE) -> ::c_int;
+    pub fn hasmntopt(
+        mnt: *const ::mntent,
+        opt: *const ::c_char,
+    ) -> *mut ::c_char;
+
+    pub fn posix_spawn(
+        pid: *mut ::pid_t,
+        path: *const ::c_char,
+        file_actions: *const ::posix_spawn_file_actions_t,
+        attrp: *const ::posix_spawnattr_t,
+        argv: *const *mut ::c_char,
+        envp: *const *mut ::c_char,
+    ) -> ::c_int;
+    pub fn posix_spawnp(
+        pid: *mut ::pid_t,
+        file: *const ::c_char,
+        file_actions: *const ::posix_spawn_file_actions_t,
+        attrp: *const ::posix_spawnattr_t,
+        argv: *const *mut ::c_char,
+        envp: *const *mut ::c_char,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_init(attr: *mut posix_spawnattr_t) -> ::c_int;
+    pub fn posix_spawnattr_destroy(attr: *mut posix_spawnattr_t) -> ::c_int;
+    pub fn posix_spawnattr_getsigdefault(
+        attr: *const posix_spawnattr_t,
+        default: *mut ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setsigdefault(
+        attr: *mut posix_spawnattr_t,
+        default: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getsigmask(
+        attr: *const posix_spawnattr_t,
+        default: *mut ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setsigmask(
+        attr: *mut posix_spawnattr_t,
+        default: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getflags(
+        attr: *const posix_spawnattr_t,
+        flags: *mut ::c_short,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setflags(
+        attr: *mut posix_spawnattr_t,
+        flags: ::c_short,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getpgroup(
+        attr: *const posix_spawnattr_t,
+        flags: *mut ::pid_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setpgroup(
+        attr: *mut posix_spawnattr_t,
+        flags: ::pid_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getschedpolicy(
+        attr: *const posix_spawnattr_t,
+        flags: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setschedpolicy(
+        attr: *mut posix_spawnattr_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_getschedparam(
+        attr: *const posix_spawnattr_t,
+        param: *mut ::sched_param,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setschedparam(
+        attr: *mut posix_spawnattr_t,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+
+    pub fn posix_spawn_file_actions_init(
+        actions: *mut posix_spawn_file_actions_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_destroy(
+        actions: *mut posix_spawn_file_actions_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_addopen(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+        path: *const ::c_char,
+        oflag: ::c_int,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_addclose(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_adddup2(
+        actions: *mut posix_spawn_file_actions_t,
+        fd: ::c_int,
+        newfd: ::c_int,
+    ) -> ::c_int;
+    pub fn fread_unlocked(
+        ptr: *mut ::c_void,
+        size: ::size_t,
+        nobj: ::size_t,
+        stream: *mut ::FILE,
+    ) -> ::size_t;
+    pub fn inotify_rm_watch(fd: ::c_int, wd: ::c_int) -> ::c_int;
+    pub fn inotify_init() -> ::c_int;
+    pub fn inotify_init1(flags: ::c_int) -> ::c_int;
+    pub fn inotify_add_watch(
+        fd: ::c_int,
+        path: *const ::c_char,
+        mask: u32,
+    ) -> ::c_int;
+    pub fn fanotify_init(flags: ::c_uint, event_f_flags: ::c_uint) -> ::c_int;
+
+    pub fn regcomp(
+        preg: *mut ::regex_t,
+        pattern: *const ::c_char,
+        cflags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn regexec(
+        preg: *const ::regex_t,
+        input: *const ::c_char,
+        nmatch: ::size_t,
+        pmatch: *mut regmatch_t,
+        eflags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn regerror(
+        errcode: ::c_int,
+        preg: *const ::regex_t,
+        errbuf: *mut ::c_char,
+        errbuf_size: ::size_t,
+    ) -> ::size_t;
+
+    pub fn regfree(preg: *mut ::regex_t);
+}
+
+cfg_if! {
+    if #[cfg(target_env = "musl")] {
+        mod musl;
+        pub use self::musl::*;
+    } else if #[cfg(target_env = "gnu")] {
+        mod gnu;
+        pub use self::gnu::*;
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        #[macro_use]
+        mod align;
+    } else {
+        #[macro_use]
+        mod no_align;
+    }
+}
+expand_align!();
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/arm/align.rs b/library/libc/src/unix/linux_like/linux/musl/b32/arm/align.rs
new file mode 100644
index 00000000..aedbf7a9
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/arm/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(8))]
+    pub struct max_align_t {
+        priv_: (i64, i64)
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/arm/mod.rs b/library/libc/src/unix/linux_like/linux/musl/b32/arm/mod.rs
new file mode 100644
index 00000000..88e8d56b
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/arm/mod.rs
@@ -0,0 +1,849 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        __st_dev_padding: ::c_int,
+        __st_ino_truncated: ::c_long,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_rdev_padding: ::c_int,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::ino_t,
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        __st_dev_padding: ::c_int,
+        __st_ino_truncated: ::c_long,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_rdev_padding: ::c_int,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::ino_t,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __unused1: ::c_long,
+        __unused2: ::c_long
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        __unused1: ::c_int,
+        pub shm_dtime: ::time_t,
+        __unused2: ::c_int,
+        pub shm_ctime: ::time_t,
+        __unused3: ::c_int,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        __unused1: ::c_int,
+        pub msg_rtime: ::time_t,
+        __unused2: ::c_int,
+        pub msg_ctime: ::time_t,
+        __unused3: ::c_int,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+}
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+
+pub const O_DIRECT: ::c_int = 0x10000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_LARGEFILE: ::c_int = 0o400000;
+
+pub const FIOCLEX: ::c_int = 0x5451;
+pub const FIONCLEX: ::c_int = 0x5450;
+pub const FIONBIO: ::c_int = 0x5421;
+
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::c_int = 0x00000800;
+pub const TAB2: ::c_int = 0x00001000;
+pub const TAB3: ::c_int = 0x00001800;
+pub const CR1: ::c_int = 0x00000200;
+pub const CR2: ::c_int = 0x00000400;
+pub const CR3: ::c_int = 0x00000600;
+pub const FF1: ::c_int = 0x00008000;
+pub const BS1: ::c_int = 0x00002000;
+pub const VT1: ::c_int = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+
+pub const SOCK_NONBLOCK: ::c_int = 2048;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+
+pub const F_GETLK: ::c_int = 12;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETLK: ::c_int = 13;
+pub const F_SETLKW: ::c_int = 14;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const VEOF: usize = 4;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+
+pub const TCGETS: ::c_int = 0x5401;
+pub const TCSETS: ::c_int = 0x5402;
+pub const TCSETSW: ::c_int = 0x5403;
+pub const TCSETSF: ::c_int = 0x5404;
+pub const TCGETA: ::c_int = 0x5405;
+pub const TCSETA: ::c_int = 0x5406;
+pub const TCSETAW: ::c_int = 0x5407;
+pub const TCSETAF: ::c_int = 0x5408;
+pub const TCSBRK: ::c_int = 0x5409;
+pub const TCXONC: ::c_int = 0x540A;
+pub const TCFLSH: ::c_int = 0x540B;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x540F;
+pub const TIOCSPGRP: ::c_int = 0x5410;
+pub const TIOCOUTQ: ::c_int = 0x5411;
+pub const TIOCSTI: ::c_int = 0x5412;
+pub const TIOCGWINSZ: ::c_int = 0x5413;
+pub const TIOCSWINSZ: ::c_int = 0x5414;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x541B;
+pub const TIOCCONS: ::c_int = 0x541D;
+
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+// Syscall table
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_poll: ::c_long = 168;
+pub const SYS_nfsservctl: ::c_long = 169;
+pub const SYS_setresgid: ::c_long = 170;
+pub const SYS_getresgid: ::c_long = 171;
+pub const SYS_prctl: ::c_long = 172;
+pub const SYS_rt_sigreturn: ::c_long = 173;
+pub const SYS_rt_sigaction: ::c_long = 174;
+pub const SYS_rt_sigprocmask: ::c_long = 175;
+pub const SYS_rt_sigpending: ::c_long = 176;
+pub const SYS_rt_sigtimedwait: ::c_long = 177;
+pub const SYS_rt_sigqueueinfo: ::c_long = 178;
+pub const SYS_rt_sigsuspend: ::c_long = 179;
+pub const SYS_pread64: ::c_long = 180;
+pub const SYS_pwrite64: ::c_long = 181;
+pub const SYS_chown: ::c_long = 182;
+pub const SYS_getcwd: ::c_long = 183;
+pub const SYS_capget: ::c_long = 184;
+pub const SYS_capset: ::c_long = 185;
+pub const SYS_sigaltstack: ::c_long = 186;
+pub const SYS_sendfile: ::c_long = 187;
+pub const SYS_vfork: ::c_long = 190;
+pub const SYS_ugetrlimit: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_lchown32: ::c_long = 198;
+pub const SYS_getuid32: ::c_long = 199;
+pub const SYS_getgid32: ::c_long = 200;
+pub const SYS_geteuid32: ::c_long = 201;
+pub const SYS_getegid32: ::c_long = 202;
+pub const SYS_setreuid32: ::c_long = 203;
+pub const SYS_setregid32: ::c_long = 204;
+pub const SYS_getgroups32: ::c_long = 205;
+pub const SYS_setgroups32: ::c_long = 206;
+pub const SYS_fchown32: ::c_long = 207;
+pub const SYS_setresuid32: ::c_long = 208;
+pub const SYS_getresuid32: ::c_long = 209;
+pub const SYS_setresgid32: ::c_long = 210;
+pub const SYS_getresgid32: ::c_long = 211;
+pub const SYS_chown32: ::c_long = 212;
+pub const SYS_setuid32: ::c_long = 213;
+pub const SYS_setgid32: ::c_long = 214;
+pub const SYS_setfsuid32: ::c_long = 215;
+pub const SYS_setfsgid32: ::c_long = 216;
+pub const SYS_getdents64: ::c_long = 217;
+pub const SYS_pivot_root: ::c_long = 218;
+pub const SYS_mincore: ::c_long = 219;
+pub const SYS_madvise: ::c_long = 220;
+pub const SYS_fcntl64: ::c_long = 221;
+pub const SYS_gettid: ::c_long = 224;
+pub const SYS_readahead: ::c_long = 225;
+pub const SYS_setxattr: ::c_long = 226;
+pub const SYS_lsetxattr: ::c_long = 227;
+pub const SYS_fsetxattr: ::c_long = 228;
+pub const SYS_getxattr: ::c_long = 229;
+pub const SYS_lgetxattr: ::c_long = 230;
+pub const SYS_fgetxattr: ::c_long = 231;
+pub const SYS_listxattr: ::c_long = 232;
+pub const SYS_llistxattr: ::c_long = 233;
+pub const SYS_flistxattr: ::c_long = 234;
+pub const SYS_removexattr: ::c_long = 235;
+pub const SYS_lremovexattr: ::c_long = 236;
+pub const SYS_fremovexattr: ::c_long = 237;
+pub const SYS_tkill: ::c_long = 238;
+pub const SYS_sendfile64: ::c_long = 239;
+pub const SYS_futex: ::c_long = 240;
+pub const SYS_sched_setaffinity: ::c_long = 241;
+pub const SYS_sched_getaffinity: ::c_long = 242;
+pub const SYS_io_setup: ::c_long = 243;
+pub const SYS_io_destroy: ::c_long = 244;
+pub const SYS_io_getevents: ::c_long = 245;
+pub const SYS_io_submit: ::c_long = 246;
+pub const SYS_io_cancel: ::c_long = 247;
+pub const SYS_exit_group: ::c_long = 248;
+pub const SYS_lookup_dcookie: ::c_long = 249;
+pub const SYS_epoll_create: ::c_long = 250;
+pub const SYS_epoll_ctl: ::c_long = 251;
+pub const SYS_epoll_wait: ::c_long = 252;
+pub const SYS_remap_file_pages: ::c_long = 253;
+pub const SYS_set_tid_address: ::c_long = 256;
+pub const SYS_timer_create: ::c_long = 257;
+pub const SYS_timer_settime: ::c_long = 258;
+pub const SYS_timer_gettime: ::c_long = 259;
+pub const SYS_timer_getoverrun: ::c_long = 260;
+pub const SYS_timer_delete: ::c_long = 261;
+pub const SYS_clock_settime: ::c_long = 262;
+pub const SYS_clock_gettime: ::c_long = 263;
+pub const SYS_clock_getres: ::c_long = 264;
+pub const SYS_clock_nanosleep: ::c_long = 265;
+pub const SYS_statfs64: ::c_long = 266;
+pub const SYS_fstatfs64: ::c_long = 267;
+pub const SYS_tgkill: ::c_long = 268;
+pub const SYS_utimes: ::c_long = 269;
+pub const SYS_pciconfig_iobase: ::c_long = 271;
+pub const SYS_pciconfig_read: ::c_long = 272;
+pub const SYS_pciconfig_write: ::c_long = 273;
+pub const SYS_mq_open: ::c_long = 274;
+pub const SYS_mq_unlink: ::c_long = 275;
+pub const SYS_mq_timedsend: ::c_long = 276;
+pub const SYS_mq_timedreceive: ::c_long = 277;
+pub const SYS_mq_notify: ::c_long = 278;
+pub const SYS_mq_getsetattr: ::c_long = 279;
+pub const SYS_waitid: ::c_long = 280;
+pub const SYS_socket: ::c_long = 281;
+pub const SYS_bind: ::c_long = 282;
+pub const SYS_connect: ::c_long = 283;
+pub const SYS_listen: ::c_long = 284;
+pub const SYS_accept: ::c_long = 285;
+pub const SYS_getsockname: ::c_long = 286;
+pub const SYS_getpeername: ::c_long = 287;
+pub const SYS_socketpair: ::c_long = 288;
+pub const SYS_send: ::c_long = 289;
+pub const SYS_sendto: ::c_long = 290;
+pub const SYS_recv: ::c_long = 291;
+pub const SYS_recvfrom: ::c_long = 292;
+pub const SYS_shutdown: ::c_long = 293;
+pub const SYS_setsockopt: ::c_long = 294;
+pub const SYS_getsockopt: ::c_long = 295;
+pub const SYS_sendmsg: ::c_long = 296;
+pub const SYS_recvmsg: ::c_long = 297;
+pub const SYS_semop: ::c_long = 298;
+pub const SYS_semget: ::c_long = 299;
+pub const SYS_semctl: ::c_long = 300;
+pub const SYS_msgsnd: ::c_long = 301;
+pub const SYS_msgrcv: ::c_long = 302;
+pub const SYS_msgget: ::c_long = 303;
+pub const SYS_msgctl: ::c_long = 304;
+pub const SYS_shmat: ::c_long = 305;
+pub const SYS_shmdt: ::c_long = 306;
+pub const SYS_shmget: ::c_long = 307;
+pub const SYS_shmctl: ::c_long = 308;
+pub const SYS_add_key: ::c_long = 309;
+pub const SYS_request_key: ::c_long = 310;
+pub const SYS_keyctl: ::c_long = 311;
+pub const SYS_semtimedop: ::c_long = 312;
+pub const SYS_vserver: ::c_long = 313;
+pub const SYS_ioprio_set: ::c_long = 314;
+pub const SYS_ioprio_get: ::c_long = 315;
+pub const SYS_inotify_init: ::c_long = 316;
+pub const SYS_inotify_add_watch: ::c_long = 317;
+pub const SYS_inotify_rm_watch: ::c_long = 318;
+pub const SYS_mbind: ::c_long = 319;
+pub const SYS_get_mempolicy: ::c_long = 320;
+pub const SYS_set_mempolicy: ::c_long = 321;
+pub const SYS_openat: ::c_long = 322;
+pub const SYS_mkdirat: ::c_long = 323;
+pub const SYS_mknodat: ::c_long = 324;
+pub const SYS_fchownat: ::c_long = 325;
+pub const SYS_futimesat: ::c_long = 326;
+pub const SYS_fstatat64: ::c_long = 327;
+pub const SYS_unlinkat: ::c_long = 328;
+pub const SYS_renameat: ::c_long = 329;
+pub const SYS_linkat: ::c_long = 330;
+pub const SYS_symlinkat: ::c_long = 331;
+pub const SYS_readlinkat: ::c_long = 332;
+pub const SYS_fchmodat: ::c_long = 333;
+pub const SYS_faccessat: ::c_long = 334;
+pub const SYS_pselect6: ::c_long = 335;
+pub const SYS_ppoll: ::c_long = 336;
+pub const SYS_unshare: ::c_long = 337;
+pub const SYS_set_robust_list: ::c_long = 338;
+pub const SYS_get_robust_list: ::c_long = 339;
+pub const SYS_splice: ::c_long = 340;
+pub const SYS_tee: ::c_long = 342;
+pub const SYS_vmsplice: ::c_long = 343;
+pub const SYS_move_pages: ::c_long = 344;
+pub const SYS_getcpu: ::c_long = 345;
+pub const SYS_epoll_pwait: ::c_long = 346;
+pub const SYS_kexec_load: ::c_long = 347;
+pub const SYS_utimensat: ::c_long = 348;
+pub const SYS_signalfd: ::c_long = 349;
+pub const SYS_timerfd_create: ::c_long = 350;
+pub const SYS_eventfd: ::c_long = 351;
+pub const SYS_fallocate: ::c_long = 352;
+pub const SYS_timerfd_settime: ::c_long = 353;
+pub const SYS_timerfd_gettime: ::c_long = 354;
+pub const SYS_signalfd4: ::c_long = 355;
+pub const SYS_eventfd2: ::c_long = 356;
+pub const SYS_epoll_create1: ::c_long = 357;
+pub const SYS_dup3: ::c_long = 358;
+pub const SYS_pipe2: ::c_long = 359;
+pub const SYS_inotify_init1: ::c_long = 360;
+pub const SYS_preadv: ::c_long = 361;
+pub const SYS_pwritev: ::c_long = 362;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 363;
+pub const SYS_perf_event_open: ::c_long = 364;
+pub const SYS_recvmmsg: ::c_long = 365;
+pub const SYS_accept4: ::c_long = 366;
+pub const SYS_fanotify_init: ::c_long = 367;
+pub const SYS_fanotify_mark: ::c_long = 368;
+pub const SYS_prlimit64: ::c_long = 369;
+pub const SYS_name_to_handle_at: ::c_long = 370;
+pub const SYS_open_by_handle_at: ::c_long = 371;
+pub const SYS_clock_adjtime: ::c_long = 372;
+pub const SYS_syncfs: ::c_long = 373;
+pub const SYS_sendmmsg: ::c_long = 374;
+pub const SYS_setns: ::c_long = 375;
+pub const SYS_process_vm_readv: ::c_long = 376;
+pub const SYS_process_vm_writev: ::c_long = 377;
+pub const SYS_kcmp: ::c_long = 378;
+pub const SYS_finit_module: ::c_long = 379;
+pub const SYS_sched_setattr: ::c_long = 380;
+pub const SYS_sched_getattr: ::c_long = 381;
+pub const SYS_renameat2: ::c_long = 382;
+pub const SYS_seccomp: ::c_long = 383;
+pub const SYS_getrandom: ::c_long = 384;
+pub const SYS_memfd_create: ::c_long = 385;
+pub const SYS_bpf: ::c_long = 386;
+pub const SYS_execveat: ::c_long = 387;
+pub const SYS_userfaultfd: ::c_long = 388;
+pub const SYS_membarrier: ::c_long = 389;
+pub const SYS_mlock2: ::c_long = 390;
+pub const SYS_copy_file_range: ::c_long = 391;
+pub const SYS_preadv2: ::c_long = 392;
+pub const SYS_pwritev2: ::c_long = 393;
+pub const SYS_pkey_mprotect: ::c_long = 394;
+pub const SYS_pkey_alloc: ::c_long = 395;
+pub const SYS_pkey_free: ::c_long = 396;
+pub const SYS_statx: ::c_long = 397;
+
+extern "C" {
+    pub fn getrandom(
+        buf: *mut ::c_void,
+        buflen: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/hexagon.rs b/library/libc/src/unix/linux_like/linux/musl/b32/hexagon.rs
new file mode 100644
index 00000000..00061976
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/hexagon.rs
@@ -0,0 +1,796 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+pub type stat64 = ::stat;
+
+s! {
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::c_ulonglong,
+        pub st_mode: ::c_uint,
+        pub st_nlink: ::c_uint,
+        pub st_uid: ::c_uint,
+        pub st_gid: ::c_uint,
+        pub st_rdev: ::c_ulonglong,
+        __st_rdev_padding: ::c_ulong,
+        pub st_size: ::c_longlong,
+        pub st_blksize: ::blksize_t,
+        __st_blksize_padding: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+
+        __unused: [::c_int;2],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_ushort,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        __unused1: ::c_int,
+        pub shm_dtime: ::time_t,
+        __unused2: ::c_int,
+        pub shm_ctime: ::time_t,
+        __unused3: ::c_int,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        __unused1: ::c_int,
+        pub msg_rtime: ::time_t,
+        __unused2: ::c_int,
+        pub msg_ctime: ::time_t,
+        __unused3: ::c_int,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct termios2 {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 19],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+}
+
+pub const AF_FILE: ::c_int = 1;
+pub const AF_KCM: ::c_int = 41;
+pub const AF_MAX: ::c_int = 43;
+pub const AF_QIPCRTR: ::c_int = 42;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EALREADY: ::c_int = 114;
+pub const EBADE: ::c_int = 52;
+pub const EBADMSG: ::c_int = 74;
+pub const EBADR: ::c_int = 53;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const ECANCELED: ::c_int = 125;
+pub const ECHRNG: ::c_int = 44;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const ECONNRESET: ::c_int = 104;
+pub const EDEADLK: ::c_int = 35;
+pub const EDEADLOCK: ::c_int = 35;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EDQUOT: ::c_int = 122;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EHWPOISON: ::c_int = 133;
+pub const EIDRM: ::c_int = 43;
+pub const EILSEQ: ::c_int = 84;
+pub const EINPROGRESS: ::c_int = 115;
+pub const EISCONN: ::c_int = 106;
+pub const EISNAM: ::c_int = 120;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EL2HLT: ::c_int = 51;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBEXEC: ::c_int = 83;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELNRNG: ::c_int = 48;
+pub const ELOOP: ::c_int = 40;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EMULTIHOP: ::c_int = 72;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENAVAIL: ::c_int = 119;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETRESET: ::c_int = 102;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENOANO: ::c_int = 55;
+pub const ENOBUFS: ::c_int = 105;
+pub const ENOCSI: ::c_int = 50;
+pub const ENOKEY: ::c_int = 126;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const ENOMSG: ::c_int = 42;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTCONN: ::c_int = 107;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ENOTSOCK: ::c_int = 88;
+pub const ENOTSUP: ::c_int = 95;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EOVERFLOW: ::c_int = 75;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EREMCHG: ::c_int = 78;
+pub const ERESTART: ::c_int = 85;
+pub const ERFKILL: ::c_int = 132;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const ESTALE: ::c_int = 116;
+pub const ESTRPIPE: ::c_int = 86;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const EUCLEAN: ::c_int = 117;
+pub const EUNATCH: ::c_int = 49;
+pub const EUSERS: ::c_int = 87;
+pub const EXFULL: ::c_int = 54;
+pub const EXTPROC: ::c_int = 65536;
+pub const F_EXLCK: ::c_int = 4;
+pub const F_GETLK: ::c_int = 12;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_GETOWNER_UIDS: ::c_int = 17;
+pub const F_GETOWN_EX: ::c_int = 16;
+pub const F_GETSIG: ::c_int = 11;
+pub const FIOASYNC: ::c_int = 21586;
+pub const FIOCLEX: ::c_int = 21585;
+pub const FIONBIO: ::c_int = 21537;
+pub const FIONCLEX: ::c_int = 21584;
+pub const FIONREAD: ::c_int = 21531;
+pub const FIOQSIZE: ::c_int = 21600;
+pub const F_LINUX_SPECIFIC_BASE: ::c_int = 1024;
+pub const FLUSHO: ::c_int = 4096;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+pub const F_OWNER_PGRP: ::c_int = 2;
+pub const F_OWNER_PID: ::c_int = 1;
+pub const F_OWNER_TID: ::c_int = 0;
+pub const F_SETLK: ::c_int = 13;
+pub const F_SETLKW: ::c_int = 14;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_SETOWN_EX: ::c_int = 15;
+pub const F_SETSIG: ::c_int = 10;
+pub const F_SHLCK: ::c_int = 8;
+pub const IEXTEN: ::c_int = 32768;
+pub const MAP_ANON: ::c_int = 32;
+pub const MAP_DENYWRITE: ::c_int = 2048;
+pub const MAP_EXECUTABLE: ::c_int = 4096;
+pub const MAP_GROWSDOWN: ::c_int = 256;
+pub const MAP_HUGETLB: ::c_int = 262144;
+pub const MAP_LOCKED: ::c_int = 8192;
+pub const MAP_NONBLOCK: ::c_int = 65536;
+pub const MAP_NORESERVE: ::c_int = 16384;
+pub const MAP_POPULATE: ::c_int = 32768;
+pub const MAP_STACK: ::c_int = 131072;
+pub const MAP_UNINITIALIZED: ::c_int = 0;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_ASYNC: ::c_int = 8192;
+pub const O_CREAT: ::c_int = 64;
+pub const O_DIRECT: ::c_int = 16384;
+pub const O_DIRECTORY: ::c_int = 65536;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_EXCL: ::c_int = 128;
+pub const O_LARGEFILE: ::c_int = 32768;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NOFOLLOW: ::c_int = 131072;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const PF_FILE: ::c_int = 1;
+pub const PF_KCM: ::c_int = 41;
+pub const PF_MAX: ::c_int = 43;
+pub const PF_QIPCRTR: ::c_int = 42;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_RSS: ::c_int = 5;
+#[deprecated(since = "0.2.64", note = "Not stable across OS versions")]
+pub const RLIM_NLIMITS: ::c_int = 16;
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGIO: ::c_int = 29;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGPWR: ::c_int = 30;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGURG: ::c_int = 23;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIG_SETMASK: ::c_int = 2; // FIXME check these
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_ATTACH_REUSEPORT_CBPF: ::c_int = 51;
+pub const SO_ATTACH_REUSEPORT_EBPF: ::c_int = 52;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_NONBLOCK: ::c_int = 2048;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SO_CNX_ADVICE: ::c_int = 53;
+pub const SO_DETACH_BPF: ::c_int = 27;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_GET_FILTER: ::c_int = 26;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SOL_CAIF: ::c_int = 278;
+pub const SO_LINGER: ::c_int = 13;
+pub const SOL_IUCV: ::c_int = 277;
+pub const SOL_KCM: ::c_int = 281;
+pub const SOL_NFC: ::c_int = 280;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SOL_PNPIPE: ::c_int = 275;
+pub const SOL_PPPOL2TP: ::c_int = 273;
+pub const SOL_RDS: ::c_int = 276;
+pub const SOL_RXRPC: ::c_int = 272;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_PEERSEC: ::c_int = 31;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SYS3264_fadvise64: ::c_int = 223;
+pub const SYS3264_fcntl: ::c_int = 25;
+pub const SYS3264_fstatat: ::c_int = 79;
+pub const SYS3264_fstat: ::c_int = 80;
+pub const SYS3264_fstatfs: ::c_int = 44;
+pub const SYS3264_ftruncate: ::c_int = 46;
+pub const SYS3264_lseek: ::c_int = 62;
+pub const SYS3264_lstat: ::c_int = 1039;
+pub const SYS3264_mmap: ::c_int = 222;
+pub const SYS3264_sendfile: ::c_int = 71;
+pub const SYS3264_stat: ::c_int = 1038;
+pub const SYS3264_statfs: ::c_int = 43;
+pub const SYS3264_truncate: ::c_int = 45;
+pub const SYS_accept4: ::c_int = 242;
+pub const SYS_accept: ::c_int = 202;
+pub const SYS_access: ::c_int = 1033;
+pub const SYS_acct: ::c_int = 89;
+pub const SYS_add_key: ::c_int = 217;
+pub const SYS_adjtimex: ::c_int = 171;
+pub const SYS_alarm: ::c_int = 1059;
+pub const SYS_arch_specific_syscall: ::c_int = 244;
+pub const SYS_bdflush: ::c_int = 1075;
+pub const SYS_bind: ::c_int = 200;
+pub const SYS_bpf: ::c_int = 280;
+pub const SYS_brk: ::c_int = 214;
+pub const SYS_capget: ::c_int = 90;
+pub const SYS_capset: ::c_int = 91;
+pub const SYS_chdir: ::c_int = 49;
+pub const SYS_chmod: ::c_int = 1028;
+pub const SYS_chown: ::c_int = 1029;
+pub const SYS_chroot: ::c_int = 51;
+pub const SYS_clock_adjtime: ::c_int = 266;
+pub const SYS_clock_getres: ::c_int = 114;
+pub const SYS_clock_gettime: ::c_int = 113;
+pub const SYS_clock_nanosleep: ::c_int = 115;
+pub const SYS_clock_settime: ::c_int = 112;
+pub const SYS_clone: ::c_int = 220;
+pub const SYS_close: ::c_int = 57;
+pub const SYS_connect: ::c_int = 203;
+pub const SYS_copy_file_range: ::c_int = -1; // FIXME
+pub const SYS_creat: ::c_int = 1064;
+pub const SYS_delete_module: ::c_int = 106;
+pub const SYS_dup2: ::c_int = 1041;
+pub const SYS_dup3: ::c_int = 24;
+pub const SYS_dup: ::c_int = 23;
+pub const SYS_epoll_create1: ::c_int = 20;
+pub const SYS_epoll_create: ::c_int = 1042;
+pub const SYS_epoll_ctl: ::c_int = 21;
+pub const SYS_epoll_pwait: ::c_int = 22;
+pub const SYS_epoll_wait: ::c_int = 1069;
+pub const SYS_eventfd2: ::c_int = 19;
+pub const SYS_eventfd: ::c_int = 1044;
+pub const SYS_execveat: ::c_int = 281;
+pub const SYS_execve: ::c_int = 221;
+pub const SYS_exit: ::c_int = 93;
+pub const SYS_exit_group: ::c_int = 94;
+pub const SYS_faccessat: ::c_int = 48;
+pub const SYS_fadvise64_64: ::c_int = 223;
+pub const SYS_fallocate: ::c_int = 47;
+pub const SYS_fanotify_init: ::c_int = 262;
+pub const SYS_fanotify_mark: ::c_int = 263;
+pub const SYS_fchdir: ::c_int = 50;
+pub const SYS_fchmodat: ::c_int = 53;
+pub const SYS_fchmod: ::c_int = 52;
+pub const SYS_fchownat: ::c_int = 54;
+pub const SYS_fchown: ::c_int = 55;
+pub const SYS_fcntl64: ::c_int = 25;
+pub const SYS_fcntl: ::c_int = 25;
+pub const SYS_fdatasync: ::c_int = 83;
+pub const SYS_fgetxattr: ::c_int = 10;
+pub const SYS_finit_module: ::c_int = 273;
+pub const SYS_flistxattr: ::c_int = 13;
+pub const SYS_flock: ::c_int = 32;
+pub const SYS_fork: ::c_int = 1079;
+pub const SYS_fremovexattr: ::c_int = 16;
+pub const SYS_fsetxattr: ::c_int = 7;
+pub const SYS_fstat64: ::c_int = 80;
+pub const SYS_fstatat64: ::c_int = 79;
+pub const SYS_fstatfs64: ::c_int = 44;
+pub const SYS_fstatfs: ::c_int = 44;
+pub const SYS_fsync: ::c_int = 82;
+pub const SYS_ftruncate64: ::c_int = 46;
+pub const SYS_ftruncate: ::c_int = 46;
+pub const SYS_futex: ::c_int = 98;
+pub const SYS_futimesat: ::c_int = 1066;
+pub const SYS_getcpu: ::c_int = 168;
+pub const SYS_getcwd: ::c_int = 17;
+pub const SYS_getdents64: ::c_int = 61;
+pub const SYS_getdents: ::c_int = 1065;
+pub const SYS_getegid: ::c_int = 177;
+pub const SYS_geteuid: ::c_int = 175;
+pub const SYS_getgid: ::c_int = 176;
+pub const SYS_getgroups: ::c_int = 158;
+pub const SYS_getitimer: ::c_int = 102;
+pub const SYS_get_mempolicy: ::c_int = 236;
+pub const SYS_getpeername: ::c_int = 205;
+pub const SYS_getpgid: ::c_int = 155;
+pub const SYS_getpgrp: ::c_int = 1060;
+pub const SYS_getpid: ::c_int = 172;
+pub const SYS_getppid: ::c_int = 173;
+pub const SYS_getpriority: ::c_int = 141;
+pub const SYS_getrandom: ::c_int = 278;
+pub const SYS_getresgid: ::c_int = 150;
+pub const SYS_getresuid: ::c_int = 148;
+pub const SYS_getrlimit: ::c_int = 163;
+pub const SYS_get_robust_list: ::c_int = 100;
+pub const SYS_getrusage: ::c_int = 165;
+pub const SYS_getsid: ::c_int = 156;
+pub const SYS_getsockname: ::c_int = 204;
+pub const SYS_getsockopt: ::c_int = 209;
+pub const SYS_gettid: ::c_int = 178;
+pub const SYS_gettimeofday: ::c_int = 169;
+pub const SYS_getuid: ::c_int = 174;
+pub const SYS_getxattr: ::c_int = 8;
+pub const SYS_init_module: ::c_int = 105;
+pub const SYS_inotify_add_watch: ::c_int = 27;
+pub const SYS_inotify_init1: ::c_int = 26;
+pub const SYS_inotify_init: ::c_int = 1043;
+pub const SYS_inotify_rm_watch: ::c_int = 28;
+pub const SYS_io_cancel: ::c_int = 3;
+pub const SYS_ioctl: ::c_int = 29;
+pub const SYS_io_destroy: ::c_int = 1;
+pub const SYS_io_getevents: ::c_int = 4;
+pub const SYS_ioprio_get: ::c_int = 31;
+pub const SYS_ioprio_set: ::c_int = 30;
+pub const SYS_io_setup: ::c_int = 0;
+pub const SYS_io_submit: ::c_int = 2;
+pub const SYS_kcmp: ::c_int = 272;
+pub const SYS_kexec_load: ::c_int = 104;
+pub const SYS_keyctl: ::c_int = 219;
+pub const SYS_kill: ::c_int = 129;
+pub const SYS_lchown: ::c_int = 1032;
+pub const SYS_lgetxattr: ::c_int = 9;
+pub const SYS_linkat: ::c_int = 37;
+pub const SYS_link: ::c_int = 1025;
+pub const SYS_listen: ::c_int = 201;
+pub const SYS_listxattr: ::c_int = 11;
+pub const SYS_llistxattr: ::c_int = 12;
+pub const SYS__llseek: ::c_int = 62;
+pub const SYS_lookup_dcookie: ::c_int = 18;
+pub const SYS_lremovexattr: ::c_int = 15;
+pub const SYS_lseek: ::c_int = 62;
+pub const SYS_lsetxattr: ::c_int = 6;
+pub const SYS_lstat64: ::c_int = 1039;
+pub const SYS_lstat: ::c_int = 1039;
+pub const SYS_madvise: ::c_int = 233;
+pub const SYS_mbind: ::c_int = 235;
+pub const SYS_memfd_create: ::c_int = 279;
+pub const SYS_migrate_pages: ::c_int = 238;
+pub const SYS_mincore: ::c_int = 232;
+pub const SYS_mkdirat: ::c_int = 34;
+pub const SYS_mkdir: ::c_int = 1030;
+pub const SYS_mknodat: ::c_int = 33;
+pub const SYS_mknod: ::c_int = 1027;
+pub const SYS_mlockall: ::c_int = 230;
+pub const SYS_mlock: ::c_int = 228;
+pub const SYS_mmap2: ::c_int = 222;
+pub const SYS_mount: ::c_int = 40;
+pub const SYS_move_pages: ::c_int = 239;
+pub const SYS_mprotect: ::c_int = 226;
+pub const SYS_mq_getsetattr: ::c_int = 185;
+pub const SYS_mq_notify: ::c_int = 184;
+pub const SYS_mq_open: ::c_int = 180;
+pub const SYS_mq_timedreceive: ::c_int = 183;
+pub const SYS_mq_timedsend: ::c_int = 182;
+pub const SYS_mq_unlink: ::c_int = 181;
+pub const SYS_mremap: ::c_int = 216;
+pub const SYS_msgctl: ::c_int = 187;
+pub const SYS_msgget: ::c_int = 186;
+pub const SYS_msgrcv: ::c_int = 188;
+pub const SYS_msgsnd: ::c_int = 189;
+pub const SYS_msync: ::c_int = 227;
+pub const SYS_munlockall: ::c_int = 231;
+pub const SYS_munlock: ::c_int = 229;
+pub const SYS_munmap: ::c_int = 215;
+pub const SYS_name_to_handle_at: ::c_int = 264;
+pub const SYS_nanosleep: ::c_int = 101;
+pub const SYS_newfstatat: ::c_int = 79;
+pub const SYS_nfsservctl: ::c_int = 42;
+pub const SYS_oldwait4: ::c_int = 1072;
+pub const SYS_openat: ::c_int = 56;
+pub const SYS_open_by_handle_at: ::c_int = 265;
+pub const SYS_open: ::c_int = 1024;
+pub const SYS_pause: ::c_int = 1061;
+pub const SYS_perf_event_open: ::c_int = 241;
+pub const SYS_personality: ::c_int = 92;
+pub const SYS_pipe2: ::c_int = 59;
+pub const SYS_pipe: ::c_int = 1040;
+pub const SYS_pivot_root: ::c_int = 41;
+pub const SYS_poll: ::c_int = 1068;
+pub const SYS_ppoll: ::c_int = 73;
+pub const SYS_prctl: ::c_int = 167;
+pub const SYS_pread64: ::c_int = 67;
+pub const SYS_preadv: ::c_int = 69;
+pub const SYS_prlimit64: ::c_int = 261;
+pub const SYS_process_vm_readv: ::c_int = 270;
+pub const SYS_process_vm_writev: ::c_int = 271;
+pub const SYS_pselect6: ::c_int = 72;
+pub const SYS_ptrace: ::c_int = 117;
+pub const SYS_pwrite64: ::c_int = 68;
+pub const SYS_pwritev: ::c_int = 70;
+pub const SYS_quotactl: ::c_int = 60;
+pub const SYS_readahead: ::c_int = 213;
+pub const SYS_read: ::c_int = 63;
+pub const SYS_readlinkat: ::c_int = 78;
+pub const SYS_readlink: ::c_int = 1035;
+pub const SYS_readv: ::c_int = 65;
+pub const SYS_reboot: ::c_int = 142;
+pub const SYS_recv: ::c_int = 1073;
+pub const SYS_recvfrom: ::c_int = 207;
+pub const SYS_recvmmsg: ::c_int = 243;
+pub const SYS_recvmsg: ::c_int = 212;
+pub const SYS_remap_file_pages: ::c_int = 234;
+pub const SYS_removexattr: ::c_int = 14;
+pub const SYS_renameat2: ::c_int = 276;
+pub const SYS_renameat: ::c_int = 38;
+pub const SYS_rename: ::c_int = 1034;
+pub const SYS_request_key: ::c_int = 218;
+pub const SYS_restart_syscall: ::c_int = 128;
+pub const SYS_rmdir: ::c_int = 1031;
+pub const SYS_rt_sigaction: ::c_int = 134;
+pub const SYS_rt_sigpending: ::c_int = 136;
+pub const SYS_rt_sigprocmask: ::c_int = 135;
+pub const SYS_rt_sigqueueinfo: ::c_int = 138;
+pub const SYS_rt_sigreturn: ::c_int = 139;
+pub const SYS_rt_sigsuspend: ::c_int = 133;
+pub const SYS_rt_sigtimedwait: ::c_int = 137;
+pub const SYS_rt_tgsigqueueinfo: ::c_int = 240;
+pub const SYS_sched_getaffinity: ::c_int = 123;
+pub const SYS_sched_getattr: ::c_int = 275;
+pub const SYS_sched_getparam: ::c_int = 121;
+pub const SYS_sched_get_priority_max: ::c_int = 125;
+pub const SYS_sched_get_priority_min: ::c_int = 126;
+pub const SYS_sched_getscheduler: ::c_int = 120;
+pub const SYS_sched_rr_get_interval: ::c_int = 127;
+pub const SYS_sched_setaffinity: ::c_int = 122;
+pub const SYS_sched_setattr: ::c_int = 274;
+pub const SYS_sched_setparam: ::c_int = 118;
+pub const SYS_sched_setscheduler: ::c_int = 119;
+pub const SYS_sched_yield: ::c_int = 124;
+pub const SYS_seccomp: ::c_int = 277;
+pub const SYS_select: ::c_int = 1067;
+pub const SYS_semctl: ::c_int = 191;
+pub const SYS_semget: ::c_int = 190;
+pub const SYS_semop: ::c_int = 193;
+pub const SYS_semtimedop: ::c_int = 192;
+pub const SYS_send: ::c_int = 1074;
+pub const SYS_sendfile64: ::c_int = 71;
+pub const SYS_sendfile: ::c_int = 71;
+pub const SYS_sendmmsg: ::c_int = 269;
+pub const SYS_sendmsg: ::c_int = 211;
+pub const SYS_sendto: ::c_int = 206;
+pub const SYS_setdomainname: ::c_int = 162;
+pub const SYS_setfsgid: ::c_int = 152;
+pub const SYS_setfsuid: ::c_int = 151;
+pub const SYS_setgid: ::c_int = 144;
+pub const SYS_setgroups: ::c_int = 159;
+pub const SYS_sethostname: ::c_int = 161;
+pub const SYS_setitimer: ::c_int = 103;
+pub const SYS_set_mempolicy: ::c_int = 237;
+pub const SYS_setns: ::c_int = 268;
+pub const SYS_setpgid: ::c_int = 154;
+pub const SYS_setpriority: ::c_int = 140;
+pub const SYS_setregid: ::c_int = 143;
+pub const SYS_setresgid: ::c_int = 149;
+pub const SYS_setresuid: ::c_int = 147;
+pub const SYS_setreuid: ::c_int = 145;
+pub const SYS_setrlimit: ::c_int = 164;
+pub const SYS_set_robust_list: ::c_int = 99;
+pub const SYS_setsid: ::c_int = 157;
+pub const SYS_setsockopt: ::c_int = 208;
+pub const SYS_set_tid_address: ::c_int = 96;
+pub const SYS_settimeofday: ::c_int = 170;
+pub const SYS_setuid: ::c_int = 146;
+pub const SYS_setxattr: ::c_int = 5;
+pub const SYS_shmat: ::c_int = 196;
+pub const SYS_shmctl: ::c_int = 195;
+pub const SYS_shmdt: ::c_int = 197;
+pub const SYS_shmget: ::c_int = 194;
+pub const SYS_shutdown: ::c_int = 210;
+pub const SYS_sigaltstack: ::c_int = 132;
+pub const SYS_signalfd4: ::c_int = 74;
+pub const SYS_signalfd: ::c_int = 1045;
+pub const SYS_socket: ::c_int = 198;
+pub const SYS_socketpair: ::c_int = 199;
+pub const SYS_splice: ::c_int = 76;
+pub const SYS_stat64: ::c_int = 1038;
+pub const SYS_stat: ::c_int = 1038;
+pub const SYS_statfs64: ::c_int = 43;
+pub const SYS_swapoff: ::c_int = 225;
+pub const SYS_swapon: ::c_int = 224;
+pub const SYS_symlinkat: ::c_int = 36;
+pub const SYS_symlink: ::c_int = 1036;
+pub const SYS_sync: ::c_int = 81;
+pub const SYS_sync_file_range2: ::c_int = 84;
+pub const SYS_sync_file_range: ::c_int = 84;
+pub const SYS_syncfs: ::c_int = 267;
+pub const SYS_syscalls: ::c_int = 1080;
+pub const SYS__sysctl: ::c_int = 1078;
+pub const SYS_sysinfo: ::c_int = 179;
+pub const SYS_syslog: ::c_int = 116;
+pub const SYS_tee: ::c_int = 77;
+pub const SYS_tgkill: ::c_int = 131;
+pub const SYS_time: ::c_int = 1062;
+pub const SYS_timer_create: ::c_int = 107;
+pub const SYS_timer_delete: ::c_int = 111;
+pub const SYS_timerfd_create: ::c_int = 85;
+pub const SYS_timerfd_gettime: ::c_int = 87;
+pub const SYS_timerfd_settime: ::c_int = 86;
+pub const SYS_timer_getoverrun: ::c_int = 109;
+pub const SYS_timer_gettime: ::c_int = 108;
+pub const SYS_timer_settime: ::c_int = 110;
+pub const SYS_times: ::c_int = 153;
+pub const SYS_tkill: ::c_int = 130;
+pub const SYS_truncate64: ::c_int = 45;
+pub const SYS_truncate: ::c_int = 45;
+pub const SYS_umask: ::c_int = 166;
+pub const SYS_umount2: ::c_int = 39;
+pub const SYS_umount: ::c_int = 1076;
+pub const SYS_uname: ::c_int = 160;
+pub const SYS_unlinkat: ::c_int = 35;
+pub const SYS_unlink: ::c_int = 1026;
+pub const SYS_unshare: ::c_int = 97;
+pub const SYS_uselib: ::c_int = 1077;
+pub const SYS_ustat: ::c_int = 1070;
+pub const SYS_utime: ::c_int = 1063;
+pub const SYS_utimensat: ::c_int = 88;
+pub const SYS_utimes: ::c_int = 1037;
+pub const SYS_vfork: ::c_int = 1071;
+pub const SYS_vhangup: ::c_int = 58;
+pub const SYS_vmsplice: ::c_int = 75;
+pub const SYS_wait4: ::c_int = 260;
+pub const SYS_waitid: ::c_int = 95;
+pub const SYS_write: ::c_int = 64;
+pub const SYS_writev: ::c_int = 66;
+pub const SYS_statx: ::c_int = 291;
+pub const TCFLSH: ::c_int = 21515;
+pub const TCGETA: ::c_int = 21509;
+pub const TCGETS: ::c_int = 21505;
+pub const TCGETX: ::c_int = 21554;
+pub const TCSBRK: ::c_int = 21513;
+pub const TCSBRKP: ::c_int = 21541;
+pub const TCSETA: ::c_int = 21510;
+pub const TCSETAF: ::c_int = 21512;
+pub const TCSETAW: ::c_int = 21511;
+pub const TCSETS: ::c_int = 21506;
+pub const TCSETSF: ::c_int = 21508;
+pub const TCSETSW: ::c_int = 21507;
+pub const TCSETX: ::c_int = 21555;
+pub const TCSETXF: ::c_int = 21556;
+pub const TCSETXW: ::c_int = 21557;
+pub const TCXONC: ::c_int = 21514;
+pub const TIOCCONS: ::c_int = 21533;
+pub const TIOCEXCL: ::c_int = 21516;
+pub const TIOCGETD: ::c_int = 21540;
+pub const TIOCGICOUNT: ::c_int = 21597;
+pub const TIOCGLCKTRMIOS: ::c_int = 21590;
+pub const TIOCGPGRP: ::c_int = 21519;
+pub const TIOCGRS485: ::c_int = 21550;
+pub const TIOCGSERIAL: ::c_int = 21534;
+pub const TIOCGSID: ::c_int = 21545;
+pub const TIOCGSOFTCAR: ::c_int = 21529;
+pub const TIOCGWINSZ: ::c_int = 21523;
+pub const TIOCLINUX: ::c_int = 21532;
+pub const TIOCMBIC: ::c_int = 21527;
+pub const TIOCMBIS: ::c_int = 21526;
+pub const TIOCM_CAR: ::c_int = 64;
+pub const TIOCM_CD: ::c_int = 64;
+pub const TIOCM_CTS: ::c_int = 32;
+pub const TIOCM_DSR: ::c_int = 256;
+pub const TIOCM_DTR: ::c_int = 2;
+pub const TIOCMGET: ::c_int = 21525;
+pub const TIOCMIWAIT: ::c_int = 21596;
+pub const TIOCM_LE: ::c_int = 1;
+pub const TIOCM_LOOP: ::c_int = 32768;
+pub const TIOCM_OUT1: ::c_int = 8192;
+pub const TIOCM_OUT2: ::c_int = 16384;
+pub const TIOCM_RI: ::c_int = 128;
+pub const TIOCM_RNG: ::c_int = 128;
+pub const TIOCM_RTS: ::c_int = 4;
+pub const TIOCMSET: ::c_int = 21528;
+pub const TIOCM_SR: ::c_int = 16;
+pub const TIOCM_ST: ::c_int = 8;
+pub const TIOCNOTTY: ::c_int = 21538;
+pub const TIOCNXCL: ::c_int = 21517;
+pub const TIOCOUTQ: ::c_int = 21521;
+pub const TIOCPKT: ::c_int = 21536;
+pub const TIOCPKT_DATA: ::c_int = 0;
+pub const TIOCPKT_DOSTOP: ::c_int = 32;
+pub const TIOCPKT_FLUSHREAD: ::c_int = 1;
+pub const TIOCPKT_FLUSHWRITE: ::c_int = 2;
+pub const TIOCPKT_IOCTL: ::c_int = 64;
+pub const TIOCPKT_NOSTOP: ::c_int = 16;
+pub const TIOCPKT_START: ::c_int = 8;
+pub const TIOCPKT_STOP: ::c_int = 4;
+pub const TIOCSCTTY: ::c_int = 21518;
+pub const TIOCSERCONFIG: ::c_int = 21587;
+pub const TIOCSERGETLSR: ::c_int = 21593;
+pub const TIOCSERGETMULTI: ::c_int = 21594;
+pub const TIOCSERGSTRUCT: ::c_int = 21592;
+pub const TIOCSERGWILD: ::c_int = 21588;
+pub const TIOCSERSETMULTI: ::c_int = 21595;
+pub const TIOCSERSWILD: ::c_int = 21589;
+pub const TIOCSER_TEMT: ::c_int = 1;
+pub const TIOCSETD: ::c_int = 21539;
+pub const TIOCSLCKTRMIOS: ::c_int = 21591;
+pub const TIOCSPGRP: ::c_int = 21520;
+pub const TIOCSRS485: ::c_int = 21551;
+pub const TIOCSSERIAL: ::c_int = 21535;
+pub const TIOCSSOFTCAR: ::c_int = 21530;
+pub const TIOCSTI: ::c_int = 21522;
+pub const TIOCSWINSZ: ::c_int = 21524;
+pub const TIOCVHANGUP: ::c_int = 21559;
+pub const TOSTOP: ::c_int = 256;
+pub const VEOF: ::c_int = 4;
+pub const VEOL2: ::c_int = 16;
+pub const VEOL: ::c_int = 11;
+pub const VMIN: ::c_int = 6;
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/mips/align.rs b/library/libc/src/unix/linux_like/linux/musl/b32/mips/align.rs
new file mode 100644
index 00000000..8c228eba
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/mips/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(8))]
+    pub struct max_align_t {
+        priv_: [f32; 4]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/mips/mod.rs b/library/libc/src/unix/linux_like/linux/musl/b32/mips/mod.rs
new file mode 100644
index 00000000..2e17ccc6
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/mips/mod.rs
@@ -0,0 +1,852 @@
+pub type c_char = i8;
+pub type wchar_t = ::c_int;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        __st_padding1: [::c_long; 2],
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_padding2: [::c_long; 2],
+        pub st_size: ::off_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        __st_padding3: ::c_long,
+        pub st_blocks: ::blkcnt_t,
+        __st_padding4: [::c_long; 14],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        __st_padding1: [::c_long; 2],
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_padding2: [::c_long; 2],
+        pub st_size: ::off_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        __st_padding3: ::c_long,
+        pub st_blocks: ::blkcnt64_t,
+        __st_padding4: [::c_long; 14],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __unused1: ::c_long,
+        __unused2: ::c_long
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        #[cfg(target_endian = "big")]
+        __unused1: ::c_int,
+        pub msg_stime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __unused1: ::c_int,
+        #[cfg(target_endian = "big")]
+        __unused2: ::c_int,
+        pub msg_rtime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __unused2: ::c_int,
+        #[cfg(target_endian = "big")]
+        __unused3: ::c_int,
+        pub msg_ctime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __unused3: ::c_int,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 5],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 5],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        #[cfg(target_endian = "little")]
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        #[cfg(target_endian = "big")]
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+}
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+
+pub const O_DIRECT: ::c_int = 0o100000;
+pub const O_DIRECTORY: ::c_int = 0o200000;
+pub const O_NOFOLLOW: ::c_int = 0o400000;
+pub const O_ASYNC: ::c_int = 0o10000;
+pub const O_LARGEFILE: ::c_int = 0x2000;
+
+pub const FIOCLEX: ::c_int = 0x6601;
+pub const FIONCLEX: ::c_int = 0x6602;
+pub const FIONBIO: ::c_int = 0x667E;
+
+pub const RLIMIT_RSS: ::c_int = 7;
+pub const RLIMIT_NOFILE: ::c_int = 5;
+pub const RLIMIT_AS: ::c_int = 6;
+pub const RLIMIT_NPROC: ::c_int = 8;
+pub const RLIMIT_MEMLOCK: ::c_int = 9;
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::c_int = 0x00000800;
+pub const TAB2: ::c_int = 0x00001000;
+pub const TAB3: ::c_int = 0x00001800;
+pub const CR1: ::c_int = 0x00000200;
+pub const CR2: ::c_int = 0x00000400;
+pub const CR3: ::c_int = 0x00000600;
+pub const FF1: ::c_int = 0x00008000;
+pub const BS1: ::c_int = 0x00002000;
+pub const VT1: ::c_int = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const O_APPEND: ::c_int = 0o010;
+pub const O_CREAT: ::c_int = 0o400;
+pub const O_EXCL: ::c_int = 0o2000;
+pub const O_NOCTTY: ::c_int = 0o4000;
+pub const O_NONBLOCK: ::c_int = 0o200;
+pub const O_SYNC: ::c_int = 0o40020;
+pub const O_RSYNC: ::c_int = 0o40020;
+pub const O_DSYNC: ::c_int = 0o020;
+
+pub const SOCK_NONBLOCK: ::c_int = 0o200;
+
+pub const MAP_ANON: ::c_int = 0x800;
+pub const MAP_GROWSDOWN: ::c_int = 0x1000;
+pub const MAP_DENYWRITE: ::c_int = 0x2000;
+pub const MAP_EXECUTABLE: ::c_int = 0x4000;
+pub const MAP_LOCKED: ::c_int = 0x8000;
+pub const MAP_NORESERVE: ::c_int = 0x0400;
+pub const MAP_POPULATE: ::c_int = 0x10000;
+pub const MAP_NONBLOCK: ::c_int = 0x20000;
+pub const MAP_STACK: ::c_int = 0x40000;
+
+pub const EDEADLK: ::c_int = 45;
+pub const ENAMETOOLONG: ::c_int = 78;
+pub const ENOLCK: ::c_int = 46;
+pub const ENOSYS: ::c_int = 89;
+pub const ENOTEMPTY: ::c_int = 93;
+pub const ELOOP: ::c_int = 90;
+pub const ENOMSG: ::c_int = 35;
+pub const EIDRM: ::c_int = 36;
+pub const ECHRNG: ::c_int = 37;
+pub const EL2NSYNC: ::c_int = 38;
+pub const EL3HLT: ::c_int = 39;
+pub const EL3RST: ::c_int = 40;
+pub const ELNRNG: ::c_int = 41;
+pub const EUNATCH: ::c_int = 42;
+pub const ENOCSI: ::c_int = 43;
+pub const EL2HLT: ::c_int = 44;
+pub const EBADE: ::c_int = 50;
+pub const EBADR: ::c_int = 51;
+pub const EXFULL: ::c_int = 52;
+pub const ENOANO: ::c_int = 53;
+pub const EBADRQC: ::c_int = 54;
+pub const EBADSLT: ::c_int = 55;
+pub const EDEADLOCK: ::c_int = 56;
+pub const EMULTIHOP: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 79;
+pub const ENOTUNIQ: ::c_int = 80;
+pub const EBADFD: ::c_int = 81;
+pub const EBADMSG: ::c_int = 77;
+pub const EREMCHG: ::c_int = 82;
+pub const ELIBACC: ::c_int = 83;
+pub const ELIBBAD: ::c_int = 84;
+pub const ELIBSCN: ::c_int = 85;
+pub const ELIBMAX: ::c_int = 86;
+pub const ELIBEXEC: ::c_int = 87;
+pub const EILSEQ: ::c_int = 88;
+pub const ERESTART: ::c_int = 91;
+pub const ESTRPIPE: ::c_int = 92;
+pub const EUSERS: ::c_int = 94;
+pub const ENOTSOCK: ::c_int = 95;
+pub const EDESTADDRREQ: ::c_int = 96;
+pub const EMSGSIZE: ::c_int = 97;
+pub const EPROTOTYPE: ::c_int = 98;
+pub const ENOPROTOOPT: ::c_int = 99;
+pub const EPROTONOSUPPORT: ::c_int = 120;
+pub const ESOCKTNOSUPPORT: ::c_int = 121;
+pub const EOPNOTSUPP: ::c_int = 122;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 123;
+pub const EAFNOSUPPORT: ::c_int = 124;
+pub const EADDRINUSE: ::c_int = 125;
+pub const EADDRNOTAVAIL: ::c_int = 126;
+pub const ENETDOWN: ::c_int = 127;
+pub const ENETUNREACH: ::c_int = 128;
+pub const ENETRESET: ::c_int = 129;
+pub const ECONNABORTED: ::c_int = 130;
+pub const ECONNRESET: ::c_int = 131;
+pub const ENOBUFS: ::c_int = 132;
+pub const EISCONN: ::c_int = 133;
+pub const ENOTCONN: ::c_int = 134;
+pub const ESHUTDOWN: ::c_int = 143;
+pub const ETOOMANYREFS: ::c_int = 144;
+pub const ETIMEDOUT: ::c_int = 145;
+pub const ECONNREFUSED: ::c_int = 146;
+pub const EHOSTDOWN: ::c_int = 147;
+pub const EHOSTUNREACH: ::c_int = 148;
+pub const EALREADY: ::c_int = 149;
+pub const EINPROGRESS: ::c_int = 150;
+pub const ESTALE: ::c_int = 151;
+pub const EUCLEAN: ::c_int = 135;
+pub const ENOTNAM: ::c_int = 137;
+pub const ENAVAIL: ::c_int = 138;
+pub const EISNAM: ::c_int = 139;
+pub const EREMOTEIO: ::c_int = 140;
+pub const EDQUOT: ::c_int = 1133;
+pub const ENOMEDIUM: ::c_int = 159;
+pub const EMEDIUMTYPE: ::c_int = 160;
+pub const ECANCELED: ::c_int = 158;
+pub const ENOKEY: ::c_int = 161;
+pub const EKEYEXPIRED: ::c_int = 162;
+pub const EKEYREVOKED: ::c_int = 163;
+pub const EKEYREJECTED: ::c_int = 164;
+pub const EOWNERDEAD: ::c_int = 165;
+pub const ENOTRECOVERABLE: ::c_int = 166;
+pub const EHWPOISON: ::c_int = 168;
+pub const ERFKILL: ::c_int = 167;
+
+pub const SOCK_STREAM: ::c_int = 2;
+pub const SOCK_DGRAM: ::c_int = 1;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+pub const SOL_SOCKET: ::c_int = 65535;
+
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_ACCEPTCONN: ::c_int = 0x1009;
+pub const SO_PROTOCOL: ::c_int = 0x1028;
+pub const SO_DOMAIN: ::c_int = 0x1029;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_PASSCRED: ::c_int = 17;
+pub const SO_PEERCRED: ::c_int = 18;
+pub const SO_SNDBUFFORCE: ::c_int = 31;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 8;
+pub const SA_NOCLDWAIT: ::c_int = 0x10000;
+
+pub const SIGCHLD: ::c_int = 18;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGTTIN: ::c_int = 26;
+pub const SIGTTOU: ::c_int = 27;
+pub const SIGXCPU: ::c_int = 30;
+pub const SIGXFSZ: ::c_int = 31;
+pub const SIGVTALRM: ::c_int = 28;
+pub const SIGPROF: ::c_int = 29;
+pub const SIGWINCH: ::c_int = 20;
+pub const SIGUSR1: ::c_int = 16;
+pub const SIGUSR2: ::c_int = 17;
+pub const SIGCONT: ::c_int = 25;
+pub const SIGSTOP: ::c_int = 23;
+pub const SIGTSTP: ::c_int = 24;
+pub const SIGURG: ::c_int = 21;
+pub const SIGIO: ::c_int = 22;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGSTKFLT: ::c_int = 7;
+pub const SIGPOLL: ::c_int = ::SIGIO;
+pub const SIGPWR: ::c_int = 19;
+pub const SIG_SETMASK: ::c_int = 3;
+pub const SIG_BLOCK: ::c_int = 1;
+pub const SIG_UNBLOCK: ::c_int = 2;
+
+pub const EXTPROC: ::tcflag_t = 0o200000;
+
+pub const MAP_HUGETLB: ::c_int = 0x80000;
+
+pub const F_GETLK: ::c_int = 33;
+pub const F_GETOWN: ::c_int = 23;
+pub const F_SETLK: ::c_int = 34;
+pub const F_SETLKW: ::c_int = 35;
+pub const F_SETOWN: ::c_int = 24;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const VEOF: usize = 16;
+pub const VEOL: usize = 17;
+pub const VEOL2: usize = 6;
+pub const VMIN: usize = 4;
+pub const IEXTEN: ::tcflag_t = 0o000400;
+pub const TOSTOP: ::tcflag_t = 0o100000;
+pub const FLUSHO: ::tcflag_t = 0o020000;
+
+pub const TCGETS: ::c_int = 0x540D;
+pub const TCSETS: ::c_int = 0x540E;
+pub const TCSETSW: ::c_int = 0x540F;
+pub const TCSETSF: ::c_int = 0x5410;
+pub const TCGETA: ::c_int = 0x5401;
+pub const TCSETA: ::c_int = 0x5402;
+pub const TCSETAW: ::c_int = 0x5403;
+pub const TCSETAF: ::c_int = 0x5404;
+pub const TCSBRK: ::c_int = 0x5405;
+pub const TCXONC: ::c_int = 0x5406;
+pub const TCFLSH: ::c_int = 0x5407;
+pub const TIOCGSOFTCAR: ::c_int = 0x5481;
+pub const TIOCSSOFTCAR: ::c_int = 0x5482;
+pub const TIOCLINUX: ::c_int = 0x5483;
+pub const TIOCGSERIAL: ::c_int = 0x5484;
+pub const TIOCEXCL: ::c_int = 0x740D;
+pub const TIOCNXCL: ::c_int = 0x740E;
+pub const TIOCSCTTY: ::c_int = 0x5480;
+pub const TIOCGPGRP: ::c_int = 0x40047477;
+pub const TIOCSPGRP: ::c_int = 0x80047476;
+pub const TIOCOUTQ: ::c_int = 0x7472;
+pub const TIOCSTI: ::c_int = 0x5472;
+pub const TIOCGWINSZ: ::c_int = 0x40087468;
+pub const TIOCSWINSZ: ::c_int = 0x80087467;
+pub const TIOCMGET: ::c_int = 0x741D;
+pub const TIOCMBIS: ::c_int = 0x741B;
+pub const TIOCMBIC: ::c_int = 0x741C;
+pub const TIOCMSET: ::c_int = 0x741A;
+pub const FIONREAD: ::c_int = 0x467F;
+pub const TIOCCONS: ::c_int = 0x80047478;
+
+pub const TIOCGRS485: ::c_int = 0x4020542E;
+pub const TIOCSRS485: ::c_int = 0xC020542F;
+
+pub const POLLWRNORM: ::c_short = 0x4;
+pub const POLLWRBAND: ::c_short = 0x100;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x010;
+pub const TIOCM_SR: ::c_int = 0x020;
+pub const TIOCM_CTS: ::c_int = 0x040;
+pub const TIOCM_CAR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RNG: ::c_int = 0x200;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+pub const TIOCM_DSR: ::c_int = 0x400;
+
+pub const SYS_syscall: ::c_long = 4000 + 0;
+pub const SYS_exit: ::c_long = 4000 + 1;
+pub const SYS_fork: ::c_long = 4000 + 2;
+pub const SYS_read: ::c_long = 4000 + 3;
+pub const SYS_write: ::c_long = 4000 + 4;
+pub const SYS_open: ::c_long = 4000 + 5;
+pub const SYS_close: ::c_long = 4000 + 6;
+pub const SYS_waitpid: ::c_long = 4000 + 7;
+pub const SYS_creat: ::c_long = 4000 + 8;
+pub const SYS_link: ::c_long = 4000 + 9;
+pub const SYS_unlink: ::c_long = 4000 + 10;
+pub const SYS_execve: ::c_long = 4000 + 11;
+pub const SYS_chdir: ::c_long = 4000 + 12;
+pub const SYS_time: ::c_long = 4000 + 13;
+pub const SYS_mknod: ::c_long = 4000 + 14;
+pub const SYS_chmod: ::c_long = 4000 + 15;
+pub const SYS_lchown: ::c_long = 4000 + 16;
+pub const SYS_break: ::c_long = 4000 + 17;
+pub const SYS_lseek: ::c_long = 4000 + 19;
+pub const SYS_getpid: ::c_long = 4000 + 20;
+pub const SYS_mount: ::c_long = 4000 + 21;
+pub const SYS_umount: ::c_long = 4000 + 22;
+pub const SYS_setuid: ::c_long = 4000 + 23;
+pub const SYS_getuid: ::c_long = 4000 + 24;
+pub const SYS_stime: ::c_long = 4000 + 25;
+pub const SYS_ptrace: ::c_long = 4000 + 26;
+pub const SYS_alarm: ::c_long = 4000 + 27;
+pub const SYS_pause: ::c_long = 4000 + 29;
+pub const SYS_utime: ::c_long = 4000 + 30;
+pub const SYS_stty: ::c_long = 4000 + 31;
+pub const SYS_gtty: ::c_long = 4000 + 32;
+pub const SYS_access: ::c_long = 4000 + 33;
+pub const SYS_nice: ::c_long = 4000 + 34;
+pub const SYS_ftime: ::c_long = 4000 + 35;
+pub const SYS_sync: ::c_long = 4000 + 36;
+pub const SYS_kill: ::c_long = 4000 + 37;
+pub const SYS_rename: ::c_long = 4000 + 38;
+pub const SYS_mkdir: ::c_long = 4000 + 39;
+pub const SYS_rmdir: ::c_long = 4000 + 40;
+pub const SYS_dup: ::c_long = 4000 + 41;
+pub const SYS_pipe: ::c_long = 4000 + 42;
+pub const SYS_times: ::c_long = 4000 + 43;
+pub const SYS_prof: ::c_long = 4000 + 44;
+pub const SYS_brk: ::c_long = 4000 + 45;
+pub const SYS_setgid: ::c_long = 4000 + 46;
+pub const SYS_getgid: ::c_long = 4000 + 47;
+pub const SYS_signal: ::c_long = 4000 + 48;
+pub const SYS_geteuid: ::c_long = 4000 + 49;
+pub const SYS_getegid: ::c_long = 4000 + 50;
+pub const SYS_acct: ::c_long = 4000 + 51;
+pub const SYS_umount2: ::c_long = 4000 + 52;
+pub const SYS_lock: ::c_long = 4000 + 53;
+pub const SYS_ioctl: ::c_long = 4000 + 54;
+pub const SYS_fcntl: ::c_long = 4000 + 55;
+pub const SYS_mpx: ::c_long = 4000 + 56;
+pub const SYS_setpgid: ::c_long = 4000 + 57;
+pub const SYS_ulimit: ::c_long = 4000 + 58;
+pub const SYS_umask: ::c_long = 4000 + 60;
+pub const SYS_chroot: ::c_long = 4000 + 61;
+pub const SYS_ustat: ::c_long = 4000 + 62;
+pub const SYS_dup2: ::c_long = 4000 + 63;
+pub const SYS_getppid: ::c_long = 4000 + 64;
+pub const SYS_getpgrp: ::c_long = 4000 + 65;
+pub const SYS_setsid: ::c_long = 4000 + 66;
+pub const SYS_sigaction: ::c_long = 4000 + 67;
+pub const SYS_sgetmask: ::c_long = 4000 + 68;
+pub const SYS_ssetmask: ::c_long = 4000 + 69;
+pub const SYS_setreuid: ::c_long = 4000 + 70;
+pub const SYS_setregid: ::c_long = 4000 + 71;
+pub const SYS_sigsuspend: ::c_long = 4000 + 72;
+pub const SYS_sigpending: ::c_long = 4000 + 73;
+pub const SYS_sethostname: ::c_long = 4000 + 74;
+pub const SYS_setrlimit: ::c_long = 4000 + 75;
+pub const SYS_getrlimit: ::c_long = 4000 + 76;
+pub const SYS_getrusage: ::c_long = 4000 + 77;
+pub const SYS_gettimeofday: ::c_long = 4000 + 78;
+pub const SYS_settimeofday: ::c_long = 4000 + 79;
+pub const SYS_getgroups: ::c_long = 4000 + 80;
+pub const SYS_setgroups: ::c_long = 4000 + 81;
+pub const SYS_symlink: ::c_long = 4000 + 83;
+pub const SYS_readlink: ::c_long = 4000 + 85;
+pub const SYS_uselib: ::c_long = 4000 + 86;
+pub const SYS_swapon: ::c_long = 4000 + 87;
+pub const SYS_reboot: ::c_long = 4000 + 88;
+pub const SYS_readdir: ::c_long = 4000 + 89;
+pub const SYS_mmap: ::c_long = 4000 + 90;
+pub const SYS_munmap: ::c_long = 4000 + 91;
+pub const SYS_truncate: ::c_long = 4000 + 92;
+pub const SYS_ftruncate: ::c_long = 4000 + 93;
+pub const SYS_fchmod: ::c_long = 4000 + 94;
+pub const SYS_fchown: ::c_long = 4000 + 95;
+pub const SYS_getpriority: ::c_long = 4000 + 96;
+pub const SYS_setpriority: ::c_long = 4000 + 97;
+pub const SYS_profil: ::c_long = 4000 + 98;
+pub const SYS_statfs: ::c_long = 4000 + 99;
+pub const SYS_fstatfs: ::c_long = 4000 + 100;
+pub const SYS_ioperm: ::c_long = 4000 + 101;
+pub const SYS_socketcall: ::c_long = 4000 + 102;
+pub const SYS_syslog: ::c_long = 4000 + 103;
+pub const SYS_setitimer: ::c_long = 4000 + 104;
+pub const SYS_getitimer: ::c_long = 4000 + 105;
+pub const SYS_stat: ::c_long = 4000 + 106;
+pub const SYS_lstat: ::c_long = 4000 + 107;
+pub const SYS_fstat: ::c_long = 4000 + 108;
+pub const SYS_iopl: ::c_long = 4000 + 110;
+pub const SYS_vhangup: ::c_long = 4000 + 111;
+pub const SYS_idle: ::c_long = 4000 + 112;
+pub const SYS_vm86: ::c_long = 4000 + 113;
+pub const SYS_wait4: ::c_long = 4000 + 114;
+pub const SYS_swapoff: ::c_long = 4000 + 115;
+pub const SYS_sysinfo: ::c_long = 4000 + 116;
+pub const SYS_ipc: ::c_long = 4000 + 117;
+pub const SYS_fsync: ::c_long = 4000 + 118;
+pub const SYS_sigreturn: ::c_long = 4000 + 119;
+pub const SYS_clone: ::c_long = 4000 + 120;
+pub const SYS_setdomainname: ::c_long = 4000 + 121;
+pub const SYS_uname: ::c_long = 4000 + 122;
+pub const SYS_modify_ldt: ::c_long = 4000 + 123;
+pub const SYS_adjtimex: ::c_long = 4000 + 124;
+pub const SYS_mprotect: ::c_long = 4000 + 125;
+pub const SYS_sigprocmask: ::c_long = 4000 + 126;
+pub const SYS_create_module: ::c_long = 4000 + 127;
+pub const SYS_init_module: ::c_long = 4000 + 128;
+pub const SYS_delete_module: ::c_long = 4000 + 129;
+pub const SYS_get_kernel_syms: ::c_long = 4000 + 130;
+pub const SYS_quotactl: ::c_long = 4000 + 131;
+pub const SYS_getpgid: ::c_long = 4000 + 132;
+pub const SYS_fchdir: ::c_long = 4000 + 133;
+pub const SYS_bdflush: ::c_long = 4000 + 134;
+pub const SYS_sysfs: ::c_long = 4000 + 135;
+pub const SYS_personality: ::c_long = 4000 + 136;
+pub const SYS_afs_syscall: ::c_long = 4000 + 137;
+pub const SYS_setfsuid: ::c_long = 4000 + 138;
+pub const SYS_setfsgid: ::c_long = 4000 + 139;
+pub const SYS__llseek: ::c_long = 4000 + 140;
+pub const SYS_getdents: ::c_long = 4000 + 141;
+pub const SYS_flock: ::c_long = 4000 + 143;
+pub const SYS_msync: ::c_long = 4000 + 144;
+pub const SYS_readv: ::c_long = 4000 + 145;
+pub const SYS_writev: ::c_long = 4000 + 146;
+pub const SYS_cacheflush: ::c_long = 4000 + 147;
+pub const SYS_cachectl: ::c_long = 4000 + 148;
+pub const SYS_sysmips: ::c_long = 4000 + 149;
+pub const SYS_getsid: ::c_long = 4000 + 151;
+pub const SYS_fdatasync: ::c_long = 4000 + 152;
+pub const SYS__sysctl: ::c_long = 4000 + 153;
+pub const SYS_mlock: ::c_long = 4000 + 154;
+pub const SYS_munlock: ::c_long = 4000 + 155;
+pub const SYS_mlockall: ::c_long = 4000 + 156;
+pub const SYS_munlockall: ::c_long = 4000 + 157;
+pub const SYS_sched_setparam: ::c_long = 4000 + 158;
+pub const SYS_sched_getparam: ::c_long = 4000 + 159;
+pub const SYS_sched_setscheduler: ::c_long = 4000 + 160;
+pub const SYS_sched_getscheduler: ::c_long = 4000 + 161;
+pub const SYS_sched_yield: ::c_long = 4000 + 162;
+pub const SYS_sched_get_priority_max: ::c_long = 4000 + 163;
+pub const SYS_sched_get_priority_min: ::c_long = 4000 + 164;
+pub const SYS_sched_rr_get_interval: ::c_long = 4000 + 165;
+pub const SYS_nanosleep: ::c_long = 4000 + 166;
+pub const SYS_mremap: ::c_long = 4000 + 167;
+pub const SYS_accept: ::c_long = 4000 + 168;
+pub const SYS_bind: ::c_long = 4000 + 169;
+pub const SYS_connect: ::c_long = 4000 + 170;
+pub const SYS_getpeername: ::c_long = 4000 + 171;
+pub const SYS_getsockname: ::c_long = 4000 + 172;
+pub const SYS_getsockopt: ::c_long = 4000 + 173;
+pub const SYS_listen: ::c_long = 4000 + 174;
+pub const SYS_recv: ::c_long = 4000 + 175;
+pub const SYS_recvfrom: ::c_long = 4000 + 176;
+pub const SYS_recvmsg: ::c_long = 4000 + 177;
+pub const SYS_send: ::c_long = 4000 + 178;
+pub const SYS_sendmsg: ::c_long = 4000 + 179;
+pub const SYS_sendto: ::c_long = 4000 + 180;
+pub const SYS_setsockopt: ::c_long = 4000 + 181;
+pub const SYS_shutdown: ::c_long = 4000 + 182;
+pub const SYS_socket: ::c_long = 4000 + 183;
+pub const SYS_socketpair: ::c_long = 4000 + 184;
+pub const SYS_setresuid: ::c_long = 4000 + 185;
+pub const SYS_getresuid: ::c_long = 4000 + 186;
+pub const SYS_query_module: ::c_long = 4000 + 187;
+pub const SYS_poll: ::c_long = 4000 + 188;
+pub const SYS_nfsservctl: ::c_long = 4000 + 189;
+pub const SYS_setresgid: ::c_long = 4000 + 190;
+pub const SYS_getresgid: ::c_long = 4000 + 191;
+pub const SYS_prctl: ::c_long = 4000 + 192;
+pub const SYS_rt_sigreturn: ::c_long = 4000 + 193;
+pub const SYS_rt_sigaction: ::c_long = 4000 + 194;
+pub const SYS_rt_sigprocmask: ::c_long = 4000 + 195;
+pub const SYS_rt_sigpending: ::c_long = 4000 + 196;
+pub const SYS_rt_sigtimedwait: ::c_long = 4000 + 197;
+pub const SYS_rt_sigqueueinfo: ::c_long = 4000 + 198;
+pub const SYS_rt_sigsuspend: ::c_long = 4000 + 199;
+pub const SYS_chown: ::c_long = 4000 + 202;
+pub const SYS_getcwd: ::c_long = 4000 + 203;
+pub const SYS_capget: ::c_long = 4000 + 204;
+pub const SYS_capset: ::c_long = 4000 + 205;
+pub const SYS_sigaltstack: ::c_long = 4000 + 206;
+pub const SYS_sendfile: ::c_long = 4000 + 207;
+pub const SYS_getpmsg: ::c_long = 4000 + 208;
+pub const SYS_putpmsg: ::c_long = 4000 + 209;
+pub const SYS_mmap2: ::c_long = 4000 + 210;
+pub const SYS_truncate64: ::c_long = 4000 + 211;
+pub const SYS_ftruncate64: ::c_long = 4000 + 212;
+pub const SYS_stat64: ::c_long = 4000 + 213;
+pub const SYS_lstat64: ::c_long = 4000 + 214;
+pub const SYS_fstat64: ::c_long = 4000 + 215;
+pub const SYS_pivot_root: ::c_long = 4000 + 216;
+pub const SYS_mincore: ::c_long = 4000 + 217;
+pub const SYS_madvise: ::c_long = 4000 + 218;
+pub const SYS_getdents64: ::c_long = 4000 + 219;
+pub const SYS_fcntl64: ::c_long = 4000 + 220;
+pub const SYS_gettid: ::c_long = 4000 + 222;
+pub const SYS_readahead: ::c_long = 4000 + 223;
+pub const SYS_setxattr: ::c_long = 4000 + 224;
+pub const SYS_lsetxattr: ::c_long = 4000 + 225;
+pub const SYS_fsetxattr: ::c_long = 4000 + 226;
+pub const SYS_getxattr: ::c_long = 4000 + 227;
+pub const SYS_lgetxattr: ::c_long = 4000 + 228;
+pub const SYS_fgetxattr: ::c_long = 4000 + 229;
+pub const SYS_listxattr: ::c_long = 4000 + 230;
+pub const SYS_llistxattr: ::c_long = 4000 + 231;
+pub const SYS_flistxattr: ::c_long = 4000 + 232;
+pub const SYS_removexattr: ::c_long = 4000 + 233;
+pub const SYS_lremovexattr: ::c_long = 4000 + 234;
+pub const SYS_fremovexattr: ::c_long = 4000 + 235;
+pub const SYS_tkill: ::c_long = 4000 + 236;
+pub const SYS_sendfile64: ::c_long = 4000 + 237;
+pub const SYS_futex: ::c_long = 4000 + 238;
+pub const SYS_sched_setaffinity: ::c_long = 4000 + 239;
+pub const SYS_sched_getaffinity: ::c_long = 4000 + 240;
+pub const SYS_io_setup: ::c_long = 4000 + 241;
+pub const SYS_io_destroy: ::c_long = 4000 + 242;
+pub const SYS_io_getevents: ::c_long = 4000 + 243;
+pub const SYS_io_submit: ::c_long = 4000 + 244;
+pub const SYS_io_cancel: ::c_long = 4000 + 245;
+pub const SYS_exit_group: ::c_long = 4000 + 246;
+pub const SYS_lookup_dcookie: ::c_long = 4000 + 247;
+pub const SYS_epoll_create: ::c_long = 4000 + 248;
+pub const SYS_epoll_ctl: ::c_long = 4000 + 249;
+pub const SYS_epoll_wait: ::c_long = 4000 + 250;
+pub const SYS_remap_file_pages: ::c_long = 4000 + 251;
+pub const SYS_set_tid_address: ::c_long = 4000 + 252;
+pub const SYS_restart_syscall: ::c_long = 4000 + 253;
+pub const SYS_statfs64: ::c_long = 4000 + 255;
+pub const SYS_fstatfs64: ::c_long = 4000 + 256;
+pub const SYS_timer_create: ::c_long = 4000 + 257;
+pub const SYS_timer_settime: ::c_long = 4000 + 258;
+pub const SYS_timer_gettime: ::c_long = 4000 + 259;
+pub const SYS_timer_getoverrun: ::c_long = 4000 + 260;
+pub const SYS_timer_delete: ::c_long = 4000 + 261;
+pub const SYS_clock_settime: ::c_long = 4000 + 262;
+pub const SYS_clock_gettime: ::c_long = 4000 + 263;
+pub const SYS_clock_getres: ::c_long = 4000 + 264;
+pub const SYS_clock_nanosleep: ::c_long = 4000 + 265;
+pub const SYS_tgkill: ::c_long = 4000 + 266;
+pub const SYS_utimes: ::c_long = 4000 + 267;
+pub const SYS_mbind: ::c_long = 4000 + 268;
+pub const SYS_get_mempolicy: ::c_long = 4000 + 269;
+pub const SYS_set_mempolicy: ::c_long = 4000 + 270;
+pub const SYS_mq_open: ::c_long = 4000 + 271;
+pub const SYS_mq_unlink: ::c_long = 4000 + 272;
+pub const SYS_mq_timedsend: ::c_long = 4000 + 273;
+pub const SYS_mq_timedreceive: ::c_long = 4000 + 274;
+pub const SYS_mq_notify: ::c_long = 4000 + 275;
+pub const SYS_mq_getsetattr: ::c_long = 4000 + 276;
+pub const SYS_vserver: ::c_long = 4000 + 277;
+pub const SYS_waitid: ::c_long = 4000 + 278;
+/* pub const SYS_sys_setaltroot: ::c_long = 4000 + 279; */
+pub const SYS_add_key: ::c_long = 4000 + 280;
+pub const SYS_request_key: ::c_long = 4000 + 281;
+pub const SYS_keyctl: ::c_long = 4000 + 282;
+pub const SYS_set_thread_area: ::c_long = 4000 + 283;
+pub const SYS_inotify_init: ::c_long = 4000 + 284;
+pub const SYS_inotify_add_watch: ::c_long = 4000 + 285;
+pub const SYS_inotify_rm_watch: ::c_long = 4000 + 286;
+pub const SYS_migrate_pages: ::c_long = 4000 + 287;
+pub const SYS_openat: ::c_long = 4000 + 288;
+pub const SYS_mkdirat: ::c_long = 4000 + 289;
+pub const SYS_mknodat: ::c_long = 4000 + 290;
+pub const SYS_fchownat: ::c_long = 4000 + 291;
+pub const SYS_futimesat: ::c_long = 4000 + 292;
+pub const SYS_unlinkat: ::c_long = 4000 + 294;
+pub const SYS_renameat: ::c_long = 4000 + 295;
+pub const SYS_linkat: ::c_long = 4000 + 296;
+pub const SYS_symlinkat: ::c_long = 4000 + 297;
+pub const SYS_readlinkat: ::c_long = 4000 + 298;
+pub const SYS_fchmodat: ::c_long = 4000 + 299;
+pub const SYS_faccessat: ::c_long = 4000 + 300;
+pub const SYS_pselect6: ::c_long = 4000 + 301;
+pub const SYS_ppoll: ::c_long = 4000 + 302;
+pub const SYS_unshare: ::c_long = 4000 + 303;
+pub const SYS_splice: ::c_long = 4000 + 304;
+pub const SYS_sync_file_range: ::c_long = 4000 + 305;
+pub const SYS_tee: ::c_long = 4000 + 306;
+pub const SYS_vmsplice: ::c_long = 4000 + 307;
+pub const SYS_move_pages: ::c_long = 4000 + 308;
+pub const SYS_set_robust_list: ::c_long = 4000 + 309;
+pub const SYS_get_robust_list: ::c_long = 4000 + 310;
+pub const SYS_kexec_load: ::c_long = 4000 + 311;
+pub const SYS_getcpu: ::c_long = 4000 + 312;
+pub const SYS_epoll_pwait: ::c_long = 4000 + 313;
+pub const SYS_ioprio_set: ::c_long = 4000 + 314;
+pub const SYS_ioprio_get: ::c_long = 4000 + 315;
+pub const SYS_utimensat: ::c_long = 4000 + 316;
+pub const SYS_signalfd: ::c_long = 4000 + 317;
+pub const SYS_timerfd: ::c_long = 4000 + 318;
+pub const SYS_eventfd: ::c_long = 4000 + 319;
+pub const SYS_fallocate: ::c_long = 4000 + 320;
+pub const SYS_timerfd_create: ::c_long = 4000 + 321;
+pub const SYS_timerfd_gettime: ::c_long = 4000 + 322;
+pub const SYS_timerfd_settime: ::c_long = 4000 + 323;
+pub const SYS_signalfd4: ::c_long = 4000 + 324;
+pub const SYS_eventfd2: ::c_long = 4000 + 325;
+pub const SYS_epoll_create1: ::c_long = 4000 + 326;
+pub const SYS_dup3: ::c_long = 4000 + 327;
+pub const SYS_pipe2: ::c_long = 4000 + 328;
+pub const SYS_inotify_init1: ::c_long = 4000 + 329;
+pub const SYS_preadv: ::c_long = 4000 + 330;
+pub const SYS_pwritev: ::c_long = 4000 + 331;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 4000 + 332;
+pub const SYS_perf_event_open: ::c_long = 4000 + 333;
+pub const SYS_accept4: ::c_long = 4000 + 334;
+pub const SYS_recvmmsg: ::c_long = 4000 + 335;
+pub const SYS_fanotify_init: ::c_long = 4000 + 336;
+pub const SYS_fanotify_mark: ::c_long = 4000 + 337;
+pub const SYS_prlimit64: ::c_long = 4000 + 338;
+pub const SYS_name_to_handle_at: ::c_long = 4000 + 339;
+pub const SYS_open_by_handle_at: ::c_long = 4000 + 340;
+pub const SYS_clock_adjtime: ::c_long = 4000 + 341;
+pub const SYS_syncfs: ::c_long = 4000 + 342;
+pub const SYS_sendmmsg: ::c_long = 4000 + 343;
+pub const SYS_setns: ::c_long = 4000 + 344;
+pub const SYS_process_vm_readv: ::c_long = 4000 + 345;
+pub const SYS_process_vm_writev: ::c_long = 4000 + 346;
+pub const SYS_kcmp: ::c_long = 4000 + 347;
+pub const SYS_finit_module: ::c_long = 4000 + 348;
+pub const SYS_sched_setattr: ::c_long = 4000 + 349;
+pub const SYS_sched_getattr: ::c_long = 4000 + 350;
+pub const SYS_renameat2: ::c_long = 4000 + 351;
+pub const SYS_seccomp: ::c_long = 4000 + 352;
+pub const SYS_getrandom: ::c_long = 4000 + 353;
+pub const SYS_memfd_create: ::c_long = 4000 + 354;
+pub const SYS_bpf: ::c_long = 4000 + 355;
+pub const SYS_execveat: ::c_long = 4000 + 356;
+pub const SYS_userfaultfd: ::c_long = 4000 + 357;
+pub const SYS_membarrier: ::c_long = 4000 + 358;
+pub const SYS_mlock2: ::c_long = 4000 + 359;
+pub const SYS_copy_file_range: ::c_long = 4000 + 360;
+pub const SYS_preadv2: ::c_long = 4000 + 361;
+pub const SYS_pwritev2: ::c_long = 4000 + 362;
+pub const SYS_pkey_mprotect: ::c_long = 4000 + 363;
+pub const SYS_pkey_alloc: ::c_long = 4000 + 364;
+pub const SYS_pkey_free: ::c_long = 4000 + 365;
+pub const SYS_statx: ::c_long = 4000 + 366;
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/mod.rs b/library/libc/src/unix/linux_like/linux/musl/b32/mod.rs
new file mode 100644
index 00000000..f54e5d9c
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/mod.rs
@@ -0,0 +1,66 @@
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type nlink_t = u32;
+pub type blksize_t = ::c_long;
+pub type __u64 = ::c_ulonglong;
+pub type regoff_t = ::c_int;
+
+s! {
+    pub struct pthread_attr_t {
+        __size: [u32; 9]
+    }
+
+    pub struct sigset_t {
+        __val: [::c_ulong; 32],
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::socklen_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct sem_t {
+        __val: [::c_int; 4],
+    }
+}
+
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 24;
+
+pub const TIOCINQ: ::c_int = ::FIONREAD;
+
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(any(target_arch = "x86"))] {
+        mod x86;
+        pub use self::x86::*;
+    } else if #[cfg(any(target_arch = "mips"))] {
+        mod mips;
+        pub use self::mips::*;
+    } else if #[cfg(any(target_arch = "arm"))] {
+        mod arm;
+        pub use self::arm::*;
+    } else if #[cfg(any(target_arch = "powerpc"))] {
+        mod powerpc;
+        pub use self::powerpc::*;
+    } else if #[cfg(any(target_arch = "hexagon"))] {
+        mod hexagon;
+        pub use self::hexagon::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/powerpc.rs b/library/libc/src/unix/linux_like/linux/musl/b32/powerpc.rs
new file mode 100644
index 00000000..b94bb7b1
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/powerpc.rs
@@ -0,0 +1,866 @@
+pub type c_char = u8;
+pub type wchar_t = i32;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_rdev_padding: ::c_short,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 2],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_rdev_padding: ::c_short,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 2],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __pad1: ::c_int,
+        __pad2: ::c_longlong,
+        __pad3: ::c_longlong
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        __unused1: ::c_int,
+        pub shm_atime: ::time_t,
+        __unused2: ::c_int,
+        pub shm_dtime: ::time_t,
+        __unused3: ::c_int,
+        pub shm_ctime: ::time_t,
+        __unused4: ::c_int,
+        pub shm_segsz: ::size_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        __unused1: ::c_int,
+        pub msg_stime: ::time_t,
+        __unused2: ::c_int,
+        pub msg_rtime: ::time_t,
+        __unused3: ::c_int,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        #[cfg(target_endian = "little")]
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        #[cfg(target_endian = "big")]
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+}
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const SIGSTKSZ: ::size_t = 10240;
+pub const MINSIGSTKSZ: ::size_t = 4096;
+
+pub const O_DIRECT: ::c_int = 0x20000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_LARGEFILE: ::c_int = 0x10000;
+
+pub const FIOCLEX: ::c_int = 0x20006601;
+pub const FIONCLEX: ::c_int = 0x20006602;
+pub const FIONBIO: ::c_int = 0x8004667E;
+
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+
+pub const MCL_CURRENT: ::c_int = 0x2000;
+pub const MCL_FUTURE: ::c_int = 0x4000;
+pub const CBAUD: ::tcflag_t = 0o0000377;
+pub const TAB1: ::c_int = 0x00000400;
+pub const TAB2: ::c_int = 0x00000800;
+pub const TAB3: ::c_int = 0x00000C00;
+pub const CR1: ::c_int = 0x00001000;
+pub const CR2: ::c_int = 0x00002000;
+pub const CR3: ::c_int = 0x00003000;
+pub const FF1: ::c_int = 0x00004000;
+pub const BS1: ::c_int = 0x00008000;
+pub const VT1: ::c_int = 0x00010000;
+pub const VWERASE: usize = 10;
+pub const VREPRINT: usize = 11;
+pub const VSUSP: usize = 12;
+pub const VSTART: usize = 13;
+pub const VSTOP: usize = 14;
+pub const VDISCARD: usize = 16;
+pub const VTIME: usize = 7;
+pub const IXON: ::tcflag_t = 0x00000200;
+pub const IXOFF: ::tcflag_t = 0x00000400;
+pub const ONLCR: ::tcflag_t = 0x00000002;
+pub const CSIZE: ::tcflag_t = 0x00000300;
+pub const CS6: ::tcflag_t = 0x00000100;
+pub const CS7: ::tcflag_t = 0x00000200;
+pub const CS8: ::tcflag_t = 0x00000300;
+pub const CSTOPB: ::tcflag_t = 0x00000400;
+pub const CREAD: ::tcflag_t = 0x00000800;
+pub const PARENB: ::tcflag_t = 0x00001000;
+pub const PARODD: ::tcflag_t = 0x00002000;
+pub const HUPCL: ::tcflag_t = 0x00004000;
+pub const CLOCAL: ::tcflag_t = 0x00008000;
+pub const ECHOKE: ::tcflag_t = 0x00000001;
+pub const ECHOE: ::tcflag_t = 0x00000002;
+pub const ECHOK: ::tcflag_t = 0x00000004;
+pub const ECHONL: ::tcflag_t = 0x00000010;
+pub const ECHOPRT: ::tcflag_t = 0x00000020;
+pub const ECHOCTL: ::tcflag_t = 0x00000040;
+pub const ISIG: ::tcflag_t = 0x00000080;
+pub const ICANON: ::tcflag_t = 0x00000100;
+pub const PENDIN: ::tcflag_t = 0x20000000;
+pub const NOFLSH: ::tcflag_t = 0x80000000;
+pub const CIBAUD: ::tcflag_t = 0o00077600000;
+pub const CBAUDEX: ::tcflag_t = 0o000020;
+pub const VSWTC: usize = 9;
+pub const OLCUC: ::tcflag_t = 0o000004;
+pub const NLDLY: ::tcflag_t = 0o001400;
+pub const CRDLY: ::tcflag_t = 0o030000;
+pub const TABDLY: ::tcflag_t = 0o006000;
+pub const BSDLY: ::tcflag_t = 0o100000;
+pub const FFDLY: ::tcflag_t = 0o040000;
+pub const VTDLY: ::tcflag_t = 0o200000;
+pub const XTABS: ::tcflag_t = 0o006000;
+pub const B57600: ::speed_t = 0o000020;
+pub const B115200: ::speed_t = 0o000021;
+pub const B230400: ::speed_t = 0o000022;
+pub const B460800: ::speed_t = 0o000023;
+pub const B500000: ::speed_t = 0o000024;
+pub const B576000: ::speed_t = 0o000025;
+pub const B921600: ::speed_t = 0o000026;
+pub const B1000000: ::speed_t = 0o000027;
+pub const B1152000: ::speed_t = 0o000030;
+pub const B1500000: ::speed_t = 0o000031;
+pub const B2000000: ::speed_t = 0o000032;
+pub const B2500000: ::speed_t = 0o000033;
+pub const B3000000: ::speed_t = 0o000034;
+pub const B3500000: ::speed_t = 0o000035;
+pub const B4000000: ::speed_t = 0o000036;
+
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+
+pub const SOCK_NONBLOCK: ::c_int = 2048;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x00080;
+pub const MAP_NORESERVE: ::c_int = 0x00040;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EDEADLOCK: ::c_int = 58;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_RCVLOWAT: ::c_int = 16;
+pub const SO_SNDLOWAT: ::c_int = 17;
+pub const SO_RCVTIMEO: ::c_int = 18;
+pub const SO_SNDTIMEO: ::c_int = 19;
+pub const SO_PASSCRED: ::c_int = 20;
+pub const SO_PEERCRED: ::c_int = 21;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const EXTPROC: ::tcflag_t = 0x10000000;
+
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+
+pub const F_GETLK: ::c_int = 12;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETLK: ::c_int = 13;
+pub const F_SETLKW: ::c_int = 14;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const VEOF: usize = 4;
+pub const VEOL: usize = 6;
+pub const VEOL2: usize = 8;
+pub const VMIN: usize = 5;
+pub const IEXTEN: ::tcflag_t = 0x00000400;
+pub const TOSTOP: ::tcflag_t = 0x00400000;
+pub const FLUSHO: ::tcflag_t = 0x00800000;
+
+pub const TCGETS: ::c_int = 0x402C7413;
+pub const TCSETS: ::c_int = 0x802C7414;
+pub const TCSETSW: ::c_int = 0x802C7415;
+pub const TCSETSF: ::c_int = 0x802C7416;
+pub const TCGETA: ::c_int = 0x40147417;
+pub const TCSETA: ::c_int = 0x80147418;
+pub const TCSETAW: ::c_int = 0x80147419;
+pub const TCSETAF: ::c_int = 0x8014741C;
+pub const TCSBRK: ::c_int = 0x2000741D;
+pub const TCXONC: ::c_int = 0x2000741E;
+pub const TCFLSH: ::c_int = 0x2000741F;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x40047477;
+pub const TIOCSPGRP: ::c_int = 0x80047476;
+pub const TIOCOUTQ: ::c_int = 0x40047473;
+pub const TIOCSTI: ::c_int = 0x5412;
+pub const TIOCGWINSZ: ::c_int = 0x40087468;
+pub const TIOCSWINSZ: ::c_int = 0x80087467;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x4004667F;
+pub const TIOCCONS: ::c_int = 0x541D;
+
+pub const TIOCGRS485: ::c_int = 0x542e;
+pub const TIOCSRS485: ::c_int = 0x542f;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+// Syscall table
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_waitpid: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_time: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_break: ::c_long = 17;
+pub const SYS_oldstat: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_umount: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_stime: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_oldfstat: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_stty: ::c_long = 31;
+pub const SYS_gtty: ::c_long = 32;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_ftime: ::c_long = 35;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_prof: ::c_long = 44;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_lock: ::c_long = 53;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_mpx: ::c_long = 56;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_ulimit: ::c_long = 58;
+pub const SYS_oldolduname: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_sgetmask: ::c_long = 68;
+pub const SYS_ssetmask: ::c_long = 69;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrlimit: ::c_long = 76;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_select: ::c_long = 82;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_oldlstat: ::c_long = 84;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_readdir: ::c_long = 89;
+pub const SYS_mmap: ::c_long = 90;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_profil: ::c_long = 98;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_ioperm: ::c_long = 101;
+pub const SYS_socketcall: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_olduname: ::c_long = 109;
+pub const SYS_iopl: ::c_long = 110;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_idle: ::c_long = 112;
+pub const SYS_vm86: ::c_long = 113;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_ipc: ::c_long = 117;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_modify_ldt: ::c_long = 123;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_create_module: ::c_long = 127;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_get_kernel_syms: ::c_long = 130;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_afs_syscall: ::c_long = 137;
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_query_module: ::c_long = 166;
+pub const SYS_poll: ::c_long = 167;
+pub const SYS_nfsservctl: ::c_long = 168;
+pub const SYS_setresgid: ::c_long = 169;
+pub const SYS_getresgid: ::c_long = 170;
+pub const SYS_prctl: ::c_long = 171;
+pub const SYS_rt_sigreturn: ::c_long = 172;
+pub const SYS_rt_sigaction: ::c_long = 173;
+pub const SYS_rt_sigprocmask: ::c_long = 174;
+pub const SYS_rt_sigpending: ::c_long = 175;
+pub const SYS_rt_sigtimedwait: ::c_long = 176;
+pub const SYS_rt_sigqueueinfo: ::c_long = 177;
+pub const SYS_rt_sigsuspend: ::c_long = 178;
+pub const SYS_pread64: ::c_long = 179;
+pub const SYS_pwrite64: ::c_long = 180;
+pub const SYS_chown: ::c_long = 181;
+pub const SYS_getcwd: ::c_long = 182;
+pub const SYS_capget: ::c_long = 183;
+pub const SYS_capset: ::c_long = 184;
+pub const SYS_sigaltstack: ::c_long = 185;
+pub const SYS_sendfile: ::c_long = 186;
+pub const SYS_getpmsg: ::c_long = 187;
+pub const SYS_putpmsg: ::c_long = 188;
+pub const SYS_vfork: ::c_long = 189;
+pub const SYS_ugetrlimit: ::c_long = 190;
+pub const SYS_readahead: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_pciconfig_read: ::c_long = 198;
+pub const SYS_pciconfig_write: ::c_long = 199;
+pub const SYS_pciconfig_iobase: ::c_long = 200;
+pub const SYS_multiplexer: ::c_long = 201;
+pub const SYS_getdents64: ::c_long = 202;
+pub const SYS_pivot_root: ::c_long = 203;
+pub const SYS_fcntl64: ::c_long = 204;
+pub const SYS_madvise: ::c_long = 205;
+pub const SYS_mincore: ::c_long = 206;
+pub const SYS_gettid: ::c_long = 207;
+pub const SYS_tkill: ::c_long = 208;
+pub const SYS_setxattr: ::c_long = 209;
+pub const SYS_lsetxattr: ::c_long = 210;
+pub const SYS_fsetxattr: ::c_long = 211;
+pub const SYS_getxattr: ::c_long = 212;
+pub const SYS_lgetxattr: ::c_long = 213;
+pub const SYS_fgetxattr: ::c_long = 214;
+pub const SYS_listxattr: ::c_long = 215;
+pub const SYS_llistxattr: ::c_long = 216;
+pub const SYS_flistxattr: ::c_long = 217;
+pub const SYS_removexattr: ::c_long = 218;
+pub const SYS_lremovexattr: ::c_long = 219;
+pub const SYS_fremovexattr: ::c_long = 220;
+pub const SYS_futex: ::c_long = 221;
+pub const SYS_sched_setaffinity: ::c_long = 222;
+pub const SYS_sched_getaffinity: ::c_long = 223;
+pub const SYS_tuxcall: ::c_long = 225;
+pub const SYS_sendfile64: ::c_long = 226;
+pub const SYS_io_setup: ::c_long = 227;
+pub const SYS_io_destroy: ::c_long = 228;
+pub const SYS_io_getevents: ::c_long = 229;
+pub const SYS_io_submit: ::c_long = 230;
+pub const SYS_io_cancel: ::c_long = 231;
+pub const SYS_set_tid_address: ::c_long = 232;
+pub const SYS_fadvise64: ::c_long = 233;
+pub const SYS_exit_group: ::c_long = 234;
+pub const SYS_lookup_dcookie: ::c_long = 235;
+pub const SYS_epoll_create: ::c_long = 236;
+pub const SYS_epoll_ctl: ::c_long = 237;
+pub const SYS_epoll_wait: ::c_long = 238;
+pub const SYS_remap_file_pages: ::c_long = 239;
+pub const SYS_timer_create: ::c_long = 240;
+pub const SYS_timer_settime: ::c_long = 241;
+pub const SYS_timer_gettime: ::c_long = 242;
+pub const SYS_timer_getoverrun: ::c_long = 243;
+pub const SYS_timer_delete: ::c_long = 244;
+pub const SYS_clock_settime: ::c_long = 245;
+pub const SYS_clock_gettime: ::c_long = 246;
+pub const SYS_clock_getres: ::c_long = 247;
+pub const SYS_clock_nanosleep: ::c_long = 248;
+pub const SYS_swapcontext: ::c_long = 249;
+pub const SYS_tgkill: ::c_long = 250;
+pub const SYS_utimes: ::c_long = 251;
+pub const SYS_statfs64: ::c_long = 252;
+pub const SYS_fstatfs64: ::c_long = 253;
+pub const SYS_fadvise64_64: ::c_long = 254;
+pub const SYS_rtas: ::c_long = 255;
+pub const SYS_sys_debug_setcontext: ::c_long = 256;
+pub const SYS_migrate_pages: ::c_long = 258;
+pub const SYS_mbind: ::c_long = 259;
+pub const SYS_get_mempolicy: ::c_long = 260;
+pub const SYS_set_mempolicy: ::c_long = 261;
+pub const SYS_mq_open: ::c_long = 262;
+pub const SYS_mq_unlink: ::c_long = 263;
+pub const SYS_mq_timedsend: ::c_long = 264;
+pub const SYS_mq_timedreceive: ::c_long = 265;
+pub const SYS_mq_notify: ::c_long = 266;
+pub const SYS_mq_getsetattr: ::c_long = 267;
+pub const SYS_kexec_load: ::c_long = 268;
+pub const SYS_add_key: ::c_long = 269;
+pub const SYS_request_key: ::c_long = 270;
+pub const SYS_keyctl: ::c_long = 271;
+pub const SYS_waitid: ::c_long = 272;
+pub const SYS_ioprio_set: ::c_long = 273;
+pub const SYS_ioprio_get: ::c_long = 274;
+pub const SYS_inotify_init: ::c_long = 275;
+pub const SYS_inotify_add_watch: ::c_long = 276;
+pub const SYS_inotify_rm_watch: ::c_long = 277;
+pub const SYS_spu_run: ::c_long = 278;
+pub const SYS_spu_create: ::c_long = 279;
+pub const SYS_pselect6: ::c_long = 280;
+pub const SYS_ppoll: ::c_long = 281;
+pub const SYS_unshare: ::c_long = 282;
+pub const SYS_splice: ::c_long = 283;
+pub const SYS_tee: ::c_long = 284;
+pub const SYS_vmsplice: ::c_long = 285;
+pub const SYS_openat: ::c_long = 286;
+pub const SYS_mkdirat: ::c_long = 287;
+pub const SYS_mknodat: ::c_long = 288;
+pub const SYS_fchownat: ::c_long = 289;
+pub const SYS_futimesat: ::c_long = 290;
+pub const SYS_fstatat64: ::c_long = 291;
+pub const SYS_unlinkat: ::c_long = 292;
+pub const SYS_renameat: ::c_long = 293;
+pub const SYS_linkat: ::c_long = 294;
+pub const SYS_symlinkat: ::c_long = 295;
+pub const SYS_readlinkat: ::c_long = 296;
+pub const SYS_fchmodat: ::c_long = 297;
+pub const SYS_faccessat: ::c_long = 298;
+pub const SYS_get_robust_list: ::c_long = 299;
+pub const SYS_set_robust_list: ::c_long = 300;
+pub const SYS_move_pages: ::c_long = 301;
+pub const SYS_getcpu: ::c_long = 302;
+pub const SYS_epoll_pwait: ::c_long = 303;
+pub const SYS_utimensat: ::c_long = 304;
+pub const SYS_signalfd: ::c_long = 305;
+pub const SYS_timerfd_create: ::c_long = 306;
+pub const SYS_eventfd: ::c_long = 307;
+pub const SYS_sync_file_range2: ::c_long = 308;
+pub const SYS_fallocate: ::c_long = 309;
+pub const SYS_subpage_prot: ::c_long = 310;
+pub const SYS_timerfd_settime: ::c_long = 311;
+pub const SYS_timerfd_gettime: ::c_long = 312;
+pub const SYS_signalfd4: ::c_long = 313;
+pub const SYS_eventfd2: ::c_long = 314;
+pub const SYS_epoll_create1: ::c_long = 315;
+pub const SYS_dup3: ::c_long = 316;
+pub const SYS_pipe2: ::c_long = 317;
+pub const SYS_inotify_init1: ::c_long = 318;
+pub const SYS_perf_event_open: ::c_long = 319;
+pub const SYS_preadv: ::c_long = 320;
+pub const SYS_pwritev: ::c_long = 321;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 322;
+pub const SYS_fanotify_init: ::c_long = 323;
+pub const SYS_fanotify_mark: ::c_long = 324;
+pub const SYS_prlimit64: ::c_long = 325;
+pub const SYS_socket: ::c_long = 326;
+pub const SYS_bind: ::c_long = 327;
+pub const SYS_connect: ::c_long = 328;
+pub const SYS_listen: ::c_long = 329;
+pub const SYS_accept: ::c_long = 330;
+pub const SYS_getsockname: ::c_long = 331;
+pub const SYS_getpeername: ::c_long = 332;
+pub const SYS_socketpair: ::c_long = 333;
+pub const SYS_send: ::c_long = 334;
+pub const SYS_sendto: ::c_long = 335;
+pub const SYS_recv: ::c_long = 336;
+pub const SYS_recvfrom: ::c_long = 337;
+pub const SYS_shutdown: ::c_long = 338;
+pub const SYS_setsockopt: ::c_long = 339;
+pub const SYS_getsockopt: ::c_long = 340;
+pub const SYS_sendmsg: ::c_long = 341;
+pub const SYS_recvmsg: ::c_long = 342;
+pub const SYS_recvmmsg: ::c_long = 343;
+pub const SYS_accept4: ::c_long = 344;
+pub const SYS_name_to_handle_at: ::c_long = 345;
+pub const SYS_open_by_handle_at: ::c_long = 346;
+pub const SYS_clock_adjtime: ::c_long = 347;
+pub const SYS_syncfs: ::c_long = 348;
+pub const SYS_sendmmsg: ::c_long = 349;
+pub const SYS_setns: ::c_long = 350;
+pub const SYS_process_vm_readv: ::c_long = 351;
+pub const SYS_process_vm_writev: ::c_long = 352;
+pub const SYS_finit_module: ::c_long = 353;
+pub const SYS_kcmp: ::c_long = 354;
+pub const SYS_sched_setattr: ::c_long = 355;
+pub const SYS_sched_getattr: ::c_long = 356;
+pub const SYS_renameat2: ::c_long = 357;
+pub const SYS_seccomp: ::c_long = 358;
+pub const SYS_getrandom: ::c_long = 359;
+pub const SYS_memfd_create: ::c_long = 360;
+pub const SYS_bpf: ::c_long = 361;
+pub const SYS_execveat: ::c_long = 362;
+pub const SYS_switch_endian: ::c_long = 363;
+pub const SYS_userfaultfd: ::c_long = 364;
+pub const SYS_membarrier: ::c_long = 365;
+pub const SYS_mlock2: ::c_long = 378;
+pub const SYS_copy_file_range: ::c_long = 379;
+pub const SYS_preadv2: ::c_long = 380;
+pub const SYS_pwritev2: ::c_long = 381;
+pub const SYS_kexec_file_load: ::c_long = 382;
+pub const SYS_statx: ::c_long = 383;
+pub const SYS_pkey_alloc: ::c_long = 384;
+pub const SYS_pkey_free: ::c_long = 385;
+pub const SYS_pkey_mprotect: ::c_long = 386;
+
+extern "C" {
+    pub fn getrandom(
+        buf: *mut ::c_void,
+        buflen: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/x86/align.rs b/library/libc/src/unix/linux_like/linux/musl/b32/x86/align.rs
new file mode 100644
index 00000000..79544176
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/x86/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(8))]
+    pub struct max_align_t {
+        priv_: [f64; 3]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b32/x86/mod.rs b/library/libc/src/unix/linux_like/linux/musl/b32/x86/mod.rs
new file mode 100644
index 00000000..82ef84a9
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b32/x86/mod.rs
@@ -0,0 +1,958 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        __st_dev_padding: ::c_int,
+        __st_ino_truncated: ::c_long,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_rdev_padding: ::c_int,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::ino_t,
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        __st_dev_padding: ::c_int,
+        __st_ino_truncated: ::c_long,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __st_rdev_padding: ::c_int,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_ino: ::ino_t,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __unused1: ::c_long,
+        __unused2: ::c_long
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        __unused1: ::c_int,
+        pub shm_dtime: ::time_t,
+        __unused2: ::c_int,
+        pub shm_ctime: ::time_t,
+        __unused3: ::c_int,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        __unused1: ::c_int,
+        pub msg_rtime: ::time_t,
+        __unused2: ::c_int,
+        pub msg_ctime: ::time_t,
+        __unused3: ::c_int,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct mcontext_t {
+        __private: [u32; 22]
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        __f_unused: ::c_int,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+}
+
+s_no_extra_traits! {
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_mcontext: mcontext_t,
+        pub uc_sigmask: ::sigset_t,
+        __private: [u8; 112],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for ucontext_t {
+            fn eq(&self, other: &ucontext_t) -> bool {
+                self.uc_flags == other.uc_flags
+                    && self.uc_link == other.uc_link
+                    && self.uc_stack == other.uc_stack
+                    && self.uc_mcontext == other.uc_mcontext
+                    && self.uc_sigmask == other.uc_sigmask
+                    && self
+                    .__private
+                    .iter()
+                    .zip(other.__private.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for ucontext_t {}
+
+        impl ::fmt::Debug for ucontext_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("ucontext_t")
+                    .field("uc_flags", &self.uc_flags)
+                    .field("uc_link", &self.uc_link)
+                    .field("uc_stack", &self.uc_stack)
+                    .field("uc_mcontext", &self.uc_mcontext)
+                    .field("uc_sigmask", &self.uc_sigmask)
+                // Ignore __private field
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for ucontext_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uc_flags.hash(state);
+                self.uc_link.hash(state);
+                self.uc_stack.hash(state);
+                self.uc_mcontext.hash(state);
+                self.uc_sigmask.hash(state);
+                self.__private.hash(state);
+            }
+        }
+    }
+}
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+
+pub const O_DIRECT: ::c_int = 0x4000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+pub const O_ASYNC: ::c_int = 0x2000;
+pub const O_LARGEFILE: ::c_int = 0o0100000;
+
+pub const FIOCLEX: ::c_int = 0x5451;
+pub const FIONCLEX: ::c_int = 0x5450;
+pub const FIONBIO: ::c_int = 0x5421;
+
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::c_int = 0x00000800;
+pub const TAB2: ::c_int = 0x00001000;
+pub const TAB3: ::c_int = 0x00001800;
+pub const CR1: ::c_int = 0x00000200;
+pub const CR2: ::c_int = 0x00000400;
+pub const CR3: ::c_int = 0x00000600;
+pub const FF1: ::c_int = 0x00008000;
+pub const BS1: ::c_int = 0x00002000;
+pub const VT1: ::c_int = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const O_APPEND: ::c_int = 1024;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+
+pub const SOCK_NONBLOCK: ::c_int = 2048;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+pub const SOL_SOCKET: ::c_int = 1;
+
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_32BIT: ::c_int = 0x0040;
+
+pub const F_GETLK: ::c_int = 12;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETLK: ::c_int = 13;
+pub const F_SETLKW: ::c_int = 14;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const VEOF: usize = 4;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+
+pub const TCGETS: ::c_int = 0x5401;
+pub const TCSETS: ::c_int = 0x5402;
+pub const TCSETSW: ::c_int = 0x5403;
+pub const TCSETSF: ::c_int = 0x5404;
+pub const TCGETA: ::c_int = 0x5405;
+pub const TCSETA: ::c_int = 0x5406;
+pub const TCSETAW: ::c_int = 0x5407;
+pub const TCSETAF: ::c_int = 0x5408;
+pub const TCSBRK: ::c_int = 0x5409;
+pub const TCXONC: ::c_int = 0x540A;
+pub const TCFLSH: ::c_int = 0x540B;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x540F;
+pub const TIOCSPGRP: ::c_int = 0x5410;
+pub const TIOCOUTQ: ::c_int = 0x5411;
+pub const TIOCSTI: ::c_int = 0x5412;
+pub const TIOCGWINSZ: ::c_int = 0x5413;
+pub const TIOCSWINSZ: ::c_int = 0x5414;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x541B;
+pub const TIOCCONS: ::c_int = 0x541D;
+
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+// Syscall table
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_waitpid: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_time: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_break: ::c_long = 17;
+pub const SYS_oldstat: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_umount: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_stime: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_oldfstat: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_stty: ::c_long = 31;
+pub const SYS_gtty: ::c_long = 32;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_ftime: ::c_long = 35;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_prof: ::c_long = 44;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_lock: ::c_long = 53;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_mpx: ::c_long = 56;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_ulimit: ::c_long = 58;
+pub const SYS_oldolduname: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_sgetmask: ::c_long = 68;
+pub const SYS_ssetmask: ::c_long = 69;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrlimit: ::c_long = 76;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_select: ::c_long = 82;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_oldlstat: ::c_long = 84;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_readdir: ::c_long = 89;
+pub const SYS_mmap: ::c_long = 90;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_profil: ::c_long = 98;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_ioperm: ::c_long = 101;
+pub const SYS_socketcall: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_olduname: ::c_long = 109;
+pub const SYS_iopl: ::c_long = 110;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_idle: ::c_long = 112;
+pub const SYS_vm86old: ::c_long = 113;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_ipc: ::c_long = 117;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_modify_ldt: ::c_long = 123;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_create_module: ::c_long = 127;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_get_kernel_syms: ::c_long = 130;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_afs_syscall: ::c_long = 137;
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_vm86: ::c_long = 166;
+pub const SYS_query_module: ::c_long = 167;
+pub const SYS_poll: ::c_long = 168;
+pub const SYS_nfsservctl: ::c_long = 169;
+pub const SYS_setresgid: ::c_long = 170;
+pub const SYS_getresgid: ::c_long = 171;
+pub const SYS_prctl: ::c_long = 172;
+pub const SYS_rt_sigreturn: ::c_long = 173;
+pub const SYS_rt_sigaction: ::c_long = 174;
+pub const SYS_rt_sigprocmask: ::c_long = 175;
+pub const SYS_rt_sigpending: ::c_long = 176;
+pub const SYS_rt_sigtimedwait: ::c_long = 177;
+pub const SYS_rt_sigqueueinfo: ::c_long = 178;
+pub const SYS_rt_sigsuspend: ::c_long = 179;
+pub const SYS_pread64: ::c_long = 180;
+pub const SYS_pwrite64: ::c_long = 181;
+pub const SYS_chown: ::c_long = 182;
+pub const SYS_getcwd: ::c_long = 183;
+pub const SYS_capget: ::c_long = 184;
+pub const SYS_capset: ::c_long = 185;
+pub const SYS_sigaltstack: ::c_long = 186;
+pub const SYS_sendfile: ::c_long = 187;
+pub const SYS_getpmsg: ::c_long = 188;
+pub const SYS_putpmsg: ::c_long = 189;
+pub const SYS_vfork: ::c_long = 190;
+pub const SYS_ugetrlimit: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_lchown32: ::c_long = 198;
+pub const SYS_getuid32: ::c_long = 199;
+pub const SYS_getgid32: ::c_long = 200;
+pub const SYS_geteuid32: ::c_long = 201;
+pub const SYS_getegid32: ::c_long = 202;
+pub const SYS_setreuid32: ::c_long = 203;
+pub const SYS_setregid32: ::c_long = 204;
+pub const SYS_getgroups32: ::c_long = 205;
+pub const SYS_setgroups32: ::c_long = 206;
+pub const SYS_fchown32: ::c_long = 207;
+pub const SYS_setresuid32: ::c_long = 208;
+pub const SYS_getresuid32: ::c_long = 209;
+pub const SYS_setresgid32: ::c_long = 210;
+pub const SYS_getresgid32: ::c_long = 211;
+pub const SYS_chown32: ::c_long = 212;
+pub const SYS_setuid32: ::c_long = 213;
+pub const SYS_setgid32: ::c_long = 214;
+pub const SYS_setfsuid32: ::c_long = 215;
+pub const SYS_setfsgid32: ::c_long = 216;
+pub const SYS_pivot_root: ::c_long = 217;
+pub const SYS_mincore: ::c_long = 218;
+pub const SYS_madvise: ::c_long = 219;
+pub const SYS_getdents64: ::c_long = 220;
+pub const SYS_fcntl64: ::c_long = 221;
+pub const SYS_gettid: ::c_long = 224;
+pub const SYS_readahead: ::c_long = 225;
+pub const SYS_setxattr: ::c_long = 226;
+pub const SYS_lsetxattr: ::c_long = 227;
+pub const SYS_fsetxattr: ::c_long = 228;
+pub const SYS_getxattr: ::c_long = 229;
+pub const SYS_lgetxattr: ::c_long = 230;
+pub const SYS_fgetxattr: ::c_long = 231;
+pub const SYS_listxattr: ::c_long = 232;
+pub const SYS_llistxattr: ::c_long = 233;
+pub const SYS_flistxattr: ::c_long = 234;
+pub const SYS_removexattr: ::c_long = 235;
+pub const SYS_lremovexattr: ::c_long = 236;
+pub const SYS_fremovexattr: ::c_long = 237;
+pub const SYS_tkill: ::c_long = 238;
+pub const SYS_sendfile64: ::c_long = 239;
+pub const SYS_futex: ::c_long = 240;
+pub const SYS_sched_setaffinity: ::c_long = 241;
+pub const SYS_sched_getaffinity: ::c_long = 242;
+pub const SYS_set_thread_area: ::c_long = 243;
+pub const SYS_get_thread_area: ::c_long = 244;
+pub const SYS_io_setup: ::c_long = 245;
+pub const SYS_io_destroy: ::c_long = 246;
+pub const SYS_io_getevents: ::c_long = 247;
+pub const SYS_io_submit: ::c_long = 248;
+pub const SYS_io_cancel: ::c_long = 249;
+pub const SYS_fadvise64: ::c_long = 250;
+pub const SYS_exit_group: ::c_long = 252;
+pub const SYS_lookup_dcookie: ::c_long = 253;
+pub const SYS_epoll_create: ::c_long = 254;
+pub const SYS_epoll_ctl: ::c_long = 255;
+pub const SYS_epoll_wait: ::c_long = 256;
+pub const SYS_remap_file_pages: ::c_long = 257;
+pub const SYS_set_tid_address: ::c_long = 258;
+pub const SYS_timer_create: ::c_long = 259;
+pub const SYS_timer_settime: ::c_long = 260;
+pub const SYS_timer_gettime: ::c_long = 261;
+pub const SYS_timer_getoverrun: ::c_long = 262;
+pub const SYS_timer_delete: ::c_long = 263;
+pub const SYS_clock_settime: ::c_long = 264;
+pub const SYS_clock_gettime: ::c_long = 265;
+pub const SYS_clock_getres: ::c_long = 266;
+pub const SYS_clock_nanosleep: ::c_long = 267;
+pub const SYS_statfs64: ::c_long = 268;
+pub const SYS_fstatfs64: ::c_long = 269;
+pub const SYS_tgkill: ::c_long = 270;
+pub const SYS_utimes: ::c_long = 271;
+pub const SYS_fadvise64_64: ::c_long = 272;
+pub const SYS_vserver: ::c_long = 273;
+pub const SYS_mbind: ::c_long = 274;
+pub const SYS_get_mempolicy: ::c_long = 275;
+pub const SYS_set_mempolicy: ::c_long = 276;
+pub const SYS_mq_open: ::c_long = 277;
+pub const SYS_mq_unlink: ::c_long = 278;
+pub const SYS_mq_timedsend: ::c_long = 279;
+pub const SYS_mq_timedreceive: ::c_long = 280;
+pub const SYS_mq_notify: ::c_long = 281;
+pub const SYS_mq_getsetattr: ::c_long = 282;
+pub const SYS_kexec_load: ::c_long = 283;
+pub const SYS_waitid: ::c_long = 284;
+pub const SYS_add_key: ::c_long = 286;
+pub const SYS_request_key: ::c_long = 287;
+pub const SYS_keyctl: ::c_long = 288;
+pub const SYS_ioprio_set: ::c_long = 289;
+pub const SYS_ioprio_get: ::c_long = 290;
+pub const SYS_inotify_init: ::c_long = 291;
+pub const SYS_inotify_add_watch: ::c_long = 292;
+pub const SYS_inotify_rm_watch: ::c_long = 293;
+pub const SYS_migrate_pages: ::c_long = 294;
+pub const SYS_openat: ::c_long = 295;
+pub const SYS_mkdirat: ::c_long = 296;
+pub const SYS_mknodat: ::c_long = 297;
+pub const SYS_fchownat: ::c_long = 298;
+pub const SYS_futimesat: ::c_long = 299;
+pub const SYS_fstatat64: ::c_long = 300;
+pub const SYS_unlinkat: ::c_long = 301;
+pub const SYS_renameat: ::c_long = 302;
+pub const SYS_linkat: ::c_long = 303;
+pub const SYS_symlinkat: ::c_long = 304;
+pub const SYS_readlinkat: ::c_long = 305;
+pub const SYS_fchmodat: ::c_long = 306;
+pub const SYS_faccessat: ::c_long = 307;
+pub const SYS_pselect6: ::c_long = 308;
+pub const SYS_ppoll: ::c_long = 309;
+pub const SYS_unshare: ::c_long = 310;
+pub const SYS_set_robust_list: ::c_long = 311;
+pub const SYS_get_robust_list: ::c_long = 312;
+pub const SYS_splice: ::c_long = 313;
+pub const SYS_sync_file_range: ::c_long = 314;
+pub const SYS_tee: ::c_long = 315;
+pub const SYS_vmsplice: ::c_long = 316;
+pub const SYS_move_pages: ::c_long = 317;
+pub const SYS_getcpu: ::c_long = 318;
+pub const SYS_epoll_pwait: ::c_long = 319;
+pub const SYS_utimensat: ::c_long = 320;
+pub const SYS_signalfd: ::c_long = 321;
+pub const SYS_timerfd_create: ::c_long = 322;
+pub const SYS_eventfd: ::c_long = 323;
+pub const SYS_fallocate: ::c_long = 324;
+pub const SYS_timerfd_settime: ::c_long = 325;
+pub const SYS_timerfd_gettime: ::c_long = 326;
+pub const SYS_signalfd4: ::c_long = 327;
+pub const SYS_eventfd2: ::c_long = 328;
+pub const SYS_epoll_create1: ::c_long = 329;
+pub const SYS_dup3: ::c_long = 330;
+pub const SYS_pipe2: ::c_long = 331;
+pub const SYS_inotify_init1: ::c_long = 332;
+pub const SYS_preadv: ::c_long = 333;
+pub const SYS_pwritev: ::c_long = 334;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 335;
+pub const SYS_perf_event_open: ::c_long = 336;
+pub const SYS_recvmmsg: ::c_long = 337;
+pub const SYS_fanotify_init: ::c_long = 338;
+pub const SYS_fanotify_mark: ::c_long = 339;
+pub const SYS_prlimit64: ::c_long = 340;
+pub const SYS_name_to_handle_at: ::c_long = 341;
+pub const SYS_open_by_handle_at: ::c_long = 342;
+pub const SYS_clock_adjtime: ::c_long = 343;
+pub const SYS_syncfs: ::c_long = 344;
+pub const SYS_sendmmsg: ::c_long = 345;
+pub const SYS_setns: ::c_long = 346;
+pub const SYS_process_vm_readv: ::c_long = 347;
+pub const SYS_process_vm_writev: ::c_long = 348;
+pub const SYS_kcmp: ::c_long = 349;
+pub const SYS_finit_module: ::c_long = 350;
+pub const SYS_sched_setattr: ::c_long = 351;
+pub const SYS_sched_getattr: ::c_long = 352;
+pub const SYS_renameat2: ::c_long = 353;
+pub const SYS_seccomp: ::c_long = 354;
+pub const SYS_getrandom: ::c_long = 355;
+pub const SYS_memfd_create: ::c_long = 356;
+pub const SYS_bpf: ::c_long = 357;
+pub const SYS_execveat: ::c_long = 358;
+pub const SYS_socket: ::c_long = 359;
+pub const SYS_socketpair: ::c_long = 360;
+pub const SYS_bind: ::c_long = 361;
+pub const SYS_connect: ::c_long = 362;
+pub const SYS_listen: ::c_long = 363;
+pub const SYS_accept4: ::c_long = 364;
+pub const SYS_getsockopt: ::c_long = 365;
+pub const SYS_setsockopt: ::c_long = 366;
+pub const SYS_getsockname: ::c_long = 367;
+pub const SYS_getpeername: ::c_long = 368;
+pub const SYS_sendto: ::c_long = 369;
+pub const SYS_sendmsg: ::c_long = 370;
+pub const SYS_recvfrom: ::c_long = 371;
+pub const SYS_recvmsg: ::c_long = 372;
+pub const SYS_shutdown: ::c_long = 373;
+pub const SYS_userfaultfd: ::c_long = 374;
+pub const SYS_membarrier: ::c_long = 375;
+pub const SYS_mlock2: ::c_long = 376;
+pub const SYS_copy_file_range: ::c_long = 377;
+pub const SYS_preadv2: ::c_long = 378;
+pub const SYS_pwritev2: ::c_long = 379;
+pub const SYS_pkey_mprotect: ::c_long = 380;
+pub const SYS_pkey_alloc: ::c_long = 381;
+pub const SYS_pkey_free: ::c_long = 382;
+pub const SYS_statx: ::c_long = 383;
+
+// offsets in user_regs_structs, from sys/reg.h
+pub const EBX: ::c_int = 0;
+pub const ECX: ::c_int = 1;
+pub const EDX: ::c_int = 2;
+pub const ESI: ::c_int = 3;
+pub const EDI: ::c_int = 4;
+pub const EBP: ::c_int = 5;
+pub const EAX: ::c_int = 6;
+pub const DS: ::c_int = 7;
+pub const ES: ::c_int = 8;
+pub const FS: ::c_int = 9;
+pub const GS: ::c_int = 10;
+pub const ORIG_EAX: ::c_int = 11;
+pub const EIP: ::c_int = 12;
+pub const CS: ::c_int = 13;
+pub const EFL: ::c_int = 14;
+pub const UESP: ::c_int = 15;
+pub const SS: ::c_int = 16;
+
+extern "C" {
+    pub fn getrandom(
+        buf: *mut ::c_void,
+        buflen: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b64/aarch64/align.rs b/library/libc/src/unix/linux_like/linux/musl/b64/aarch64/align.rs
new file mode 100644
index 00000000..81c55c64
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b64/aarch64/align.rs
@@ -0,0 +1,27 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f32; 8]
+    }
+}
+
+s! {
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_sigmask: ::sigset_t,
+        pub uc_mcontext: mcontext_t,
+    }
+
+    #[repr(align(16))]
+    pub struct mcontext_t {
+        pub fault_address: ::c_ulong,
+        pub regs: [::c_ulong; 31],
+        pub sp: ::c_ulong,
+        pub pc: ::c_ulong,
+        pub pstate: ::c_ulong,
+        __reserved: [[u64; 32]; 16],
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b64/aarch64/mod.rs b/library/libc/src/unix/linux_like/linux/musl/b64/aarch64/mod.rs
new file mode 100644
index 00000000..88c252ea
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b64/aarch64/mod.rs
@@ -0,0 +1,663 @@
+pub type c_char = u8;
+pub type __u64 = ::c_ulonglong;
+pub type wchar_t = u32;
+pub type nlink_t = u32;
+pub type blksize_t = ::c_int;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad0: ::c_ulong,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        __pad1: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_uint; 2],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad0: ::c_ulong,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        __pad1: ::c_int,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_uint; 2],
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong,
+    }
+}
+
+pub const O_APPEND: ::c_int = 1024;
+pub const O_DIRECT: ::c_int = 0x10000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_LARGEFILE: ::c_int = 0x20000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_ASYNC: ::c_int = 0x2000;
+
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const VEOF: usize = 4;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const MINSIGSTKSZ: ::size_t = 6144;
+pub const SIGSTKSZ: ::size_t = 12288;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const SYS_io_setup: ::c_long = 0;
+pub const SYS_io_destroy: ::c_long = 1;
+pub const SYS_io_submit: ::c_long = 2;
+pub const SYS_io_cancel: ::c_long = 3;
+pub const SYS_io_getevents: ::c_long = 4;
+pub const SYS_setxattr: ::c_long = 5;
+pub const SYS_lsetxattr: ::c_long = 6;
+pub const SYS_fsetxattr: ::c_long = 7;
+pub const SYS_getxattr: ::c_long = 8;
+pub const SYS_lgetxattr: ::c_long = 9;
+pub const SYS_fgetxattr: ::c_long = 10;
+pub const SYS_listxattr: ::c_long = 11;
+pub const SYS_llistxattr: ::c_long = 12;
+pub const SYS_flistxattr: ::c_long = 13;
+pub const SYS_removexattr: ::c_long = 14;
+pub const SYS_lremovexattr: ::c_long = 15;
+pub const SYS_fremovexattr: ::c_long = 16;
+pub const SYS_getcwd: ::c_long = 17;
+pub const SYS_lookup_dcookie: ::c_long = 18;
+pub const SYS_eventfd2: ::c_long = 19;
+pub const SYS_epoll_create1: ::c_long = 20;
+pub const SYS_epoll_ctl: ::c_long = 21;
+pub const SYS_epoll_pwait: ::c_long = 22;
+pub const SYS_dup: ::c_long = 23;
+pub const SYS_dup3: ::c_long = 24;
+pub const SYS_fcntl: ::c_long = 25;
+pub const SYS_inotify_init1: ::c_long = 26;
+pub const SYS_inotify_add_watch: ::c_long = 27;
+pub const SYS_inotify_rm_watch: ::c_long = 28;
+pub const SYS_ioctl: ::c_long = 29;
+pub const SYS_ioprio_set: ::c_long = 30;
+pub const SYS_ioprio_get: ::c_long = 31;
+pub const SYS_flock: ::c_long = 32;
+pub const SYS_mknodat: ::c_long = 33;
+pub const SYS_mkdirat: ::c_long = 34;
+pub const SYS_unlinkat: ::c_long = 35;
+pub const SYS_symlinkat: ::c_long = 36;
+pub const SYS_linkat: ::c_long = 37;
+pub const SYS_renameat: ::c_long = 38;
+pub const SYS_umount2: ::c_long = 39;
+pub const SYS_mount: ::c_long = 40;
+pub const SYS_pivot_root: ::c_long = 41;
+pub const SYS_nfsservctl: ::c_long = 42;
+pub const SYS_statfs: ::c_long = 43;
+pub const SYS_fstatfs: ::c_long = 44;
+pub const SYS_truncate: ::c_long = 45;
+pub const SYS_ftruncate: ::c_long = 46;
+pub const SYS_fallocate: ::c_long = 47;
+pub const SYS_faccessat: ::c_long = 48;
+pub const SYS_chdir: ::c_long = 49;
+pub const SYS_fchdir: ::c_long = 50;
+pub const SYS_chroot: ::c_long = 51;
+pub const SYS_fchmod: ::c_long = 52;
+pub const SYS_fchmodat: ::c_long = 53;
+pub const SYS_fchownat: ::c_long = 54;
+pub const SYS_fchown: ::c_long = 55;
+pub const SYS_openat: ::c_long = 56;
+pub const SYS_close: ::c_long = 57;
+pub const SYS_vhangup: ::c_long = 58;
+pub const SYS_pipe2: ::c_long = 59;
+pub const SYS_quotactl: ::c_long = 60;
+pub const SYS_getdents64: ::c_long = 61;
+pub const SYS_lseek: ::c_long = 62;
+pub const SYS_read: ::c_long = 63;
+pub const SYS_write: ::c_long = 64;
+pub const SYS_readv: ::c_long = 65;
+pub const SYS_writev: ::c_long = 66;
+pub const SYS_pread64: ::c_long = 67;
+pub const SYS_pwrite64: ::c_long = 68;
+pub const SYS_preadv: ::c_long = 69;
+pub const SYS_pwritev: ::c_long = 70;
+pub const SYS_pselect6: ::c_long = 72;
+pub const SYS_ppoll: ::c_long = 73;
+pub const SYS_signalfd4: ::c_long = 74;
+pub const SYS_vmsplice: ::c_long = 75;
+pub const SYS_splice: ::c_long = 76;
+pub const SYS_tee: ::c_long = 77;
+pub const SYS_readlinkat: ::c_long = 78;
+pub const SYS_newfstatat: ::c_long = 79;
+pub const SYS_fstat: ::c_long = 80;
+pub const SYS_sync: ::c_long = 81;
+pub const SYS_fsync: ::c_long = 82;
+pub const SYS_fdatasync: ::c_long = 83;
+pub const SYS_sync_file_range: ::c_long = 84;
+pub const SYS_timerfd_create: ::c_long = 85;
+pub const SYS_timerfd_settime: ::c_long = 86;
+pub const SYS_timerfd_gettime: ::c_long = 87;
+pub const SYS_utimensat: ::c_long = 88;
+pub const SYS_acct: ::c_long = 89;
+pub const SYS_capget: ::c_long = 90;
+pub const SYS_capset: ::c_long = 91;
+pub const SYS_personality: ::c_long = 92;
+pub const SYS_exit: ::c_long = 93;
+pub const SYS_exit_group: ::c_long = 94;
+pub const SYS_waitid: ::c_long = 95;
+pub const SYS_set_tid_address: ::c_long = 96;
+pub const SYS_unshare: ::c_long = 97;
+pub const SYS_futex: ::c_long = 98;
+pub const SYS_set_robust_list: ::c_long = 99;
+pub const SYS_get_robust_list: ::c_long = 100;
+pub const SYS_nanosleep: ::c_long = 101;
+pub const SYS_getitimer: ::c_long = 102;
+pub const SYS_setitimer: ::c_long = 103;
+pub const SYS_kexec_load: ::c_long = 104;
+pub const SYS_init_module: ::c_long = 105;
+pub const SYS_delete_module: ::c_long = 106;
+pub const SYS_timer_create: ::c_long = 107;
+pub const SYS_timer_gettime: ::c_long = 108;
+pub const SYS_timer_getoverrun: ::c_long = 109;
+pub const SYS_timer_settime: ::c_long = 110;
+pub const SYS_timer_delete: ::c_long = 111;
+pub const SYS_clock_settime: ::c_long = 112;
+pub const SYS_clock_gettime: ::c_long = 113;
+pub const SYS_clock_getres: ::c_long = 114;
+pub const SYS_clock_nanosleep: ::c_long = 115;
+pub const SYS_syslog: ::c_long = 116;
+pub const SYS_ptrace: ::c_long = 117;
+pub const SYS_sched_setparam: ::c_long = 118;
+pub const SYS_sched_setscheduler: ::c_long = 119;
+pub const SYS_sched_getscheduler: ::c_long = 120;
+pub const SYS_sched_getparam: ::c_long = 121;
+pub const SYS_sched_setaffinity: ::c_long = 122;
+pub const SYS_sched_getaffinity: ::c_long = 123;
+pub const SYS_sched_yield: ::c_long = 124;
+pub const SYS_sched_get_priority_max: ::c_long = 125;
+pub const SYS_sched_get_priority_min: ::c_long = 126;
+pub const SYS_sched_rr_get_interval: ::c_long = 127;
+pub const SYS_restart_syscall: ::c_long = 128;
+pub const SYS_kill: ::c_long = 129;
+pub const SYS_tkill: ::c_long = 130;
+pub const SYS_tgkill: ::c_long = 131;
+pub const SYS_sigaltstack: ::c_long = 132;
+pub const SYS_rt_sigsuspend: ::c_long = 133;
+pub const SYS_rt_sigaction: ::c_long = 134;
+pub const SYS_rt_sigprocmask: ::c_long = 135;
+pub const SYS_rt_sigpending: ::c_long = 136;
+pub const SYS_rt_sigtimedwait: ::c_long = 137;
+pub const SYS_rt_sigqueueinfo: ::c_long = 138;
+pub const SYS_rt_sigreturn: ::c_long = 139;
+pub const SYS_setpriority: ::c_long = 140;
+pub const SYS_getpriority: ::c_long = 141;
+pub const SYS_reboot: ::c_long = 142;
+pub const SYS_setregid: ::c_long = 143;
+pub const SYS_setgid: ::c_long = 144;
+pub const SYS_setreuid: ::c_long = 145;
+pub const SYS_setuid: ::c_long = 146;
+pub const SYS_setresuid: ::c_long = 147;
+pub const SYS_getresuid: ::c_long = 148;
+pub const SYS_setresgid: ::c_long = 149;
+pub const SYS_getresgid: ::c_long = 150;
+pub const SYS_setfsuid: ::c_long = 151;
+pub const SYS_setfsgid: ::c_long = 152;
+pub const SYS_times: ::c_long = 153;
+pub const SYS_setpgid: ::c_long = 154;
+pub const SYS_getpgid: ::c_long = 155;
+pub const SYS_getsid: ::c_long = 156;
+pub const SYS_setsid: ::c_long = 157;
+pub const SYS_getgroups: ::c_long = 158;
+pub const SYS_setgroups: ::c_long = 159;
+pub const SYS_uname: ::c_long = 160;
+pub const SYS_sethostname: ::c_long = 161;
+pub const SYS_setdomainname: ::c_long = 162;
+pub const SYS_getrlimit: ::c_long = 163;
+pub const SYS_setrlimit: ::c_long = 164;
+pub const SYS_getrusage: ::c_long = 165;
+pub const SYS_umask: ::c_long = 166;
+pub const SYS_prctl: ::c_long = 167;
+pub const SYS_getcpu: ::c_long = 168;
+pub const SYS_gettimeofday: ::c_long = 169;
+pub const SYS_settimeofday: ::c_long = 170;
+pub const SYS_adjtimex: ::c_long = 171;
+pub const SYS_getpid: ::c_long = 172;
+pub const SYS_getppid: ::c_long = 173;
+pub const SYS_getuid: ::c_long = 174;
+pub const SYS_geteuid: ::c_long = 175;
+pub const SYS_getgid: ::c_long = 176;
+pub const SYS_getegid: ::c_long = 177;
+pub const SYS_gettid: ::c_long = 178;
+pub const SYS_sysinfo: ::c_long = 179;
+pub const SYS_mq_open: ::c_long = 180;
+pub const SYS_mq_unlink: ::c_long = 181;
+pub const SYS_mq_timedsend: ::c_long = 182;
+pub const SYS_mq_timedreceive: ::c_long = 183;
+pub const SYS_mq_notify: ::c_long = 184;
+pub const SYS_mq_getsetattr: ::c_long = 185;
+pub const SYS_msgget: ::c_long = 186;
+pub const SYS_msgctl: ::c_long = 187;
+pub const SYS_msgrcv: ::c_long = 188;
+pub const SYS_msgsnd: ::c_long = 189;
+pub const SYS_semget: ::c_long = 190;
+pub const SYS_semctl: ::c_long = 191;
+pub const SYS_semtimedop: ::c_long = 192;
+pub const SYS_semop: ::c_long = 193;
+pub const SYS_shmget: ::c_long = 194;
+pub const SYS_shmctl: ::c_long = 195;
+pub const SYS_shmat: ::c_long = 196;
+pub const SYS_shmdt: ::c_long = 197;
+pub const SYS_socket: ::c_long = 198;
+pub const SYS_socketpair: ::c_long = 199;
+pub const SYS_bind: ::c_long = 200;
+pub const SYS_listen: ::c_long = 201;
+pub const SYS_accept: ::c_long = 202;
+pub const SYS_connect: ::c_long = 203;
+pub const SYS_getsockname: ::c_long = 204;
+pub const SYS_getpeername: ::c_long = 205;
+pub const SYS_sendto: ::c_long = 206;
+pub const SYS_recvfrom: ::c_long = 207;
+pub const SYS_setsockopt: ::c_long = 208;
+pub const SYS_getsockopt: ::c_long = 209;
+pub const SYS_shutdown: ::c_long = 210;
+pub const SYS_sendmsg: ::c_long = 211;
+pub const SYS_recvmsg: ::c_long = 212;
+pub const SYS_readahead: ::c_long = 213;
+pub const SYS_brk: ::c_long = 214;
+pub const SYS_munmap: ::c_long = 215;
+pub const SYS_mremap: ::c_long = 216;
+pub const SYS_add_key: ::c_long = 217;
+pub const SYS_request_key: ::c_long = 218;
+pub const SYS_keyctl: ::c_long = 219;
+pub const SYS_clone: ::c_long = 220;
+pub const SYS_execve: ::c_long = 221;
+pub const SYS_mmap: ::c_long = 222;
+pub const SYS_swapon: ::c_long = 224;
+pub const SYS_swapoff: ::c_long = 225;
+pub const SYS_mprotect: ::c_long = 226;
+pub const SYS_msync: ::c_long = 227;
+pub const SYS_mlock: ::c_long = 228;
+pub const SYS_munlock: ::c_long = 229;
+pub const SYS_mlockall: ::c_long = 230;
+pub const SYS_munlockall: ::c_long = 231;
+pub const SYS_mincore: ::c_long = 232;
+pub const SYS_madvise: ::c_long = 233;
+pub const SYS_remap_file_pages: ::c_long = 234;
+pub const SYS_mbind: ::c_long = 235;
+pub const SYS_get_mempolicy: ::c_long = 236;
+pub const SYS_set_mempolicy: ::c_long = 237;
+pub const SYS_migrate_pages: ::c_long = 238;
+pub const SYS_move_pages: ::c_long = 239;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 240;
+pub const SYS_perf_event_open: ::c_long = 241;
+pub const SYS_accept4: ::c_long = 242;
+pub const SYS_recvmmsg: ::c_long = 243;
+pub const SYS_wait4: ::c_long = 260;
+pub const SYS_prlimit64: ::c_long = 261;
+pub const SYS_fanotify_init: ::c_long = 262;
+pub const SYS_fanotify_mark: ::c_long = 263;
+pub const SYS_name_to_handle_at: ::c_long = 264;
+pub const SYS_open_by_handle_at: ::c_long = 265;
+pub const SYS_clock_adjtime: ::c_long = 266;
+pub const SYS_syncfs: ::c_long = 267;
+pub const SYS_setns: ::c_long = 268;
+pub const SYS_sendmmsg: ::c_long = 269;
+pub const SYS_process_vm_readv: ::c_long = 270;
+pub const SYS_process_vm_writev: ::c_long = 271;
+pub const SYS_kcmp: ::c_long = 272;
+pub const SYS_finit_module: ::c_long = 273;
+pub const SYS_sched_setattr: ::c_long = 274;
+pub const SYS_sched_getattr: ::c_long = 275;
+pub const SYS_renameat2: ::c_long = 276;
+pub const SYS_seccomp: ::c_long = 277;
+pub const SYS_getrandom: ::c_long = 278;
+pub const SYS_memfd_create: ::c_long = 279;
+pub const SYS_bpf: ::c_long = 280;
+pub const SYS_execveat: ::c_long = 281;
+pub const SYS_userfaultfd: ::c_long = 282;
+pub const SYS_membarrier: ::c_long = 283;
+pub const SYS_mlock2: ::c_long = 284;
+pub const SYS_copy_file_range: ::c_long = 285;
+pub const SYS_preadv2: ::c_long = 286;
+pub const SYS_pwritev2: ::c_long = 287;
+pub const SYS_pkey_mprotect: ::c_long = 288;
+pub const SYS_pkey_alloc: ::c_long = 289;
+pub const SYS_pkey_free: ::c_long = 290;
+pub const SYS_statx: ::c_long = 291;
+
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+pub const TIOCINQ: ::c_int = ::FIONREAD;
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::c_int = 0x00000800;
+pub const TAB2: ::c_int = 0x00001000;
+pub const TAB3: ::c_int = 0x00001800;
+pub const CR1: ::c_int = 0x00000200;
+pub const CR2: ::c_int = 0x00000400;
+pub const CR3: ::c_int = 0x00000600;
+pub const FF1: ::c_int = 0x00008000;
+pub const BS1: ::c_int = 0x00002000;
+pub const VT1: ::c_int = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const FIOCLEX: ::c_int = 0x5451;
+pub const FIONCLEX: ::c_int = 0x5450;
+pub const FIONBIO: ::c_int = 0x5421;
+pub const EDEADLK: ::c_int = 35;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+pub const TCGETS: ::c_int = 0x5401;
+pub const TCSETS: ::c_int = 0x5402;
+pub const TCSETSW: ::c_int = 0x5403;
+pub const TCSETSF: ::c_int = 0x5404;
+pub const TCGETA: ::c_int = 0x5405;
+pub const TCSETA: ::c_int = 0x5406;
+pub const TCSETAW: ::c_int = 0x5407;
+pub const TCSETAF: ::c_int = 0x5408;
+pub const TCSBRK: ::c_int = 0x5409;
+pub const TCXONC: ::c_int = 0x540A;
+pub const TCFLSH: ::c_int = 0x540B;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x540F;
+pub const TIOCSPGRP: ::c_int = 0x5410;
+pub const TIOCOUTQ: ::c_int = 0x5411;
+pub const TIOCSTI: ::c_int = 0x5412;
+pub const TIOCGWINSZ: ::c_int = 0x5413;
+pub const TIOCSWINSZ: ::c_int = 0x5414;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x541B;
+pub const TIOCCONS: ::c_int = 0x541D;
+
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b64/mips64.rs b/library/libc/src/unix/linux_like/linux/musl/b64/mips64.rs
new file mode 100644
index 00000000..06d09ea1
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b64/mips64.rs
@@ -0,0 +1,757 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type __u64 = ::c_ulong;
+pub type nlink_t = u64;
+pub type blksize_t = i64;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        __pad1: [::c_int; 3],
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad2: [::c_uint; 2],
+        pub st_size: ::off_t,
+        __pad3: ::c_int,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        __pad4: ::c_uint,
+        pub st_blocks: ::blkcnt_t,
+        __pad5: [::c_int; 14],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        __pad1: [::c_int; 3],
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        __pad2: [::c_uint; 2],
+        pub st_size: ::off_t,
+        __pad3: ::c_int,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        __pad4: ::c_uint,
+        pub st_blocks: ::blkcnt_t,
+        __pad5: [::c_int; 14],
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 5],
+    }
+
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 5],
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __pad1: ::c_int,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+}
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+
+pub const SYS_read: ::c_long = 5000 + 0;
+pub const SYS_write: ::c_long = 5000 + 1;
+pub const SYS_open: ::c_long = 5000 + 2;
+pub const SYS_close: ::c_long = 5000 + 3;
+pub const SYS_stat: ::c_long = 5000 + 4;
+pub const SYS_fstat: ::c_long = 5000 + 5;
+pub const SYS_lstat: ::c_long = 5000 + 6;
+pub const SYS_poll: ::c_long = 5000 + 7;
+pub const SYS_lseek: ::c_long = 5000 + 8;
+pub const SYS_mmap: ::c_long = 5000 + 9;
+pub const SYS_mprotect: ::c_long = 5000 + 10;
+pub const SYS_munmap: ::c_long = 5000 + 11;
+pub const SYS_brk: ::c_long = 5000 + 12;
+pub const SYS_rt_sigaction: ::c_long = 5000 + 13;
+pub const SYS_rt_sigprocmask: ::c_long = 5000 + 14;
+pub const SYS_ioctl: ::c_long = 5000 + 15;
+pub const SYS_pread64: ::c_long = 5000 + 16;
+pub const SYS_pwrite64: ::c_long = 5000 + 17;
+pub const SYS_readv: ::c_long = 5000 + 18;
+pub const SYS_writev: ::c_long = 5000 + 19;
+pub const SYS_access: ::c_long = 5000 + 20;
+pub const SYS_pipe: ::c_long = 5000 + 21;
+pub const SYS__newselect: ::c_long = 5000 + 22;
+pub const SYS_sched_yield: ::c_long = 5000 + 23;
+pub const SYS_mremap: ::c_long = 5000 + 24;
+pub const SYS_msync: ::c_long = 5000 + 25;
+pub const SYS_mincore: ::c_long = 5000 + 26;
+pub const SYS_madvise: ::c_long = 5000 + 27;
+pub const SYS_shmget: ::c_long = 5000 + 28;
+pub const SYS_shmat: ::c_long = 5000 + 29;
+pub const SYS_shmctl: ::c_long = 5000 + 30;
+pub const SYS_dup: ::c_long = 5000 + 31;
+pub const SYS_dup2: ::c_long = 5000 + 32;
+pub const SYS_pause: ::c_long = 5000 + 33;
+pub const SYS_nanosleep: ::c_long = 5000 + 34;
+pub const SYS_getitimer: ::c_long = 5000 + 35;
+pub const SYS_setitimer: ::c_long = 5000 + 36;
+pub const SYS_alarm: ::c_long = 5000 + 37;
+pub const SYS_getpid: ::c_long = 5000 + 38;
+pub const SYS_sendfile: ::c_long = 5000 + 39;
+pub const SYS_socket: ::c_long = 5000 + 40;
+pub const SYS_connect: ::c_long = 5000 + 41;
+pub const SYS_accept: ::c_long = 5000 + 42;
+pub const SYS_sendto: ::c_long = 5000 + 43;
+pub const SYS_recvfrom: ::c_long = 5000 + 44;
+pub const SYS_sendmsg: ::c_long = 5000 + 45;
+pub const SYS_recvmsg: ::c_long = 5000 + 46;
+pub const SYS_shutdown: ::c_long = 5000 + 47;
+pub const SYS_bind: ::c_long = 5000 + 48;
+pub const SYS_listen: ::c_long = 5000 + 49;
+pub const SYS_getsockname: ::c_long = 5000 + 50;
+pub const SYS_getpeername: ::c_long = 5000 + 51;
+pub const SYS_socketpair: ::c_long = 5000 + 52;
+pub const SYS_setsockopt: ::c_long = 5000 + 53;
+pub const SYS_getsockopt: ::c_long = 5000 + 54;
+pub const SYS_clone: ::c_long = 5000 + 55;
+pub const SYS_fork: ::c_long = 5000 + 56;
+pub const SYS_execve: ::c_long = 5000 + 57;
+pub const SYS_exit: ::c_long = 5000 + 58;
+pub const SYS_wait4: ::c_long = 5000 + 59;
+pub const SYS_kill: ::c_long = 5000 + 60;
+pub const SYS_uname: ::c_long = 5000 + 61;
+pub const SYS_semget: ::c_long = 5000 + 62;
+pub const SYS_semop: ::c_long = 5000 + 63;
+pub const SYS_semctl: ::c_long = 5000 + 64;
+pub const SYS_shmdt: ::c_long = 5000 + 65;
+pub const SYS_msgget: ::c_long = 5000 + 66;
+pub const SYS_msgsnd: ::c_long = 5000 + 67;
+pub const SYS_msgrcv: ::c_long = 5000 + 68;
+pub const SYS_msgctl: ::c_long = 5000 + 69;
+pub const SYS_fcntl: ::c_long = 5000 + 70;
+pub const SYS_flock: ::c_long = 5000 + 71;
+pub const SYS_fsync: ::c_long = 5000 + 72;
+pub const SYS_fdatasync: ::c_long = 5000 + 73;
+pub const SYS_truncate: ::c_long = 5000 + 74;
+pub const SYS_ftruncate: ::c_long = 5000 + 75;
+pub const SYS_getdents: ::c_long = 5000 + 76;
+pub const SYS_getcwd: ::c_long = 5000 + 77;
+pub const SYS_chdir: ::c_long = 5000 + 78;
+pub const SYS_fchdir: ::c_long = 5000 + 79;
+pub const SYS_rename: ::c_long = 5000 + 80;
+pub const SYS_mkdir: ::c_long = 5000 + 81;
+pub const SYS_rmdir: ::c_long = 5000 + 82;
+pub const SYS_creat: ::c_long = 5000 + 83;
+pub const SYS_link: ::c_long = 5000 + 84;
+pub const SYS_unlink: ::c_long = 5000 + 85;
+pub const SYS_symlink: ::c_long = 5000 + 86;
+pub const SYS_readlink: ::c_long = 5000 + 87;
+pub const SYS_chmod: ::c_long = 5000 + 88;
+pub const SYS_fchmod: ::c_long = 5000 + 89;
+pub const SYS_chown: ::c_long = 5000 + 90;
+pub const SYS_fchown: ::c_long = 5000 + 91;
+pub const SYS_lchown: ::c_long = 5000 + 92;
+pub const SYS_umask: ::c_long = 5000 + 93;
+pub const SYS_gettimeofday: ::c_long = 5000 + 94;
+pub const SYS_getrlimit: ::c_long = 5000 + 95;
+pub const SYS_getrusage: ::c_long = 5000 + 96;
+pub const SYS_sysinfo: ::c_long = 5000 + 97;
+pub const SYS_times: ::c_long = 5000 + 98;
+pub const SYS_ptrace: ::c_long = 5000 + 99;
+pub const SYS_getuid: ::c_long = 5000 + 100;
+pub const SYS_syslog: ::c_long = 5000 + 101;
+pub const SYS_getgid: ::c_long = 5000 + 102;
+pub const SYS_setuid: ::c_long = 5000 + 103;
+pub const SYS_setgid: ::c_long = 5000 + 104;
+pub const SYS_geteuid: ::c_long = 5000 + 105;
+pub const SYS_getegid: ::c_long = 5000 + 106;
+pub const SYS_setpgid: ::c_long = 5000 + 107;
+pub const SYS_getppid: ::c_long = 5000 + 108;
+pub const SYS_getpgrp: ::c_long = 5000 + 109;
+pub const SYS_setsid: ::c_long = 5000 + 110;
+pub const SYS_setreuid: ::c_long = 5000 + 111;
+pub const SYS_setregid: ::c_long = 5000 + 112;
+pub const SYS_getgroups: ::c_long = 5000 + 113;
+pub const SYS_setgroups: ::c_long = 5000 + 114;
+pub const SYS_setresuid: ::c_long = 5000 + 115;
+pub const SYS_getresuid: ::c_long = 5000 + 116;
+pub const SYS_setresgid: ::c_long = 5000 + 117;
+pub const SYS_getresgid: ::c_long = 5000 + 118;
+pub const SYS_getpgid: ::c_long = 5000 + 119;
+pub const SYS_setfsuid: ::c_long = 5000 + 120;
+pub const SYS_setfsgid: ::c_long = 5000 + 121;
+pub const SYS_getsid: ::c_long = 5000 + 122;
+pub const SYS_capget: ::c_long = 5000 + 123;
+pub const SYS_capset: ::c_long = 5000 + 124;
+pub const SYS_rt_sigpending: ::c_long = 5000 + 125;
+pub const SYS_rt_sigtimedwait: ::c_long = 5000 + 126;
+pub const SYS_rt_sigqueueinfo: ::c_long = 5000 + 127;
+pub const SYS_rt_sigsuspend: ::c_long = 5000 + 128;
+pub const SYS_sigaltstack: ::c_long = 5000 + 129;
+pub const SYS_utime: ::c_long = 5000 + 130;
+pub const SYS_mknod: ::c_long = 5000 + 131;
+pub const SYS_personality: ::c_long = 5000 + 132;
+pub const SYS_ustat: ::c_long = 5000 + 133;
+pub const SYS_statfs: ::c_long = 5000 + 134;
+pub const SYS_fstatfs: ::c_long = 5000 + 135;
+pub const SYS_sysfs: ::c_long = 5000 + 136;
+pub const SYS_getpriority: ::c_long = 5000 + 137;
+pub const SYS_setpriority: ::c_long = 5000 + 138;
+pub const SYS_sched_setparam: ::c_long = 5000 + 139;
+pub const SYS_sched_getparam: ::c_long = 5000 + 140;
+pub const SYS_sched_setscheduler: ::c_long = 5000 + 141;
+pub const SYS_sched_getscheduler: ::c_long = 5000 + 142;
+pub const SYS_sched_get_priority_max: ::c_long = 5000 + 143;
+pub const SYS_sched_get_priority_min: ::c_long = 5000 + 144;
+pub const SYS_sched_rr_get_interval: ::c_long = 5000 + 145;
+pub const SYS_mlock: ::c_long = 5000 + 146;
+pub const SYS_munlock: ::c_long = 5000 + 147;
+pub const SYS_mlockall: ::c_long = 5000 + 148;
+pub const SYS_munlockall: ::c_long = 5000 + 149;
+pub const SYS_vhangup: ::c_long = 5000 + 150;
+pub const SYS_pivot_root: ::c_long = 5000 + 151;
+pub const SYS__sysctl: ::c_long = 5000 + 152;
+pub const SYS_prctl: ::c_long = 5000 + 153;
+pub const SYS_adjtimex: ::c_long = 5000 + 154;
+pub const SYS_setrlimit: ::c_long = 5000 + 155;
+pub const SYS_chroot: ::c_long = 5000 + 156;
+pub const SYS_sync: ::c_long = 5000 + 157;
+pub const SYS_acct: ::c_long = 5000 + 158;
+pub const SYS_settimeofday: ::c_long = 5000 + 159;
+pub const SYS_mount: ::c_long = 5000 + 160;
+pub const SYS_umount2: ::c_long = 5000 + 161;
+pub const SYS_swapon: ::c_long = 5000 + 162;
+pub const SYS_swapoff: ::c_long = 5000 + 163;
+pub const SYS_reboot: ::c_long = 5000 + 164;
+pub const SYS_sethostname: ::c_long = 5000 + 165;
+pub const SYS_setdomainname: ::c_long = 5000 + 166;
+pub const SYS_create_module: ::c_long = 5000 + 167;
+pub const SYS_init_module: ::c_long = 5000 + 168;
+pub const SYS_delete_module: ::c_long = 5000 + 169;
+pub const SYS_get_kernel_syms: ::c_long = 5000 + 170;
+pub const SYS_query_module: ::c_long = 5000 + 171;
+pub const SYS_quotactl: ::c_long = 5000 + 172;
+pub const SYS_nfsservctl: ::c_long = 5000 + 173;
+pub const SYS_getpmsg: ::c_long = 5000 + 174;
+pub const SYS_putpmsg: ::c_long = 5000 + 175;
+pub const SYS_afs_syscall: ::c_long = 5000 + 176;
+pub const SYS_gettid: ::c_long = 5000 + 178;
+pub const SYS_readahead: ::c_long = 5000 + 179;
+pub const SYS_setxattr: ::c_long = 5000 + 180;
+pub const SYS_lsetxattr: ::c_long = 5000 + 181;
+pub const SYS_fsetxattr: ::c_long = 5000 + 182;
+pub const SYS_getxattr: ::c_long = 5000 + 183;
+pub const SYS_lgetxattr: ::c_long = 5000 + 184;
+pub const SYS_fgetxattr: ::c_long = 5000 + 185;
+pub const SYS_listxattr: ::c_long = 5000 + 186;
+pub const SYS_llistxattr: ::c_long = 5000 + 187;
+pub const SYS_flistxattr: ::c_long = 5000 + 188;
+pub const SYS_removexattr: ::c_long = 5000 + 189;
+pub const SYS_lremovexattr: ::c_long = 5000 + 190;
+pub const SYS_fremovexattr: ::c_long = 5000 + 191;
+pub const SYS_tkill: ::c_long = 5000 + 192;
+pub const SYS_futex: ::c_long = 5000 + 194;
+pub const SYS_sched_setaffinity: ::c_long = 5000 + 195;
+pub const SYS_sched_getaffinity: ::c_long = 5000 + 196;
+pub const SYS_cacheflush: ::c_long = 5000 + 197;
+pub const SYS_cachectl: ::c_long = 5000 + 198;
+pub const SYS_sysmips: ::c_long = 5000 + 199;
+pub const SYS_io_setup: ::c_long = 5000 + 200;
+pub const SYS_io_destroy: ::c_long = 5000 + 201;
+pub const SYS_io_getevents: ::c_long = 5000 + 202;
+pub const SYS_io_submit: ::c_long = 5000 + 203;
+pub const SYS_io_cancel: ::c_long = 5000 + 204;
+pub const SYS_exit_group: ::c_long = 5000 + 205;
+pub const SYS_lookup_dcookie: ::c_long = 5000 + 206;
+pub const SYS_epoll_create: ::c_long = 5000 + 207;
+pub const SYS_epoll_ctl: ::c_long = 5000 + 208;
+pub const SYS_epoll_wait: ::c_long = 5000 + 209;
+pub const SYS_remap_file_pages: ::c_long = 5000 + 210;
+pub const SYS_rt_sigreturn: ::c_long = 5000 + 211;
+pub const SYS_set_tid_address: ::c_long = 5000 + 212;
+pub const SYS_restart_syscall: ::c_long = 5000 + 213;
+pub const SYS_semtimedop: ::c_long = 5000 + 214;
+pub const SYS_fadvise64: ::c_long = 5000 + 215;
+pub const SYS_timer_create: ::c_long = 5000 + 216;
+pub const SYS_timer_settime: ::c_long = 5000 + 217;
+pub const SYS_timer_gettime: ::c_long = 5000 + 218;
+pub const SYS_timer_getoverrun: ::c_long = 5000 + 219;
+pub const SYS_timer_delete: ::c_long = 5000 + 220;
+pub const SYS_clock_settime: ::c_long = 5000 + 221;
+pub const SYS_clock_gettime: ::c_long = 5000 + 222;
+pub const SYS_clock_getres: ::c_long = 5000 + 223;
+pub const SYS_clock_nanosleep: ::c_long = 5000 + 224;
+pub const SYS_tgkill: ::c_long = 5000 + 225;
+pub const SYS_utimes: ::c_long = 5000 + 226;
+pub const SYS_mbind: ::c_long = 5000 + 227;
+pub const SYS_get_mempolicy: ::c_long = 5000 + 228;
+pub const SYS_set_mempolicy: ::c_long = 5000 + 229;
+pub const SYS_mq_open: ::c_long = 5000 + 230;
+pub const SYS_mq_unlink: ::c_long = 5000 + 231;
+pub const SYS_mq_timedsend: ::c_long = 5000 + 232;
+pub const SYS_mq_timedreceive: ::c_long = 5000 + 233;
+pub const SYS_mq_notify: ::c_long = 5000 + 234;
+pub const SYS_mq_getsetattr: ::c_long = 5000 + 235;
+pub const SYS_vserver: ::c_long = 5000 + 236;
+pub const SYS_waitid: ::c_long = 5000 + 237;
+/* pub const SYS_sys_setaltroot: ::c_long = 5000 + 238; */
+pub const SYS_add_key: ::c_long = 5000 + 239;
+pub const SYS_request_key: ::c_long = 5000 + 240;
+pub const SYS_keyctl: ::c_long = 5000 + 241;
+pub const SYS_set_thread_area: ::c_long = 5000 + 242;
+pub const SYS_inotify_init: ::c_long = 5000 + 243;
+pub const SYS_inotify_add_watch: ::c_long = 5000 + 244;
+pub const SYS_inotify_rm_watch: ::c_long = 5000 + 245;
+pub const SYS_migrate_pages: ::c_long = 5000 + 246;
+pub const SYS_openat: ::c_long = 5000 + 247;
+pub const SYS_mkdirat: ::c_long = 5000 + 248;
+pub const SYS_mknodat: ::c_long = 5000 + 249;
+pub const SYS_fchownat: ::c_long = 5000 + 250;
+pub const SYS_futimesat: ::c_long = 5000 + 251;
+pub const SYS_newfstatat: ::c_long = 5000 + 252;
+pub const SYS_unlinkat: ::c_long = 5000 + 253;
+pub const SYS_renameat: ::c_long = 5000 + 254;
+pub const SYS_linkat: ::c_long = 5000 + 255;
+pub const SYS_symlinkat: ::c_long = 5000 + 256;
+pub const SYS_readlinkat: ::c_long = 5000 + 257;
+pub const SYS_fchmodat: ::c_long = 5000 + 258;
+pub const SYS_faccessat: ::c_long = 5000 + 259;
+pub const SYS_pselect6: ::c_long = 5000 + 260;
+pub const SYS_ppoll: ::c_long = 5000 + 261;
+pub const SYS_unshare: ::c_long = 5000 + 262;
+pub const SYS_splice: ::c_long = 5000 + 263;
+pub const SYS_sync_file_range: ::c_long = 5000 + 264;
+pub const SYS_tee: ::c_long = 5000 + 265;
+pub const SYS_vmsplice: ::c_long = 5000 + 266;
+pub const SYS_move_pages: ::c_long = 5000 + 267;
+pub const SYS_set_robust_list: ::c_long = 5000 + 268;
+pub const SYS_get_robust_list: ::c_long = 5000 + 269;
+pub const SYS_kexec_load: ::c_long = 5000 + 270;
+pub const SYS_getcpu: ::c_long = 5000 + 271;
+pub const SYS_epoll_pwait: ::c_long = 5000 + 272;
+pub const SYS_ioprio_set: ::c_long = 5000 + 273;
+pub const SYS_ioprio_get: ::c_long = 5000 + 274;
+pub const SYS_utimensat: ::c_long = 5000 + 275;
+pub const SYS_signalfd: ::c_long = 5000 + 276;
+pub const SYS_timerfd: ::c_long = 5000 + 277;
+pub const SYS_eventfd: ::c_long = 5000 + 278;
+pub const SYS_fallocate: ::c_long = 5000 + 279;
+pub const SYS_timerfd_create: ::c_long = 5000 + 280;
+pub const SYS_timerfd_gettime: ::c_long = 5000 + 281;
+pub const SYS_timerfd_settime: ::c_long = 5000 + 282;
+pub const SYS_signalfd4: ::c_long = 5000 + 283;
+pub const SYS_eventfd2: ::c_long = 5000 + 284;
+pub const SYS_epoll_create1: ::c_long = 5000 + 285;
+pub const SYS_dup3: ::c_long = 5000 + 286;
+pub const SYS_pipe2: ::c_long = 5000 + 287;
+pub const SYS_inotify_init1: ::c_long = 5000 + 288;
+pub const SYS_preadv: ::c_long = 5000 + 289;
+pub const SYS_pwritev: ::c_long = 5000 + 290;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 5000 + 291;
+pub const SYS_perf_event_open: ::c_long = 5000 + 292;
+pub const SYS_accept4: ::c_long = 5000 + 293;
+pub const SYS_recvmmsg: ::c_long = 5000 + 294;
+pub const SYS_fanotify_init: ::c_long = 5000 + 295;
+pub const SYS_fanotify_mark: ::c_long = 5000 + 296;
+pub const SYS_prlimit64: ::c_long = 5000 + 297;
+pub const SYS_name_to_handle_at: ::c_long = 5000 + 298;
+pub const SYS_open_by_handle_at: ::c_long = 5000 + 299;
+pub const SYS_clock_adjtime: ::c_long = 5000 + 300;
+pub const SYS_syncfs: ::c_long = 5000 + 301;
+pub const SYS_sendmmsg: ::c_long = 5000 + 302;
+pub const SYS_setns: ::c_long = 5000 + 303;
+pub const SYS_process_vm_readv: ::c_long = 5000 + 304;
+pub const SYS_process_vm_writev: ::c_long = 5000 + 305;
+pub const SYS_kcmp: ::c_long = 5000 + 306;
+pub const SYS_finit_module: ::c_long = 5000 + 307;
+pub const SYS_getdents64: ::c_long = 5000 + 308;
+pub const SYS_sched_setattr: ::c_long = 5000 + 309;
+pub const SYS_sched_getattr: ::c_long = 5000 + 310;
+pub const SYS_renameat2: ::c_long = 5000 + 311;
+pub const SYS_seccomp: ::c_long = 5000 + 312;
+pub const SYS_getrandom: ::c_long = 5000 + 313;
+pub const SYS_memfd_create: ::c_long = 5000 + 314;
+pub const SYS_bpf: ::c_long = 5000 + 315;
+pub const SYS_execveat: ::c_long = 5000 + 316;
+pub const SYS_userfaultfd: ::c_long = 5000 + 317;
+pub const SYS_membarrier: ::c_long = 5000 + 318;
+pub const SYS_mlock2: ::c_long = 5000 + 319;
+pub const SYS_copy_file_range: ::c_long = 5000 + 320;
+pub const SYS_preadv2: ::c_long = 5000 + 321;
+pub const SYS_pwritev2: ::c_long = 5000 + 322;
+pub const SYS_pkey_mprotect: ::c_long = 5000 + 323;
+pub const SYS_pkey_alloc: ::c_long = 5000 + 324;
+pub const SYS_pkey_free: ::c_long = 5000 + 325;
+pub const SYS_statx: ::c_long = 5000 + 326;
+
+pub const O_DIRECT: ::c_int = 0x8000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+
+pub const O_APPEND: ::c_int = 8;
+pub const O_CREAT: ::c_int = 256;
+pub const O_EXCL: ::c_int = 1024;
+pub const O_NOCTTY: ::c_int = 2048;
+pub const O_NONBLOCK: ::c_int = 128;
+pub const O_SYNC: ::c_int = 0x4010;
+pub const O_RSYNC: ::c_int = 0x4010;
+pub const O_DSYNC: ::c_int = 0x10;
+pub const O_ASYNC: ::c_int = 0x1000;
+
+pub const EDEADLK: ::c_int = 45;
+pub const ENAMETOOLONG: ::c_int = 78;
+pub const ENOLCK: ::c_int = 46;
+pub const ENOSYS: ::c_int = 89;
+pub const ENOTEMPTY: ::c_int = 93;
+pub const ELOOP: ::c_int = 90;
+pub const ENOMSG: ::c_int = 35;
+pub const EIDRM: ::c_int = 36;
+pub const ECHRNG: ::c_int = 37;
+pub const EL2NSYNC: ::c_int = 38;
+pub const EL3HLT: ::c_int = 39;
+pub const EL3RST: ::c_int = 40;
+pub const ELNRNG: ::c_int = 41;
+pub const EUNATCH: ::c_int = 42;
+pub const ENOCSI: ::c_int = 43;
+pub const EL2HLT: ::c_int = 44;
+pub const EBADE: ::c_int = 50;
+pub const EBADR: ::c_int = 51;
+pub const EXFULL: ::c_int = 52;
+pub const ENOANO: ::c_int = 53;
+pub const EBADRQC: ::c_int = 54;
+pub const EBADSLT: ::c_int = 55;
+pub const EDEADLOCK: ::c_int = 56;
+pub const EMULTIHOP: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 79;
+pub const ENOTUNIQ: ::c_int = 80;
+pub const EBADFD: ::c_int = 81;
+pub const EBADMSG: ::c_int = 77;
+pub const EREMCHG: ::c_int = 82;
+pub const ELIBACC: ::c_int = 83;
+pub const ELIBBAD: ::c_int = 84;
+pub const ELIBSCN: ::c_int = 85;
+pub const ELIBMAX: ::c_int = 86;
+pub const ELIBEXEC: ::c_int = 87;
+pub const EILSEQ: ::c_int = 88;
+pub const ERESTART: ::c_int = 91;
+pub const ESTRPIPE: ::c_int = 92;
+pub const EUSERS: ::c_int = 94;
+pub const ENOTSOCK: ::c_int = 95;
+pub const EDESTADDRREQ: ::c_int = 96;
+pub const EMSGSIZE: ::c_int = 97;
+pub const EPROTOTYPE: ::c_int = 98;
+pub const ENOPROTOOPT: ::c_int = 99;
+pub const EPROTONOSUPPORT: ::c_int = 120;
+pub const ESOCKTNOSUPPORT: ::c_int = 121;
+pub const EOPNOTSUPP: ::c_int = 122;
+pub const EPFNOSUPPORT: ::c_int = 123;
+pub const EAFNOSUPPORT: ::c_int = 124;
+pub const EADDRINUSE: ::c_int = 125;
+pub const EADDRNOTAVAIL: ::c_int = 126;
+pub const ENETDOWN: ::c_int = 127;
+pub const ENETUNREACH: ::c_int = 128;
+pub const ENETRESET: ::c_int = 129;
+pub const ECONNABORTED: ::c_int = 130;
+pub const ECONNRESET: ::c_int = 131;
+pub const ENOBUFS: ::c_int = 132;
+pub const EISCONN: ::c_int = 133;
+pub const ENOTCONN: ::c_int = 134;
+pub const ESHUTDOWN: ::c_int = 143;
+pub const ETOOMANYREFS: ::c_int = 144;
+pub const ETIMEDOUT: ::c_int = 145;
+pub const ECONNREFUSED: ::c_int = 146;
+pub const EHOSTDOWN: ::c_int = 147;
+pub const EHOSTUNREACH: ::c_int = 148;
+pub const EALREADY: ::c_int = 149;
+pub const EINPROGRESS: ::c_int = 150;
+pub const ESTALE: ::c_int = 151;
+pub const EUCLEAN: ::c_int = 135;
+pub const ENOTNAM: ::c_int = 137;
+pub const ENAVAIL: ::c_int = 138;
+pub const EISNAM: ::c_int = 139;
+pub const EREMOTEIO: ::c_int = 140;
+pub const EDQUOT: ::c_int = 1133;
+pub const ENOMEDIUM: ::c_int = 159;
+pub const EMEDIUMTYPE: ::c_int = 160;
+pub const ECANCELED: ::c_int = 158;
+pub const ENOKEY: ::c_int = 161;
+pub const EKEYEXPIRED: ::c_int = 162;
+pub const EKEYREVOKED: ::c_int = 163;
+pub const EKEYREJECTED: ::c_int = 164;
+pub const EOWNERDEAD: ::c_int = 165;
+pub const ENOTRECOVERABLE: ::c_int = 166;
+pub const ERFKILL: ::c_int = 167;
+
+pub const MAP_ANON: ::c_int = 0x800;
+pub const MAP_GROWSDOWN: ::c_int = 0x1000;
+pub const MAP_DENYWRITE: ::c_int = 0x2000;
+pub const MAP_EXECUTABLE: ::c_int = 0x4000;
+pub const MAP_LOCKED: ::c_int = 0x8000;
+pub const MAP_NORESERVE: ::c_int = 0x400;
+pub const MAP_POPULATE: ::c_int = 0x10000;
+pub const MAP_NONBLOCK: ::c_int = 0x20000;
+pub const MAP_STACK: ::c_int = 0x40000;
+pub const MAP_HUGETLB: ::c_int = 0x080000;
+
+pub const SOCK_STREAM: ::c_int = 2;
+pub const SOCK_DGRAM: ::c_int = 1;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ACCEPTCONN: ::c_int = 0x1009;
+pub const SO_PROTOCOL: ::c_int = 0x1028;
+pub const SO_DOMAIN: ::c_int = 0x1029;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_PASSCRED: ::c_int = 17;
+pub const SO_PEERCRED: ::c_int = 18;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_PEERSEC: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 31;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = SO_DETACH_FILTER;
+
+pub const FIOCLEX: ::c_int = 0x6601;
+pub const FIONCLEX: ::c_int = 0x6602;
+pub const FIONBIO: ::c_int = 0x667e;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000008;
+pub const SA_NOCLDWAIT: ::c_int = 0x00010000;
+
+pub const SIGCHLD: ::c_int = 18;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGTTIN: ::c_int = 26;
+pub const SIGTTOU: ::c_int = 27;
+pub const SIGXCPU: ::c_int = 30;
+pub const SIGXFSZ: ::c_int = 31;
+pub const SIGVTALRM: ::c_int = 28;
+pub const SIGPROF: ::c_int = 29;
+pub const SIGWINCH: ::c_int = 20;
+pub const SIGUSR1: ::c_int = 16;
+pub const SIGUSR2: ::c_int = 17;
+pub const SIGCONT: ::c_int = 25;
+pub const SIGSTOP: ::c_int = 23;
+pub const SIGTSTP: ::c_int = 24;
+pub const SIGURG: ::c_int = 21;
+pub const SIGIO: ::c_int = 22;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGPOLL: ::c_int = 22;
+pub const SIGPWR: ::c_int = 19;
+pub const SIG_SETMASK: ::c_int = 3;
+pub const SIG_BLOCK: ::c_int = 0x1;
+pub const SIG_UNBLOCK: ::c_int = 0x2;
+
+pub const POLLWRNORM: ::c_short = 0x004;
+pub const POLLWRBAND: ::c_short = 0x100;
+
+pub const VEOF: usize = 16;
+pub const VEOL: usize = 17;
+pub const VEOL2: usize = 6;
+pub const VMIN: usize = 4;
+pub const IEXTEN: ::tcflag_t = 0x00000100;
+pub const TOSTOP: ::tcflag_t = 0x00008000;
+pub const FLUSHO: ::tcflag_t = 0x00002000;
+pub const EXTPROC: ::tcflag_t = 0o200000;
+
+pub const F_GETLK: ::c_int = 14;
+pub const F_GETOWN: ::c_int = 23;
+pub const F_SETOWN: ::c_int = 24;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const TCGETS: ::c_ulong = 0x540d;
+pub const TCSETS: ::c_ulong = 0x540e;
+pub const TCSETSW: ::c_ulong = 0x540f;
+pub const TCSETSF: ::c_ulong = 0x5410;
+pub const TCGETA: ::c_ulong = 0x5401;
+pub const TCSETA: ::c_ulong = 0x5402;
+pub const TCSETAW: ::c_ulong = 0x5403;
+pub const TCSETAF: ::c_ulong = 0x5404;
+pub const TCSBRK: ::c_ulong = 0x5405;
+pub const TCXONC: ::c_ulong = 0x5406;
+pub const TCFLSH: ::c_ulong = 0x5407;
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5481;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x5482;
+pub const TIOCINQ: ::c_ulong = 0x467f;
+pub const TIOCLINUX: ::c_ulong = 0x5483;
+pub const TIOCGSERIAL: ::c_ulong = 0x5484;
+pub const TIOCEXCL: ::c_ulong = 0x740d;
+pub const TIOCNXCL: ::c_ulong = 0x740e;
+pub const TIOCSCTTY: ::c_ulong = 0x5480;
+pub const TIOCGPGRP: ::c_ulong = 0x40047477;
+pub const TIOCSPGRP: ::c_ulong = 0x80047476;
+pub const TIOCOUTQ: ::c_ulong = 0x7472;
+pub const TIOCSTI: ::c_ulong = 0x5472;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const TIOCMGET: ::c_ulong = 0x741d;
+pub const TIOCMBIS: ::c_ulong = 0x741b;
+pub const TIOCMBIC: ::c_ulong = 0x741c;
+pub const TIOCMSET: ::c_ulong = 0x741a;
+pub const FIONREAD: ::c_ulong = 0x467f;
+pub const TIOCCONS: ::c_ulong = 0x80047478;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+
+pub const BOTHER: ::speed_t = 0o010000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const TIOCM_ST: ::c_int = 0x010;
+pub const TIOCM_SR: ::c_int = 0x020;
+pub const TIOCM_CTS: ::c_int = 0x040;
+pub const TIOCM_CAR: ::c_int = 0x100;
+pub const TIOCM_RNG: ::c_int = 0x200;
+pub const TIOCM_DSR: ::c_int = 0x400;
+
+pub const EHWPOISON: ::c_int = 168;
+
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b64/mod.rs b/library/libc/src/unix/linux_like/linux/musl/b64/mod.rs
new file mode 100644
index 00000000..5403d727
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b64/mod.rs
@@ -0,0 +1,170 @@
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type regoff_t = ::c_long;
+
+s! {
+    pub struct statfs64 {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: u64,
+        pub f_bfree: u64,
+        pub f_bavail: u64,
+        pub f_files: u64,
+        pub f_ffree: u64,
+        pub f_favail: u64,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct pthread_attr_t {
+        __size: [u64; 7]
+    }
+
+    pub struct sigset_t {
+        __val: [::c_ulong; 16],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        pub msg_rtime: ::time_t,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __pad1: ::c_ulong,
+        __pad2: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub f_spare: [::c_ulong; 4],
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        #[cfg(target_endian = "big")]
+        __pad1: ::c_int,
+        pub msg_iovlen: ::c_int,
+        #[cfg(target_endian = "little")]
+        __pad1: ::c_int,
+        pub msg_control: *mut ::c_void,
+        #[cfg(target_endian = "big")]
+        __pad2: ::c_int,
+        pub msg_controllen: ::socklen_t,
+        #[cfg(target_endian = "little")]
+        __pad2: ::c_int,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        #[cfg(target_endian = "big")]
+        pub __pad1: ::c_int,
+        pub cmsg_len: ::socklen_t,
+        #[cfg(target_endian = "little")]
+        pub __pad1: ::c_int,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct sem_t {
+        __val: [::c_int; 8],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+        _align: [usize; 0],
+    }
+}
+
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+
+pub const SOCK_NONBLOCK: ::c_int = 2048;
+
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+extern "C" {
+    pub fn getrandom(
+        buf: *mut ::c_void,
+        buflen: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(target_arch = "mips64")] {
+        mod mips64;
+        pub use self::mips64::*;
+    } else if #[cfg(any(target_arch = "powerpc64"))] {
+        mod powerpc64;
+        pub use self::powerpc64::*;
+    } else if #[cfg(any(target_arch = "x86_64", target_arch = "llir_x86_64"))] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b64/powerpc64.rs b/library/libc/src/unix/linux_like/linux/musl/b64/powerpc64.rs
new file mode 100644
index 00000000..2533ffd6
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b64/powerpc64.rs
@@ -0,0 +1,743 @@
+pub type c_char = u8;
+pub type wchar_t = i32;
+pub type __u64 = ::c_ulong;
+pub type nlink_t = u64;
+pub type blksize_t = ::c_long;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 3],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __reserved: [::c_long; 3],
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __unused1: ::c_long,
+        __unused2: ::c_long
+    }
+}
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_32BIT: ::c_int = 0x0040;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_DIRECT: ::c_int = 0x20000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_LARGEFILE: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_ASYNC: ::c_int = 0x2000;
+
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const VEOF: usize = 4;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const SIGSTKSZ: ::size_t = 10240;
+pub const MINSIGSTKSZ: ::size_t = 4096;
+
+// Syscall table
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_waitpid: ::c_long = 7;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_time: ::c_long = 13;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_break: ::c_long = 17;
+pub const SYS_oldstat: ::c_long = 18;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_umount: ::c_long = 22;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_stime: ::c_long = 25;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_alarm: ::c_long = 27;
+pub const SYS_oldfstat: ::c_long = 28;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_utime: ::c_long = 30;
+pub const SYS_stty: ::c_long = 31;
+pub const SYS_gtty: ::c_long = 32;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_ftime: ::c_long = 35;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_prof: ::c_long = 44;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_signal: ::c_long = 48;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_lock: ::c_long = 53;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_mpx: ::c_long = 56;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_ulimit: ::c_long = 58;
+pub const SYS_oldolduname: ::c_long = 59;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_sgetmask: ::c_long = 68;
+pub const SYS_ssetmask: ::c_long = 69;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrlimit: ::c_long = 76;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_select: ::c_long = 82;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_oldlstat: ::c_long = 84;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_readdir: ::c_long = 89;
+pub const SYS_mmap: ::c_long = 90;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_profil: ::c_long = 98;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_ioperm: ::c_long = 101;
+pub const SYS_socketcall: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_olduname: ::c_long = 109;
+pub const SYS_iopl: ::c_long = 110;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_idle: ::c_long = 112;
+pub const SYS_vm86: ::c_long = 113;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_ipc: ::c_long = 117;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_modify_ldt: ::c_long = 123;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_create_module: ::c_long = 127;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_get_kernel_syms: ::c_long = 130;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_afs_syscall: ::c_long = 137; /* Syscall for Andrew File System */
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_query_module: ::c_long = 166;
+pub const SYS_poll: ::c_long = 167;
+pub const SYS_nfsservctl: ::c_long = 168;
+pub const SYS_setresgid: ::c_long = 169;
+pub const SYS_getresgid: ::c_long = 170;
+pub const SYS_prctl: ::c_long = 171;
+pub const SYS_rt_sigreturn: ::c_long = 172;
+pub const SYS_rt_sigaction: ::c_long = 173;
+pub const SYS_rt_sigprocmask: ::c_long = 174;
+pub const SYS_rt_sigpending: ::c_long = 175;
+pub const SYS_rt_sigtimedwait: ::c_long = 176;
+pub const SYS_rt_sigqueueinfo: ::c_long = 177;
+pub const SYS_rt_sigsuspend: ::c_long = 178;
+pub const SYS_pread64: ::c_long = 179;
+pub const SYS_pwrite64: ::c_long = 180;
+pub const SYS_chown: ::c_long = 181;
+pub const SYS_getcwd: ::c_long = 182;
+pub const SYS_capget: ::c_long = 183;
+pub const SYS_capset: ::c_long = 184;
+pub const SYS_sigaltstack: ::c_long = 185;
+pub const SYS_sendfile: ::c_long = 186;
+pub const SYS_getpmsg: ::c_long = 187; /* some people actually want streams */
+pub const SYS_putpmsg: ::c_long = 188; /* some people actually want streams */
+pub const SYS_vfork: ::c_long = 189;
+pub const SYS_ugetrlimit: ::c_long = 190; /* SuS compliant getrlimit */
+pub const SYS_readahead: ::c_long = 191;
+pub const SYS_pciconfig_read: ::c_long = 198;
+pub const SYS_pciconfig_write: ::c_long = 199;
+pub const SYS_pciconfig_iobase: ::c_long = 200;
+pub const SYS_multiplexer: ::c_long = 201;
+pub const SYS_getdents64: ::c_long = 202;
+pub const SYS_pivot_root: ::c_long = 203;
+pub const SYS_madvise: ::c_long = 205;
+pub const SYS_mincore: ::c_long = 206;
+pub const SYS_gettid: ::c_long = 207;
+pub const SYS_tkill: ::c_long = 208;
+pub const SYS_setxattr: ::c_long = 209;
+pub const SYS_lsetxattr: ::c_long = 210;
+pub const SYS_fsetxattr: ::c_long = 211;
+pub const SYS_getxattr: ::c_long = 212;
+pub const SYS_lgetxattr: ::c_long = 213;
+pub const SYS_fgetxattr: ::c_long = 214;
+pub const SYS_listxattr: ::c_long = 215;
+pub const SYS_llistxattr: ::c_long = 216;
+pub const SYS_flistxattr: ::c_long = 217;
+pub const SYS_removexattr: ::c_long = 218;
+pub const SYS_lremovexattr: ::c_long = 219;
+pub const SYS_fremovexattr: ::c_long = 220;
+pub const SYS_futex: ::c_long = 221;
+pub const SYS_sched_setaffinity: ::c_long = 222;
+pub const SYS_sched_getaffinity: ::c_long = 223;
+pub const SYS_tuxcall: ::c_long = 225;
+pub const SYS_io_setup: ::c_long = 227;
+pub const SYS_io_destroy: ::c_long = 228;
+pub const SYS_io_getevents: ::c_long = 229;
+pub const SYS_io_submit: ::c_long = 230;
+pub const SYS_io_cancel: ::c_long = 231;
+pub const SYS_set_tid_address: ::c_long = 232;
+pub const SYS_exit_group: ::c_long = 234;
+pub const SYS_lookup_dcookie: ::c_long = 235;
+pub const SYS_epoll_create: ::c_long = 236;
+pub const SYS_epoll_ctl: ::c_long = 237;
+pub const SYS_epoll_wait: ::c_long = 238;
+pub const SYS_remap_file_pages: ::c_long = 239;
+pub const SYS_timer_create: ::c_long = 240;
+pub const SYS_timer_settime: ::c_long = 241;
+pub const SYS_timer_gettime: ::c_long = 242;
+pub const SYS_timer_getoverrun: ::c_long = 243;
+pub const SYS_timer_delete: ::c_long = 244;
+pub const SYS_clock_settime: ::c_long = 245;
+pub const SYS_clock_gettime: ::c_long = 246;
+pub const SYS_clock_getres: ::c_long = 247;
+pub const SYS_clock_nanosleep: ::c_long = 248;
+pub const SYS_swapcontext: ::c_long = 249;
+pub const SYS_tgkill: ::c_long = 250;
+pub const SYS_utimes: ::c_long = 251;
+pub const SYS_statfs64: ::c_long = 252;
+pub const SYS_fstatfs64: ::c_long = 253;
+pub const SYS_rtas: ::c_long = 255;
+pub const SYS_sys_debug_setcontext: ::c_long = 256;
+pub const SYS_migrate_pages: ::c_long = 258;
+pub const SYS_mbind: ::c_long = 259;
+pub const SYS_get_mempolicy: ::c_long = 260;
+pub const SYS_set_mempolicy: ::c_long = 261;
+pub const SYS_mq_open: ::c_long = 262;
+pub const SYS_mq_unlink: ::c_long = 263;
+pub const SYS_mq_timedsend: ::c_long = 264;
+pub const SYS_mq_timedreceive: ::c_long = 265;
+pub const SYS_mq_notify: ::c_long = 266;
+pub const SYS_mq_getsetattr: ::c_long = 267;
+pub const SYS_kexec_load: ::c_long = 268;
+pub const SYS_add_key: ::c_long = 269;
+pub const SYS_request_key: ::c_long = 270;
+pub const SYS_keyctl: ::c_long = 271;
+pub const SYS_waitid: ::c_long = 272;
+pub const SYS_ioprio_set: ::c_long = 273;
+pub const SYS_ioprio_get: ::c_long = 274;
+pub const SYS_inotify_init: ::c_long = 275;
+pub const SYS_inotify_add_watch: ::c_long = 276;
+pub const SYS_inotify_rm_watch: ::c_long = 277;
+pub const SYS_spu_run: ::c_long = 278;
+pub const SYS_spu_create: ::c_long = 279;
+pub const SYS_pselect6: ::c_long = 280;
+pub const SYS_ppoll: ::c_long = 281;
+pub const SYS_unshare: ::c_long = 282;
+pub const SYS_splice: ::c_long = 283;
+pub const SYS_tee: ::c_long = 284;
+pub const SYS_vmsplice: ::c_long = 285;
+pub const SYS_openat: ::c_long = 286;
+pub const SYS_mkdirat: ::c_long = 287;
+pub const SYS_mknodat: ::c_long = 288;
+pub const SYS_fchownat: ::c_long = 289;
+pub const SYS_futimesat: ::c_long = 290;
+pub const SYS_newfstatat: ::c_long = 291;
+pub const SYS_unlinkat: ::c_long = 292;
+pub const SYS_renameat: ::c_long = 293;
+pub const SYS_linkat: ::c_long = 294;
+pub const SYS_symlinkat: ::c_long = 295;
+pub const SYS_readlinkat: ::c_long = 296;
+pub const SYS_fchmodat: ::c_long = 297;
+pub const SYS_faccessat: ::c_long = 298;
+pub const SYS_get_robust_list: ::c_long = 299;
+pub const SYS_set_robust_list: ::c_long = 300;
+pub const SYS_move_pages: ::c_long = 301;
+pub const SYS_getcpu: ::c_long = 302;
+pub const SYS_epoll_pwait: ::c_long = 303;
+pub const SYS_utimensat: ::c_long = 304;
+pub const SYS_signalfd: ::c_long = 305;
+pub const SYS_timerfd_create: ::c_long = 306;
+pub const SYS_eventfd: ::c_long = 307;
+pub const SYS_sync_file_range2: ::c_long = 308;
+pub const SYS_fallocate: ::c_long = 309;
+pub const SYS_subpage_prot: ::c_long = 310;
+pub const SYS_timerfd_settime: ::c_long = 311;
+pub const SYS_timerfd_gettime: ::c_long = 312;
+pub const SYS_signalfd4: ::c_long = 313;
+pub const SYS_eventfd2: ::c_long = 314;
+pub const SYS_epoll_create1: ::c_long = 315;
+pub const SYS_dup3: ::c_long = 316;
+pub const SYS_pipe2: ::c_long = 317;
+pub const SYS_inotify_init1: ::c_long = 318;
+pub const SYS_perf_event_open: ::c_long = 319;
+pub const SYS_preadv: ::c_long = 320;
+pub const SYS_pwritev: ::c_long = 321;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 322;
+pub const SYS_fanotify_init: ::c_long = 323;
+pub const SYS_fanotify_mark: ::c_long = 324;
+pub const SYS_prlimit64: ::c_long = 325;
+pub const SYS_socket: ::c_long = 326;
+pub const SYS_bind: ::c_long = 327;
+pub const SYS_connect: ::c_long = 328;
+pub const SYS_listen: ::c_long = 329;
+pub const SYS_accept: ::c_long = 330;
+pub const SYS_getsockname: ::c_long = 331;
+pub const SYS_getpeername: ::c_long = 332;
+pub const SYS_socketpair: ::c_long = 333;
+pub const SYS_send: ::c_long = 334;
+pub const SYS_sendto: ::c_long = 335;
+pub const SYS_recv: ::c_long = 336;
+pub const SYS_recvfrom: ::c_long = 337;
+pub const SYS_shutdown: ::c_long = 338;
+pub const SYS_setsockopt: ::c_long = 339;
+pub const SYS_getsockopt: ::c_long = 340;
+pub const SYS_sendmsg: ::c_long = 341;
+pub const SYS_recvmsg: ::c_long = 342;
+pub const SYS_recvmmsg: ::c_long = 343;
+pub const SYS_accept4: ::c_long = 344;
+pub const SYS_name_to_handle_at: ::c_long = 345;
+pub const SYS_open_by_handle_at: ::c_long = 346;
+pub const SYS_clock_adjtime: ::c_long = 347;
+pub const SYS_syncfs: ::c_long = 348;
+pub const SYS_sendmmsg: ::c_long = 349;
+pub const SYS_setns: ::c_long = 350;
+pub const SYS_process_vm_readv: ::c_long = 351;
+pub const SYS_process_vm_writev: ::c_long = 352;
+pub const SYS_finit_module: ::c_long = 353;
+pub const SYS_kcmp: ::c_long = 354;
+pub const SYS_sched_setattr: ::c_long = 355;
+pub const SYS_sched_getattr: ::c_long = 356;
+pub const SYS_renameat2: ::c_long = 357;
+pub const SYS_seccomp: ::c_long = 358;
+pub const SYS_getrandom: ::c_long = 359;
+pub const SYS_memfd_create: ::c_long = 360;
+pub const SYS_bpf: ::c_long = 361;
+pub const SYS_execveat: ::c_long = 362;
+pub const SYS_switch_endian: ::c_long = 363;
+pub const SYS_userfaultfd: ::c_long = 364;
+pub const SYS_membarrier: ::c_long = 365;
+pub const SYS_mlock2: ::c_long = 378;
+pub const SYS_copy_file_range: ::c_long = 379;
+pub const SYS_preadv2: ::c_long = 380;
+pub const SYS_pwritev2: ::c_long = 381;
+pub const SYS_kexec_file_load: ::c_long = 382;
+pub const SYS_statx: ::c_long = 383;
+
+pub const FIOCLEX: ::c_int = 0x20006601;
+pub const FIONCLEX: ::c_int = 0x20006602;
+pub const FIONBIO: ::c_int = 0x8004667e;
+pub const EDEADLK: ::c_int = 58;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const SO_PASSCRED: ::c_int = 20;
+pub const SO_PEERCRED: ::c_int = 21;
+pub const SO_RCVLOWAT: ::c_int = 16;
+pub const SO_SNDLOWAT: ::c_int = 17;
+pub const SO_RCVTIMEO: ::c_int = 18;
+pub const SO_SNDTIMEO: ::c_int = 19;
+pub const EXTPROC: ::tcflag_t = 0x10000000;
+pub const VEOL: usize = 6;
+pub const VEOL2: usize = 8;
+pub const VMIN: usize = 5;
+pub const IEXTEN: ::tcflag_t = 0x00000400;
+pub const TOSTOP: ::tcflag_t = 0x00400000;
+pub const FLUSHO: ::tcflag_t = 0x00800000;
+pub const TCGETS: ::c_int = 0x403c7413;
+pub const TCSETS: ::c_int = 0x803c7414;
+pub const TCSETSW: ::c_int = 0x803c7415;
+pub const TCSETSF: ::c_int = 0x803c7416;
+pub const TCGETA: ::c_int = 0x40147417;
+pub const TCSETA: ::c_int = 0x80147418;
+pub const TCSETAW: ::c_int = 0x80147419;
+pub const TCSETAF: ::c_int = 0x8014741c;
+pub const TCSBRK: ::c_int = 0x2000741d;
+pub const TCXONC: ::c_int = 0x2000741e;
+pub const TCFLSH: ::c_int = 0x2000741f;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x40047477;
+pub const TIOCSPGRP: ::c_int = 0x80047476;
+pub const TIOCOUTQ: ::c_int = 0x40047473;
+pub const TIOCGWINSZ: ::c_int = 0x40087468;
+pub const TIOCSWINSZ: ::c_int = 0x80087467;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x4004667f;
+pub const TIOCCONS: ::c_int = 0x541D;
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+pub const TIOCINQ: ::c_int = ::FIONREAD;
+pub const MCL_CURRENT: ::c_int = 0x2000;
+pub const MCL_FUTURE: ::c_int = 0x4000;
+pub const CBAUD: ::tcflag_t = 0xff;
+pub const TAB1: ::c_int = 0x400;
+pub const TAB2: ::c_int = 0x800;
+pub const TAB3: ::c_int = 0xc00;
+pub const CR1: ::c_int = 0x1000;
+pub const CR2: ::c_int = 0x2000;
+pub const CR3: ::c_int = 0x3000;
+pub const FF1: ::c_int = 0x4000;
+pub const BS1: ::c_int = 0x8000;
+pub const VT1: ::c_int = 0x10000;
+pub const VWERASE: usize = 10;
+pub const VREPRINT: usize = 11;
+pub const VSUSP: usize = 12;
+pub const VSTART: usize = 13;
+pub const VSTOP: usize = 14;
+pub const VDISCARD: usize = 16;
+pub const VTIME: usize = 7;
+pub const IXON: ::tcflag_t = 0x00000200;
+pub const IXOFF: ::tcflag_t = 0x00000400;
+pub const ONLCR: ::tcflag_t = 0x2;
+pub const CSIZE: ::tcflag_t = 0x00000300;
+
+pub const CS6: ::tcflag_t = 0x00000100;
+pub const CS7: ::tcflag_t = 0x00000200;
+pub const CS8: ::tcflag_t = 0x00000300;
+pub const CSTOPB: ::tcflag_t = 0x00000400;
+pub const CREAD: ::tcflag_t = 0x00000800;
+pub const PARENB: ::tcflag_t = 0x00001000;
+pub const PARODD: ::tcflag_t = 0x00002000;
+pub const HUPCL: ::tcflag_t = 0x00004000;
+pub const CLOCAL: ::tcflag_t = 0x00008000;
+pub const ECHOKE: ::tcflag_t = 0x00000001;
+pub const ECHOE: ::tcflag_t = 0x00000002;
+pub const ECHOK: ::tcflag_t = 0x00000004;
+pub const ECHONL: ::tcflag_t = 0x00000010;
+pub const ECHOPRT: ::tcflag_t = 0x00000020;
+pub const ECHOCTL: ::tcflag_t = 0x00000040;
+pub const ISIG: ::tcflag_t = 0x00000080;
+pub const ICANON: ::tcflag_t = 0x00000100;
+pub const PENDIN: ::tcflag_t = 0x20000000;
+pub const NOFLSH: ::tcflag_t = 0x80000000;
+
+pub const CIBAUD: ::tcflag_t = 0o77600000;
+pub const CBAUDEX: ::tcflag_t = 0o0000020;
+pub const VSWTC: usize = 9;
+pub const OLCUC: ::tcflag_t = 0o000004;
+pub const NLDLY: ::tcflag_t = 0o0001400;
+pub const CRDLY: ::tcflag_t = 0o0030000;
+pub const TABDLY: ::tcflag_t = 0o0006000;
+pub const BSDLY: ::tcflag_t = 0o0100000;
+pub const FFDLY: ::tcflag_t = 0o0040000;
+pub const VTDLY: ::tcflag_t = 0o0200000;
+pub const XTABS: ::tcflag_t = 0o00006000;
+
+pub const B57600: ::speed_t = 0o00020;
+pub const B115200: ::speed_t = 0o00021;
+pub const B230400: ::speed_t = 0o00022;
+pub const B460800: ::speed_t = 0o00023;
+pub const B500000: ::speed_t = 0o00024;
+pub const B576000: ::speed_t = 0o00025;
+pub const B921600: ::speed_t = 0o00026;
+pub const B1000000: ::speed_t = 0o00027;
+pub const B1152000: ::speed_t = 0o00030;
+pub const B1500000: ::speed_t = 0o00031;
+pub const B2000000: ::speed_t = 0o00032;
+pub const B2500000: ::speed_t = 0o00033;
+pub const B3000000: ::speed_t = 0o00034;
+pub const B3500000: ::speed_t = 0o00035;
+pub const B4000000: ::speed_t = 0o00036;
+
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b64/x86_64/align.rs b/library/libc/src/unix/linux_like/linux/musl/b64/x86_64/align.rs
new file mode 100644
index 00000000..7ca870fd
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b64/x86_64/align.rs
@@ -0,0 +1,7 @@
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    #[repr(align(16))]
+    pub struct max_align_t {
+        priv_: [f64; 4]
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/b64/x86_64/mod.rs b/library/libc/src/unix/linux_like/linux/musl/b64/x86_64/mod.rs
new file mode 100644
index 00000000..1229bec1
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/b64/x86_64/mod.rs
@@ -0,0 +1,965 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type nlink_t = u64;
+pub type blksize_t = ::c_long;
+pub type __u64 = ::c_ulonglong;
+pub type greg_t = i64;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __unused: [::c_long; 3],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino64_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        __pad0: ::c_int,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        __reserved: [::c_long; 3],
+    }
+
+    pub struct user_regs_struct {
+        pub r15: ::c_ulong,
+        pub r14: ::c_ulong,
+        pub r13: ::c_ulong,
+        pub r12: ::c_ulong,
+        pub rbp: ::c_ulong,
+        pub rbx: ::c_ulong,
+        pub r11: ::c_ulong,
+        pub r10: ::c_ulong,
+        pub r9: ::c_ulong,
+        pub r8: ::c_ulong,
+        pub rax: ::c_ulong,
+        pub rcx: ::c_ulong,
+        pub rdx: ::c_ulong,
+        pub rsi: ::c_ulong,
+        pub rdi: ::c_ulong,
+        pub orig_rax: ::c_ulong,
+        pub rip: ::c_ulong,
+        pub cs: ::c_ulong,
+        pub eflags: ::c_ulong,
+        pub rsp: ::c_ulong,
+        pub ss: ::c_ulong,
+        pub fs_base: ::c_ulong,
+        pub gs_base: ::c_ulong,
+        pub ds: ::c_ulong,
+        pub es: ::c_ulong,
+        pub fs: ::c_ulong,
+        pub gs: ::c_ulong,
+    }
+
+    pub struct user {
+        pub regs: user_regs_struct,
+        pub u_fpvalid: ::c_int,
+        pub i387: user_fpregs_struct,
+        pub u_tsize: ::c_ulong,
+        pub u_dsize: ::c_ulong,
+        pub u_ssize: ::c_ulong,
+        pub start_code: ::c_ulong,
+        pub start_stack: ::c_ulong,
+        pub signal: ::c_long,
+        __reserved: ::c_int,
+        #[cfg(target_pointer_width = "32")]
+        __pad1: u32,
+        pub u_ar0: *mut user_regs_struct,
+        #[cfg(target_pointer_width = "32")]
+        __pad2: u32,
+        pub u_fpstate: *mut user_fpregs_struct,
+        pub magic: ::c_ulong,
+        pub u_comm: [::c_char; 32],
+        pub u_debugreg: [::c_ulong; 8],
+    }
+
+    // GitHub repo: ifduyue/musl/
+    // commit: b4b1e10364c8737a632be61582e05a8d3acf5690
+    // file: arch/x86_64/bits/signal.h#L80-L84
+    pub struct mcontext_t {
+        pub gregs: [greg_t; 23],
+        __private: [u64; 9],
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __seq: ::c_int,
+        __unused1: ::c_long,
+        __unused2: ::c_long
+    }
+}
+
+s_no_extra_traits! {
+    pub struct user_fpregs_struct {
+        pub cwd: ::c_ushort,
+        pub swd: ::c_ushort,
+        pub ftw: ::c_ushort,
+        pub fop: ::c_ushort,
+        pub rip: ::c_ulong,
+        pub rdp: ::c_ulong,
+        pub mxcsr: ::c_uint,
+        pub mxcr_mask: ::c_uint,
+        pub st_space: [::c_uint; 32],
+        pub xmm_space: [::c_uint; 64],
+        padding: [::c_uint; 24],
+    }
+
+    pub struct ucontext_t {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ucontext_t,
+        pub uc_stack: ::stack_t,
+        pub uc_mcontext: mcontext_t,
+        pub uc_sigmask: ::sigset_t,
+        __private: [u8; 512],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for user_fpregs_struct {
+            fn eq(&self, other: &user_fpregs_struct) -> bool {
+                self.cwd == other.cwd
+                    && self.swd == other.swd
+                    && self.ftw == other.ftw
+                    && self.fop == other.fop
+                    && self.rip == other.rip
+                    && self.rdp == other.rdp
+                    && self.mxcsr == other.mxcsr
+                    && self.mxcr_mask == other.mxcr_mask
+                    && self.st_space == other.st_space
+                    && self
+                    .xmm_space
+                    .iter()
+                    .zip(other.xmm_space.iter())
+                    .all(|(a,b)| a == b)
+                // Ignore padding field
+            }
+        }
+
+        impl Eq for user_fpregs_struct {}
+
+        impl ::fmt::Debug for user_fpregs_struct {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("user_fpregs_struct")
+                    .field("cwd", &self.cwd)
+                    .field("ftw", &self.ftw)
+                    .field("fop", &self.fop)
+                    .field("rip", &self.rip)
+                    .field("rdp", &self.rdp)
+                    .field("mxcsr", &self.mxcsr)
+                    .field("mxcr_mask", &self.mxcr_mask)
+                    .field("st_space", &self.st_space)
+                // FIXME: .field("xmm_space", &self.xmm_space)
+                // Ignore padding field
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for user_fpregs_struct {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.cwd.hash(state);
+                self.ftw.hash(state);
+                self.fop.hash(state);
+                self.rip.hash(state);
+                self.rdp.hash(state);
+                self.mxcsr.hash(state);
+                self.mxcr_mask.hash(state);
+                self.st_space.hash(state);
+                self.xmm_space.hash(state);
+                // Ignore padding field
+            }
+        }
+
+        impl PartialEq for ucontext_t {
+            fn eq(&self, other: &ucontext_t) -> bool {
+                self.uc_flags == other.uc_flags
+                    && self.uc_link == other.uc_link
+                    && self.uc_stack == other.uc_stack
+                    && self.uc_mcontext == other.uc_mcontext
+                    && self.uc_sigmask == other.uc_sigmask
+                    && self
+                    .__private
+                    .iter()
+                    .zip(other.__private.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for ucontext_t {}
+
+        impl ::fmt::Debug for ucontext_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("ucontext_t")
+                    .field("uc_flags", &self.uc_flags)
+                    .field("uc_link", &self.uc_link)
+                    .field("uc_stack", &self.uc_stack)
+                    .field("uc_mcontext", &self.uc_mcontext)
+                    .field("uc_sigmask", &self.uc_sigmask)
+                // Ignore __private field
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for ucontext_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uc_flags.hash(state);
+                self.uc_link.hash(state);
+                self.uc_stack.hash(state);
+                self.uc_mcontext.hash(state);
+                self.uc_sigmask.hash(state);
+                self.__private.hash(state);
+            }
+        }
+    }
+}
+
+// Syscall table
+
+pub const SYS_read: ::c_long = 0;
+pub const SYS_write: ::c_long = 1;
+pub const SYS_open: ::c_long = 2;
+pub const SYS_close: ::c_long = 3;
+pub const SYS_stat: ::c_long = 4;
+pub const SYS_fstat: ::c_long = 5;
+pub const SYS_lstat: ::c_long = 6;
+pub const SYS_poll: ::c_long = 7;
+pub const SYS_lseek: ::c_long = 8;
+pub const SYS_mmap: ::c_long = 9;
+pub const SYS_mprotect: ::c_long = 10;
+pub const SYS_munmap: ::c_long = 11;
+pub const SYS_brk: ::c_long = 12;
+pub const SYS_rt_sigaction: ::c_long = 13;
+pub const SYS_rt_sigprocmask: ::c_long = 14;
+pub const SYS_rt_sigreturn: ::c_long = 15;
+pub const SYS_ioctl: ::c_long = 16;
+pub const SYS_pread64: ::c_long = 17;
+pub const SYS_pwrite64: ::c_long = 18;
+pub const SYS_readv: ::c_long = 19;
+pub const SYS_writev: ::c_long = 20;
+pub const SYS_access: ::c_long = 21;
+pub const SYS_pipe: ::c_long = 22;
+pub const SYS_select: ::c_long = 23;
+pub const SYS_sched_yield: ::c_long = 24;
+pub const SYS_mremap: ::c_long = 25;
+pub const SYS_msync: ::c_long = 26;
+pub const SYS_mincore: ::c_long = 27;
+pub const SYS_madvise: ::c_long = 28;
+pub const SYS_shmget: ::c_long = 29;
+pub const SYS_shmat: ::c_long = 30;
+pub const SYS_shmctl: ::c_long = 31;
+pub const SYS_dup: ::c_long = 32;
+pub const SYS_dup2: ::c_long = 33;
+pub const SYS_pause: ::c_long = 34;
+pub const SYS_nanosleep: ::c_long = 35;
+pub const SYS_getitimer: ::c_long = 36;
+pub const SYS_alarm: ::c_long = 37;
+pub const SYS_setitimer: ::c_long = 38;
+pub const SYS_getpid: ::c_long = 39;
+pub const SYS_sendfile: ::c_long = 40;
+pub const SYS_socket: ::c_long = 41;
+pub const SYS_connect: ::c_long = 42;
+pub const SYS_accept: ::c_long = 43;
+pub const SYS_sendto: ::c_long = 44;
+pub const SYS_recvfrom: ::c_long = 45;
+pub const SYS_sendmsg: ::c_long = 46;
+pub const SYS_recvmsg: ::c_long = 47;
+pub const SYS_shutdown: ::c_long = 48;
+pub const SYS_bind: ::c_long = 49;
+pub const SYS_listen: ::c_long = 50;
+pub const SYS_getsockname: ::c_long = 51;
+pub const SYS_getpeername: ::c_long = 52;
+pub const SYS_socketpair: ::c_long = 53;
+pub const SYS_setsockopt: ::c_long = 54;
+pub const SYS_getsockopt: ::c_long = 55;
+pub const SYS_clone: ::c_long = 56;
+pub const SYS_fork: ::c_long = 57;
+pub const SYS_vfork: ::c_long = 58;
+pub const SYS_execve: ::c_long = 59;
+pub const SYS_exit: ::c_long = 60;
+pub const SYS_wait4: ::c_long = 61;
+pub const SYS_kill: ::c_long = 62;
+pub const SYS_uname: ::c_long = 63;
+pub const SYS_semget: ::c_long = 64;
+pub const SYS_semop: ::c_long = 65;
+pub const SYS_semctl: ::c_long = 66;
+pub const SYS_shmdt: ::c_long = 67;
+pub const SYS_msgget: ::c_long = 68;
+pub const SYS_msgsnd: ::c_long = 69;
+pub const SYS_msgrcv: ::c_long = 70;
+pub const SYS_msgctl: ::c_long = 71;
+pub const SYS_fcntl: ::c_long = 72;
+pub const SYS_flock: ::c_long = 73;
+pub const SYS_fsync: ::c_long = 74;
+pub const SYS_fdatasync: ::c_long = 75;
+pub const SYS_truncate: ::c_long = 76;
+pub const SYS_ftruncate: ::c_long = 77;
+pub const SYS_getdents: ::c_long = 78;
+pub const SYS_getcwd: ::c_long = 79;
+pub const SYS_chdir: ::c_long = 80;
+pub const SYS_fchdir: ::c_long = 81;
+pub const SYS_rename: ::c_long = 82;
+pub const SYS_mkdir: ::c_long = 83;
+pub const SYS_rmdir: ::c_long = 84;
+pub const SYS_creat: ::c_long = 85;
+pub const SYS_link: ::c_long = 86;
+pub const SYS_unlink: ::c_long = 87;
+pub const SYS_symlink: ::c_long = 88;
+pub const SYS_readlink: ::c_long = 89;
+pub const SYS_chmod: ::c_long = 90;
+pub const SYS_fchmod: ::c_long = 91;
+pub const SYS_chown: ::c_long = 92;
+pub const SYS_fchown: ::c_long = 93;
+pub const SYS_lchown: ::c_long = 94;
+pub const SYS_umask: ::c_long = 95;
+pub const SYS_gettimeofday: ::c_long = 96;
+pub const SYS_getrlimit: ::c_long = 97;
+pub const SYS_getrusage: ::c_long = 98;
+pub const SYS_sysinfo: ::c_long = 99;
+pub const SYS_times: ::c_long = 100;
+pub const SYS_ptrace: ::c_long = 101;
+pub const SYS_getuid: ::c_long = 102;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_getgid: ::c_long = 104;
+pub const SYS_setuid: ::c_long = 105;
+pub const SYS_setgid: ::c_long = 106;
+pub const SYS_geteuid: ::c_long = 107;
+pub const SYS_getegid: ::c_long = 108;
+pub const SYS_setpgid: ::c_long = 109;
+pub const SYS_getppid: ::c_long = 110;
+pub const SYS_getpgrp: ::c_long = 111;
+pub const SYS_setsid: ::c_long = 112;
+pub const SYS_setreuid: ::c_long = 113;
+pub const SYS_setregid: ::c_long = 114;
+pub const SYS_getgroups: ::c_long = 115;
+pub const SYS_setgroups: ::c_long = 116;
+pub const SYS_setresuid: ::c_long = 117;
+pub const SYS_getresuid: ::c_long = 118;
+pub const SYS_setresgid: ::c_long = 119;
+pub const SYS_getresgid: ::c_long = 120;
+pub const SYS_getpgid: ::c_long = 121;
+pub const SYS_setfsuid: ::c_long = 122;
+pub const SYS_setfsgid: ::c_long = 123;
+pub const SYS_getsid: ::c_long = 124;
+pub const SYS_capget: ::c_long = 125;
+pub const SYS_capset: ::c_long = 126;
+pub const SYS_rt_sigpending: ::c_long = 127;
+pub const SYS_rt_sigtimedwait: ::c_long = 128;
+pub const SYS_rt_sigqueueinfo: ::c_long = 129;
+pub const SYS_rt_sigsuspend: ::c_long = 130;
+pub const SYS_sigaltstack: ::c_long = 131;
+pub const SYS_utime: ::c_long = 132;
+pub const SYS_mknod: ::c_long = 133;
+pub const SYS_uselib: ::c_long = 134;
+pub const SYS_personality: ::c_long = 135;
+pub const SYS_ustat: ::c_long = 136;
+pub const SYS_statfs: ::c_long = 137;
+pub const SYS_fstatfs: ::c_long = 138;
+pub const SYS_sysfs: ::c_long = 139;
+pub const SYS_getpriority: ::c_long = 140;
+pub const SYS_setpriority: ::c_long = 141;
+pub const SYS_sched_setparam: ::c_long = 142;
+pub const SYS_sched_getparam: ::c_long = 143;
+pub const SYS_sched_setscheduler: ::c_long = 144;
+pub const SYS_sched_getscheduler: ::c_long = 145;
+pub const SYS_sched_get_priority_max: ::c_long = 146;
+pub const SYS_sched_get_priority_min: ::c_long = 147;
+pub const SYS_sched_rr_get_interval: ::c_long = 148;
+pub const SYS_mlock: ::c_long = 149;
+pub const SYS_munlock: ::c_long = 150;
+pub const SYS_mlockall: ::c_long = 151;
+pub const SYS_munlockall: ::c_long = 152;
+pub const SYS_vhangup: ::c_long = 153;
+pub const SYS_modify_ldt: ::c_long = 154;
+pub const SYS_pivot_root: ::c_long = 155;
+pub const SYS__sysctl: ::c_long = 156;
+pub const SYS_prctl: ::c_long = 157;
+pub const SYS_arch_prctl: ::c_long = 158;
+pub const SYS_adjtimex: ::c_long = 159;
+pub const SYS_setrlimit: ::c_long = 160;
+pub const SYS_chroot: ::c_long = 161;
+pub const SYS_sync: ::c_long = 162;
+pub const SYS_acct: ::c_long = 163;
+pub const SYS_settimeofday: ::c_long = 164;
+pub const SYS_mount: ::c_long = 165;
+pub const SYS_umount2: ::c_long = 166;
+pub const SYS_swapon: ::c_long = 167;
+pub const SYS_swapoff: ::c_long = 168;
+pub const SYS_reboot: ::c_long = 169;
+pub const SYS_sethostname: ::c_long = 170;
+pub const SYS_setdomainname: ::c_long = 171;
+pub const SYS_iopl: ::c_long = 172;
+pub const SYS_ioperm: ::c_long = 173;
+pub const SYS_create_module: ::c_long = 174;
+pub const SYS_init_module: ::c_long = 175;
+pub const SYS_delete_module: ::c_long = 176;
+pub const SYS_get_kernel_syms: ::c_long = 177;
+pub const SYS_query_module: ::c_long = 178;
+pub const SYS_quotactl: ::c_long = 179;
+pub const SYS_nfsservctl: ::c_long = 180;
+pub const SYS_getpmsg: ::c_long = 181;
+pub const SYS_putpmsg: ::c_long = 182;
+pub const SYS_afs_syscall: ::c_long = 183;
+pub const SYS_tuxcall: ::c_long = 184;
+pub const SYS_security: ::c_long = 185;
+pub const SYS_gettid: ::c_long = 186;
+pub const SYS_readahead: ::c_long = 187;
+pub const SYS_setxattr: ::c_long = 188;
+pub const SYS_lsetxattr: ::c_long = 189;
+pub const SYS_fsetxattr: ::c_long = 190;
+pub const SYS_getxattr: ::c_long = 191;
+pub const SYS_lgetxattr: ::c_long = 192;
+pub const SYS_fgetxattr: ::c_long = 193;
+pub const SYS_listxattr: ::c_long = 194;
+pub const SYS_llistxattr: ::c_long = 195;
+pub const SYS_flistxattr: ::c_long = 196;
+pub const SYS_removexattr: ::c_long = 197;
+pub const SYS_lremovexattr: ::c_long = 198;
+pub const SYS_fremovexattr: ::c_long = 199;
+pub const SYS_tkill: ::c_long = 200;
+pub const SYS_time: ::c_long = 201;
+pub const SYS_futex: ::c_long = 202;
+pub const SYS_sched_setaffinity: ::c_long = 203;
+pub const SYS_sched_getaffinity: ::c_long = 204;
+pub const SYS_set_thread_area: ::c_long = 205;
+pub const SYS_io_setup: ::c_long = 206;
+pub const SYS_io_destroy: ::c_long = 207;
+pub const SYS_io_getevents: ::c_long = 208;
+pub const SYS_io_submit: ::c_long = 209;
+pub const SYS_io_cancel: ::c_long = 210;
+pub const SYS_get_thread_area: ::c_long = 211;
+pub const SYS_lookup_dcookie: ::c_long = 212;
+pub const SYS_epoll_create: ::c_long = 213;
+pub const SYS_epoll_ctl_old: ::c_long = 214;
+pub const SYS_epoll_wait_old: ::c_long = 215;
+pub const SYS_remap_file_pages: ::c_long = 216;
+pub const SYS_getdents64: ::c_long = 217;
+pub const SYS_set_tid_address: ::c_long = 218;
+pub const SYS_restart_syscall: ::c_long = 219;
+pub const SYS_semtimedop: ::c_long = 220;
+pub const SYS_fadvise64: ::c_long = 221;
+pub const SYS_timer_create: ::c_long = 222;
+pub const SYS_timer_settime: ::c_long = 223;
+pub const SYS_timer_gettime: ::c_long = 224;
+pub const SYS_timer_getoverrun: ::c_long = 225;
+pub const SYS_timer_delete: ::c_long = 226;
+pub const SYS_clock_settime: ::c_long = 227;
+pub const SYS_clock_gettime: ::c_long = 228;
+pub const SYS_clock_getres: ::c_long = 229;
+pub const SYS_clock_nanosleep: ::c_long = 230;
+pub const SYS_exit_group: ::c_long = 231;
+pub const SYS_epoll_wait: ::c_long = 232;
+pub const SYS_epoll_ctl: ::c_long = 233;
+pub const SYS_tgkill: ::c_long = 234;
+pub const SYS_utimes: ::c_long = 235;
+pub const SYS_vserver: ::c_long = 236;
+pub const SYS_mbind: ::c_long = 237;
+pub const SYS_set_mempolicy: ::c_long = 238;
+pub const SYS_get_mempolicy: ::c_long = 239;
+pub const SYS_mq_open: ::c_long = 240;
+pub const SYS_mq_unlink: ::c_long = 241;
+pub const SYS_mq_timedsend: ::c_long = 242;
+pub const SYS_mq_timedreceive: ::c_long = 243;
+pub const SYS_mq_notify: ::c_long = 244;
+pub const SYS_mq_getsetattr: ::c_long = 245;
+pub const SYS_kexec_load: ::c_long = 246;
+pub const SYS_waitid: ::c_long = 247;
+pub const SYS_add_key: ::c_long = 248;
+pub const SYS_request_key: ::c_long = 249;
+pub const SYS_keyctl: ::c_long = 250;
+pub const SYS_ioprio_set: ::c_long = 251;
+pub const SYS_ioprio_get: ::c_long = 252;
+pub const SYS_inotify_init: ::c_long = 253;
+pub const SYS_inotify_add_watch: ::c_long = 254;
+pub const SYS_inotify_rm_watch: ::c_long = 255;
+pub const SYS_migrate_pages: ::c_long = 256;
+pub const SYS_openat: ::c_long = 257;
+pub const SYS_mkdirat: ::c_long = 258;
+pub const SYS_mknodat: ::c_long = 259;
+pub const SYS_fchownat: ::c_long = 260;
+pub const SYS_futimesat: ::c_long = 261;
+pub const SYS_newfstatat: ::c_long = 262;
+pub const SYS_unlinkat: ::c_long = 263;
+pub const SYS_renameat: ::c_long = 264;
+pub const SYS_linkat: ::c_long = 265;
+pub const SYS_symlinkat: ::c_long = 266;
+pub const SYS_readlinkat: ::c_long = 267;
+pub const SYS_fchmodat: ::c_long = 268;
+pub const SYS_faccessat: ::c_long = 269;
+pub const SYS_pselect6: ::c_long = 270;
+pub const SYS_ppoll: ::c_long = 271;
+pub const SYS_unshare: ::c_long = 272;
+pub const SYS_set_robust_list: ::c_long = 273;
+pub const SYS_get_robust_list: ::c_long = 274;
+pub const SYS_splice: ::c_long = 275;
+pub const SYS_tee: ::c_long = 276;
+pub const SYS_sync_file_range: ::c_long = 277;
+pub const SYS_vmsplice: ::c_long = 278;
+pub const SYS_move_pages: ::c_long = 279;
+pub const SYS_utimensat: ::c_long = 280;
+pub const SYS_epoll_pwait: ::c_long = 281;
+pub const SYS_signalfd: ::c_long = 282;
+pub const SYS_timerfd_create: ::c_long = 283;
+pub const SYS_eventfd: ::c_long = 284;
+pub const SYS_fallocate: ::c_long = 285;
+pub const SYS_timerfd_settime: ::c_long = 286;
+pub const SYS_timerfd_gettime: ::c_long = 287;
+pub const SYS_accept4: ::c_long = 288;
+pub const SYS_signalfd4: ::c_long = 289;
+pub const SYS_eventfd2: ::c_long = 290;
+pub const SYS_epoll_create1: ::c_long = 291;
+pub const SYS_dup3: ::c_long = 292;
+pub const SYS_pipe2: ::c_long = 293;
+pub const SYS_inotify_init1: ::c_long = 294;
+pub const SYS_preadv: ::c_long = 295;
+pub const SYS_pwritev: ::c_long = 296;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 297;
+pub const SYS_perf_event_open: ::c_long = 298;
+pub const SYS_recvmmsg: ::c_long = 299;
+pub const SYS_fanotify_init: ::c_long = 300;
+pub const SYS_fanotify_mark: ::c_long = 301;
+pub const SYS_prlimit64: ::c_long = 302;
+pub const SYS_name_to_handle_at: ::c_long = 303;
+pub const SYS_open_by_handle_at: ::c_long = 304;
+pub const SYS_clock_adjtime: ::c_long = 305;
+pub const SYS_syncfs: ::c_long = 306;
+pub const SYS_sendmmsg: ::c_long = 307;
+pub const SYS_setns: ::c_long = 308;
+pub const SYS_getcpu: ::c_long = 309;
+pub const SYS_process_vm_readv: ::c_long = 310;
+pub const SYS_process_vm_writev: ::c_long = 311;
+pub const SYS_kcmp: ::c_long = 312;
+pub const SYS_finit_module: ::c_long = 313;
+pub const SYS_sched_setattr: ::c_long = 314;
+pub const SYS_sched_getattr: ::c_long = 315;
+pub const SYS_renameat2: ::c_long = 316;
+pub const SYS_seccomp: ::c_long = 317;
+pub const SYS_getrandom: ::c_long = 318;
+pub const SYS_memfd_create: ::c_long = 319;
+pub const SYS_kexec_file_load: ::c_long = 320;
+pub const SYS_bpf: ::c_long = 321;
+pub const SYS_execveat: ::c_long = 322;
+pub const SYS_userfaultfd: ::c_long = 323;
+pub const SYS_membarrier: ::c_long = 324;
+pub const SYS_mlock2: ::c_long = 325;
+pub const SYS_copy_file_range: ::c_long = 326;
+pub const SYS_preadv2: ::c_long = 327;
+pub const SYS_pwritev2: ::c_long = 328;
+pub const SYS_pkey_mprotect: ::c_long = 329;
+pub const SYS_pkey_alloc: ::c_long = 330;
+pub const SYS_pkey_free: ::c_long = 331;
+pub const SYS_statx: ::c_long = 332;
+
+// offsets in user_regs_structs, from sys/reg.h
+pub const R15: ::c_int = 0;
+pub const R14: ::c_int = 1;
+pub const R13: ::c_int = 2;
+pub const R12: ::c_int = 3;
+pub const RBP: ::c_int = 4;
+pub const RBX: ::c_int = 5;
+pub const R11: ::c_int = 6;
+pub const R10: ::c_int = 7;
+pub const R9: ::c_int = 8;
+pub const R8: ::c_int = 9;
+pub const RAX: ::c_int = 10;
+pub const RCX: ::c_int = 11;
+pub const RDX: ::c_int = 12;
+pub const RSI: ::c_int = 13;
+pub const RDI: ::c_int = 14;
+pub const ORIG_RAX: ::c_int = 15;
+pub const RIP: ::c_int = 16;
+pub const CS: ::c_int = 17;
+pub const EFLAGS: ::c_int = 18;
+pub const RSP: ::c_int = 19;
+pub const SS: ::c_int = 20;
+pub const FS_BASE: ::c_int = 21;
+pub const GS_BASE: ::c_int = 22;
+pub const DS: ::c_int = 23;
+pub const ES: ::c_int = 24;
+pub const FS: ::c_int = 25;
+pub const GS: ::c_int = 26;
+
+// offsets in mcontext_t.gregs from bits/signal.h
+// GitHub repo: ifduyue/musl/
+// commit: b4b1e10364c8737a632be61582e05a8d3acf5690
+// file: arch/x86_64/bits/signal.h#L9-L56
+pub const REG_R8: ::c_int = 0;
+pub const REG_R9: ::c_int = 1;
+pub const REG_R10: ::c_int = 2;
+pub const REG_R11: ::c_int = 3;
+pub const REG_R12: ::c_int = 4;
+pub const REG_R13: ::c_int = 5;
+pub const REG_R14: ::c_int = 6;
+pub const REG_R15: ::c_int = 7;
+pub const REG_RDI: ::c_int = 8;
+pub const REG_RSI: ::c_int = 9;
+pub const REG_RBP: ::c_int = 10;
+pub const REG_RBX: ::c_int = 11;
+pub const REG_RDX: ::c_int = 12;
+pub const REG_RAX: ::c_int = 13;
+pub const REG_RCX: ::c_int = 14;
+pub const REG_RSP: ::c_int = 15;
+pub const REG_RIP: ::c_int = 16;
+pub const REG_EFL: ::c_int = 17;
+pub const REG_CSGSFS: ::c_int = 18;
+pub const REG_ERR: ::c_int = 19;
+pub const REG_TRAPNO: ::c_int = 20;
+pub const REG_OLDMASK: ::c_int = 21;
+pub const REG_CR2: ::c_int = 22;
+
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MAP_32BIT: ::c_int = 0x0040;
+pub const O_APPEND: ::c_int = 1024;
+pub const O_DIRECT: ::c_int = 0x4000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_LARGEFILE: ::c_int = 0;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+pub const O_CREAT: ::c_int = 64;
+pub const O_EXCL: ::c_int = 128;
+pub const O_NOCTTY: ::c_int = 256;
+pub const O_NONBLOCK: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 1052672;
+pub const O_RSYNC: ::c_int = 1052672;
+pub const O_DSYNC: ::c_int = 4096;
+pub const O_ASYNC: ::c_int = 0x2000;
+
+pub const TIOCGRS485: ::c_int = 0x542E;
+pub const TIOCSRS485: ::c_int = 0x542F;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const MINSIGSTKSZ: ::size_t = 2048;
+
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_SIGINFO: ::c_int = 0x00000004;
+pub const SA_NOCLDWAIT: ::c_int = 0x00000002;
+
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGURG: ::c_int = 23;
+pub const SIGIO: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIG_BLOCK: ::c_int = 0x000000;
+pub const SIG_UNBLOCK: ::c_int = 0x01;
+
+pub const F_GETLK: ::c_int = 5;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_OFD_GETLK: ::c_int = 36;
+pub const F_OFD_SETLK: ::c_int = 37;
+pub const F_OFD_SETLKW: ::c_int = 38;
+
+pub const VEOF: usize = 4;
+
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_GROWSDOWN: ::c_int = 0x0100;
+pub const MAP_DENYWRITE: ::c_int = 0x0800;
+pub const MAP_EXECUTABLE: ::c_int = 0x01000;
+pub const MAP_LOCKED: ::c_int = 0x02000;
+pub const MAP_NORESERVE: ::c_int = 0x04000;
+pub const MAP_POPULATE: ::c_int = 0x08000;
+pub const MAP_NONBLOCK: ::c_int = 0x010000;
+pub const MAP_STACK: ::c_int = 0x020000;
+pub const MAP_HUGETLB: ::c_int = 0x040000;
+pub const MAP_SYNC: ::c_int = 0x080000;
+
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+pub const TIOCINQ: ::c_int = ::FIONREAD;
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::c_int = 0x00000800;
+pub const TAB2: ::c_int = 0x00001000;
+pub const TAB3: ::c_int = 0x00001800;
+pub const CR1: ::c_int = 0x00000200;
+pub const CR2: ::c_int = 0x00000400;
+pub const CR3: ::c_int = 0x00000600;
+pub const FF1: ::c_int = 0x00008000;
+pub const BS1: ::c_int = 0x00002000;
+pub const VT1: ::c_int = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+pub const CIBAUD: ::tcflag_t = 0o02003600000;
+pub const CBAUDEX: ::tcflag_t = 0o010000;
+pub const VSWTC: usize = 7;
+pub const OLCUC: ::tcflag_t = 0o000002;
+pub const NLDLY: ::tcflag_t = 0o000400;
+pub const CRDLY: ::tcflag_t = 0o003000;
+pub const TABDLY: ::tcflag_t = 0o014000;
+pub const BSDLY: ::tcflag_t = 0o020000;
+pub const FFDLY: ::tcflag_t = 0o100000;
+pub const VTDLY: ::tcflag_t = 0o040000;
+pub const XTABS: ::tcflag_t = 0o014000;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+pub const FIOCLEX: ::c_int = 0x5451;
+pub const FIONCLEX: ::c_int = 0x5450;
+pub const FIONBIO: ::c_int = 0x5421;
+pub const EDEADLK: ::c_int = 35;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const EXTPROC: ::tcflag_t = 0x00010000;
+pub const VEOL: usize = 11;
+pub const VEOL2: usize = 16;
+pub const VMIN: usize = 6;
+pub const IEXTEN: ::tcflag_t = 0x00008000;
+pub const TOSTOP: ::tcflag_t = 0x00000100;
+pub const FLUSHO: ::tcflag_t = 0x00001000;
+pub const TCGETS: ::c_int = 0x5401;
+pub const TCSETS: ::c_int = 0x5402;
+pub const TCSETSW: ::c_int = 0x5403;
+pub const TCSETSF: ::c_int = 0x5404;
+pub const TCGETA: ::c_int = 0x5405;
+pub const TCSETA: ::c_int = 0x5406;
+pub const TCSETAW: ::c_int = 0x5407;
+pub const TCSETAF: ::c_int = 0x5408;
+pub const TCSBRK: ::c_int = 0x5409;
+pub const TCXONC: ::c_int = 0x540A;
+pub const TCFLSH: ::c_int = 0x540B;
+pub const TIOCGSOFTCAR: ::c_int = 0x5419;
+pub const TIOCSSOFTCAR: ::c_int = 0x541A;
+pub const TIOCLINUX: ::c_int = 0x541C;
+pub const TIOCGSERIAL: ::c_int = 0x541E;
+pub const TIOCEXCL: ::c_int = 0x540C;
+pub const TIOCNXCL: ::c_int = 0x540D;
+pub const TIOCSCTTY: ::c_int = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x540F;
+pub const TIOCSPGRP: ::c_int = 0x5410;
+pub const TIOCOUTQ: ::c_int = 0x5411;
+pub const TIOCSTI: ::c_int = 0x5412;
+pub const TIOCGWINSZ: ::c_int = 0x5413;
+pub const TIOCSWINSZ: ::c_int = 0x5414;
+pub const TIOCMGET: ::c_int = 0x5415;
+pub const TIOCMBIS: ::c_int = 0x5416;
+pub const TIOCMBIC: ::c_int = 0x5417;
+pub const TIOCMSET: ::c_int = 0x5418;
+pub const FIONREAD: ::c_int = 0x541B;
+pub const TIOCCONS: ::c_int = 0x541D;
+
+pub const TIOCM_LE: ::c_int = 0x001;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCM_ST: ::c_int = 0x008;
+pub const TIOCM_SR: ::c_int = 0x010;
+pub const TIOCM_CTS: ::c_int = 0x020;
+pub const TIOCM_CAR: ::c_int = 0x040;
+pub const TIOCM_RNG: ::c_int = 0x080;
+pub const TIOCM_DSR: ::c_int = 0x100;
+pub const TIOCM_CD: ::c_int = TIOCM_CAR;
+pub const TIOCM_RI: ::c_int = TIOCM_RNG;
+
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/unix/linux_like/linux/musl/mod.rs b/library/libc/src/unix/linux_like/linux/musl/mod.rs
new file mode 100644
index 00000000..22f35ff3
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/musl/mod.rs
@@ -0,0 +1,703 @@
+pub type pthread_t = *mut ::c_void;
+pub type clock_t = c_long;
+#[cfg_attr(
+    not(feature = "rustc-dep-of-std"),
+    deprecated(
+        since = "0.2.80",
+        note = "This type is changed to 64-bit in musl 1.2.0, \
+                we'll follow that change in the future release. \
+                See #1848 for more info."
+    )
+)]
+pub type time_t = c_long;
+pub type suseconds_t = c_long;
+pub type ino_t = u64;
+pub type off_t = i64;
+pub type blkcnt_t = i64;
+
+pub type shmatt_t = ::c_ulong;
+pub type msgqnum_t = ::c_ulong;
+pub type msglen_t = ::c_ulong;
+pub type fsblkcnt_t = ::c_ulonglong;
+pub type fsfilcnt_t = ::c_ulonglong;
+pub type rlim_t = ::c_ulonglong;
+
+pub type flock64 = flock;
+
+impl siginfo_t {
+    pub unsafe fn si_addr(&self) -> *mut ::c_void {
+        #[repr(C)]
+        struct siginfo_sigfault {
+            _si_signo: ::c_int,
+            _si_errno: ::c_int,
+            _si_code: ::c_int,
+            si_addr: *mut ::c_void,
+        }
+        (*(self as *const siginfo_t as *const siginfo_sigfault)).si_addr
+    }
+
+    pub unsafe fn si_value(&self) -> ::sigval {
+        #[repr(C)]
+        struct siginfo_si_value {
+            _si_signo: ::c_int,
+            _si_errno: ::c_int,
+            _si_code: ::c_int,
+            _si_timerid: ::c_int,
+            _si_overrun: ::c_int,
+            si_value: ::sigval,
+        }
+        (*(self as *const siginfo_t as *const siginfo_si_value)).si_value
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_union)] {
+        // Internal, for casts to access union fields
+        #[repr(C)]
+        struct sifields_sigchld {
+            si_pid: ::pid_t,
+            si_uid: ::uid_t,
+            si_status: ::c_int,
+            si_utime: ::c_long,
+            si_stime: ::c_long,
+        }
+        impl ::Copy for sifields_sigchld {}
+        impl ::Clone for sifields_sigchld {
+            fn clone(&self) -> sifields_sigchld {
+                *self
+            }
+        }
+
+        // Internal, for casts to access union fields
+        #[repr(C)]
+        union sifields {
+            _align_pointer: *mut ::c_void,
+            sigchld: sifields_sigchld,
+        }
+
+        // Internal, for casts to access union fields. Note that some variants
+        // of sifields start with a pointer, which makes the alignment of
+        // sifields vary on 32-bit and 64-bit architectures.
+        #[repr(C)]
+        struct siginfo_f {
+            _siginfo_base: [::c_int; 3],
+            sifields: sifields,
+        }
+
+        impl siginfo_t {
+            unsafe fn sifields(&self) -> &sifields {
+                &(*(self as *const siginfo_t as *const siginfo_f)).sifields
+            }
+
+            pub unsafe fn si_pid(&self) -> ::pid_t {
+                self.sifields().sigchld.si_pid
+            }
+
+            pub unsafe fn si_uid(&self) -> ::uid_t {
+                self.sifields().sigchld.si_uid
+            }
+
+            pub unsafe fn si_status(&self) -> ::c_int {
+                self.sifields().sigchld.si_status
+            }
+
+            pub unsafe fn si_utime(&self) -> ::c_long {
+                self.sifields().sigchld.si_utime
+            }
+
+            pub unsafe fn si_stime(&self) -> ::c_long {
+                self.sifields().sigchld.si_stime
+            }
+        }
+    }
+}
+
+s! {
+    pub struct aiocb {
+        pub aio_fildes: ::c_int,
+        pub aio_lio_opcode: ::c_int,
+        pub aio_reqprio: ::c_int,
+        pub aio_buf: *mut ::c_void,
+        pub aio_nbytes: ::size_t,
+        pub aio_sigevent: ::sigevent,
+        __td: *mut ::c_void,
+        __lock: [::c_int; 2],
+        __err: ::c_int,
+        __ret: ::ssize_t,
+        pub aio_offset: off_t,
+        __next: *mut ::c_void,
+        __prev: *mut ::c_void,
+        #[cfg(target_pointer_width = "32")]
+        __dummy4: [::c_char; 24],
+        #[cfg(target_pointer_width = "64")]
+        __dummy4: [::c_char; 16],
+    }
+
+    pub struct nlmsghdr {
+        pub nlmsg_len: u32,
+        pub nlmsg_type: u16,
+        pub nlmsg_flags: u16,
+        pub nlmsg_seq: u32,
+        pub nlmsg_pid: u32,
+    }
+
+    pub struct nlmsgerr {
+        pub error: ::c_int,
+        pub msg: nlmsghdr,
+    }
+
+    pub struct nlattr {
+        pub nla_len: u16,
+        pub nla_type: u16,
+    }
+
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: ::sigset_t,
+        pub sa_flags: ::c_int,
+        pub sa_restorer: ::Option<extern fn()>,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        #[cfg(target_endian = "little")]
+        pub f_fsid: ::c_ulong,
+        #[cfg(target_pointer_width = "32")]
+        __f_unused: ::c_int,
+        #[cfg(target_endian = "big")]
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        pub __c_ispeed: ::speed_t,
+        pub __c_ospeed: ::speed_t,
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct regex_t {
+        __re_nsub: ::size_t,
+        __opaque: *mut ::c_void,
+        __padding: [*mut ::c_void; 4usize],
+        __nsub2: ::size_t,
+        __padding2: ::c_char,
+    }
+
+    pub struct rtentry {
+        pub rt_pad1: ::c_ulong,
+        pub rt_dst: ::sockaddr,
+        pub rt_gateway: ::sockaddr,
+        pub rt_genmask: ::sockaddr,
+        pub rt_flags: ::c_ushort,
+        pub rt_pad2: ::c_short,
+        pub rt_pad3: ::c_ulong,
+        pub rt_tos: ::c_uchar,
+        pub rt_class: ::c_uchar,
+        #[cfg(target_pointer_width = "64")]
+        pub rt_pad4: [::c_short; 3usize],
+        #[cfg(not(target_pointer_width = "64"))]
+        pub rt_pad4: [::c_short; 1usize],
+        pub rt_metric: ::c_short,
+        pub rt_dev: *mut ::c_char,
+        pub rt_mtu: ::c_ulong,
+        pub rt_window: ::c_ulong,
+        pub rt_irtt: ::c_ushort,
+    }
+
+    pub struct ip_mreqn {
+        pub imr_multiaddr: ::in_addr,
+        pub imr_address: ::in_addr,
+        pub imr_ifindex: ::c_int,
+    }
+
+    pub struct __exit_status {
+        pub e_termination: ::c_short,
+        pub e_exit: ::c_short,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct sysinfo {
+        pub uptime: ::c_ulong,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub __reserved: [::c_char; 256],
+    }
+
+    // FIXME: musl added paddings and adjusted
+    // layout in 1.2.0 but our CI is still 1.1.24.
+    // So, I'm leaving some fields as comments for now.
+    // ref. https://github.com/bminor/musl/commit/
+    // 1e7f0fcd7ff2096904fd93a2ee6d12a2392be392
+    pub struct utmpx {
+        pub ut_type: ::c_short,
+        //__ut_pad1: ::c_short,
+        pub ut_pid: ::pid_t,
+        pub ut_line: [::c_char; 32],
+        pub ut_id: [::c_char; 4],
+        pub ut_user: [::c_char; 32],
+        pub ut_host: [::c_char; 256],
+        pub ut_exit: __exit_status,
+
+        //#[cfg(target_endian = "little")]
+        pub ut_session: ::c_long,
+        //#[cfg(target_endian = "little")]
+        //__ut_pad2: ::c_long,
+
+        //#[cfg(not(target_endian = "little"))]
+        //__ut_pad2: ::c_int,
+        //#[cfg(not(target_endian = "little"))]
+        //pub ut_session: ::c_int,
+
+        pub ut_tv: ::timeval,
+        pub ut_addr_v6: [::c_uint; 4],
+        __unused: [::c_char; 20],
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for sysinfo {
+            fn eq(&self, other: &sysinfo) -> bool {
+                self.uptime == other.uptime
+                    && self.loads == other.loads
+                    && self.totalram == other.totalram
+                    && self.freeram == other.freeram
+                    && self.sharedram == other.sharedram
+                    && self.bufferram == other.bufferram
+                    && self.totalswap == other.totalswap
+                    && self.freeswap == other.freeswap
+                    && self.procs == other.procs
+                    && self.pad == other.pad
+                    && self.totalhigh == other.totalhigh
+                    && self.freehigh == other.freehigh
+                    && self.mem_unit == other.mem_unit
+                    && self
+                        .__reserved
+                        .iter()
+                        .zip(other.__reserved.iter())
+                        .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for sysinfo {}
+
+        impl ::fmt::Debug for sysinfo {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sysinfo")
+                    .field("uptime", &self.uptime)
+                    .field("loads", &self.loads)
+                    .field("totalram", &self.totalram)
+                    .field("freeram", &self.freeram)
+                    .field("sharedram", &self.sharedram)
+                    .field("bufferram", &self.bufferram)
+                    .field("totalswap", &self.totalswap)
+                    .field("freeswap", &self.freeswap)
+                    .field("procs", &self.procs)
+                    .field("pad", &self.pad)
+                    .field("totalhigh", &self.totalhigh)
+                    .field("freehigh", &self.freehigh)
+                    .field("mem_unit", &self.mem_unit)
+                    // FIXME: .field("__reserved", &self.__reserved)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sysinfo {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.uptime.hash(state);
+                self.loads.hash(state);
+                self.totalram.hash(state);
+                self.freeram.hash(state);
+                self.sharedram.hash(state);
+                self.bufferram.hash(state);
+                self.totalswap.hash(state);
+                self.freeswap.hash(state);
+                self.procs.hash(state);
+                self.pad.hash(state);
+                self.totalhigh.hash(state);
+                self.freehigh.hash(state);
+                self.mem_unit.hash(state);
+                self.__reserved.hash(state);
+            }
+        }
+
+        impl PartialEq for utmpx {
+            fn eq(&self, other: &utmpx) -> bool {
+                self.ut_type == other.ut_type
+                    //&& self.__ut_pad1 == other.__ut_pad1
+                    && self.ut_pid == other.ut_pid
+                    && self.ut_line == other.ut_line
+                    && self.ut_id == other.ut_id
+                    && self.ut_user == other.ut_user
+                    && self
+                        .ut_host
+                        .iter()
+                        .zip(other.ut_host.iter())
+                        .all(|(a,b)| a == b)
+                    && self.ut_exit == other.ut_exit
+                    && self.ut_session == other.ut_session
+                    //&& self.__ut_pad2 == other.__ut_pad2
+                    && self.ut_tv == other.ut_tv
+                    && self.ut_addr_v6 == other.ut_addr_v6
+                    && self.__unused == other.__unused
+            }
+        }
+
+        impl Eq for utmpx {}
+
+        impl ::fmt::Debug for utmpx {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmpx")
+                    .field("ut_type", &self.ut_type)
+                    //.field("__ut_pad1", &self.__ut_pad1)
+                    .field("ut_pid", &self.ut_pid)
+                    .field("ut_line", &self.ut_line)
+                    .field("ut_id", &self.ut_id)
+                    .field("ut_user", &self.ut_user)
+                    //FIXME: .field("ut_host", &self.ut_host)
+                    .field("ut_exit", &self.ut_exit)
+                    .field("ut_session", &self.ut_session)
+                    //.field("__ut_pad2", &self.__ut_pad2)
+                    .field("ut_tv", &self.ut_tv)
+                    .field("ut_addr_v6", &self.ut_addr_v6)
+                    .field("__unused", &self.__unused)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utmpx {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_type.hash(state);
+                //self.__ut_pad1.hash(state);
+                self.ut_pid.hash(state);
+                self.ut_line.hash(state);
+                self.ut_id.hash(state);
+                self.ut_user.hash(state);
+                self.ut_host.hash(state);
+                self.ut_exit.hash(state);
+                self.ut_session.hash(state);
+                //self.__ut_pad2.hash(state);
+                self.ut_tv.hash(state);
+                self.ut_addr_v6.hash(state);
+                self.__unused.hash(state);
+            }
+        }
+    }
+}
+
+// include/sys/mman.h
+/*
+ * Huge page size encoding when MAP_HUGETLB is specified, and a huge page
+ * size other than the default is desired.  See hugetlb_encode.h.
+ * All known huge page size encodings are provided here.  It is the
+ * responsibility of the application to know which sizes are supported on
+ * the running system.  See mmap(2) man page for details.
+ */
+pub const MAP_HUGE_SHIFT: ::c_int = 26;
+pub const MAP_HUGE_MASK: ::c_int = 0x3f;
+
+pub const MAP_HUGE_64KB: ::c_int = 16 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_512KB: ::c_int = 19 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_1MB: ::c_int = 20 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_2MB: ::c_int = 21 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_8MB: ::c_int = 23 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_16MB: ::c_int = 24 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_32MB: ::c_int = 25 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_256MB: ::c_int = 28 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_512MB: ::c_int = 29 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_1GB: ::c_int = 30 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_2GB: ::c_int = 31 << MAP_HUGE_SHIFT;
+pub const MAP_HUGE_16GB: ::c_int = 34 << MAP_HUGE_SHIFT;
+
+pub const MS_RMT_MASK: ::c_ulong = 0x02800051;
+
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 512;
+pub const O_NOATIME: ::c_int = 0o1000000;
+pub const O_CLOEXEC: ::c_int = 0x80000;
+pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const BUFSIZ: ::c_uint = 1024;
+pub const TMP_MAX: ::c_uint = 10000;
+pub const FOPEN_MAX: ::c_uint = 1000;
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_EXEC: ::c_int = 0o10000000;
+pub const O_SEARCH: ::c_int = 0o10000000;
+pub const O_ACCMODE: ::c_int = 0o10000003;
+pub const O_NDELAY: ::c_int = O_NONBLOCK;
+pub const NI_MAXHOST: ::socklen_t = 255;
+pub const PTHREAD_STACK_MIN: ::size_t = 2048;
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+
+pub const RLIM_INFINITY: ::rlim_t = !0;
+pub const RLIMIT_RTTIME: ::c_int = 15;
+
+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;
+
+pub const SOCK_DCCP: ::c_int = 6;
+pub const SOCK_PACKET: ::c_int = 10;
+
+pub const TCP_COOKIE_TRANSACTIONS: ::c_int = 15;
+pub const TCP_THIN_LINEAR_TIMEOUTS: ::c_int = 16;
+pub const TCP_THIN_DUPACK: ::c_int = 17;
+pub const TCP_USER_TIMEOUT: ::c_int = 18;
+pub const TCP_REPAIR: ::c_int = 19;
+pub const TCP_REPAIR_QUEUE: ::c_int = 20;
+pub const TCP_QUEUE_SEQ: ::c_int = 21;
+pub const TCP_REPAIR_OPTIONS: ::c_int = 22;
+pub const TCP_FASTOPEN: ::c_int = 23;
+pub const TCP_TIMESTAMP: ::c_int = 24;
+pub const TCP_FASTOPEN_CONNECT: ::c_int = 30;
+
+#[deprecated(since = "0.2.55", note = "Use SIGSYS instead")]
+pub const SIGUNUSED: ::c_int = ::SIGSYS;
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+
+pub const CPU_SETSIZE: ::c_int = 128;
+
+pub const PTRACE_TRACEME: ::c_int = 0;
+pub const PTRACE_PEEKTEXT: ::c_int = 1;
+pub const PTRACE_PEEKDATA: ::c_int = 2;
+pub const PTRACE_PEEKUSER: ::c_int = 3;
+pub const PTRACE_POKETEXT: ::c_int = 4;
+pub const PTRACE_POKEDATA: ::c_int = 5;
+pub const PTRACE_POKEUSER: ::c_int = 6;
+pub const PTRACE_CONT: ::c_int = 7;
+pub const PTRACE_KILL: ::c_int = 8;
+pub const PTRACE_SINGLESTEP: ::c_int = 9;
+pub const PTRACE_GETREGS: ::c_int = 12;
+pub const PTRACE_SETREGS: ::c_int = 13;
+pub const PTRACE_GETFPREGS: ::c_int = 14;
+pub const PTRACE_SETFPREGS: ::c_int = 15;
+pub const PTRACE_ATTACH: ::c_int = 16;
+pub const PTRACE_DETACH: ::c_int = 17;
+pub const PTRACE_GETFPXREGS: ::c_int = 18;
+pub const PTRACE_SETFPXREGS: ::c_int = 19;
+pub const PTRACE_SYSCALL: ::c_int = 24;
+pub const PTRACE_SETOPTIONS: ::c_int = 0x4200;
+pub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;
+pub const PTRACE_GETSIGINFO: ::c_int = 0x4202;
+pub const PTRACE_SETSIGINFO: ::c_int = 0x4203;
+pub const PTRACE_GETREGSET: ::c_int = 0x4204;
+pub const PTRACE_SETREGSET: ::c_int = 0x4205;
+pub const PTRACE_SEIZE: ::c_int = 0x4206;
+pub const PTRACE_INTERRUPT: ::c_int = 0x4207;
+pub const PTRACE_LISTEN: ::c_int = 0x4208;
+pub const PTRACE_PEEKSIGINFO: ::c_int = 0x4209;
+
+pub const EPOLLWAKEUP: ::c_int = 0x20000000;
+
+pub const SEEK_DATA: ::c_int = 3;
+pub const SEEK_HOLE: ::c_int = 4;
+
+pub const EFD_NONBLOCK: ::c_int = ::O_NONBLOCK;
+
+pub const SFD_NONBLOCK: ::c_int = ::O_NONBLOCK;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+
+pub const CLOCK_SGI_CYCLE: ::clockid_t = 10;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_BUSY_POLL: ::c_int = 46;
+
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_LOCKS: ::c_int = 10;
+pub const RLIMIT_SIGPENDING: ::c_int = 11;
+pub const RLIMIT_MSGQUEUE: ::c_int = 12;
+pub const RLIMIT_NICE: ::c_int = 13;
+pub const RLIMIT_RTPRIO: ::c_int = 14;
+
+pub const REG_OK: ::c_int = 0;
+
+pub const TIOCSBRK: ::c_int = 0x5427;
+pub const TIOCCBRK: ::c_int = 0x5428;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+extern "C" {
+    pub fn sendmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_uint,
+    ) -> ::c_int;
+    pub fn recvmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_uint,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+
+    pub fn getrlimit64(resource: ::c_int, rlim: *mut ::rlimit64) -> ::c_int;
+    pub fn setrlimit64(resource: ::c_int, rlim: *const ::rlimit64) -> ::c_int;
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+    pub fn prlimit(
+        pid: ::pid_t,
+        resource: ::c_int,
+        new_limit: *const ::rlimit,
+        old_limit: *mut ::rlimit,
+    ) -> ::c_int;
+    pub fn prlimit64(
+        pid: ::pid_t,
+        resource: ::c_int,
+        new_limit: *const ::rlimit64,
+        old_limit: *mut ::rlimit64,
+    ) -> ::c_int;
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn ptrace(request: ::c_int, ...) -> ::c_long;
+    pub fn getpriority(which: ::c_int, who: ::id_t) -> ::c_int;
+    pub fn setpriority(which: ::c_int, who: ::id_t, prio: ::c_int) -> ::c_int;
+    pub fn pthread_getaffinity_np(
+        thread: ::pthread_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_setaffinity_np(
+        thread: ::pthread_t,
+        cpusetsize: ::size_t,
+        cpuset: *const ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn sched_getcpu() -> ::c_int;
+    pub fn memmem(
+        haystack: *const ::c_void,
+        haystacklen: ::size_t,
+        needle: *const ::c_void,
+        needlelen: ::size_t,
+    ) -> *mut ::c_void;
+    // Musl targets need the `mask` argument of `fanotify_mark` be specified
+    // `::c_ulonglong` instead of `u64` or there will be a type mismatch between
+    // `long long unsigned int` and the expected `uint64_t`.
+    pub fn fanotify_mark(
+        fd: ::c_int,
+        flags: ::c_uint,
+        mask: ::c_ulonglong,
+        dirfd: ::c_int,
+        path: *const ::c_char,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(any(target_arch = "x86_64",
+		 target_arch = "llir_x86_64",
+                 target_arch = "aarch64",
+                 target_arch = "mips64",
+                 target_arch = "powerpc64"))] {
+        mod b64;
+        pub use self::b64::*;
+    } else if #[cfg(any(target_arch = "x86",
+                        target_arch = "mips",
+                        target_arch = "powerpc",
+                        target_arch = "hexagon",
+                        target_arch = "arm"))] {
+        mod b32;
+        pub use self::b32::*;
+    } else { }
+}
diff --git a/library/libc/src/unix/linux_like/linux/no_align.rs b/library/libc/src/unix/linux_like/linux/no_align.rs
new file mode 100644
index 00000000..de64be5a
--- /dev/null
+++ b/library/libc/src/unix/linux_like/linux/no_align.rs
@@ -0,0 +1,99 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            pub struct pthread_mutexattr_t {
+                #[cfg(any(target_arch = "x86_64",
+                          target_arch = "powerpc64",
+                          target_arch = "mips64",
+                          target_arch = "s390x",
+                          target_arch = "sparc64",
+                          target_arch = "riscv64",
+                          target_arch = "riscv32",
+                          all(target_arch = "aarch64",
+                              target_env = "musl")))]
+                __align: [::c_int; 0],
+                #[cfg(not(any(target_arch = "x86_64",
+                              target_arch = "powerpc64",
+                              target_arch = "mips64",
+                              target_arch = "s390x",
+                              target_arch = "sparc64",
+                              target_arch = "riscv64",
+                              target_arch = "riscv32",
+                              all(target_arch = "aarch64",
+                                  target_env = "musl"))))]
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            pub struct pthread_rwlockattr_t {
+                #[cfg(target_env = "musl")]
+                __align: [::c_int; 0],
+                #[cfg(not(target_env = "musl"))]
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],
+            }
+
+            pub struct pthread_condattr_t {
+                __align: [::c_int; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+
+            pub struct fanotify_event_metadata {
+                __align: [::c_long; 0],
+                pub event_len: __u32,
+                pub vers: __u8,
+                pub reserved: __u8,
+                pub metadata_len: __u16,
+                pub mask: __u64,
+                pub fd: ::c_int,
+                pub pid: ::c_int,
+            }
+        }
+
+        s_no_extra_traits! {
+            pub struct pthread_cond_t {
+                #[cfg(target_env = "musl")]
+                __align: [*const ::c_void; 0],
+                #[cfg(not(target_env = "musl"))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            pub struct pthread_mutex_t {
+                #[cfg(any(target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc",
+                          target_arch = "sparc",
+                          all(target_arch = "x86_64",
+                              target_pointer_width = "32")))]
+                __align: [::c_long; 0],
+                #[cfg(not(any(target_arch = "mips",
+                              target_arch = "arm",
+                              target_arch = "powerpc",
+                              target_arch = "sparc",
+                              all(target_arch = "x86_64",
+                                  target_pointer_width = "32"))))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            pub struct pthread_rwlock_t {
+                #[cfg(any(target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc",
+                          target_arch = "sparc",
+                          all(target_arch = "x86_64",
+                              target_pointer_width = "32")))]
+                __align: [::c_long; 0],
+                #[cfg(not(any(target_arch = "mips",
+                              target_arch = "arm",
+                              target_arch = "powerpc",
+                              target_arch = "sparc",
+                              all(target_arch = "x86_64",
+                                  target_pointer_width = "32"))))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+        }
+    };
+}
diff --git a/library/libc/src/unix/linux_like/mod.rs b/library/libc/src/unix/linux_like/mod.rs
new file mode 100644
index 00000000..d5299b2c
--- /dev/null
+++ b/library/libc/src/unix/linux_like/mod.rs
@@ -0,0 +1,1705 @@
+pub type sa_family_t = u16;
+pub type speed_t = ::c_uint;
+pub type tcflag_t = ::c_uint;
+pub type clockid_t = ::c_int;
+pub type key_t = ::c_int;
+pub type id_t = ::c_uint;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+
+s! {
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct ip_mreq_source {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+        pub imr_sourceaddr: in_addr,
+    }
+
+    pub struct sockaddr {
+        pub sa_family: sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in {
+        pub sin_family: sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [u8; 8],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_family: sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    // The order of the `ai_addr` field in this struct is crucial
+    // for converting between the Rust and C types.
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: socklen_t,
+
+        #[cfg(any(target_os = "linux",
+                  target_os = "emscripten"))]
+        pub ai_addr: *mut ::sockaddr,
+
+        pub ai_canonname: *mut c_char,
+
+        #[cfg(target_os = "android")]
+        pub ai_addr: *mut ::sockaddr,
+
+        pub ai_next: *mut addrinfo,
+    }
+
+    pub struct sockaddr_ll {
+        pub sll_family: ::c_ushort,
+        pub sll_protocol: ::c_ushort,
+        pub sll_ifindex: ::c_int,
+        pub sll_hatype: ::c_ushort,
+        pub sll_pkttype: ::c_uchar,
+        pub sll_halen: ::c_uchar,
+        pub sll_addr: [::c_uchar; 8]
+    }
+
+    pub struct fd_set {
+        fds_bits: [::c_ulong; FD_SETSIZE / ULONG_SIZE],
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+        pub tm_gmtoff: ::c_long,
+        pub tm_zone: *const ::c_char,
+    }
+
+    pub struct sched_param {
+        pub sched_priority: ::c_int,
+        #[cfg(any(target_env = "musl", target_os = "emscripten"))]
+        pub sched_ss_low_priority: ::c_int,
+        #[cfg(any(target_env = "musl", target_os = "emscripten"))]
+        pub sched_ss_repl_period: ::timespec,
+        #[cfg(any(target_env = "musl", target_os = "emscripten"))]
+        pub sched_ss_init_budget: ::timespec,
+        #[cfg(any(target_env = "musl", target_os = "emscripten"))]
+        pub sched_ss_max_repl: ::c_int,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct in_pktinfo {
+        pub ipi_ifindex: ::c_int,
+        pub ipi_spec_dst: ::in_addr,
+        pub ipi_addr: ::in_addr,
+    }
+
+    pub struct ifaddrs {
+        pub ifa_next: *mut ifaddrs,
+        pub ifa_name: *mut c_char,
+        pub ifa_flags: ::c_uint,
+        pub ifa_addr: *mut ::sockaddr,
+        pub ifa_netmask: *mut ::sockaddr,
+        pub ifa_ifu: *mut ::sockaddr, // FIXME This should be a union
+        pub ifa_data: *mut ::c_void
+    }
+
+    pub struct in6_rtmsg {
+        rtmsg_dst: ::in6_addr,
+        rtmsg_src: ::in6_addr,
+        rtmsg_gateway: ::in6_addr,
+        rtmsg_type: u32,
+        rtmsg_dst_len: u16,
+        rtmsg_src_len: u16,
+        rtmsg_metric: u32,
+        rtmsg_info: ::c_ulong,
+        rtmsg_flags: u32,
+        rtmsg_ifindex: ::c_int,
+    }
+
+    pub struct arpreq {
+        pub arp_pa: ::sockaddr,
+        pub arp_ha: ::sockaddr,
+        pub arp_flags: ::c_int,
+        pub arp_netmask: ::sockaddr,
+        pub arp_dev: [::c_char; 16],
+    }
+
+    pub struct arpreq_old {
+        pub arp_pa: ::sockaddr,
+        pub arp_ha: ::sockaddr,
+        pub arp_flags: ::c_int,
+        pub arp_netmask: ::sockaddr,
+    }
+
+    pub struct arphdr {
+        pub ar_hrd: u16,
+        pub ar_pro: u16,
+        pub ar_hln: u8,
+        pub ar_pln: u8,
+        pub ar_op: u16,
+    }
+
+    pub struct mmsghdr {
+        pub msg_hdr: ::msghdr,
+        pub msg_len: ::c_uint,
+    }
+}
+
+s_no_extra_traits! {
+    #[cfg_attr(
+        any(
+            all(
+                target_arch = "x86",
+                not(target_env = "musl"),
+                not(target_os = "android")),
+            target_arch = "x86_64"),
+        repr(packed))]
+    pub struct epoll_event {
+        pub events: u32,
+        pub u64: u64,
+    }
+
+    pub struct sockaddr_un {
+        pub sun_family: sa_family_t,
+        pub sun_path: [::c_char; 108]
+    }
+
+    pub struct sockaddr_storage {
+        pub ss_family: sa_family_t,
+        __ss_align: ::size_t,
+        #[cfg(target_pointer_width = "32")]
+        __ss_pad2: [u8; 128 - 2 * 4],
+        #[cfg(target_pointer_width = "64")]
+        __ss_pad2: [u8; 128 - 2 * 8],
+    }
+
+    pub struct utsname {
+        pub sysname: [::c_char; 65],
+        pub nodename: [::c_char; 65],
+        pub release: [::c_char; 65],
+        pub version: [::c_char; 65],
+        pub machine: [::c_char; 65],
+        pub domainname: [::c_char; 65]
+    }
+
+    pub struct sigevent {
+        pub sigev_value: ::sigval,
+        pub sigev_signo: ::c_int,
+        pub sigev_notify: ::c_int,
+        // Actually a union.  We only expose sigev_notify_thread_id because it's
+        // the most useful member
+        pub sigev_notify_thread_id: ::c_int,
+        #[cfg(target_pointer_width = "64")]
+        __unused1: [::c_int; 11],
+        #[cfg(target_pointer_width = "32")]
+        __unused1: [::c_int; 12]
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for epoll_event {
+            fn eq(&self, other: &epoll_event) -> bool {
+                self.events == other.events
+                    && self.u64 == other.u64
+            }
+        }
+        impl Eq for epoll_event {}
+        impl ::fmt::Debug for epoll_event {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                let events = self.events;
+                let u64 = self.u64;
+                f.debug_struct("epoll_event")
+                    .field("events", &events)
+                    .field("u64", &u64)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for epoll_event {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                let events = self.events;
+                let u64 = self.u64;
+                events.hash(state);
+                u64.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_un {
+            fn eq(&self, other: &sockaddr_un) -> bool {
+                self.sun_family == other.sun_family
+                    && self
+                    .sun_path
+                    .iter()
+                    .zip(other.sun_path.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_un {}
+        impl ::fmt::Debug for sockaddr_un {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_un")
+                    .field("sun_family", &self.sun_family)
+                // FIXME: .field("sun_path", &self.sun_path)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_un {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sun_family.hash(state);
+                self.sun_path.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_family == other.ss_family
+                    && self
+                    .__ss_pad2
+                    .iter()
+                    .zip(other.__ss_pad2.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+
+        impl Eq for sockaddr_storage {}
+
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_align", &self.__ss_align)
+                // FIXME: .field("__ss_pad2", &self.__ss_pad2)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_family.hash(state);
+                self.__ss_pad2.hash(state);
+            }
+        }
+
+        impl PartialEq for utsname {
+            fn eq(&self, other: &utsname) -> bool {
+                self.sysname
+                    .iter()
+                    .zip(other.sysname.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .nodename
+                    .iter()
+                    .zip(other.nodename.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .release
+                    .iter()
+                    .zip(other.release.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .version
+                    .iter()
+                    .zip(other.version.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .machine
+                    .iter()
+                    .zip(other.machine.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .domainname
+                    .iter()
+                    .zip(other.domainname.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+
+        impl Eq for utsname {}
+
+        impl ::fmt::Debug for utsname {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utsname")
+                // FIXME: .field("sysname", &self.sysname)
+                // FIXME: .field("nodename", &self.nodename)
+                // FIXME: .field("release", &self.release)
+                // FIXME: .field("version", &self.version)
+                // FIXME: .field("machine", &self.machine)
+                // FIXME: .field("domainname", &self.domainname)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utsname {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sysname.hash(state);
+                self.nodename.hash(state);
+                self.release.hash(state);
+                self.version.hash(state);
+                self.machine.hash(state);
+                self.domainname.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_value == other.sigev_value
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_notify == other.sigev_notify
+                    && self.sigev_notify_thread_id
+                        == other.sigev_notify_thread_id
+            }
+        }
+        impl Eq for sigevent {}
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_value", &self.sigev_value)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_notify_thread_id",
+                           &self.sigev_notify_thread_id)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_value.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_notify.hash(state);
+                self.sigev_notify_thread_id.hash(state);
+            }
+        }
+    }
+}
+
+// intentionally not public, only used for fd_set
+cfg_if! {
+    if #[cfg(target_pointer_width = "32")] {
+        const ULONG_SIZE: usize = 32;
+    } else if #[cfg(target_pointer_width = "64")] {
+        const ULONG_SIZE: usize = 64;
+    } else {
+        // Unknown target_pointer_width
+    }
+}
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const RAND_MAX: ::c_int = 2147483647;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 2;
+pub const _IOLBF: ::c_int = 1;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+
+// Linux-specific fcntls
+pub const F_SETLEASE: ::c_int = 1024;
+pub const F_GETLEASE: ::c_int = 1025;
+pub const F_NOTIFY: ::c_int = 1026;
+pub const F_CANCELLK: ::c_int = 1029;
+pub const F_DUPFD_CLOEXEC: ::c_int = 1030;
+pub const F_SETPIPE_SZ: ::c_int = 1031;
+pub const F_GETPIPE_SZ: ::c_int = 1032;
+pub const F_ADD_SEALS: ::c_int = 1033;
+pub const F_GET_SEALS: ::c_int = 1034;
+
+pub const F_SEAL_SEAL: ::c_int = 0x0001;
+pub const F_SEAL_SHRINK: ::c_int = 0x0002;
+pub const F_SEAL_GROW: ::c_int = 0x0004;
+pub const F_SEAL_WRITE: ::c_int = 0x0008;
+
+// FIXME(#235): Include file sealing fcntls once we have a way to verify them.
+
+pub const SIGTRAP: ::c_int = 5;
+
+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;
+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;
+
+pub const CLOCK_REALTIME: ::clockid_t = 0;
+pub const CLOCK_MONOTONIC: ::clockid_t = 1;
+pub const CLOCK_PROCESS_CPUTIME_ID: ::clockid_t = 2;
+pub const CLOCK_THREAD_CPUTIME_ID: ::clockid_t = 3;
+pub const CLOCK_MONOTONIC_RAW: ::clockid_t = 4;
+pub const CLOCK_REALTIME_COARSE: ::clockid_t = 5;
+pub const CLOCK_MONOTONIC_COARSE: ::clockid_t = 6;
+pub const CLOCK_BOOTTIME: ::clockid_t = 7;
+pub const CLOCK_REALTIME_ALARM: ::clockid_t = 8;
+pub const CLOCK_BOOTTIME_ALARM: ::clockid_t = 9;
+pub const CLOCK_TAI: ::clockid_t = 11;
+pub const TIMER_ABSTIME: ::c_int = 1;
+
+pub const RUSAGE_SELF: ::c_int = 0;
+
+pub const O_RDONLY: ::c_int = 0;
+pub const O_WRONLY: ::c_int = 1;
+pub const O_RDWR: ::c_int = 2;
+
+pub const SOCK_CLOEXEC: ::c_int = O_CLOEXEC;
+
+pub const S_IFIFO: ::mode_t = 4096;
+pub const S_IFCHR: ::mode_t = 8192;
+pub const S_IFBLK: ::mode_t = 24576;
+pub const S_IFDIR: ::mode_t = 16384;
+pub const S_IFREG: ::mode_t = 32768;
+pub const S_IFLNK: ::mode_t = 40960;
+pub const S_IFSOCK: ::mode_t = 49152;
+pub const S_IFMT: ::mode_t = 61440;
+pub const S_IRWXU: ::mode_t = 448;
+pub const S_IXUSR: ::mode_t = 64;
+pub const S_IWUSR: ::mode_t = 128;
+pub const S_IRUSR: ::mode_t = 256;
+pub const S_IRWXG: ::mode_t = 56;
+pub const S_IXGRP: ::mode_t = 8;
+pub const S_IWGRP: ::mode_t = 16;
+pub const S_IRGRP: ::mode_t = 32;
+pub const S_IRWXO: ::mode_t = 7;
+pub const S_IXOTH: ::mode_t = 1;
+pub const S_IWOTH: ::mode_t = 2;
+pub const S_IROTH: ::mode_t = 4;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+
+pub const PROT_NONE: ::c_int = 0;
+pub const PROT_READ: ::c_int = 1;
+pub const PROT_WRITE: ::c_int = 2;
+pub const PROT_EXEC: ::c_int = 4;
+
+pub const LC_CTYPE: ::c_int = 0;
+pub const LC_NUMERIC: ::c_int = 1;
+pub const LC_TIME: ::c_int = 2;
+pub const LC_COLLATE: ::c_int = 3;
+pub const LC_MONETARY: ::c_int = 4;
+pub const LC_MESSAGES: ::c_int = 5;
+pub const LC_ALL: ::c_int = 6;
+pub const LC_CTYPE_MASK: ::c_int = 1 << LC_CTYPE;
+pub const LC_NUMERIC_MASK: ::c_int = 1 << LC_NUMERIC;
+pub const LC_TIME_MASK: ::c_int = 1 << LC_TIME;
+pub const LC_COLLATE_MASK: ::c_int = 1 << LC_COLLATE;
+pub const LC_MONETARY_MASK: ::c_int = 1 << LC_MONETARY;
+pub const LC_MESSAGES_MASK: ::c_int = 1 << LC_MESSAGES;
+// LC_ALL_MASK defined per platform
+
+pub const MAP_FILE: ::c_int = 0x0000;
+pub const MAP_SHARED: ::c_int = 0x0001;
+pub const MAP_PRIVATE: ::c_int = 0x0002;
+pub const MAP_FIXED: ::c_int = 0x0010;
+
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+// MS_ flags for msync(2)
+pub const MS_ASYNC: ::c_int = 0x0001;
+pub const MS_INVALIDATE: ::c_int = 0x0002;
+pub const MS_SYNC: ::c_int = 0x0004;
+
+// MS_ flags for mount(2)
+pub const MS_RDONLY: ::c_ulong = 0x01;
+pub const MS_NOSUID: ::c_ulong = 0x02;
+pub const MS_NODEV: ::c_ulong = 0x04;
+pub const MS_NOEXEC: ::c_ulong = 0x08;
+pub const MS_SYNCHRONOUS: ::c_ulong = 0x10;
+pub const MS_REMOUNT: ::c_ulong = 0x20;
+pub const MS_MANDLOCK: ::c_ulong = 0x40;
+pub const MS_DIRSYNC: ::c_ulong = 0x80;
+pub const MS_NOATIME: ::c_ulong = 0x0400;
+pub const MS_NODIRATIME: ::c_ulong = 0x0800;
+pub const MS_BIND: ::c_ulong = 0x1000;
+pub const MS_MOVE: ::c_ulong = 0x2000;
+pub const MS_REC: ::c_ulong = 0x4000;
+pub const MS_SILENT: ::c_ulong = 0x8000;
+pub const MS_POSIXACL: ::c_ulong = 0x010000;
+pub const MS_UNBINDABLE: ::c_ulong = 0x020000;
+pub const MS_PRIVATE: ::c_ulong = 0x040000;
+pub const MS_SLAVE: ::c_ulong = 0x080000;
+pub const MS_SHARED: ::c_ulong = 0x100000;
+pub const MS_RELATIME: ::c_ulong = 0x200000;
+pub const MS_KERNMOUNT: ::c_ulong = 0x400000;
+pub const MS_I_VERSION: ::c_ulong = 0x800000;
+pub const MS_STRICTATIME: ::c_ulong = 0x1000000;
+pub const MS_ACTIVE: ::c_ulong = 0x40000000;
+pub const MS_MGC_VAL: ::c_ulong = 0xc0ed0000;
+pub const MS_MGC_MSK: ::c_ulong = 0xffff0000;
+
+pub const SCM_RIGHTS: ::c_int = 0x01;
+pub const SCM_CREDENTIALS: ::c_int = 0x02;
+
+pub const PROT_GROWSDOWN: ::c_int = 0x1000000;
+pub const PROT_GROWSUP: ::c_int = 0x2000000;
+
+pub const MAP_TYPE: ::c_int = 0x000f;
+
+pub const MADV_NORMAL: ::c_int = 0;
+pub const MADV_RANDOM: ::c_int = 1;
+pub const MADV_SEQUENTIAL: ::c_int = 2;
+pub const MADV_WILLNEED: ::c_int = 3;
+pub const MADV_DONTNEED: ::c_int = 4;
+pub const MADV_FREE: ::c_int = 8;
+pub const MADV_REMOVE: ::c_int = 9;
+pub const MADV_DONTFORK: ::c_int = 10;
+pub const MADV_DOFORK: ::c_int = 11;
+pub const MADV_MERGEABLE: ::c_int = 12;
+pub const MADV_UNMERGEABLE: ::c_int = 13;
+pub const MADV_HUGEPAGE: ::c_int = 14;
+pub const MADV_NOHUGEPAGE: ::c_int = 15;
+pub const MADV_DONTDUMP: ::c_int = 16;
+pub const MADV_DODUMP: ::c_int = 17;
+pub const MADV_HWPOISON: ::c_int = 100;
+
+pub const IFF_UP: ::c_int = 0x1;
+pub const IFF_BROADCAST: ::c_int = 0x2;
+pub const IFF_DEBUG: ::c_int = 0x4;
+pub const IFF_LOOPBACK: ::c_int = 0x8;
+pub const IFF_POINTOPOINT: ::c_int = 0x10;
+pub const IFF_NOTRAILERS: ::c_int = 0x20;
+pub const IFF_RUNNING: ::c_int = 0x40;
+pub const IFF_NOARP: ::c_int = 0x80;
+pub const IFF_PROMISC: ::c_int = 0x100;
+pub const IFF_ALLMULTI: ::c_int = 0x200;
+pub const IFF_MASTER: ::c_int = 0x400;
+pub const IFF_SLAVE: ::c_int = 0x800;
+pub const IFF_MULTICAST: ::c_int = 0x1000;
+pub const IFF_PORTSEL: ::c_int = 0x2000;
+pub const IFF_AUTOMEDIA: ::c_int = 0x4000;
+pub const IFF_DYNAMIC: ::c_int = 0x8000;
+
+pub const SOL_IP: ::c_int = 0;
+pub const SOL_TCP: ::c_int = 6;
+pub const SOL_UDP: ::c_int = 17;
+pub const SOL_IPV6: ::c_int = 41;
+pub const SOL_ICMPV6: ::c_int = 58;
+pub const SOL_RAW: ::c_int = 255;
+pub const SOL_DECNET: ::c_int = 261;
+pub const SOL_X25: ::c_int = 262;
+pub const SOL_PACKET: ::c_int = 263;
+pub const SOL_ATM: ::c_int = 264;
+pub const SOL_AAL: ::c_int = 265;
+pub const SOL_IRDA: ::c_int = 266;
+pub const SOL_NETBEUI: ::c_int = 267;
+pub const SOL_LLC: ::c_int = 268;
+pub const SOL_DCCP: ::c_int = 269;
+pub const SOL_NETLINK: ::c_int = 270;
+pub const SOL_TIPC: ::c_int = 271;
+pub const SOL_BLUETOOTH: ::c_int = 274;
+pub const SOL_ALG: ::c_int = 279;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_UNIX: ::c_int = 1;
+pub const AF_LOCAL: ::c_int = 1;
+pub const AF_INET: ::c_int = 2;
+pub const AF_AX25: ::c_int = 3;
+pub const AF_IPX: ::c_int = 4;
+pub const AF_APPLETALK: ::c_int = 5;
+pub const AF_NETROM: ::c_int = 6;
+pub const AF_BRIDGE: ::c_int = 7;
+pub const AF_ATMPVC: ::c_int = 8;
+pub const AF_X25: ::c_int = 9;
+pub const AF_INET6: ::c_int = 10;
+pub const AF_ROSE: ::c_int = 11;
+pub const AF_DECnet: ::c_int = 12;
+pub const AF_NETBEUI: ::c_int = 13;
+pub const AF_SECURITY: ::c_int = 14;
+pub const AF_KEY: ::c_int = 15;
+pub const AF_NETLINK: ::c_int = 16;
+pub const AF_ROUTE: ::c_int = AF_NETLINK;
+pub const AF_PACKET: ::c_int = 17;
+pub const AF_ASH: ::c_int = 18;
+pub const AF_ECONET: ::c_int = 19;
+pub const AF_ATMSVC: ::c_int = 20;
+pub const AF_RDS: ::c_int = 21;
+pub const AF_SNA: ::c_int = 22;
+pub const AF_IRDA: ::c_int = 23;
+pub const AF_PPPOX: ::c_int = 24;
+pub const AF_WANPIPE: ::c_int = 25;
+pub const AF_LLC: ::c_int = 26;
+pub const AF_CAN: ::c_int = 29;
+pub const AF_TIPC: ::c_int = 30;
+pub const AF_BLUETOOTH: ::c_int = 31;
+pub const AF_IUCV: ::c_int = 32;
+pub const AF_RXRPC: ::c_int = 33;
+pub const AF_ISDN: ::c_int = 34;
+pub const AF_PHONET: ::c_int = 35;
+pub const AF_IEEE802154: ::c_int = 36;
+pub const AF_CAIF: ::c_int = 37;
+pub const AF_ALG: ::c_int = 38;
+
+pub const PF_UNSPEC: ::c_int = AF_UNSPEC;
+pub const PF_UNIX: ::c_int = AF_UNIX;
+pub const PF_LOCAL: ::c_int = AF_LOCAL;
+pub const PF_INET: ::c_int = AF_INET;
+pub const PF_AX25: ::c_int = AF_AX25;
+pub const PF_IPX: ::c_int = AF_IPX;
+pub const PF_APPLETALK: ::c_int = AF_APPLETALK;
+pub const PF_NETROM: ::c_int = AF_NETROM;
+pub const PF_BRIDGE: ::c_int = AF_BRIDGE;
+pub const PF_ATMPVC: ::c_int = AF_ATMPVC;
+pub const PF_X25: ::c_int = AF_X25;
+pub const PF_INET6: ::c_int = AF_INET6;
+pub const PF_ROSE: ::c_int = AF_ROSE;
+pub const PF_DECnet: ::c_int = AF_DECnet;
+pub const PF_NETBEUI: ::c_int = AF_NETBEUI;
+pub const PF_SECURITY: ::c_int = AF_SECURITY;
+pub const PF_KEY: ::c_int = AF_KEY;
+pub const PF_NETLINK: ::c_int = AF_NETLINK;
+pub const PF_ROUTE: ::c_int = AF_ROUTE;
+pub const PF_PACKET: ::c_int = AF_PACKET;
+pub const PF_ASH: ::c_int = AF_ASH;
+pub const PF_ECONET: ::c_int = AF_ECONET;
+pub const PF_ATMSVC: ::c_int = AF_ATMSVC;
+pub const PF_RDS: ::c_int = AF_RDS;
+pub const PF_SNA: ::c_int = AF_SNA;
+pub const PF_IRDA: ::c_int = AF_IRDA;
+pub const PF_PPPOX: ::c_int = AF_PPPOX;
+pub const PF_WANPIPE: ::c_int = AF_WANPIPE;
+pub const PF_LLC: ::c_int = AF_LLC;
+pub const PF_CAN: ::c_int = AF_CAN;
+pub const PF_TIPC: ::c_int = AF_TIPC;
+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;
+pub const PF_IUCV: ::c_int = AF_IUCV;
+pub const PF_RXRPC: ::c_int = AF_RXRPC;
+pub const PF_ISDN: ::c_int = AF_ISDN;
+pub const PF_PHONET: ::c_int = AF_PHONET;
+pub const PF_IEEE802154: ::c_int = AF_IEEE802154;
+pub const PF_CAIF: ::c_int = AF_CAIF;
+pub const PF_ALG: ::c_int = AF_ALG;
+
+pub const SOMAXCONN: ::c_int = 128;
+
+pub const MSG_OOB: ::c_int = 1;
+pub const MSG_PEEK: ::c_int = 2;
+pub const MSG_DONTROUTE: ::c_int = 4;
+pub const MSG_CTRUNC: ::c_int = 8;
+pub const MSG_TRUNC: ::c_int = 0x20;
+pub const MSG_DONTWAIT: ::c_int = 0x40;
+pub const MSG_EOR: ::c_int = 0x80;
+pub const MSG_WAITALL: ::c_int = 0x100;
+pub const MSG_FIN: ::c_int = 0x200;
+pub const MSG_SYN: ::c_int = 0x400;
+pub const MSG_CONFIRM: ::c_int = 0x800;
+pub const MSG_RST: ::c_int = 0x1000;
+pub const MSG_ERRQUEUE: ::c_int = 0x2000;
+pub const MSG_NOSIGNAL: ::c_int = 0x4000;
+pub const MSG_MORE: ::c_int = 0x8000;
+pub const MSG_WAITFORONE: ::c_int = 0x10000;
+pub const MSG_FASTOPEN: ::c_int = 0x20000000;
+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x40000000;
+
+pub const SCM_TIMESTAMP: ::c_int = SO_TIMESTAMP;
+
+pub const SOCK_RAW: ::c_int = 3;
+pub const SOCK_RDM: ::c_int = 4;
+pub const IP_TOS: ::c_int = 1;
+pub const IP_TTL: ::c_int = 2;
+pub const IP_HDRINCL: ::c_int = 3;
+pub const IP_OPTIONS: ::c_int = 4;
+pub const IP_ROUTER_ALERT: ::c_int = 5;
+pub const IP_RECVOPTS: ::c_int = 6;
+pub const IP_RETOPTS: ::c_int = 7;
+pub const IP_PKTINFO: ::c_int = 8;
+pub const IP_PKTOPTIONS: ::c_int = 9;
+pub const IP_MTU_DISCOVER: ::c_int = 10;
+pub const IP_RECVERR: ::c_int = 11;
+pub const IP_RECVTTL: ::c_int = 12;
+pub const IP_RECVTOS: ::c_int = 13;
+pub const IP_MTU: ::c_int = 14;
+pub const IP_FREEBIND: ::c_int = 15;
+pub const IP_IPSEC_POLICY: ::c_int = 16;
+pub const IP_XFRM_POLICY: ::c_int = 17;
+pub const IP_PASSSEC: ::c_int = 18;
+pub const IP_TRANSPARENT: ::c_int = 19;
+pub const IP_ORIGDSTADDR: ::c_int = 20;
+pub const IP_RECVORIGDSTADDR: ::c_int = IP_ORIGDSTADDR;
+pub const IP_MINTTL: ::c_int = 21;
+pub const IP_NODEFRAG: ::c_int = 22;
+pub const IP_CHECKSUM: ::c_int = 23;
+pub const IP_BIND_ADDRESS_NO_PORT: ::c_int = 24;
+pub const IP_MULTICAST_IF: ::c_int = 32;
+pub const IP_MULTICAST_TTL: ::c_int = 33;
+pub const IP_MULTICAST_LOOP: ::c_int = 34;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 35;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 36;
+pub const IP_UNBLOCK_SOURCE: ::c_int = 37;
+pub const IP_BLOCK_SOURCE: ::c_int = 38;
+pub const IP_ADD_SOURCE_MEMBERSHIP: ::c_int = 39;
+pub const IP_DROP_SOURCE_MEMBERSHIP: ::c_int = 40;
+pub const IP_MSFILTER: ::c_int = 41;
+pub const IP_MULTICAST_ALL: ::c_int = 49;
+pub const IP_UNICAST_IF: ::c_int = 50;
+
+pub const IP_DEFAULT_MULTICAST_TTL: ::c_int = 1;
+pub const IP_DEFAULT_MULTICAST_LOOP: ::c_int = 1;
+
+pub const IP_PMTUDISC_DONT: ::c_int = 0;
+pub const IP_PMTUDISC_WANT: ::c_int = 1;
+pub const IP_PMTUDISC_DO: ::c_int = 2;
+pub const IP_PMTUDISC_PROBE: ::c_int = 3;
+pub const IP_PMTUDISC_INTERFACE: ::c_int = 4;
+pub const IP_PMTUDISC_OMIT: ::c_int = 5;
+
+// IPPROTO_IP defined in src/unix/mod.rs
+/// Hop-by-hop option header
+pub const IPPROTO_HOPOPTS: ::c_int = 0;
+// IPPROTO_ICMP defined in src/unix/mod.rs
+/// group mgmt protocol
+pub const IPPROTO_IGMP: ::c_int = 2;
+/// for compatibility
+pub const IPPROTO_IPIP: ::c_int = 4;
+// IPPROTO_TCP defined in src/unix/mod.rs
+/// exterior gateway protocol
+pub const IPPROTO_EGP: ::c_int = 8;
+/// pup
+pub const IPPROTO_PUP: ::c_int = 12;
+// IPPROTO_UDP defined in src/unix/mod.rs
+/// xns idp
+pub const IPPROTO_IDP: ::c_int = 22;
+/// tp-4 w/ class negotiation
+pub const IPPROTO_TP: ::c_int = 29;
+/// DCCP
+pub const IPPROTO_DCCP: ::c_int = 33;
+// IPPROTO_IPV6 defined in src/unix/mod.rs
+/// IP6 routing header
+pub const IPPROTO_ROUTING: ::c_int = 43;
+/// IP6 fragmentation header
+pub const IPPROTO_FRAGMENT: ::c_int = 44;
+/// resource reservation
+pub const IPPROTO_RSVP: ::c_int = 46;
+/// General Routing Encap.
+pub const IPPROTO_GRE: ::c_int = 47;
+/// IP6 Encap Sec. Payload
+pub const IPPROTO_ESP: ::c_int = 50;
+/// IP6 Auth Header
+pub const IPPROTO_AH: ::c_int = 51;
+// IPPROTO_ICMPV6 defined in src/unix/mod.rs
+/// IP6 no next header
+pub const IPPROTO_NONE: ::c_int = 59;
+/// IP6 destination option
+pub const IPPROTO_DSTOPTS: ::c_int = 60;
+pub const IPPROTO_MTP: ::c_int = 92;
+pub const IPPROTO_BEETPH: ::c_int = 94;
+/// encapsulation header
+pub const IPPROTO_ENCAP: ::c_int = 98;
+/// Protocol indep. multicast
+pub const IPPROTO_PIM: ::c_int = 103;
+/// IP Payload Comp. Protocol
+pub const IPPROTO_COMP: ::c_int = 108;
+/// SCTP
+pub const IPPROTO_SCTP: ::c_int = 132;
+pub const IPPROTO_MH: ::c_int = 135;
+pub const IPPROTO_UDPLITE: ::c_int = 136;
+pub const IPPROTO_MPLS: ::c_int = 137;
+/// raw IP packet
+pub const IPPROTO_RAW: ::c_int = 255;
+
+pub const MCAST_EXCLUDE: ::c_int = 0;
+pub const MCAST_INCLUDE: ::c_int = 1;
+pub const MCAST_JOIN_GROUP: ::c_int = 42;
+pub const MCAST_BLOCK_SOURCE: ::c_int = 43;
+pub const MCAST_UNBLOCK_SOURCE: ::c_int = 44;
+pub const MCAST_LEAVE_GROUP: ::c_int = 45;
+pub const MCAST_JOIN_SOURCE_GROUP: ::c_int = 46;
+pub const MCAST_LEAVE_SOURCE_GROUP: ::c_int = 47;
+pub const MCAST_MSFILTER: ::c_int = 48;
+
+pub const IPV6_ADDRFORM: ::c_int = 1;
+pub const IPV6_2292PKTINFO: ::c_int = 2;
+pub const IPV6_2292HOPOPTS: ::c_int = 3;
+pub const IPV6_2292DSTOPTS: ::c_int = 4;
+pub const IPV6_2292RTHDR: ::c_int = 5;
+pub const IPV6_2292PKTOPTIONS: ::c_int = 6;
+pub const IPV6_CHECKSUM: ::c_int = 7;
+pub const IPV6_2292HOPLIMIT: ::c_int = 8;
+pub const IPV6_NEXTHOP: ::c_int = 9;
+pub const IPV6_AUTHHDR: ::c_int = 10;
+pub const IPV6_UNICAST_HOPS: ::c_int = 16;
+pub const IPV6_MULTICAST_IF: ::c_int = 17;
+pub const IPV6_MULTICAST_HOPS: ::c_int = 18;
+pub const IPV6_MULTICAST_LOOP: ::c_int = 19;
+pub const IPV6_ADD_MEMBERSHIP: ::c_int = 20;
+pub const IPV6_DROP_MEMBERSHIP: ::c_int = 21;
+pub const IPV6_ROUTER_ALERT: ::c_int = 22;
+pub const IPV6_MTU_DISCOVER: ::c_int = 23;
+pub const IPV6_MTU: ::c_int = 24;
+pub const IPV6_RECVERR: ::c_int = 25;
+pub const IPV6_V6ONLY: ::c_int = 26;
+pub const IPV6_JOIN_ANYCAST: ::c_int = 27;
+pub const IPV6_LEAVE_ANYCAST: ::c_int = 28;
+pub const IPV6_IPSEC_POLICY: ::c_int = 34;
+pub const IPV6_XFRM_POLICY: ::c_int = 35;
+pub const IPV6_HDRINCL: ::c_int = 36;
+pub const IPV6_RECVPKTINFO: ::c_int = 49;
+pub const IPV6_PKTINFO: ::c_int = 50;
+pub const IPV6_RECVHOPLIMIT: ::c_int = 51;
+pub const IPV6_HOPLIMIT: ::c_int = 52;
+pub const IPV6_RECVHOPOPTS: ::c_int = 53;
+pub const IPV6_HOPOPTS: ::c_int = 54;
+pub const IPV6_RTHDRDSTOPTS: ::c_int = 55;
+pub const IPV6_RECVRTHDR: ::c_int = 56;
+pub const IPV6_RTHDR: ::c_int = 57;
+pub const IPV6_RECVDSTOPTS: ::c_int = 58;
+pub const IPV6_DSTOPTS: ::c_int = 59;
+pub const IPV6_RECVPATHMTU: ::c_int = 60;
+pub const IPV6_PATHMTU: ::c_int = 61;
+pub const IPV6_DONTFRAG: ::c_int = 62;
+pub const IPV6_RECVTCLASS: ::c_int = 66;
+pub const IPV6_TCLASS: ::c_int = 67;
+pub const IPV6_AUTOFLOWLABEL: ::c_int = 70;
+pub const IPV6_ADDR_PREFERENCES: ::c_int = 72;
+pub const IPV6_MINHOPCOUNT: ::c_int = 73;
+pub const IPV6_ORIGDSTADDR: ::c_int = 74;
+pub const IPV6_RECVORIGDSTADDR: ::c_int = IPV6_ORIGDSTADDR;
+pub const IPV6_TRANSPARENT: ::c_int = 75;
+pub const IPV6_UNICAST_IF: ::c_int = 76;
+pub const IPV6_PREFER_SRC_TMP: ::c_int = 0x0001;
+pub const IPV6_PREFER_SRC_PUBLIC: ::c_int = 0x0002;
+pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: ::c_int = 0x0100;
+pub const IPV6_PREFER_SRC_COA: ::c_int = 0x0004;
+pub const IPV6_PREFER_SRC_HOME: ::c_int = 0x0400;
+pub const IPV6_PREFER_SRC_CGA: ::c_int = 0x0008;
+pub const IPV6_PREFER_SRC_NONCGA: ::c_int = 0x0800;
+
+pub const IPV6_PMTUDISC_DONT: ::c_int = 0;
+pub const IPV6_PMTUDISC_WANT: ::c_int = 1;
+pub const IPV6_PMTUDISC_DO: ::c_int = 2;
+pub const IPV6_PMTUDISC_PROBE: ::c_int = 3;
+pub const IPV6_PMTUDISC_INTERFACE: ::c_int = 4;
+pub const IPV6_PMTUDISC_OMIT: ::c_int = 5;
+
+pub const TCP_NODELAY: ::c_int = 1;
+pub const TCP_MAXSEG: ::c_int = 2;
+pub const TCP_CORK: ::c_int = 3;
+pub const TCP_KEEPIDLE: ::c_int = 4;
+pub const TCP_KEEPINTVL: ::c_int = 5;
+pub const TCP_KEEPCNT: ::c_int = 6;
+pub const TCP_SYNCNT: ::c_int = 7;
+pub const TCP_LINGER2: ::c_int = 8;
+pub const TCP_DEFER_ACCEPT: ::c_int = 9;
+pub const TCP_WINDOW_CLAMP: ::c_int = 10;
+pub const TCP_INFO: ::c_int = 11;
+pub const TCP_QUICKACK: ::c_int = 12;
+pub const TCP_CONGESTION: ::c_int = 13;
+
+pub const SO_DEBUG: ::c_int = 1;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const LOCK_SH: ::c_int = 1;
+pub const LOCK_EX: ::c_int = 2;
+pub const LOCK_NB: ::c_int = 4;
+pub const LOCK_UN: ::c_int = 8;
+
+pub const SS_ONSTACK: ::c_int = 1;
+pub const SS_DISABLE: ::c_int = 2;
+
+pub const PATH_MAX: ::c_int = 4096;
+
+pub const UIO_MAXIOV: ::c_int = 1024;
+
+pub const FD_SETSIZE: usize = 1024;
+
+pub const EPOLLIN: ::c_int = 0x1;
+pub const EPOLLPRI: ::c_int = 0x2;
+pub const EPOLLOUT: ::c_int = 0x4;
+pub const EPOLLRDNORM: ::c_int = 0x40;
+pub const EPOLLRDBAND: ::c_int = 0x80;
+pub const EPOLLWRNORM: ::c_int = 0x100;
+pub const EPOLLWRBAND: ::c_int = 0x200;
+pub const EPOLLMSG: ::c_int = 0x400;
+pub const EPOLLERR: ::c_int = 0x8;
+pub const EPOLLHUP: ::c_int = 0x10;
+pub const EPOLLET: ::c_int = 0x80000000;
+
+pub const EPOLL_CTL_ADD: ::c_int = 1;
+pub const EPOLL_CTL_MOD: ::c_int = 3;
+pub const EPOLL_CTL_DEL: ::c_int = 2;
+
+pub const MNT_DETACH: ::c_int = 0x2;
+pub const MNT_EXPIRE: ::c_int = 0x4;
+
+pub const Q_GETFMT: ::c_int = 0x800004;
+pub const Q_GETINFO: ::c_int = 0x800005;
+pub const Q_SETINFO: ::c_int = 0x800006;
+pub const QIF_BLIMITS: u32 = 1;
+pub const QIF_SPACE: u32 = 2;
+pub const QIF_ILIMITS: u32 = 4;
+pub const QIF_INODES: u32 = 8;
+pub const QIF_BTIME: u32 = 16;
+pub const QIF_ITIME: u32 = 32;
+pub const QIF_LIMITS: u32 = 5;
+pub const QIF_USAGE: u32 = 10;
+pub const QIF_TIMES: u32 = 48;
+pub const QIF_ALL: u32 = 63;
+
+pub const MNT_FORCE: ::c_int = 0x1;
+
+pub const Q_SYNC: ::c_int = 0x800001;
+pub const Q_QUOTAON: ::c_int = 0x800002;
+pub const Q_QUOTAOFF: ::c_int = 0x800003;
+pub const Q_GETQUOTA: ::c_int = 0x800007;
+pub const Q_SETQUOTA: ::c_int = 0x800008;
+
+pub const TCIOFF: ::c_int = 2;
+pub const TCION: ::c_int = 3;
+pub const TCOOFF: ::c_int = 0;
+pub const TCOON: ::c_int = 1;
+pub const TCIFLUSH: ::c_int = 0;
+pub const TCOFLUSH: ::c_int = 1;
+pub const TCIOFLUSH: ::c_int = 2;
+pub const NL0: ::tcflag_t = 0x00000000;
+pub const NL1: ::tcflag_t = 0x00000100;
+pub const TAB0: ::tcflag_t = 0x00000000;
+pub const CR0: ::tcflag_t = 0x00000000;
+pub const FF0: ::tcflag_t = 0x00000000;
+pub const BS0: ::tcflag_t = 0x00000000;
+pub const VT0: ::tcflag_t = 0x00000000;
+pub const VERASE: usize = 2;
+pub const VKILL: usize = 3;
+pub const VINTR: usize = 0;
+pub const VQUIT: usize = 1;
+pub const VLNEXT: usize = 15;
+pub const IGNBRK: ::tcflag_t = 0x00000001;
+pub const BRKINT: ::tcflag_t = 0x00000002;
+pub const IGNPAR: ::tcflag_t = 0x00000004;
+pub const PARMRK: ::tcflag_t = 0x00000008;
+pub const INPCK: ::tcflag_t = 0x00000010;
+pub const ISTRIP: ::tcflag_t = 0x00000020;
+pub const INLCR: ::tcflag_t = 0x00000040;
+pub const IGNCR: ::tcflag_t = 0x00000080;
+pub const ICRNL: ::tcflag_t = 0x00000100;
+pub const IXANY: ::tcflag_t = 0x00000800;
+pub const IMAXBEL: ::tcflag_t = 0x00002000;
+pub const OPOST: ::tcflag_t = 0x1;
+pub const CS5: ::tcflag_t = 0x00000000;
+pub const CRTSCTS: ::tcflag_t = 0x80000000;
+pub const ECHO: ::tcflag_t = 0x00000008;
+pub const OCRNL: ::tcflag_t = 0o000010;
+pub const ONOCR: ::tcflag_t = 0o000020;
+pub const ONLRET: ::tcflag_t = 0o000040;
+pub const OFILL: ::tcflag_t = 0o000100;
+pub const OFDEL: ::tcflag_t = 0o000200;
+
+pub const CLONE_VM: ::c_int = 0x100;
+pub const CLONE_FS: ::c_int = 0x200;
+pub const CLONE_FILES: ::c_int = 0x400;
+pub const CLONE_SIGHAND: ::c_int = 0x800;
+pub const CLONE_PTRACE: ::c_int = 0x2000;
+pub const CLONE_VFORK: ::c_int = 0x4000;
+pub const CLONE_PARENT: ::c_int = 0x8000;
+pub const CLONE_THREAD: ::c_int = 0x10000;
+pub const CLONE_NEWNS: ::c_int = 0x20000;
+pub const CLONE_SYSVSEM: ::c_int = 0x40000;
+pub const CLONE_SETTLS: ::c_int = 0x80000;
+pub const CLONE_PARENT_SETTID: ::c_int = 0x100000;
+pub const CLONE_CHILD_CLEARTID: ::c_int = 0x200000;
+pub const CLONE_DETACHED: ::c_int = 0x400000;
+pub const CLONE_UNTRACED: ::c_int = 0x800000;
+pub const CLONE_CHILD_SETTID: ::c_int = 0x01000000;
+pub const CLONE_NEWUTS: ::c_int = 0x04000000;
+pub const CLONE_NEWIPC: ::c_int = 0x08000000;
+pub const CLONE_NEWUSER: ::c_int = 0x10000000;
+pub const CLONE_NEWPID: ::c_int = 0x20000000;
+pub const CLONE_NEWNET: ::c_int = 0x40000000;
+pub const CLONE_IO: ::c_int = 0x80000000;
+pub const CLONE_NEWCGROUP: ::c_int = 0x02000000;
+
+pub const WNOHANG: ::c_int = 0x00000001;
+pub const WUNTRACED: ::c_int = 0x00000002;
+pub const WSTOPPED: ::c_int = WUNTRACED;
+pub const WEXITED: ::c_int = 0x00000004;
+pub const WCONTINUED: ::c_int = 0x00000008;
+pub const WNOWAIT: ::c_int = 0x01000000;
+
+// Options for personality(2).
+pub const ADDR_NO_RANDOMIZE: ::c_int = 0x0040000;
+pub const MMAP_PAGE_ZERO: ::c_int = 0x0100000;
+pub const ADDR_COMPAT_LAYOUT: ::c_int = 0x0200000;
+pub const READ_IMPLIES_EXEC: ::c_int = 0x0400000;
+pub const ADDR_LIMIT_32BIT: ::c_int = 0x0800000;
+pub const SHORT_INODE: ::c_int = 0x1000000;
+pub const WHOLE_SECONDS: ::c_int = 0x2000000;
+pub const STICKY_TIMEOUTS: ::c_int = 0x4000000;
+pub const ADDR_LIMIT_3GB: ::c_int = 0x8000000;
+
+// Options set using PTRACE_SETOPTIONS.
+pub const PTRACE_O_TRACESYSGOOD: ::c_int = 0x00000001;
+pub const PTRACE_O_TRACEFORK: ::c_int = 0x00000002;
+pub const PTRACE_O_TRACEVFORK: ::c_int = 0x00000004;
+pub const PTRACE_O_TRACECLONE: ::c_int = 0x00000008;
+pub const PTRACE_O_TRACEEXEC: ::c_int = 0x00000010;
+pub const PTRACE_O_TRACEVFORKDONE: ::c_int = 0x00000020;
+pub const PTRACE_O_TRACEEXIT: ::c_int = 0x00000040;
+pub const PTRACE_O_TRACESECCOMP: ::c_int = 0x00000080;
+pub const PTRACE_O_EXITKILL: ::c_int = 0x00100000;
+pub const PTRACE_O_SUSPEND_SECCOMP: ::c_int = 0x00200000;
+pub const PTRACE_O_MASK: ::c_int = 0x003000ff;
+
+// Wait extended result codes for the above trace options.
+pub const PTRACE_EVENT_FORK: ::c_int = 1;
+pub const PTRACE_EVENT_VFORK: ::c_int = 2;
+pub const PTRACE_EVENT_CLONE: ::c_int = 3;
+pub const PTRACE_EVENT_EXEC: ::c_int = 4;
+pub const PTRACE_EVENT_VFORK_DONE: ::c_int = 5;
+pub const PTRACE_EVENT_EXIT: ::c_int = 6;
+pub const PTRACE_EVENT_SECCOMP: ::c_int = 7;
+
+pub const __WNOTHREAD: ::c_int = 0x20000000;
+pub const __WALL: ::c_int = 0x40000000;
+pub const __WCLONE: ::c_int = 0x80000000;
+
+pub const SPLICE_F_MOVE: ::c_uint = 0x01;
+pub const SPLICE_F_NONBLOCK: ::c_uint = 0x02;
+pub const SPLICE_F_MORE: ::c_uint = 0x04;
+pub const SPLICE_F_GIFT: ::c_uint = 0x08;
+
+pub const RTLD_LOCAL: ::c_int = 0;
+pub const RTLD_LAZY: ::c_int = 1;
+
+pub const POSIX_FADV_NORMAL: ::c_int = 0;
+pub const POSIX_FADV_RANDOM: ::c_int = 1;
+pub const POSIX_FADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_FADV_WILLNEED: ::c_int = 3;
+
+pub const AT_FDCWD: ::c_int = -100;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x100;
+pub const AT_REMOVEDIR: ::c_int = 0x200;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x400;
+pub const AT_NO_AUTOMOUNT: ::c_int = 0x800;
+pub const AT_EMPTY_PATH: ::c_int = 0x1000;
+
+pub const LOG_CRON: ::c_int = 9 << 3;
+pub const LOG_AUTHPRIV: ::c_int = 10 << 3;
+pub const LOG_FTP: ::c_int = 11 << 3;
+pub const LOG_PERROR: ::c_int = 0x20;
+
+pub const PIPE_BUF: usize = 4096;
+
+pub const SI_LOAD_SHIFT: ::c_uint = 16;
+
+pub const CLD_EXITED: ::c_int = 1;
+pub const CLD_KILLED: ::c_int = 2;
+pub const CLD_DUMPED: ::c_int = 3;
+pub const CLD_TRAPPED: ::c_int = 4;
+pub const CLD_STOPPED: ::c_int = 5;
+pub const CLD_CONTINUED: ::c_int = 6;
+
+pub const SIGEV_SIGNAL: ::c_int = 0;
+pub const SIGEV_NONE: ::c_int = 1;
+pub const SIGEV_THREAD: ::c_int = 2;
+
+pub const P_ALL: idtype_t = 0;
+pub const P_PID: idtype_t = 1;
+pub const P_PGID: idtype_t = 2;
+cfg_if! {
+    if #[cfg(not(target_os = "emscripten"))] {
+        pub const P_PIDFD: idtype_t = 3;
+    }
+}
+
+pub const UTIME_OMIT: c_long = 1073741822;
+pub const UTIME_NOW: c_long = 1073741823;
+
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLPRI: ::c_short = 0x2;
+pub const POLLOUT: ::c_short = 0x4;
+pub const POLLERR: ::c_short = 0x8;
+pub const POLLHUP: ::c_short = 0x10;
+pub const POLLNVAL: ::c_short = 0x20;
+pub const POLLRDNORM: ::c_short = 0x040;
+pub const POLLRDBAND: ::c_short = 0x080;
+
+pub const IPTOS_LOWDELAY: u8 = 0x10;
+pub const IPTOS_THROUGHPUT: u8 = 0x08;
+pub const IPTOS_RELIABILITY: u8 = 0x04;
+pub const IPTOS_MINCOST: u8 = 0x02;
+
+pub const IPTOS_PREC_NETCONTROL: u8 = 0xe0;
+pub const IPTOS_PREC_INTERNETCONTROL: u8 = 0xc0;
+pub const IPTOS_PREC_CRITIC_ECP: u8 = 0xa0;
+pub const IPTOS_PREC_FLASHOVERRIDE: u8 = 0x80;
+pub const IPTOS_PREC_FLASH: u8 = 0x60;
+pub const IPTOS_PREC_IMMEDIATE: u8 = 0x40;
+pub const IPTOS_PREC_PRIORITY: u8 = 0x20;
+pub const IPTOS_PREC_ROUTINE: u8 = 0x00;
+
+pub const IPTOS_ECN_MASK: u8 = 0x03;
+pub const IPTOS_ECN_ECT1: u8 = 0x01;
+pub const IPTOS_ECN_ECT0: u8 = 0x02;
+pub const IPTOS_ECN_CE: u8 = 0x03;
+
+pub const IPOPT_COPY: u8 = 0x80;
+pub const IPOPT_CLASS_MASK: u8 = 0x60;
+pub const IPOPT_NUMBER_MASK: u8 = 0x1f;
+
+pub const IPOPT_CONTROL: u8 = 0x00;
+pub const IPOPT_RESERVED1: u8 = 0x20;
+pub const IPOPT_MEASUREMENT: u8 = 0x40;
+pub const IPOPT_RESERVED2: u8 = 0x60;
+pub const IPOPT_END: u8 = 0 | IPOPT_CONTROL;
+pub const IPOPT_NOOP: u8 = 1 | IPOPT_CONTROL;
+pub const IPOPT_SEC: u8 = 2 | IPOPT_CONTROL | IPOPT_COPY;
+pub const IPOPT_LSRR: u8 = 3 | IPOPT_CONTROL | IPOPT_COPY;
+pub const IPOPT_TIMESTAMP: u8 = 4 | IPOPT_MEASUREMENT;
+pub const IPOPT_RR: u8 = 7 | IPOPT_CONTROL;
+pub const IPOPT_SID: u8 = 8 | IPOPT_CONTROL | IPOPT_COPY;
+pub const IPOPT_SSRR: u8 = 9 | IPOPT_CONTROL | IPOPT_COPY;
+pub const IPOPT_RA: u8 = 20 | IPOPT_CONTROL | IPOPT_COPY;
+pub const IPVERSION: u8 = 4;
+pub const MAXTTL: u8 = 255;
+pub const IPDEFTTL: u8 = 64;
+pub const IPOPT_OPTVAL: u8 = 0;
+pub const IPOPT_OLEN: u8 = 1;
+pub const IPOPT_OFFSET: u8 = 2;
+pub const IPOPT_MINOFF: u8 = 4;
+pub const MAX_IPOPTLEN: u8 = 40;
+pub const IPOPT_NOP: u8 = IPOPT_NOOP;
+pub const IPOPT_EOL: u8 = IPOPT_END;
+pub const IPOPT_TS: u8 = IPOPT_TIMESTAMP;
+pub const IPOPT_TS_TSONLY: u8 = 0;
+pub const IPOPT_TS_TSANDADDR: u8 = 1;
+pub const IPOPT_TS_PRESPEC: u8 = 3;
+
+pub const ARPOP_RREQUEST: u16 = 3;
+pub const ARPOP_RREPLY: u16 = 4;
+pub const ARPOP_InREQUEST: u16 = 8;
+pub const ARPOP_InREPLY: u16 = 9;
+pub const ARPOP_NAK: u16 = 10;
+
+pub const ATF_NETMASK: ::c_int = 0x20;
+pub const ATF_DONTPUB: ::c_int = 0x40;
+
+pub const ARPHRD_NETROM: u16 = 0;
+pub const ARPHRD_ETHER: u16 = 1;
+pub const ARPHRD_EETHER: u16 = 2;
+pub const ARPHRD_AX25: u16 = 3;
+pub const ARPHRD_PRONET: u16 = 4;
+pub const ARPHRD_CHAOS: u16 = 5;
+pub const ARPHRD_IEEE802: u16 = 6;
+pub const ARPHRD_ARCNET: u16 = 7;
+pub const ARPHRD_APPLETLK: u16 = 8;
+pub const ARPHRD_DLCI: u16 = 15;
+pub const ARPHRD_ATM: u16 = 19;
+pub const ARPHRD_METRICOM: u16 = 23;
+pub const ARPHRD_IEEE1394: u16 = 24;
+pub const ARPHRD_EUI64: u16 = 27;
+pub const ARPHRD_INFINIBAND: u16 = 32;
+
+pub const ARPHRD_SLIP: u16 = 256;
+pub const ARPHRD_CSLIP: u16 = 257;
+pub const ARPHRD_SLIP6: u16 = 258;
+pub const ARPHRD_CSLIP6: u16 = 259;
+pub const ARPHRD_RSRVD: u16 = 260;
+pub const ARPHRD_ADAPT: u16 = 264;
+pub const ARPHRD_ROSE: u16 = 270;
+pub const ARPHRD_X25: u16 = 271;
+pub const ARPHRD_HWX25: u16 = 272;
+pub const ARPHRD_PPP: u16 = 512;
+pub const ARPHRD_CISCO: u16 = 513;
+pub const ARPHRD_HDLC: u16 = ARPHRD_CISCO;
+pub const ARPHRD_LAPB: u16 = 516;
+pub const ARPHRD_DDCMP: u16 = 517;
+pub const ARPHRD_RAWHDLC: u16 = 518;
+
+pub const ARPHRD_TUNNEL: u16 = 768;
+pub const ARPHRD_TUNNEL6: u16 = 769;
+pub const ARPHRD_FRAD: u16 = 770;
+pub const ARPHRD_SKIP: u16 = 771;
+pub const ARPHRD_LOOPBACK: u16 = 772;
+pub const ARPHRD_LOCALTLK: u16 = 773;
+pub const ARPHRD_FDDI: u16 = 774;
+pub const ARPHRD_BIF: u16 = 775;
+pub const ARPHRD_SIT: u16 = 776;
+pub const ARPHRD_IPDDP: u16 = 777;
+pub const ARPHRD_IPGRE: u16 = 778;
+pub const ARPHRD_PIMREG: u16 = 779;
+pub const ARPHRD_HIPPI: u16 = 780;
+pub const ARPHRD_ASH: u16 = 781;
+pub const ARPHRD_ECONET: u16 = 782;
+pub const ARPHRD_IRDA: u16 = 783;
+pub const ARPHRD_FCPP: u16 = 784;
+pub const ARPHRD_FCAL: u16 = 785;
+pub const ARPHRD_FCPL: u16 = 786;
+pub const ARPHRD_FCFABRIC: u16 = 787;
+pub const ARPHRD_IEEE802_TR: u16 = 800;
+pub const ARPHRD_IEEE80211: u16 = 801;
+pub const ARPHRD_IEEE80211_PRISM: u16 = 802;
+pub const ARPHRD_IEEE80211_RADIOTAP: u16 = 803;
+pub const ARPHRD_IEEE802154: u16 = 804;
+
+pub const ARPHRD_VOID: u16 = 0xFFFF;
+pub const ARPHRD_NONE: u16 = 0xFFFE;
+
+const_fn! {
+    {const} fn CMSG_ALIGN(len: usize) -> usize {
+        len + ::mem::size_of::<usize>() - 1 & !(::mem::size_of::<usize>() - 1)
+    }
+}
+
+f! {
+    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {
+        if (*mhdr).msg_controllen as usize >= ::mem::size_of::<cmsghdr>() {
+            (*mhdr).msg_control as *mut cmsghdr
+        } else {
+            0 as *mut cmsghdr
+        }
+    }
+
+    pub fn CMSG_DATA(cmsg: *const cmsghdr) -> *mut ::c_uchar {
+        cmsg.offset(1) as *mut ::c_uchar
+    }
+
+    pub {const} fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        (CMSG_ALIGN(length as usize) + CMSG_ALIGN(::mem::size_of::<cmsghdr>()))
+            as ::c_uint
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        CMSG_ALIGN(::mem::size_of::<cmsghdr>()) as ::c_uint + length
+    }
+
+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] &= !(1 << (fd % size));
+        return
+    }
+
+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0
+    }
+
+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] |= 1 << (fd % size);
+        return
+    }
+
+    pub fn FD_ZERO(set: *mut fd_set) -> () {
+        for slot in (*set).fds_bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+}
+
+safe_f! {
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        (status & 0xff) == 0x7f
+    }
+
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        status == 0xffff
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        ((status & 0x7f) + 1) as i8 >= 2
+    }
+
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        status & 0x7f
+    }
+
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & 0x7f) == 0
+    }
+
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {
+        (status & 0x80) != 0
+    }
+
+    pub {const} fn W_EXITCODE(ret: ::c_int, sig: ::c_int) -> ::c_int {
+        (ret << 8) | sig
+    }
+
+    pub {const} fn W_STOPCODE(sig: ::c_int) -> ::c_int {
+        (sig << 8) | 0x7f
+    }
+
+    pub {const} fn QCMD(cmd: ::c_int, type_: ::c_int) -> ::c_int {
+        (cmd << 8) | (type_ & 0x00ff)
+    }
+
+    pub {const} fn IPOPT_COPIED(o: u8) -> u8 {
+        o & IPOPT_COPY
+    }
+
+    pub {const} fn IPOPT_CLASS(o: u8) -> u8 {
+        o & IPOPT_CLASS_MASK
+    }
+
+    pub {const} fn IPOPT_NUMBER(o: u8) -> u8 {
+        o & IPOPT_NUMBER_MASK
+    }
+
+    pub {const} fn IPTOS_ECN(x: u8) -> u8 {
+        x & ::IPTOS_ECN_MASK
+    }
+}
+
+extern "C" {
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+    pub fn mincore(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        vec: *mut ::c_uchar,
+    ) -> ::c_int;
+
+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_settime(
+        clk_id: ::clockid_t,
+        tp: *const ::timespec,
+    ) -> ::c_int;
+    pub fn clock_getcpuclockid(
+        pid: ::pid_t,
+        clk_id: *mut ::clockid_t,
+    ) -> ::c_int;
+
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+
+    pub fn pthread_getattr_np(
+        native: ::pthread_t,
+        attr: *mut ::pthread_attr_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstack(
+        attr: *const ::pthread_attr_t,
+        stackaddr: *mut *mut ::c_void,
+        stacksize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;
+    pub fn setgroups(ngroups: ::size_t, ptr: *const ::gid_t) -> ::c_int;
+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;
+    pub fn statfs64(path: *const ::c_char, buf: *mut statfs64) -> ::c_int;
+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;
+    pub fn fstatfs64(fd: ::c_int, buf: *mut statfs64) -> ::c_int;
+    pub fn statvfs64(path: *const ::c_char, buf: *mut statvfs64) -> ::c_int;
+    pub fn fstatvfs64(fd: ::c_int, buf: *mut statvfs64) -> ::c_int;
+    pub fn memrchr(
+        cx: *const ::c_void,
+        c: ::c_int,
+        n: ::size_t,
+    ) -> *mut ::c_void;
+
+    pub fn posix_fadvise(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+        advise: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_fadvise64(
+        fd: ::c_int,
+        offset: ::off64_t,
+        len: ::off64_t,
+        advise: ::c_int,
+    ) -> ::c_int;
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn utimensat(
+        dirfd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn duplocale(base: ::locale_t) -> ::locale_t;
+    pub fn freelocale(loc: ::locale_t);
+    pub fn newlocale(
+        mask: ::c_int,
+        locale: *const ::c_char,
+        base: ::locale_t,
+    ) -> ::locale_t;
+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;
+    pub fn creat64(path: *const c_char, mode: mode_t) -> ::c_int;
+    pub fn fstat64(fildes: ::c_int, buf: *mut stat64) -> ::c_int;
+    pub fn fstatat64(
+        dirfd: ::c_int,
+        pathname: *const c_char,
+        buf: *mut stat64,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn ftruncate64(fd: ::c_int, length: off64_t) -> ::c_int;
+    pub fn lseek64(fd: ::c_int, offset: off64_t, whence: ::c_int) -> off64_t;
+    pub fn lstat64(path: *const c_char, buf: *mut stat64) -> ::c_int;
+    pub fn mmap64(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+        flags: ::c_int,
+        fd: ::c_int,
+        offset: off64_t,
+    ) -> *mut ::c_void;
+    pub fn open64(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;
+    pub fn openat64(
+        fd: ::c_int,
+        path: *const c_char,
+        oflag: ::c_int,
+        ...
+    ) -> ::c_int;
+    pub fn pread64(
+        fd: ::c_int,
+        buf: *mut ::c_void,
+        count: ::size_t,
+        offset: off64_t,
+    ) -> ::ssize_t;
+    pub fn preadv64(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off64_t,
+    ) -> ::ssize_t;
+    pub fn pwrite64(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::size_t,
+        offset: off64_t,
+    ) -> ::ssize_t;
+    pub fn pwritev64(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off64_t,
+    ) -> ::ssize_t;
+    pub fn readdir64(dirp: *mut ::DIR) -> *mut ::dirent64;
+    pub fn readdir64_r(
+        dirp: *mut ::DIR,
+        entry: *mut ::dirent64,
+        result: *mut *mut ::dirent64,
+    ) -> ::c_int;
+    pub fn stat64(path: *const c_char, buf: *mut stat64) -> ::c_int;
+    pub fn truncate64(path: *const c_char, length: off64_t) -> ::c_int;
+
+    pub fn mknodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: dev_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getclock(
+        attr: *const pthread_condattr_t,
+        clock_id: *mut clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setclock(
+        attr: *mut pthread_condattr_t,
+        clock_id: ::clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setpshared(
+        attr: *mut pthread_condattr_t,
+        pshared: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_setpshared(
+        attr: *mut pthread_mutexattr_t,
+        pshared: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_getpshared(
+        attr: *const pthread_rwlockattr_t,
+        val: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_setpshared(
+        attr: *mut pthread_rwlockattr_t,
+        val: ::c_int,
+    ) -> ::c_int;
+    pub fn ptsname_r(
+        fd: ::c_int,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+    pub fn clearenv() -> ::c_int;
+    pub fn waitid(
+        idtype: idtype_t,
+        id: id_t,
+        infop: *mut ::siginfo_t,
+        options: ::c_int,
+    ) -> ::c_int;
+    pub fn setreuid(ruid: ::uid_t, euid: ::uid_t) -> ::c_int;
+    pub fn setregid(rgid: ::gid_t, egid: ::gid_t) -> ::c_int;
+    pub fn getresuid(
+        ruid: *mut ::uid_t,
+        euid: *mut ::uid_t,
+        suid: *mut ::uid_t,
+    ) -> ::c_int;
+    pub fn getresgid(
+        rgid: *mut ::gid_t,
+        egid: *mut ::gid_t,
+        sgid: *mut ::gid_t,
+    ) -> ::c_int;
+    pub fn acct(filename: *const ::c_char) -> ::c_int;
+    pub fn brk(addr: *mut ::c_void) -> ::c_int;
+    pub fn sbrk(increment: ::intptr_t) -> *mut ::c_void;
+    #[deprecated(
+        since = "0.2.66",
+        note = "causes memory corruption, see rust-lang/libc#1596"
+    )]
+    pub fn vfork() -> ::pid_t;
+    pub fn setresgid(rgid: ::gid_t, egid: ::gid_t, sgid: ::gid_t) -> ::c_int;
+    pub fn setresuid(ruid: ::uid_t, euid: ::uid_t, suid: ::uid_t) -> ::c_int;
+    pub fn wait4(
+        pid: ::pid_t,
+        status: *mut ::c_int,
+        options: ::c_int,
+        rusage: *mut ::rusage,
+    ) -> ::pid_t;
+    pub fn openpty(
+        amaster: *mut ::c_int,
+        aslave: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *const termios,
+        winp: *const ::winsize,
+    ) -> ::c_int;
+    pub fn forkpty(
+        amaster: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *const termios,
+        winp: *const ::winsize,
+    ) -> ::pid_t;
+    pub fn login_tty(fd: ::c_int) -> ::c_int;
+    pub fn execvpe(
+        file: *const ::c_char,
+        argv: *const *const ::c_char,
+        envp: *const *const ::c_char,
+    ) -> ::c_int;
+    pub fn fexecve(
+        fd: ::c_int,
+        argv: *const *const ::c_char,
+        envp: *const *const ::c_char,
+    ) -> ::c_int;
+    pub fn getifaddrs(ifap: *mut *mut ::ifaddrs) -> ::c_int;
+    pub fn freeifaddrs(ifa: *mut ::ifaddrs);
+    pub fn bind(
+        socket: ::c_int,
+        address: *const ::sockaddr,
+        address_len: ::socklen_t,
+    ) -> ::c_int;
+
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+
+    pub fn sendmsg(
+        fd: ::c_int,
+        msg: *const ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn recvmsg(
+        fd: ::c_int,
+        msg: *mut ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_os = "emscripten")] {
+        mod emscripten;
+        pub use self::emscripten::*;
+    } else if #[cfg(target_os = "linux")] {
+        mod linux;
+        pub use self::linux::*;
+    } else if #[cfg(target_os = "android")] {
+        mod android;
+        pub use self::android::*;
+    } else {
+        // Unknown target_os
+    }
+}
diff --git a/library/libc/src/unix/mod.rs b/library/libc/src/unix/mod.rs
new file mode 100644
index 00000000..45a9aff4
--- /dev/null
+++ b/library/libc/src/unix/mod.rs
@@ -0,0 +1,1695 @@
+//! Definitions found commonly among almost all Unix derivatives
+//!
+//! More functions and definitions can be found in the more specific modules
+//! according to the platform in question.
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_float = f32;
+pub type c_double = f64;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+
+pub type size_t = usize;
+pub type ptrdiff_t = isize;
+pub type intptr_t = isize;
+pub type uintptr_t = usize;
+pub type ssize_t = isize;
+
+pub type pid_t = i32;
+pub type uid_t = u32;
+pub type gid_t = u32;
+pub type in_addr_t = u32;
+pub type in_port_t = u16;
+pub type sighandler_t = ::size_t;
+pub type cc_t = ::c_uchar;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum DIR {}
+impl ::Copy for DIR {}
+impl ::Clone for DIR {
+    fn clone(&self) -> DIR {
+        *self
+    }
+}
+pub type locale_t = *mut ::c_void;
+
+s! {
+    pub struct group {
+        pub gr_name: *mut ::c_char,
+        pub gr_passwd: *mut ::c_char,
+        pub gr_gid: ::gid_t,
+        pub gr_mem: *mut *mut ::c_char,
+    }
+
+    pub struct utimbuf {
+        pub actime: time_t,
+        pub modtime: time_t,
+    }
+
+    pub struct timeval {
+        pub tv_sec: time_t,
+        pub tv_usec: suseconds_t,
+    }
+
+    // linux x32 compatibility
+    // See https://sourceware.org/bugzilla/show_bug.cgi?id=16437
+    pub struct timespec {
+        pub tv_sec: time_t,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        pub tv_nsec: i64,
+        #[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+        pub tv_nsec: ::c_long,
+    }
+
+    pub struct rlimit {
+        pub rlim_cur: rlim_t,
+        pub rlim_max: rlim_t,
+    }
+
+    pub struct rusage {
+        pub ru_utime: timeval,
+        pub ru_stime: timeval,
+        pub ru_maxrss: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad1: u32,
+        pub ru_ixrss: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad2: u32,
+        pub ru_idrss: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad3: u32,
+        pub ru_isrss: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad4: u32,
+        pub ru_minflt: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad5: u32,
+        pub ru_majflt: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad6: u32,
+        pub ru_nswap: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad7: u32,
+        pub ru_inblock: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad8: u32,
+        pub ru_oublock: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad9: u32,
+        pub ru_msgsnd: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad10: u32,
+        pub ru_msgrcv: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad11: u32,
+        pub ru_nsignals: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad12: u32,
+        pub ru_nvcsw: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad13: u32,
+        pub ru_nivcsw: c_long,
+        #[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+        __pad14: u32,
+
+        #[cfg(any(target_env = "musl", target_os = "emscripten"))]
+        __reserved: [c_long; 16],
+    }
+
+    pub struct ipv6_mreq {
+        pub ipv6mr_multiaddr: in6_addr,
+        #[cfg(target_os = "android")]
+        pub ipv6mr_interface: ::c_int,
+        #[cfg(not(target_os = "android"))]
+        pub ipv6mr_interface: ::c_uint,
+    }
+
+    pub struct hostent {
+        pub h_name: *mut ::c_char,
+        pub h_aliases: *mut *mut ::c_char,
+        pub h_addrtype: ::c_int,
+        pub h_length: ::c_int,
+        pub h_addr_list: *mut *mut ::c_char,
+    }
+
+    pub struct iovec {
+        pub iov_base: *mut ::c_void,
+        pub iov_len: ::size_t,
+    }
+
+    pub struct pollfd {
+        pub fd: ::c_int,
+        pub events: ::c_short,
+        pub revents: ::c_short,
+    }
+
+    pub struct winsize {
+        pub ws_row: ::c_ushort,
+        pub ws_col: ::c_ushort,
+        pub ws_xpixel: ::c_ushort,
+        pub ws_ypixel: ::c_ushort,
+    }
+
+    pub struct linger {
+        pub l_onoff: ::c_int,
+        pub l_linger: ::c_int,
+    }
+
+    pub struct sigval {
+        // Actually a union of an int and a void*
+        pub sival_ptr: *mut ::c_void
+    }
+
+    // <sys/time.h>
+    pub struct itimerval {
+        pub it_interval: ::timeval,
+        pub it_value: ::timeval,
+    }
+
+    // <sys/times.h>
+    pub struct tms {
+        pub tms_utime: ::clock_t,
+        pub tms_stime: ::clock_t,
+        pub tms_cutime: ::clock_t,
+        pub tms_cstime: ::clock_t,
+    }
+
+    pub struct servent {
+        pub s_name: *mut ::c_char,
+        pub s_aliases: *mut *mut ::c_char,
+        pub s_port: ::c_int,
+        pub s_proto: *mut ::c_char,
+    }
+
+    pub struct protoent {
+        pub p_name: *mut ::c_char,
+        pub p_aliases: *mut *mut ::c_char,
+        pub p_proto: ::c_int,
+    }
+}
+
+pub const INT_MIN: c_int = -2147483648;
+pub const INT_MAX: c_int = 2147483647;
+
+pub const SIG_DFL: sighandler_t = 0 as sighandler_t;
+pub const SIG_IGN: sighandler_t = 1 as sighandler_t;
+pub const SIG_ERR: sighandler_t = !0 as sighandler_t;
+
+pub const DT_UNKNOWN: u8 = 0;
+pub const DT_FIFO: u8 = 1;
+pub const DT_CHR: u8 = 2;
+pub const DT_DIR: u8 = 4;
+pub const DT_BLK: u8 = 6;
+pub const DT_REG: u8 = 8;
+pub const DT_LNK: u8 = 10;
+pub const DT_SOCK: u8 = 12;
+
+cfg_if! {
+    if #[cfg(not(target_os = "redox"))] {
+        pub const FD_CLOEXEC: ::c_int = 0x1;
+    }
+}
+
+pub const USRQUOTA: ::c_int = 0;
+pub const GRPQUOTA: ::c_int = 1;
+
+pub const SIGIOT: ::c_int = 6;
+
+pub const S_ISUID: ::mode_t = 0x800;
+pub const S_ISGID: ::mode_t = 0x400;
+pub const S_ISVTX: ::mode_t = 0x200;
+
+cfg_if! {
+    if #[cfg(not(any(target_os = "illumos", target_os = "solaris")))] {
+        pub const IF_NAMESIZE: ::size_t = 16;
+        pub const IFNAMSIZ: ::size_t = IF_NAMESIZE;
+    }
+}
+
+pub const LOG_EMERG: ::c_int = 0;
+pub const LOG_ALERT: ::c_int = 1;
+pub const LOG_CRIT: ::c_int = 2;
+pub const LOG_ERR: ::c_int = 3;
+pub const LOG_WARNING: ::c_int = 4;
+pub const LOG_NOTICE: ::c_int = 5;
+pub const LOG_INFO: ::c_int = 6;
+pub const LOG_DEBUG: ::c_int = 7;
+
+pub const LOG_KERN: ::c_int = 0;
+pub const LOG_USER: ::c_int = 1 << 3;
+pub const LOG_MAIL: ::c_int = 2 << 3;
+pub const LOG_DAEMON: ::c_int = 3 << 3;
+pub const LOG_AUTH: ::c_int = 4 << 3;
+pub const LOG_SYSLOG: ::c_int = 5 << 3;
+pub const LOG_LPR: ::c_int = 6 << 3;
+pub const LOG_NEWS: ::c_int = 7 << 3;
+pub const LOG_UUCP: ::c_int = 8 << 3;
+pub const LOG_LOCAL0: ::c_int = 16 << 3;
+pub const LOG_LOCAL1: ::c_int = 17 << 3;
+pub const LOG_LOCAL2: ::c_int = 18 << 3;
+pub const LOG_LOCAL3: ::c_int = 19 << 3;
+pub const LOG_LOCAL4: ::c_int = 20 << 3;
+pub const LOG_LOCAL5: ::c_int = 21 << 3;
+pub const LOG_LOCAL6: ::c_int = 22 << 3;
+pub const LOG_LOCAL7: ::c_int = 23 << 3;
+
+pub const LOG_PID: ::c_int = 0x01;
+pub const LOG_CONS: ::c_int = 0x02;
+pub const LOG_ODELAY: ::c_int = 0x04;
+pub const LOG_NDELAY: ::c_int = 0x08;
+pub const LOG_NOWAIT: ::c_int = 0x10;
+
+pub const LOG_PRIMASK: ::c_int = 7;
+pub const LOG_FACMASK: ::c_int = 0x3f8;
+
+pub const PRIO_MIN: ::c_int = -20;
+pub const PRIO_MAX: ::c_int = 20;
+
+pub const IPPROTO_ICMP: ::c_int = 1;
+pub const IPPROTO_ICMPV6: ::c_int = 58;
+pub const IPPROTO_TCP: ::c_int = 6;
+pub const IPPROTO_UDP: ::c_int = 17;
+pub const IPPROTO_IP: ::c_int = 0;
+pub const IPPROTO_IPV6: ::c_int = 41;
+
+pub const INADDR_LOOPBACK: in_addr_t = 2130706433;
+pub const INADDR_ANY: in_addr_t = 0;
+pub const INADDR_BROADCAST: in_addr_t = 4294967295;
+pub const INADDR_NONE: in_addr_t = 4294967295;
+
+pub const ARPOP_REQUEST: u16 = 1;
+pub const ARPOP_REPLY: u16 = 2;
+
+pub const ATF_COM: ::c_int = 0x02;
+pub const ATF_PERM: ::c_int = 0x04;
+pub const ATF_PUBL: ::c_int = 0x08;
+pub const ATF_USETRAILERS: ::c_int = 0x10;
+
+cfg_if! {
+    if #[cfg(target_os = "l4re")] {
+        // required libraries for L4Re are linked externally, ATM
+    } else if #[cfg(feature = "std")] {
+        // cargo build, don't pull in anything extra as the libstd dep
+        // already pulls in all libs.
+    } else if #[cfg(all(target_os = "linux",
+                        any(target_env = "gnu", target_env = "uclibc"),
+                        feature = "rustc-dep-of-std"))] {
+        #[link(name = "util", kind = "static-nobundle",
+            cfg(target_feature = "crt-static"))]
+        #[link(name = "rt", kind = "static-nobundle",
+            cfg(target_feature = "crt-static"))]
+        #[link(name = "pthread", kind = "static-nobundle",
+            cfg(target_feature = "crt-static"))]
+        #[link(name = "m", kind = "static-nobundle",
+            cfg(target_feature = "crt-static"))]
+        #[link(name = "dl", kind = "static-nobundle",
+            cfg(target_feature = "crt-static"))]
+        #[link(name = "c", kind = "static-nobundle",
+            cfg(target_feature = "crt-static"))]
+        #[link(name = "gcc_eh", kind = "static-nobundle",
+            cfg(target_feature = "crt-static"))]
+        #[link(name = "gcc", kind = "static-nobundle",
+            cfg(target_feature = "crt-static"))]
+        #[link(name = "util", cfg(not(target_feature = "crt-static")))]
+        #[link(name = "rt", cfg(not(target_feature = "crt-static")))]
+        #[link(name = "pthread", cfg(not(target_feature = "crt-static")))]
+        #[link(name = "m", cfg(not(target_feature = "crt-static")))]
+        #[link(name = "dl", cfg(not(target_feature = "crt-static")))]
+        #[link(name = "c", cfg(not(target_feature = "crt-static")))]
+        extern {}
+    } else if #[cfg(target_env = "musl")] {
+        #[cfg_attr(feature = "rustc-dep-of-std",
+                   link(name = "c", kind = "static",
+                        cfg(target_feature = "crt-static")))]
+        #[cfg_attr(feature = "rustc-dep-of-std",
+                   link(name = "c", cfg(not(target_feature = "crt-static"))))]
+        extern {}
+    } else if #[cfg(target_os = "emscripten")] {
+        #[link(name = "c")]
+        extern {}
+    } else if #[cfg(all(target_os = "netbsd",
+                        feature = "rustc-dep-of-std",
+                        target_vendor = "rumprun"))] {
+        // Since we don't use -nodefaultlibs on Rumprun, libc is always pulled
+        // in automatically by the linker. We avoid passing it explicitly, as it
+        // causes some versions of binutils to crash with an assertion failure.
+        #[link(name = "m")]
+        extern {}
+    } else if #[cfg(any(target_os = "macos",
+                        target_os = "ios",
+                        target_os = "android",
+                        target_os = "openbsd"))] {
+        #[link(name = "c")]
+        #[link(name = "m")]
+        extern {}
+    } else if #[cfg(target_os = "haiku")] {
+        #[link(name = "root")]
+        #[link(name = "network")]
+        extern {}
+    } else if #[cfg(target_env = "newlib")] {
+        #[link(name = "c")]
+        #[link(name = "m")]
+        extern {}
+    } else if #[cfg(target_os = "hermit")] {
+        // no_default_libraries is set to false for HermitCore, so only a link
+        // to "pthread" needs to be added.
+        #[link(name = "pthread")]
+        extern {}
+    } else if #[cfg(target_env = "illumos")] {
+        #[link(name = "c")]
+        #[link(name = "m")]
+        extern {}
+    } else if #[cfg(target_os = "redox")] {
+        #[cfg_attr(feature = "rustc-dep-of-std",
+                   link(name = "c", kind = "static-nobundle",
+                        cfg(target_feature = "crt-static")))]
+        #[cfg_attr(feature = "rustc-dep-of-std",
+                   link(name = "c", cfg(not(target_feature = "crt-static"))))]
+        extern {}
+    } else {
+        #[link(name = "c")]
+        #[link(name = "m")]
+        #[link(name = "rt")]
+        #[link(name = "pthread")]
+        extern {}
+    }
+}
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum FILE {}
+impl ::Copy for FILE {}
+impl ::Clone for FILE {
+    fn clone(&self) -> FILE {
+        *self
+    }
+}
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum fpos_t {} // FIXME: fill this out with a struct
+impl ::Copy for fpos_t {}
+impl ::Clone for fpos_t {
+    fn clone(&self) -> fpos_t {
+        *self
+    }
+}
+
+extern "C" {
+    pub fn isalnum(c: c_int) -> c_int;
+    pub fn isalpha(c: c_int) -> c_int;
+    pub fn iscntrl(c: c_int) -> c_int;
+    pub fn isdigit(c: c_int) -> c_int;
+    pub fn isgraph(c: c_int) -> c_int;
+    pub fn islower(c: c_int) -> c_int;
+    pub fn isprint(c: c_int) -> c_int;
+    pub fn ispunct(c: c_int) -> c_int;
+    pub fn isspace(c: c_int) -> c_int;
+    pub fn isupper(c: c_int) -> c_int;
+    pub fn isxdigit(c: c_int) -> c_int;
+    pub fn isblank(c: c_int) -> c_int;
+    pub fn tolower(c: c_int) -> c_int;
+    pub fn toupper(c: c_int) -> c_int;
+    pub fn qsort(
+        base: *mut c_void,
+        num: size_t,
+        size: size_t,
+        compar: ::Option<
+            unsafe extern "C" fn(*const c_void, *const c_void) -> c_int,
+        >,
+    );
+    pub fn bsearch(
+        key: *const c_void,
+        base: *const c_void,
+        num: size_t,
+        size: size_t,
+        compar: ::Option<
+            unsafe extern "C" fn(*const c_void, *const c_void) -> c_int,
+        >,
+    ) -> *mut c_void;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "fopen$UNIX2003"
+    )]
+    pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "freopen$UNIX2003"
+    )]
+    pub fn freopen(
+        filename: *const c_char,
+        mode: *const c_char,
+        file: *mut FILE,
+    ) -> *mut FILE;
+    pub fn fmemopen(
+        buf: *mut c_void,
+        size: size_t,
+        mode: *const c_char,
+    ) -> *mut FILE;
+    pub fn open_memstream(
+        ptr: *mut *mut c_char,
+        sizeloc: *mut size_t,
+    ) -> *mut FILE;
+    pub fn open_wmemstream(
+        ptr: *mut *mut wchar_t,
+        sizeloc: *mut size_t,
+    ) -> *mut FILE;
+    pub fn fflush(file: *mut FILE) -> c_int;
+    pub fn fclose(file: *mut FILE) -> c_int;
+    pub fn remove(filename: *const c_char) -> c_int;
+    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;
+    pub fn tmpfile() -> *mut FILE;
+    pub fn setvbuf(
+        stream: *mut FILE,
+        buffer: *mut c_char,
+        mode: c_int,
+        size: size_t,
+    ) -> c_int;
+    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);
+    pub fn getchar() -> c_int;
+    pub fn putchar(c: c_int) -> c_int;
+    pub fn fgetc(stream: *mut FILE) -> c_int;
+    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE)
+        -> *mut c_char;
+    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "fputs$UNIX2003"
+    )]
+    pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;
+    pub fn puts(s: *const c_char) -> c_int;
+    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;
+    pub fn fread(
+        ptr: *mut c_void,
+        size: size_t,
+        nobj: size_t,
+        stream: *mut FILE,
+    ) -> size_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "fwrite$UNIX2003"
+    )]
+    pub fn fwrite(
+        ptr: *const c_void,
+        size: size_t,
+        nobj: size_t,
+        stream: *mut FILE,
+    ) -> size_t;
+    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;
+    pub fn ftell(stream: *mut FILE) -> c_long;
+    pub fn rewind(stream: *mut FILE);
+    #[cfg_attr(target_os = "netbsd", link_name = "__fgetpos50")]
+    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__fsetpos50")]
+    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;
+    pub fn feof(stream: *mut FILE) -> c_int;
+    pub fn ferror(stream: *mut FILE) -> c_int;
+    pub fn clearerr(stream: *mut FILE);
+    pub fn perror(s: *const c_char);
+    pub fn atoi(s: *const c_char) -> c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "strtod$UNIX2003"
+    )]
+    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;
+    pub fn strtol(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_long;
+    pub fn strtoul(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_ulong;
+    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;
+    pub fn malloc(size: size_t) -> *mut c_void;
+    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;
+    pub fn free(p: *mut c_void);
+    pub fn abort() -> !;
+    pub fn exit(status: c_int) -> !;
+    pub fn _exit(status: c_int) -> !;
+    pub fn atexit(cb: extern "C" fn()) -> c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "system$UNIX2003"
+    )]
+    pub fn system(s: *const c_char) -> c_int;
+    pub fn getenv(s: *const c_char) -> *mut c_char;
+
+    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;
+    pub fn strncpy(
+        dst: *mut c_char,
+        src: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strncat(
+        s: *mut c_char,
+        ct: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;
+    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strdup(cs: *const c_char) -> *mut c_char;
+    pub fn strndup(cs: *const c_char, n: size_t) -> *mut c_char;
+    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
+    pub fn strncasecmp(
+        s1: *const c_char,
+        s2: *const c_char,
+        n: size_t,
+    ) -> c_int;
+    pub fn strlen(cs: *const c_char) -> size_t;
+    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "strerror$UNIX2003"
+    )]
+    pub fn strerror(n: c_int) -> *mut c_char;
+    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;
+    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;
+    pub fn strsignal(sig: c_int) -> *mut c_char;
+    pub fn wcslen(buf: *const wchar_t) -> size_t;
+    pub fn wcstombs(
+        dest: *mut c_char,
+        src: *const wchar_t,
+        n: size_t,
+    ) -> ::size_t;
+
+    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;
+    pub fn wmemchr(cx: *const wchar_t, c: wchar_t, n: size_t) -> *mut wchar_t;
+    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;
+    pub fn memcpy(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memmove(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;
+}
+
+extern "C" {
+    #[cfg_attr(target_os = "netbsd", link_name = "__getpwnam50")]
+    pub fn getpwnam(name: *const ::c_char) -> *mut passwd;
+    #[cfg_attr(target_os = "netbsd", link_name = "__getpwuid50")]
+    pub fn getpwuid(uid: ::uid_t) -> *mut passwd;
+
+    pub fn fprintf(
+        stream: *mut ::FILE,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn printf(format: *const ::c_char, ...) -> ::c_int;
+    pub fn snprintf(
+        s: *mut ::c_char,
+        n: ::size_t,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn sprintf(s: *mut ::c_char, format: *const ::c_char, ...) -> ::c_int;
+    #[cfg_attr(target_os = "linux", link_name = "__isoc99_fscanf")]
+    pub fn fscanf(
+        stream: *mut ::FILE,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    #[cfg_attr(target_os = "linux", link_name = "__isoc99_scanf")]
+    pub fn scanf(format: *const ::c_char, ...) -> ::c_int;
+    #[cfg_attr(target_os = "linux", link_name = "__isoc99_sscanf")]
+    pub fn sscanf(s: *const ::c_char, format: *const ::c_char, ...)
+        -> ::c_int;
+    pub fn getchar_unlocked() -> ::c_int;
+    pub fn putchar_unlocked(c: ::c_int) -> ::c_int;
+
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    #[cfg_attr(target_os = "netbsd", link_name = "__socket30")]
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_socket")]
+    pub fn socket(domain: ::c_int, ty: ::c_int, protocol: ::c_int) -> ::c_int;
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "connect$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_connect")]
+    pub fn connect(
+        socket: ::c_int,
+        address: *const sockaddr,
+        len: socklen_t,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "listen$UNIX2003"
+    )]
+    pub fn listen(socket: ::c_int, backlog: ::c_int) -> ::c_int;
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "accept$UNIX2003"
+    )]
+    pub fn accept(
+        socket: ::c_int,
+        address: *mut sockaddr,
+        address_len: *mut socklen_t,
+    ) -> ::c_int;
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "getpeername$UNIX2003"
+    )]
+    pub fn getpeername(
+        socket: ::c_int,
+        address: *mut sockaddr,
+        address_len: *mut socklen_t,
+    ) -> ::c_int;
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "getsockname$UNIX2003"
+    )]
+    pub fn getsockname(
+        socket: ::c_int,
+        address: *mut sockaddr,
+        address_len: *mut socklen_t,
+    ) -> ::c_int;
+    pub fn setsockopt(
+        socket: ::c_int,
+        level: ::c_int,
+        name: ::c_int,
+        value: *const ::c_void,
+        option_len: socklen_t,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "socketpair$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_socketpair")]
+    pub fn socketpair(
+        domain: ::c_int,
+        type_: ::c_int,
+        protocol: ::c_int,
+        socket_vector: *mut ::c_int,
+    ) -> ::c_int;
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "sendto$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_sendto")]
+    pub fn sendto(
+        socket: ::c_int,
+        buf: *const ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *const sockaddr,
+        addrlen: socklen_t,
+    ) -> ::ssize_t;
+    pub fn shutdown(socket: ::c_int, how: ::c_int) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "chmod$UNIX2003"
+    )]
+    pub fn chmod(path: *const c_char, mode: mode_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "fchmod$UNIX2003"
+    )]
+    pub fn fchmod(fd: ::c_int, mode: mode_t) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", not(target_arch = "aarch64")),
+        link_name = "fstat$INODE64"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__fstat50")]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "fstat@FBSD_1.0"
+    )]
+    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;
+
+    pub fn mkdir(path: *const c_char, mode: mode_t) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", not(target_arch = "aarch64")),
+        link_name = "stat$INODE64"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__stat50")]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "stat@FBSD_1.0"
+    )]
+    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;
+
+    pub fn pclose(stream: *mut ::FILE) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "fdopen$UNIX2003"
+    )]
+    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;
+    pub fn fileno(stream: *mut ::FILE) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "open$UNIX2003"
+    )]
+    pub fn open(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "creat$UNIX2003"
+    )]
+    pub fn creat(path: *const c_char, mode: mode_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "fcntl$UNIX2003"
+    )]
+    pub fn fcntl(fd: ::c_int, cmd: ::c_int, ...) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86_64"),
+        link_name = "opendir$INODE64"
+    )]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "opendir$INODE64$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__opendir30")]
+    pub fn opendir(dirname: *const c_char) -> *mut ::DIR;
+
+    #[cfg_attr(
+        all(target_os = "macos", not(target_arch = "aarch64")),
+        link_name = "readdir$INODE64"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__readdir30")]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "readdir@FBSD_1.0"
+    )]
+    pub fn readdir(dirp: *mut ::DIR) -> *mut ::dirent;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "closedir$UNIX2003"
+    )]
+    pub fn closedir(dirp: *mut ::DIR) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86_64"),
+        link_name = "rewinddir$INODE64"
+    )]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "rewinddir$INODE64$UNIX2003"
+    )]
+    pub fn rewinddir(dirp: *mut ::DIR);
+
+    pub fn fchmodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn fchown(fd: ::c_int, owner: ::uid_t, group: ::gid_t) -> ::c_int;
+    pub fn fchownat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        owner: ::uid_t,
+        group: ::gid_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", not(target_arch = "aarch64")),
+        link_name = "fstatat$INODE64"
+    )]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "fstatat@FBSD_1.1"
+    )]
+    pub fn fstatat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        buf: *mut stat,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn linkat(
+        olddirfd: ::c_int,
+        oldpath: *const ::c_char,
+        newdirfd: ::c_int,
+        newpath: *const ::c_char,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn renameat(
+        olddirfd: ::c_int,
+        oldpath: *const ::c_char,
+        newdirfd: ::c_int,
+        newpath: *const ::c_char,
+    ) -> ::c_int;
+    pub fn symlinkat(
+        target: *const ::c_char,
+        newdirfd: ::c_int,
+        linkpath: *const ::c_char,
+    ) -> ::c_int;
+    pub fn unlinkat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;
+    pub fn alarm(seconds: ::c_uint) -> ::c_uint;
+    pub fn chdir(dir: *const c_char) -> ::c_int;
+    pub fn fchdir(dirfd: ::c_int) -> ::c_int;
+    pub fn chown(path: *const c_char, uid: uid_t, gid: gid_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "lchown$UNIX2003"
+    )]
+    pub fn lchown(path: *const c_char, uid: uid_t, gid: gid_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "close$NOCANCEL$UNIX2003"
+    )]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86_64"),
+        link_name = "close$NOCANCEL"
+    )]
+    pub fn close(fd: ::c_int) -> ::c_int;
+    pub fn dup(fd: ::c_int) -> ::c_int;
+    pub fn dup2(src: ::c_int, dst: ::c_int) -> ::c_int;
+    pub fn execl(path: *const c_char, arg0: *const c_char, ...) -> ::c_int;
+    pub fn execle(
+        path: *const ::c_char,
+        arg0: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn execlp(
+        file: *const ::c_char,
+        arg0: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn execv(prog: *const c_char, argv: *const *const c_char) -> ::c_int;
+    pub fn execve(
+        prog: *const c_char,
+        argv: *const *const c_char,
+        envp: *const *const c_char,
+    ) -> ::c_int;
+    pub fn execvp(c: *const c_char, argv: *const *const c_char) -> ::c_int;
+    pub fn fork() -> pid_t;
+    pub fn fpathconf(filedes: ::c_int, name: ::c_int) -> c_long;
+    pub fn getcwd(buf: *mut c_char, size: ::size_t) -> *mut c_char;
+    pub fn getegid() -> gid_t;
+    pub fn geteuid() -> uid_t;
+    pub fn getgid() -> gid_t;
+    pub fn getgroups(ngroups_max: ::c_int, groups: *mut gid_t) -> ::c_int;
+    #[cfg_attr(target_os = "illumos", link_name = "getloginx")]
+    pub fn getlogin() -> *mut c_char;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "getopt$UNIX2003"
+    )]
+    pub fn getopt(
+        argc: ::c_int,
+        argv: *const *mut c_char,
+        optstr: *const c_char,
+    ) -> ::c_int;
+    pub fn getpgid(pid: pid_t) -> pid_t;
+    pub fn getpgrp() -> pid_t;
+    pub fn getpid() -> pid_t;
+    pub fn getppid() -> pid_t;
+    pub fn getuid() -> uid_t;
+    pub fn isatty(fd: ::c_int) -> ::c_int;
+    pub fn link(src: *const c_char, dst: *const c_char) -> ::c_int;
+    pub fn lseek(fd: ::c_int, offset: off_t, whence: ::c_int) -> off_t;
+    pub fn pathconf(path: *const c_char, name: ::c_int) -> c_long;
+    pub fn pipe(fds: *mut ::c_int) -> ::c_int;
+    pub fn posix_memalign(
+        memptr: *mut *mut ::c_void,
+        align: ::size_t,
+        size: ::size_t,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "read$UNIX2003"
+    )]
+    pub fn read(fd: ::c_int, buf: *mut ::c_void, count: ::size_t)
+        -> ::ssize_t;
+    pub fn rmdir(path: *const c_char) -> ::c_int;
+    pub fn seteuid(uid: uid_t) -> ::c_int;
+    pub fn setegid(gid: gid_t) -> ::c_int;
+    pub fn setgid(gid: gid_t) -> ::c_int;
+    pub fn setpgid(pid: pid_t, pgid: pid_t) -> ::c_int;
+    pub fn setsid() -> pid_t;
+    pub fn setuid(uid: uid_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "sleep$UNIX2003"
+    )]
+    pub fn sleep(secs: ::c_uint) -> ::c_uint;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "nanosleep$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__nanosleep50")]
+    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::c_int;
+    pub fn tcgetpgrp(fd: ::c_int) -> pid_t;
+    pub fn tcsetpgrp(fd: ::c_int, pgrp: ::pid_t) -> ::c_int;
+    pub fn ttyname(fd: ::c_int) -> *mut c_char;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "ttyname_r$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "illumos", link_name = "__posix_ttyname_r")]
+    pub fn ttyname_r(
+        fd: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+    pub fn unlink(c: *const c_char) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "wait$UNIX2003"
+    )]
+    pub fn wait(status: *mut ::c_int) -> pid_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "waitpid$UNIX2003"
+    )]
+    pub fn waitpid(
+        pid: pid_t,
+        status: *mut ::c_int,
+        options: ::c_int,
+    ) -> pid_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "write$UNIX2003"
+    )]
+    pub fn write(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pread$UNIX2003"
+    )]
+    pub fn pread(
+        fd: ::c_int,
+        buf: *mut ::c_void,
+        count: ::size_t,
+        offset: off_t,
+    ) -> ::ssize_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pwrite$UNIX2003"
+    )]
+    pub fn pwrite(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::size_t,
+        offset: off_t,
+    ) -> ::ssize_t;
+    pub fn umask(mask: mode_t) -> mode_t;
+
+    #[cfg_attr(target_os = "netbsd", link_name = "__utime50")]
+    pub fn utime(file: *const c_char, buf: *const utimbuf) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "kill$UNIX2003"
+    )]
+    pub fn kill(pid: pid_t, sig: ::c_int) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "killpg$UNIX2003"
+    )]
+    pub fn killpg(pgrp: pid_t, sig: ::c_int) -> ::c_int;
+
+    pub fn mlock(addr: *const ::c_void, len: ::size_t) -> ::c_int;
+    pub fn munlock(addr: *const ::c_void, len: ::size_t) -> ::c_int;
+    pub fn mlockall(flags: ::c_int) -> ::c_int;
+    pub fn munlockall() -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "mmap$UNIX2003"
+    )]
+    pub fn mmap(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+        flags: ::c_int,
+        fd: ::c_int,
+        offset: off_t,
+    ) -> *mut ::c_void;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "munmap$UNIX2003"
+    )]
+    pub fn munmap(addr: *mut ::c_void, len: ::size_t) -> ::c_int;
+
+    pub fn if_nametoindex(ifname: *const c_char) -> ::c_uint;
+    pub fn if_indextoname(
+        ifindex: ::c_uint,
+        ifname: *mut ::c_char,
+    ) -> *mut ::c_char;
+
+    #[cfg_attr(
+        all(target_os = "macos", not(target_arch = "aarch64")),
+        link_name = "lstat$INODE64"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__lstat50")]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "lstat@FBSD_1.0"
+    )]
+    pub fn lstat(path: *const c_char, buf: *mut stat) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "fsync$UNIX2003"
+    )]
+    pub fn fsync(fd: ::c_int) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "setenv$UNIX2003"
+    )]
+    pub fn setenv(
+        name: *const c_char,
+        val: *const c_char,
+        overwrite: ::c_int,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "unsetenv$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__unsetenv13")]
+    pub fn unsetenv(name: *const c_char) -> ::c_int;
+
+    pub fn symlink(path1: *const c_char, path2: *const c_char) -> ::c_int;
+
+    pub fn ftruncate(fd: ::c_int, length: off_t) -> ::c_int;
+
+    pub fn signal(signum: ::c_int, handler: sighandler_t) -> sighandler_t;
+
+    #[cfg_attr(target_os = "netbsd", link_name = "__getrusage50")]
+    pub fn getrusage(resource: ::c_int, usage: *mut rusage) -> ::c_int;
+
+    #[cfg_attr(
+        any(target_os = "macos", target_os = "ios"),
+        link_name = "realpath$DARWIN_EXTSN"
+    )]
+    pub fn realpath(
+        pathname: *const ::c_char,
+        resolved: *mut ::c_char,
+    ) -> *mut ::c_char;
+
+    pub fn flock(fd: ::c_int, operation: ::c_int) -> ::c_int;
+
+    #[cfg_attr(target_os = "netbsd", link_name = "__times13")]
+    pub fn times(buf: *mut ::tms) -> ::clock_t;
+
+    pub fn pthread_self() -> ::pthread_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_join$UNIX2003"
+    )]
+    pub fn pthread_join(
+        native: ::pthread_t,
+        value: *mut *mut ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_exit(value: *mut ::c_void) -> !;
+    pub fn pthread_attr_init(attr: *mut ::pthread_attr_t) -> ::c_int;
+    pub fn pthread_attr_destroy(attr: *mut ::pthread_attr_t) -> ::c_int;
+    pub fn pthread_attr_setstacksize(
+        attr: *mut ::pthread_attr_t,
+        stack_size: ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_setdetachstate(
+        attr: *mut ::pthread_attr_t,
+        state: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_detach(thread: ::pthread_t) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__libc_thr_yield")]
+    pub fn sched_yield() -> ::c_int;
+    pub fn pthread_key_create(
+        key: *mut pthread_key_t,
+        dtor: ::Option<unsafe extern "C" fn(*mut ::c_void)>,
+    ) -> ::c_int;
+    pub fn pthread_key_delete(key: pthread_key_t) -> ::c_int;
+    pub fn pthread_getspecific(key: pthread_key_t) -> *mut ::c_void;
+    pub fn pthread_setspecific(
+        key: pthread_key_t,
+        value: *const ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_mutex_init(
+        lock: *mut pthread_mutex_t,
+        attr: *const pthread_mutexattr_t,
+    ) -> ::c_int;
+    pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> ::c_int;
+    pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> ::c_int;
+    pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> ::c_int;
+    pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> ::c_int;
+
+    pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_mutexattr_destroy$UNIX2003"
+    )]
+    pub fn pthread_mutexattr_destroy(
+        attr: *mut pthread_mutexattr_t,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_settype(
+        attr: *mut pthread_mutexattr_t,
+        _type: ::c_int,
+    ) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_cond_init$UNIX2003"
+    )]
+    pub fn pthread_cond_init(
+        cond: *mut pthread_cond_t,
+        attr: *const pthread_condattr_t,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_cond_wait$UNIX2003"
+    )]
+    pub fn pthread_cond_wait(
+        cond: *mut pthread_cond_t,
+        lock: *mut pthread_mutex_t,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_cond_timedwait$UNIX2003"
+    )]
+    pub fn pthread_cond_timedwait(
+        cond: *mut pthread_cond_t,
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> ::c_int;
+    pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> ::c_int;
+    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> ::c_int;
+    pub fn pthread_condattr_init(attr: *mut pthread_condattr_t) -> ::c_int;
+    pub fn pthread_condattr_destroy(attr: *mut pthread_condattr_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_rwlock_init$UNIX2003"
+    )]
+    pub fn pthread_rwlock_init(
+        lock: *mut pthread_rwlock_t,
+        attr: *const pthread_rwlockattr_t,
+    ) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_rwlock_destroy$UNIX2003"
+    )]
+    pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_rwlock_rdlock$UNIX2003"
+    )]
+    pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_rwlock_tryrdlock$UNIX2003"
+    )]
+    pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_rwlock_wrlock$UNIX2003"
+    )]
+    pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_rwlock_trywrlock$UNIX2003"
+    )]
+    pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pthread_rwlock_unlock$UNIX2003"
+    )]
+    pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> ::c_int;
+    pub fn pthread_rwlockattr_init(attr: *mut pthread_rwlockattr_t)
+        -> ::c_int;
+    pub fn pthread_rwlockattr_destroy(
+        attr: *mut pthread_rwlockattr_t,
+    ) -> ::c_int;
+
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_getsockopt")]
+    pub fn getsockopt(
+        sockfd: ::c_int,
+        level: ::c_int,
+        optname: ::c_int,
+        optval: *mut ::c_void,
+        optlen: *mut ::socklen_t,
+    ) -> ::c_int;
+    pub fn raise(signum: ::c_int) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigaction14")]
+    pub fn sigaction(
+        signum: ::c_int,
+        act: *const sigaction,
+        oldact: *mut sigaction,
+    ) -> ::c_int;
+
+    #[cfg_attr(target_os = "netbsd", link_name = "__utimes50")]
+    pub fn utimes(
+        filename: *const ::c_char,
+        times: *const ::timeval,
+    ) -> ::c_int;
+    pub fn dlopen(filename: *const ::c_char, flag: ::c_int) -> *mut ::c_void;
+    pub fn dlerror() -> *mut ::c_char;
+    pub fn dlsym(
+        handle: *mut ::c_void,
+        symbol: *const ::c_char,
+    ) -> *mut ::c_void;
+    pub fn dlclose(handle: *mut ::c_void) -> ::c_int;
+    pub fn dladdr(addr: *const ::c_void, info: *mut Dl_info) -> ::c_int;
+
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_getaddrinfo")]
+    pub fn getaddrinfo(
+        node: *const c_char,
+        service: *const c_char,
+        hints: *const addrinfo,
+        res: *mut *mut addrinfo,
+    ) -> ::c_int;
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    pub fn freeaddrinfo(res: *mut addrinfo);
+    pub fn gai_strerror(errcode: ::c_int) -> *const ::c_char;
+    #[cfg_attr(
+        any(
+            all(target_os = "linux", not(target_env = "musl")),
+            target_os = "freebsd",
+            target_os = "dragonfly",
+            target_os = "haiku"
+        ),
+        link_name = "__res_init"
+    )]
+    #[cfg_attr(
+        any(target_os = "macos", target_os = "ios"),
+        link_name = "res_9_init"
+    )]
+    pub fn res_init() -> ::c_int;
+
+    #[cfg_attr(target_os = "netbsd", link_name = "__gmtime_r50")]
+    #[cfg_attr(target_env = "musl", allow(deprecated))]
+    // FIXME: for `time_t`
+    pub fn gmtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;
+    #[cfg_attr(target_os = "netbsd", link_name = "__localtime_r50")]
+    #[cfg_attr(target_env = "musl", allow(deprecated))]
+    // FIXME: for `time_t`
+    pub fn localtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "mktime$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__mktime50")]
+    #[cfg_attr(target_env = "musl", allow(deprecated))]
+    // FIXME: for `time_t`
+    pub fn mktime(tm: *mut tm) -> time_t;
+    #[cfg_attr(target_os = "netbsd", link_name = "__time50")]
+    #[cfg_attr(target_env = "musl", allow(deprecated))]
+    // FIXME: for `time_t`
+    pub fn time(time: *mut time_t) -> time_t;
+    #[cfg_attr(target_os = "netbsd", link_name = "__gmtime50")]
+    #[cfg_attr(target_env = "musl", allow(deprecated))]
+    // FIXME: for `time_t`
+    pub fn gmtime(time_p: *const time_t) -> *mut tm;
+    #[cfg_attr(target_os = "netbsd", link_name = "__locatime50")]
+    #[cfg_attr(target_env = "musl", allow(deprecated))]
+    // FIXME: for `time_t`
+    pub fn localtime(time_p: *const time_t) -> *mut tm;
+    #[cfg_attr(target_os = "netbsd", link_name = "__difftime50")]
+    #[cfg_attr(target_env = "musl", allow(deprecated))]
+    // FIXME: for `time_t`
+    pub fn difftime(time1: time_t, time0: time_t) -> ::c_double;
+    #[cfg_attr(target_os = "netbsd", link_name = "__timegm50")]
+    #[cfg_attr(target_env = "musl", allow(deprecated))]
+    // FIXME: for `time_t`
+    pub fn timegm(tm: *mut ::tm) -> time_t;
+
+    #[cfg_attr(target_os = "netbsd", link_name = "__mknod50")]
+    #[cfg_attr(
+        all(target_os = "freebsd", any(freebsd11, freebsd10)),
+        link_name = "mknod@FBSD_1.0"
+    )]
+    pub fn mknod(
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: ::dev_t,
+    ) -> ::c_int;
+    pub fn gethostname(name: *mut ::c_char, len: ::size_t) -> ::c_int;
+    pub fn endservent();
+    pub fn getservbyname(
+        name: *const ::c_char,
+        proto: *const ::c_char,
+    ) -> *mut servent;
+    pub fn getservbyport(
+        port: ::c_int,
+        proto: *const ::c_char,
+    ) -> *mut servent;
+    pub fn getservent() -> *mut servent;
+    pub fn setservent(stayopen: ::c_int);
+    pub fn getprotobyname(name: *const ::c_char) -> *mut protoent;
+    pub fn getprotobynumber(proto: ::c_int) -> *mut protoent;
+    pub fn chroot(name: *const ::c_char) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "usleep$UNIX2003"
+    )]
+    pub fn usleep(secs: ::c_uint) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "send$UNIX2003"
+    )]
+    pub fn send(
+        socket: ::c_int,
+        buf: *const ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "recv$UNIX2003"
+    )]
+    pub fn recv(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "putenv$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__putenv50")]
+    pub fn putenv(string: *mut c_char) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "poll$UNIX2003"
+    )]
+    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::c_int) -> ::c_int;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86_64"),
+        link_name = "select$1050"
+    )]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "select$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__select50")]
+    pub fn select(
+        nfds: ::c_int,
+        readfs: *mut fd_set,
+        writefds: *mut fd_set,
+        errorfds: *mut fd_set,
+        timeout: *mut timeval,
+    ) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__setlocale50")]
+    pub fn setlocale(
+        category: ::c_int,
+        locale: *const ::c_char,
+    ) -> *mut ::c_char;
+    pub fn localeconv() -> *mut lconv;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "sem_wait$UNIX2003"
+    )]
+    pub fn sem_wait(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_trywait(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_post(sem: *mut sem_t) -> ::c_int;
+    pub fn statvfs(path: *const c_char, buf: *mut statvfs) -> ::c_int;
+    pub fn fstatvfs(fd: ::c_int, buf: *mut statvfs) -> ::c_int;
+
+    pub fn readlink(
+        path: *const c_char,
+        buf: *mut c_char,
+        bufsz: ::size_t,
+    ) -> ::ssize_t;
+
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigemptyset14")]
+    pub fn sigemptyset(set: *mut sigset_t) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigaddset14")]
+    pub fn sigaddset(set: *mut sigset_t, signum: ::c_int) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigfillset14")]
+    pub fn sigfillset(set: *mut sigset_t) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigdelset14")]
+    pub fn sigdelset(set: *mut sigset_t, signum: ::c_int) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigismember14")]
+    pub fn sigismember(set: *const sigset_t, signum: ::c_int) -> ::c_int;
+
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigprocmask14")]
+    pub fn sigprocmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    #[cfg_attr(target_os = "netbsd", link_name = "__sigpending14")]
+    pub fn sigpending(set: *mut sigset_t) -> ::c_int;
+
+    pub fn sysconf(name: ::c_int) -> ::c_long;
+
+    pub fn mkfifo(path: *const c_char, mode: mode_t) -> ::c_int;
+
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86_64"),
+        link_name = "pselect$1050"
+    )]
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "pselect$UNIX2003"
+    )]
+    #[cfg_attr(target_os = "netbsd", link_name = "__pselect50")]
+    pub fn pselect(
+        nfds: ::c_int,
+        readfs: *mut fd_set,
+        writefds: *mut fd_set,
+        errorfds: *mut fd_set,
+        timeout: *const timespec,
+        sigmask: *const sigset_t,
+    ) -> ::c_int;
+    pub fn fseeko(
+        stream: *mut ::FILE,
+        offset: ::off_t,
+        whence: ::c_int,
+    ) -> ::c_int;
+    pub fn ftello(stream: *mut ::FILE) -> ::off_t;
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "tcdrain$UNIX2003"
+    )]
+    pub fn tcdrain(fd: ::c_int) -> ::c_int;
+    pub fn cfgetispeed(termios: *const ::termios) -> ::speed_t;
+    pub fn cfgetospeed(termios: *const ::termios) -> ::speed_t;
+    pub fn cfsetispeed(termios: *mut ::termios, speed: ::speed_t) -> ::c_int;
+    pub fn cfsetospeed(termios: *mut ::termios, speed: ::speed_t) -> ::c_int;
+    pub fn tcgetattr(fd: ::c_int, termios: *mut ::termios) -> ::c_int;
+    pub fn tcsetattr(
+        fd: ::c_int,
+        optional_actions: ::c_int,
+        termios: *const ::termios,
+    ) -> ::c_int;
+    pub fn tcflow(fd: ::c_int, action: ::c_int) -> ::c_int;
+    pub fn tcflush(fd: ::c_int, action: ::c_int) -> ::c_int;
+    pub fn tcgetsid(fd: ::c_int) -> ::pid_t;
+    pub fn tcsendbreak(fd: ::c_int, duration: ::c_int) -> ::c_int;
+    pub fn mkstemp(template: *mut ::c_char) -> ::c_int;
+    pub fn mkdtemp(template: *mut ::c_char) -> *mut ::c_char;
+
+    pub fn tmpnam(ptr: *mut ::c_char) -> *mut ::c_char;
+
+    pub fn openlog(ident: *const ::c_char, logopt: ::c_int, facility: ::c_int);
+    pub fn closelog();
+    pub fn setlogmask(maskpri: ::c_int) -> ::c_int;
+    #[cfg_attr(target_os = "macos", link_name = "syslog$DARWIN_EXTSN")]
+    pub fn syslog(priority: ::c_int, message: *const ::c_char, ...);
+    #[cfg_attr(
+        all(target_os = "macos", target_arch = "x86"),
+        link_name = "nice$UNIX2003"
+    )]
+    pub fn nice(incr: ::c_int) -> ::c_int;
+
+    pub fn grantpt(fd: ::c_int) -> ::c_int;
+    pub fn posix_openpt(flags: ::c_int) -> ::c_int;
+    pub fn ptsname(fd: ::c_int) -> *mut ::c_char;
+    pub fn unlockpt(fd: ::c_int) -> ::c_int;
+
+    pub fn strcasestr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn getline(
+        lineptr: *mut *mut c_char,
+        n: *mut size_t,
+        stream: *mut FILE,
+    ) -> ssize_t;
+
+    pub fn lockf(fd: ::c_int, cmd: ::c_int, len: ::off_t) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(not(target_os = "redox"))] {
+        extern {
+            pub fn getsid(pid: pid_t) -> pid_t;
+            pub fn truncate(path: *const c_char, length: off_t) -> ::c_int;
+            #[cfg_attr(all(target_os = "macos", target_arch = "x86"),
+                       link_name = "pause$UNIX2003")]
+            pub fn pause() -> ::c_int;
+
+            pub fn readlinkat(dirfd: ::c_int,
+                              pathname: *const ::c_char,
+                              buf: *mut ::c_char,
+                              bufsiz: ::size_t) -> ::ssize_t;
+            pub fn mkdirat(dirfd: ::c_int, pathname: *const ::c_char,
+                           mode: ::mode_t) -> ::c_int;
+            pub fn openat(dirfd: ::c_int, pathname: *const ::c_char,
+                          flags: ::c_int, ...) -> ::c_int;
+
+            #[cfg_attr(all(target_os = "macos", target_arch = "x86_64"),
+                       link_name = "fdopendir$INODE64")]
+            #[cfg_attr(all(target_os = "macos", target_arch = "x86"),
+                       link_name = "fdopendir$INODE64$UNIX2003")]
+            pub fn fdopendir(fd: ::c_int) -> *mut ::DIR;
+
+            #[cfg_attr(all(target_os = "macos", not(target_arch = "aarch64")),
+                       link_name = "readdir_r$INODE64")]
+            #[cfg_attr(target_os = "netbsd", link_name = "__readdir_r30")]
+            #[cfg_attr(
+                all(target_os = "freebsd", any(freebsd11, freebsd10)),
+                link_name = "readdir_r@FBSD_1.0"
+            )]
+            #[allow(non_autolinks)] // FIXME: `<>` breaks line length limit.
+            /// The 64-bit libc on Solaris and illumos only has readdir_r. If a
+            /// 32-bit Solaris or illumos target is ever created, it should use
+            /// __posix_readdir_r. See libc(3LIB) on Solaris or illumos:
+            /// https://illumos.org/man/3lib/libc
+            /// https://docs.oracle.com/cd/E36784_01/html/E36873/libc-3lib.html
+            /// https://www.unix.com/man-page/opensolaris/3LIB/libc/
+            pub fn readdir_r(dirp: *mut ::DIR, entry: *mut ::dirent,
+                             result: *mut *mut ::dirent) -> ::c_int;
+        }
+    }
+}
+
+cfg_if! {
+   if #[cfg(not(any(target_os = "solaris", target_os = "illumos")))] {
+        extern {
+            pub fn cfmakeraw(termios: *mut ::termios);
+            pub fn cfsetspeed(termios: *mut ::termios,
+                              speed: ::speed_t) -> ::c_int;
+        }
+   }
+}
+
+cfg_if! {
+    if #[cfg(target_env = "uclibc")] {
+        mod uclibc;
+        pub use self::uclibc::*;
+    } else if #[cfg(target_env = "newlib")] {
+        mod newlib;
+        pub use self::newlib::*;
+    } else if #[cfg(any(target_os = "linux",
+                        target_os = "android",
+                        target_os = "emscripten"))] {
+        mod linux_like;
+        pub use self::linux_like::*;
+    } else if #[cfg(any(target_os = "macos",
+                        target_os = "ios",
+                        target_os = "freebsd",
+                        target_os = "dragonfly",
+                        target_os = "openbsd",
+                        target_os = "netbsd"))] {
+        mod bsd;
+        pub use self::bsd::*;
+    } else if #[cfg(any(target_os = "solaris",
+                        target_os = "illumos"))] {
+        mod solarish;
+        pub use self::solarish::*;
+    } else if #[cfg(target_os = "haiku")] {
+        mod haiku;
+        pub use self::haiku::*;
+    } else if #[cfg(target_os = "hermit")] {
+        mod hermit;
+        pub use self::hermit::*;
+    } else if #[cfg(target_os = "redox")] {
+        mod redox;
+        pub use self::redox::*;
+    } else {
+        // Unknown target_os
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_core_cvoid)] {
+        pub use ::ffi::c_void;
+    } else {
+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help
+        // enable more optimization opportunities around it recognizing things
+        // like malloc/free.
+        #[repr(u8)]
+        #[allow(missing_copy_implementations)]
+        #[allow(missing_debug_implementations)]
+        pub enum c_void {
+            // Two dummy variants so the #[repr] attribute can be used.
+            #[doc(hidden)]
+            __variant1,
+            #[doc(hidden)]
+            __variant2,
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    } else {
+        mod no_align;
+        pub use self::no_align::*;
+    }
+}
diff --git a/library/libc/src/unix/newlib/aarch64/mod.rs b/library/libc/src/unix/newlib/aarch64/mod.rs
new file mode 100644
index 00000000..71aa8949
--- /dev/null
+++ b/library/libc/src/unix/newlib/aarch64/mod.rs
@@ -0,0 +1,52 @@
+pub type clock_t = ::c_long;
+pub type c_char = u8;
+pub type wchar_t = u32;
+
+pub type c_long = i64;
+pub type c_ulong = u64;
+
+s! {
+    pub struct sockaddr {
+        pub sa_len: u8,
+        pub sa_family: ::sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_len: u8,
+        pub sin6_family: ::sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct sockaddr_in {
+        pub sin_len: u8,
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [::c_char; 8],
+    }
+}
+
+pub const AF_INET6: ::c_int = 23;
+
+pub const FIONBIO: ::c_ulong = 1;
+
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLPRI: ::c_short = 0x2;
+pub const POLLOUT: ::c_short = 0x4;
+pub const POLLERR: ::c_short = 0x8;
+pub const POLLHUP: ::c_short = 0x10;
+pub const POLLNVAL: ::c_short = 0x20;
+
+pub const SOL_SOCKET: ::c_int = 65535;
+
+pub const MSG_OOB: ::c_int = 1;
+pub const MSG_PEEK: ::c_int = 2;
+pub const MSG_DONTWAIT: ::c_int = 4;
+pub const MSG_DONTROUTE: ::c_int = 0;
+pub const MSG_WAITALL: ::c_int = 0;
+pub const MSG_MORE: ::c_int = 0;
+pub const MSG_NOSIGNAL: ::c_int = 0;
diff --git a/library/libc/src/unix/newlib/align.rs b/library/libc/src/unix/newlib/align.rs
new file mode 100644
index 00000000..db9beb83
--- /dev/null
+++ b/library/libc/src/unix/newlib/align.rs
@@ -0,0 +1,61 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "mips",
+                               target_arch = "arm",
+                               target_arch = "powerpc")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "mips",
+                                   target_arch = "arm",
+                                   target_arch = "powerpc"))),
+                       repr(align(8)))]
+            pub struct pthread_mutex_t { // Unverified
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "mips",
+                               target_arch = "arm",
+                               target_arch = "powerpc")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "mips",
+                                   target_arch = "arm",
+                                   target_arch = "powerpc"))),
+                       repr(align(8)))]
+            pub struct pthread_rwlock_t { // Unverified
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+
+            #[cfg_attr(any(target_pointer_width = "32",
+                           target_arch = "x86_64",
+                           target_arch = "powerpc64",
+                           target_arch = "mips64",
+                           target_arch = "s390x",
+                           target_arch = "sparc64"),
+                       repr(align(4)))]
+            #[cfg_attr(not(any(target_pointer_width = "32",
+                               target_arch = "x86_64",
+                               target_arch = "powerpc64",
+                               target_arch = "mips64",
+                               target_arch = "s390x",
+                               target_arch = "sparc64")),
+                       repr(align(8)))]
+            pub struct pthread_mutexattr_t { // Unverified
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            #[repr(align(8))]
+            pub struct pthread_cond_t { // Unverified
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_condattr_t { // Unverified
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+    };
+}
diff --git a/library/libc/src/unix/newlib/arm/mod.rs b/library/libc/src/unix/newlib/arm/mod.rs
new file mode 100644
index 00000000..78bea276
--- /dev/null
+++ b/library/libc/src/unix/newlib/arm/mod.rs
@@ -0,0 +1,54 @@
+pub type clock_t = ::c_long;
+pub type c_char = u8;
+pub type wchar_t = u32;
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+
+s! {
+    pub struct sockaddr {
+        pub sa_family: ::sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_family: ::sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct sockaddr_in {
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [u8; 8],
+    }
+
+    pub struct sockaddr_storage {
+        pub ss_family: ::sa_family_t,
+        pub __ss_padding: [u8; 26],
+    }
+}
+
+pub const AF_INET6: ::c_int = 23;
+
+pub const FIONBIO: ::c_ulong = 1;
+
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLPRI: ::c_short = 0x2;
+pub const POLLHUP: ::c_short = 0x4;
+pub const POLLERR: ::c_short = 0x8;
+pub const POLLOUT: ::c_short = 0x10;
+pub const POLLNVAL: ::c_short = 0x20;
+
+pub const SOL_SOCKET: ::c_int = 65535;
+
+pub const MSG_OOB: ::c_int = 1;
+pub const MSG_PEEK: ::c_int = 2;
+pub const MSG_DONTWAIT: ::c_int = 4;
+pub const MSG_DONTROUTE: ::c_int = 0;
+pub const MSG_WAITALL: ::c_int = 0;
+pub const MSG_MORE: ::c_int = 0;
+pub const MSG_NOSIGNAL: ::c_int = 0;
diff --git a/library/libc/src/unix/newlib/mod.rs b/library/libc/src/unix/newlib/mod.rs
new file mode 100644
index 00000000..270dd7b9
--- /dev/null
+++ b/library/libc/src/unix/newlib/mod.rs
@@ -0,0 +1,741 @@
+pub type blkcnt_t = i32;
+pub type blksize_t = i32;
+pub type clockid_t = ::c_ulong;
+pub type dev_t = u32;
+pub type fsblkcnt_t = u64;
+pub type fsfilcnt_t = u32;
+pub type id_t = u32;
+pub type ino_t = u32;
+pub type key_t = ::c_int;
+pub type loff_t = ::c_longlong;
+pub type mode_t = ::c_uint;
+pub type nfds_t = u32;
+pub type nlink_t = ::c_ushort;
+pub type off_t = i64;
+pub type pthread_t = ::c_ulong;
+pub type pthread_key_t = ::c_uint;
+pub type rlim_t = u32;
+pub type sa_family_t = u8;
+pub type socklen_t = u32;
+pub type speed_t = u32;
+pub type suseconds_t = i32;
+pub type tcflag_t = ::c_uint;
+pub type time_t = i32;
+pub type useconds_t = u32;
+
+s! {
+    // The order of the `ai_addr` field in this struct is crucial
+    // for converting between the Rust and C types.
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: socklen_t,
+
+        #[cfg(not(all(libc_cfg_target_vendor, target_arch = "powerpc",
+              target_vendor = "nintendo")))]
+        #[cfg(target_arch = "xtensa")]
+        pub ai_addr: *mut sockaddr,
+
+        pub ai_canonname: *mut ::c_char,
+
+        #[cfg(not(all(libc_cfg_target_vendor, target_arch = "powerpc",
+              target_vendor = "nintendo")))]
+        #[cfg(not(target_arch = "xtensa"))]
+        pub ai_addr: *mut sockaddr,
+
+        pub ai_next: *mut addrinfo,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct linger {
+        pub l_onoff: ::c_int,
+        pub l_linger: ::c_int,
+    }
+
+    pub struct in_addr {
+            pub s_addr: ::in_addr_t,
+    }
+
+    pub struct hostent {
+            pub h_name: *mut ::c_char,
+            pub h_aliases: *mut *mut ::c_char,
+            pub h_addrtype: ::c_int,
+            pub h_length: ::c_int,
+            pub h_addr_list: *mut *mut ::c_char,
+            pub h_addr: *mut ::c_char,
+    }
+
+    pub struct pollfd {
+        pub fd: ::c_int,
+        pub events: ::c_int,
+        pub revents: ::c_int,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: dev_t,
+        pub st_size: off_t,
+        pub st_atime: time_t,
+        pub st_spare1: ::c_long,
+        pub st_mtime: time_t,
+        pub st_spare2: ::c_long,
+        pub st_ctime: time_t,
+        pub st_spare3: ::c_long,
+        pub st_blksize: blksize_t,
+        pub st_blocks: blkcnt_t,
+        pub st_spare4: [::c_long; 2usize],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: fsblkcnt_t,
+        pub f_bfree: fsblkcnt_t,
+        pub f_bavail: fsblkcnt_t,
+        pub f_files: fsfilcnt_t,
+        pub f_ffree: fsfilcnt_t,
+        pub f_favail: fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+    }
+
+    pub struct sigset_t {
+        __val: [::c_ulong; 16],
+    }
+
+    pub struct sigaction {
+        pub sa_handler: extern fn(arg1: ::c_int),
+        pub sa_mask: sigset_t,
+        pub sa_flags: ::c_int,
+    }
+
+    pub struct dirent {
+        pub d_ino: ino_t,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256usize],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: usize,
+    }
+
+    pub struct fd_set { // Unverified
+        fds_bits: [::c_ulong; FD_SETSIZE / ULONG_SIZE],
+    }
+
+    pub struct passwd { // Unverified
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct termios { // Unverified
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+    }
+
+    pub struct sem_t { // Unverified
+        __size: [::c_char; 16],
+    }
+
+    pub struct Dl_info { // Unverified
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct utsname { // Unverified
+        pub sysname: [::c_char; 65],
+        pub nodename: [::c_char; 65],
+        pub release: [::c_char; 65],
+        pub version: [::c_char; 65],
+        pub machine: [::c_char; 65],
+        pub domainname: [::c_char; 65]
+    }
+
+    pub struct cpu_set_t { // Unverified
+        bits: [u32; 32],
+    }
+
+    pub struct pthread_attr_t { // Unverified
+        __size: [u64; 7]
+    }
+
+    pub struct pthread_rwlockattr_t { // Unverified
+        __lockkind: ::c_int,
+        __pshared: ::c_int,
+    }
+}
+
+// unverified constants
+align_const! {
+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+        size: [0; __SIZEOF_PTHREAD_MUTEX_T],
+    };
+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+        size: [0; __SIZEOF_PTHREAD_COND_T],
+    };
+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+        size: [0; __SIZEOF_PTHREAD_RWLOCK_T],
+    };
+}
+pub const NCCS: usize = 32;
+pub const __SIZEOF_PTHREAD_ATTR_T: usize = 56;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+pub const __SIZEOF_PTHREAD_BARRIER_T: usize = 32;
+pub const __SIZEOF_PTHREAD_BARRIERATTR_T: usize = 4;
+pub const __PTHREAD_MUTEX_HAVE_PREV: usize = 1;
+pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: usize = 1;
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;
+pub const FD_SETSIZE: usize = 1024;
+// intentionally not public, only used for fd_set
+const ULONG_SIZE: usize = 32;
+
+// Other constants
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const ENOMSG: ::c_int = 35;
+pub const EIDRM: ::c_int = 36;
+pub const EDEADLK: ::c_int = 45;
+pub const ENOLCK: ::c_int = 46;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENOLINK: ::c_int = 67;
+pub const EPROTO: ::c_int = 71;
+pub const EMULTIHOP: ::c_int = 74;
+pub const EBADMSG: ::c_int = 77;
+pub const EFTYPE: ::c_int = 79;
+pub const ENOSYS: ::c_int = 88;
+pub const ENOTEMPTY: ::c_int = 90;
+pub const ENAMETOOLONG: ::c_int = 91;
+pub const ELOOP: ::c_int = 92;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EAFNOSUPPORT: ::c_int = 106;
+pub const EPROTOTYPE: ::c_int = 107;
+pub const ENOTSOCK: ::c_int = 108;
+pub const ENOPROTOOPT: ::c_int = 109;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EADDRINUSE: ::c_int = 112;
+pub const ECONNABORTED: ::c_int = 113;
+pub const ENETUNREACH: ::c_int = 114;
+pub const ENETDOWN: ::c_int = 115;
+pub const ETIMEDOUT: ::c_int = 116;
+pub const EHOSTDOWN: ::c_int = 117;
+pub const EHOSTUNREACH: ::c_int = 118;
+pub const EINPROGRESS: ::c_int = 119;
+pub const EALREADY: ::c_int = 120;
+pub const EDESTADDRREQ: ::c_int = 121;
+pub const EMSGSIZE: ::c_int = 122;
+pub const EPROTONOSUPPORT: ::c_int = 123;
+pub const EADDRNOTAVAIL: ::c_int = 125;
+pub const ENETRESET: ::c_int = 126;
+pub const EISCONN: ::c_int = 127;
+pub const ENOTCONN: ::c_int = 128;
+pub const ETOOMANYREFS: ::c_int = 129;
+pub const EDQUOT: ::c_int = 132;
+pub const ESTALE: ::c_int = 133;
+pub const ENOTSUP: ::c_int = 134;
+pub const EILSEQ: ::c_int = 138;
+pub const EOVERFLOW: ::c_int = 139;
+pub const ECANCELED: ::c_int = 140;
+pub const ENOTRECOVERABLE: ::c_int = 141;
+pub const EOWNERDEAD: ::c_int = 142;
+pub const EWOULDBLOCK: ::c_int = 11;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+pub const F_GETOWN: ::c_int = 5;
+pub const F_SETOWN: ::c_int = 6;
+pub const F_GETLK: ::c_int = 7;
+pub const F_SETLK: ::c_int = 8;
+pub const F_SETLKW: ::c_int = 9;
+pub const F_RGETLK: ::c_int = 10;
+pub const F_RSETLK: ::c_int = 11;
+pub const F_CNVT: ::c_int = 12;
+pub const F_RSETLKW: ::c_int = 13;
+pub const F_DUPFD_CLOEXEC: ::c_int = 14;
+
+pub const O_RDONLY: ::c_int = 0;
+pub const O_WRONLY: ::c_int = 1;
+pub const O_RDWR: ::c_int = 2;
+pub const O_APPEND: ::c_int = 8;
+pub const O_CREAT: ::c_int = 512;
+pub const O_TRUNC: ::c_int = 1024;
+pub const O_EXCL: ::c_int = 2048;
+pub const O_SYNC: ::c_int = 8192;
+pub const O_NONBLOCK: ::c_int = 16384;
+
+pub const O_ACCMODE: ::c_int = 3;
+pub const O_CLOEXEC: ::c_int = 0x80000;
+
+pub const RTLD_LAZY: ::c_int = 0x1;
+
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+
+pub const FIOCLEX: ::c_ulong = 0x20006601;
+pub const FIONCLEX: ::c_ulong = 0x20006602;
+
+pub const S_BLKSIZE: ::mode_t = 1024;
+pub const S_IREAD: ::mode_t = 256;
+pub const S_IWRITE: ::mode_t = 128;
+pub const S_IEXEC: ::mode_t = 64;
+pub const S_ENFMT: ::mode_t = 1024;
+pub const S_IFMT: ::mode_t = 61440;
+pub const S_IFDIR: ::mode_t = 16384;
+pub const S_IFCHR: ::mode_t = 8192;
+pub const S_IFBLK: ::mode_t = 24576;
+pub const S_IFREG: ::mode_t = 32768;
+pub const S_IFLNK: ::mode_t = 40960;
+pub const S_IFSOCK: ::mode_t = 49152;
+pub const S_IFIFO: ::mode_t = 4096;
+pub const S_IRUSR: ::mode_t = 256;
+pub const S_IWUSR: ::mode_t = 128;
+pub const S_IXUSR: ::mode_t = 64;
+pub const S_IRGRP: ::mode_t = 32;
+pub const S_IWGRP: ::mode_t = 16;
+pub const S_IXGRP: ::mode_t = 8;
+pub const S_IROTH: ::mode_t = 4;
+pub const S_IWOTH: ::mode_t = 2;
+pub const S_IXOTH: ::mode_t = 1;
+
+pub const SOL_TCP: ::c_int = 6;
+
+pub const PF_UNSPEC: ::c_int = 0;
+pub const PF_INET: ::c_int = 2;
+pub const PF_INET6: ::c_int = 23;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_INET: ::c_int = 2;
+
+pub const CLOCK_REALTIME: ::clockid_t = 1;
+pub const CLOCK_MONOTONIC: ::clockid_t = 4;
+pub const CLOCK_BOOTTIME: ::clockid_t = 4;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const SO_BINTIME: ::c_int = 0x2000;
+pub const SO_NO_OFFLOAD: ::c_int = 0x4000;
+pub const SO_NO_DDP: ::c_int = 0x8000;
+pub const SO_REUSEPORT_LB: ::c_int = 0x10000;
+pub const SO_LABEL: ::c_int = 0x1009;
+pub const SO_PEERLABEL: ::c_int = 0x1010;
+pub const SO_LISTENQLIMIT: ::c_int = 0x1011;
+pub const SO_LISTENQLEN: ::c_int = 0x1012;
+pub const SO_LISTENINCQLEN: ::c_int = 0x1013;
+pub const SO_SETFIB: ::c_int = 0x1014;
+pub const SO_USER_COOKIE: ::c_int = 0x1015;
+pub const SO_PROTOCOL: ::c_int = 0x1016;
+pub const SO_PROTOTYPE: ::c_int = SO_PROTOCOL;
+pub const SO_VENDOR: ::c_int = 0x80000000;
+pub const SO_DEBUG: ::c_int = 0x01;
+pub const SO_ACCEPTCONN: ::c_int = 0x0002;
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_USELOOPBACK: ::c_int = 0x0040;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_TIMESTAMP: ::c_int = 0x0400;
+pub const SO_NOSIGPIPE: ::c_int = 0x0800;
+pub const SO_ACCEPTFILTER: ::c_int = 0x1000;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_TYPE: ::c_int = 0x1008;
+
+pub const SOCK_CLOEXEC: ::c_int = O_CLOEXEC;
+
+pub const INET_ADDRSTRLEN: ::c_int = 16;
+
+// https://github.
+// com/bminor/newlib/blob/master/newlib/libc/sys/linux/include/net/if.h#L121
+pub const IFF_UP: ::c_int = 0x1; // interface is up
+pub const IFF_BROADCAST: ::c_int = 0x2; // broadcast address valid
+pub const IFF_DEBUG: ::c_int = 0x4; // turn on debugging
+pub const IFF_LOOPBACK: ::c_int = 0x8; // is a loopback net
+pub const IFF_POINTOPOINT: ::c_int = 0x10; // interface is point-to-point link
+pub const IFF_NOTRAILERS: ::c_int = 0x20; // avoid use of trailers
+pub const IFF_RUNNING: ::c_int = 0x40; // resources allocated
+pub const IFF_NOARP: ::c_int = 0x80; // no address resolution protocol
+pub const IFF_PROMISC: ::c_int = 0x100; // receive all packets
+pub const IFF_ALLMULTI: ::c_int = 0x200; // receive all multicast packets
+pub const IFF_OACTIVE: ::c_int = 0x400; // transmission in progress
+pub const IFF_SIMPLEX: ::c_int = 0x800; // can't hear own transmissions
+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit
+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit
+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit
+pub const IFF_ALTPHYS: ::c_int = IFF_LINK2; // use alternate physical connection
+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast
+
+pub const TCP_NODELAY: ::c_int = 8193;
+pub const TCP_MAXSEG: ::c_int = 8194;
+pub const TCP_NOPUSH: ::c_int = 4;
+pub const TCP_NOOPT: ::c_int = 8;
+pub const TCP_KEEPIDLE: ::c_int = 256;
+pub const TCP_KEEPINTVL: ::c_int = 512;
+pub const TCP_KEEPCNT: ::c_int = 1024;
+
+pub const IP_TOS: ::c_int = 3;
+pub const IP_TTL: ::c_int = 8;
+pub const IP_MULTICAST_IF: ::c_int = 9;
+pub const IP_MULTICAST_TTL: ::c_int = 10;
+pub const IP_MULTICAST_LOOP: ::c_int = 11;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 11;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 12;
+
+pub const IPV6_UNICAST_HOPS: ::c_int = 4;
+pub const IPV6_MULTICAST_IF: ::c_int = 9;
+pub const IPV6_MULTICAST_HOPS: ::c_int = 10;
+pub const IPV6_MULTICAST_LOOP: ::c_int = 11;
+pub const IPV6_V6ONLY: ::c_int = 27;
+pub const IPV6_JOIN_GROUP: ::c_int = 12;
+pub const IPV6_LEAVE_GROUP: ::c_int = 13;
+pub const IPV6_ADD_MEMBERSHIP: ::c_int = 12;
+pub const IPV6_DROP_MEMBERSHIP: ::c_int = 13;
+
+pub const HOST_NOT_FOUND: ::c_int = 1;
+pub const NO_DATA: ::c_int = 2;
+pub const NO_ADDRESS: ::c_int = 2;
+pub const NO_RECOVERY: ::c_int = 3;
+pub const TRY_AGAIN: ::c_int = 4;
+
+pub const AI_PASSIVE: ::c_int = 1;
+pub const AI_CANONNAME: ::c_int = 2;
+pub const AI_NUMERICHOST: ::c_int = 4;
+pub const AI_NUMERICSERV: ::c_int = 0;
+pub const AI_ADDRCONFIG: ::c_int = 0;
+
+pub const NI_MAXHOST: ::c_int = 1025;
+pub const NI_MAXSERV: ::c_int = 32;
+pub const NI_NOFQDN: ::c_int = 1;
+pub const NI_NUMERICHOST: ::c_int = 2;
+pub const NI_NAMEREQD: ::c_int = 4;
+pub const NI_NUMERICSERV: ::c_int = 0;
+pub const NI_DGRAM: ::c_int = 0;
+
+pub const EAI_FAMILY: ::c_int = -303;
+pub const EAI_MEMORY: ::c_int = -304;
+pub const EAI_NONAME: ::c_int = -305;
+pub const EAI_SOCKTYPE: ::c_int = -307;
+
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const EXIT_FAILURE: ::c_int = 1;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+f! {
+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        (*set).fds_bits[fd / bits] &= !(1 << (fd % bits));
+        return
+    }
+
+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        return ((*set).fds_bits[fd / bits] & (1 << (fd % bits))) != 0
+    }
+
+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        (*set).fds_bits[fd / bits] |= 1 << (fd % bits);
+        return
+    }
+
+    pub fn FD_ZERO(set: *mut fd_set) -> () {
+        for slot in (*set).fds_bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+}
+
+extern "C" {
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+
+    #[cfg_attr(target_os = "linux", link_name = "__xpg_strerror_r")]
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+
+    pub fn abs(i: ::c_int) -> ::c_int;
+    pub fn atof(s: *const ::c_char) -> ::c_double;
+    pub fn labs(i: ::c_long) -> ::c_long;
+    pub fn rand() -> ::c_int;
+    pub fn srand(seed: ::c_uint);
+
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    pub fn bind(fd: ::c_int, addr: *const sockaddr, len: socklen_t)
+        -> ::c_int;
+    pub fn clock_settime(
+        clock_id: ::clockid_t,
+        tp: *const ::timespec,
+    ) -> ::c_int;
+    pub fn clock_gettime(
+        clock_id: ::clockid_t,
+        tp: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn clock_getres(
+        clock_id: ::clockid_t,
+        res: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn closesocket(sockfd: ::c_int) -> ::c_int;
+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    pub fn recvfrom(
+        fd: ::c_int,
+        buf: *mut ::c_void,
+        n: usize,
+        flags: ::c_int,
+        addr: *mut sockaddr,
+        addr_len: *mut socklen_t,
+    ) -> isize;
+    #[cfg(not(all(
+        libc_cfg_target_vendor,
+        target_arch = "powerpc",
+        target_vendor = "nintendo"
+    )))]
+    pub fn getnameinfo(
+        sa: *const sockaddr,
+        salen: socklen_t,
+        host: *mut ::c_char,
+        hostlen: socklen_t,
+        serv: *mut ::c_char,
+        servlen: socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;
+    pub fn fexecve(
+        fd: ::c_int,
+        argv: *const *const ::c_char,
+        envp: *const *const ::c_char,
+    ) -> ::c_int;
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn getgrgid_r(
+        gid: ::gid_t,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;
+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;
+    pub fn getdtablesize() -> ::c_int;
+    pub fn getgrnam_r(
+        name: *const ::c_char,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;
+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;
+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;
+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    pub fn getpwnam_r(
+        name: *const ::c_char,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "arm")] {
+        mod arm;
+        pub use self::arm::*;
+    } else if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(target_arch = "xtensa")] {
+        mod xtensa;
+        pub use self::xtensa::*;
+    } else if #[cfg(target_arch = "powerpc")] {
+        mod powerpc;
+        pub use self::powerpc::*;
+    } else {
+        // Only tested on ARM so far. Other platforms might have different
+        // definitions for types and constants.
+        pub use target_arch_not_implemented;
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        #[macro_use]
+        mod align;
+    } else {
+        #[macro_use]
+        mod no_align;
+    }
+}
+expand_align!();
diff --git a/library/libc/src/unix/newlib/no_align.rs b/library/libc/src/unix/newlib/no_align.rs
new file mode 100644
index 00000000..316c464e
--- /dev/null
+++ b/library/libc/src/unix/newlib/no_align.rs
@@ -0,0 +1,51 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            pub struct pthread_mutex_t { // Unverified
+                #[cfg(any(target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc"))]
+                __align: [::c_long; 0],
+                #[cfg(not(any(target_arch = "mips",
+                              target_arch = "arm",
+                              target_arch = "powerpc")))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            pub struct pthread_rwlock_t { // Unverified
+                #[cfg(any(target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc"))]
+                __align: [::c_long; 0],
+                #[cfg(not(any(target_arch = "mips",
+                              target_arch = "arm",
+                              target_arch = "powerpc")))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+
+            pub struct pthread_mutexattr_t { // Unverified
+                #[cfg(any(target_arch = "x86_64", target_arch = "powerpc64",
+                          target_arch = "mips64", target_arch = "s390x",
+                          target_arch = "sparc64"))]
+                __align: [::c_int; 0],
+                #[cfg(not(any(target_arch = "x86_64", target_arch = "powerpc64",
+                              target_arch = "mips64", target_arch = "s390x",
+                              target_arch = "sparc64")))]
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            pub struct pthread_cond_t { // Unverified
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            pub struct pthread_condattr_t { // Unverified
+                __align: [::c_int; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+    }
+}
diff --git a/library/libc/src/unix/newlib/powerpc/mod.rs b/library/libc/src/unix/newlib/powerpc/mod.rs
new file mode 100644
index 00000000..4289658c
--- /dev/null
+++ b/library/libc/src/unix/newlib/powerpc/mod.rs
@@ -0,0 +1,14 @@
+pub type clock_t = ::c_ulong;
+pub type c_char = u8;
+pub type wchar_t = ::c_int;
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+
+// the newlib shipped with devkitPPC does not support the following components:
+// - sockaddr
+// - AF_INET6
+// - FIONBIO
+// - POLL*
+// - SOL_SOCKET
+// - MSG_*
diff --git a/library/libc/src/unix/newlib/xtensa/mod.rs b/library/libc/src/unix/newlib/xtensa/mod.rs
new file mode 100644
index 00000000..bc31506b
--- /dev/null
+++ b/library/libc/src/unix/newlib/xtensa/mod.rs
@@ -0,0 +1,106 @@
+pub type clock_t = ::c_ulong;
+pub type c_char = i8;
+pub type wchar_t = u32;
+
+pub type c_long = i32;
+pub type c_ulong = u32;
+
+s! {
+    pub struct cmsghdr {
+        pub cmsg_len: ::socklen_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct sockaddr_un {
+        pub sun_family: ::sa_family_t,
+        pub sun_path: [::c_char; 108],
+    }
+
+    pub struct sockaddr {
+        pub sa_len: u8,
+        pub sa_family: ::sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_len: u8,
+        pub sin6_family: ::sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct sockaddr_in {
+        pub sin_len: u8,
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [::c_char; 8],
+    }
+
+    pub struct sockaddr_storage {
+        pub s2_len: u8,
+        pub ss_family: ::sa_family_t,
+        pub s2_data1: [::c_char; 2],
+        pub s2_data2: [u32; 3],
+        pub s2_data3: [u32; 3],
+    }
+}
+
+pub const AF_UNIX: ::c_int = 1;
+pub const AF_INET6: ::c_int = 10;
+
+pub const FIONBIO: ::c_ulong = 2147772030;
+
+pub const POLLIN: ::c_short = 1 << 0;
+pub const POLLRDNORM: ::c_short = 1 << 1;
+pub const POLLRDBAND: ::c_short = 1 << 2;
+pub const POLLPRI: ::c_short = POLLRDBAND;
+pub const POLLOUT: ::c_short = 1 << 3;
+pub const POLLWRNORM: ::c_short = POLLOUT;
+pub const POLLWRBAND: ::c_short = 1 << 4;
+pub const POLLERR: ::c_short = 1 << 5;
+pub const POLLHUP: ::c_short = 1 << 6;
+
+pub const SOL_SOCKET: ::c_int = 0xfff;
+
+pub const MSG_OOB: ::c_int = 0x04;
+pub const MSG_PEEK: ::c_int = 0x01;
+pub const MSG_DONTWAIT: ::c_int = 0x08;
+pub const MSG_DONTROUTE: ::c_int = 0x4;
+pub const MSG_WAITALL: ::c_int = 0x02;
+pub const MSG_MORE: ::c_int = 0x10;
+pub const MSG_NOSIGNAL: ::c_int = 0x20;
+
+extern "C" {
+    pub fn sendmsg(
+        s: ::c_int,
+        msg: *const ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn recvmsg(
+        s: ::c_int,
+        msg: *mut ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+
+    pub fn writev(s: ::c_int, iov: *const ::iovec, iovcnt: ::c_int)
+        -> ::c_int;
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+}
diff --git a/library/libc/src/unix/no_align.rs b/library/libc/src/unix/no_align.rs
new file mode 100644
index 00000000..f6b9f4c1
--- /dev/null
+++ b/library/libc/src/unix/no_align.rs
@@ -0,0 +1,6 @@
+s! {
+    pub struct in6_addr {
+        pub s6_addr: [u8; 16],
+        __align: [u32; 0],
+    }
+}
diff --git a/library/libc/src/unix/redox/mod.rs b/library/libc/src/unix/redox/mod.rs
new file mode 100644
index 00000000..faf8f0bf
--- /dev/null
+++ b/library/libc/src/unix/redox/mod.rs
@@ -0,0 +1,1225 @@
+pub type c_char = i8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type wchar_t = i32;
+
+pub type blkcnt_t = ::c_ulong;
+pub type blksize_t = ::c_long;
+pub type clock_t = ::c_long;
+pub type clockid_t = ::c_int;
+pub type dev_t = ::c_long;
+pub type fsblkcnt_t = ::c_ulong;
+pub type fsfilcnt_t = ::c_ulong;
+pub type ino_t = ::c_ulong;
+pub type mode_t = ::c_int;
+pub type nfds_t = ::c_ulong;
+pub type nlink_t = ::c_ulong;
+pub type off_t = ::c_long;
+pub type pthread_t = *mut ::c_void;
+pub type pthread_attr_t = *mut ::c_void;
+pub type pthread_cond_t = *mut ::c_void;
+pub type pthread_condattr_t = *mut ::c_void;
+// Must be usize due to libstd/sys_common/thread_local.rs,
+// should technically be *mut ::c_void
+pub type pthread_key_t = usize;
+pub type pthread_mutex_t = *mut ::c_void;
+pub type pthread_mutexattr_t = *mut ::c_void;
+pub type pthread_rwlock_t = *mut ::c_void;
+pub type pthread_rwlockattr_t = *mut ::c_void;
+pub type rlim_t = ::c_ulonglong;
+pub type sa_family_t = u16;
+pub type sem_t = *mut ::c_void;
+pub type sigset_t = ::c_ulong;
+pub type socklen_t = u32;
+pub type speed_t = u32;
+pub type suseconds_t = ::c_int;
+pub type tcflag_t = u32;
+pub type time_t = ::c_long;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+
+s_no_extra_traits! {
+    #[repr(C)]
+    pub struct utsname {
+        pub sysname: [::c_char; UTSLENGTH],
+        pub nodename: [::c_char; UTSLENGTH],
+        pub release: [::c_char; UTSLENGTH],
+        pub version: [::c_char; UTSLENGTH],
+        pub machine: [::c_char; UTSLENGTH],
+        pub domainname: [::c_char; UTSLENGTH],
+    }
+
+    pub struct dirent {
+        pub d_ino: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct sockaddr_un {
+        pub sun_family: ::sa_family_t,
+        pub sun_path: [::c_char; 108]
+    }
+
+    pub struct sockaddr_storage {
+        pub ss_family: ::sa_family_t,
+        __ss_padding: [
+            u8;
+            128 -
+            ::core::mem::size_of::<sa_family_t>() -
+            ::core::mem::size_of::<c_ulong>()
+        ],
+        __ss_align: ::c_ulong,
+    }
+}
+
+s! {
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: ::size_t,
+        pub ai_canonname: *mut ::c_char,
+        pub ai_addr: *mut ::sockaddr,
+        pub ai_next: *mut ::addrinfo,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct epoll_event {
+        pub events: u32,
+        pub u64: u64,
+        pub _pad: u64,
+    }
+
+    pub struct fd_set {
+        fds_bits: [::c_ulong; ::FD_SETSIZE / ULONG_SIZE],
+    }
+
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: ::in_addr,
+        pub imr_interface: ::in_addr,
+    }
+
+    pub struct lconv {
+        pub currency_symbol: *const ::c_char,
+        pub decimal_point: *const ::c_char,
+        pub frac_digits: ::c_char,
+        pub grouping: *const ::c_char,
+        pub int_curr_symbol: *const ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub mon_decimal_point: *const ::c_char,
+        pub mon_grouping: *const ::c_char,
+        pub mon_thousands_sep: *const ::c_char,
+        pub negative_sign: *const ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub positive_sign: *const ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub thousands_sep: *const ::c_char,
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct sigaction {
+        pub sa_handler: ::sighandler_t,
+        pub sa_flags: ::c_ulong,
+        pub sa_restorer: ::Option<extern fn()>,
+        pub sa_mask: ::sigset_t,
+    }
+
+    pub struct sockaddr {
+        pub sa_family: ::sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in {
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [::c_char; 8],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_family: ::sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        _pad: [::c_char; 24],
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+        pub tm_gmtoff: ::c_long,
+        pub tm_zone: *const ::c_char,
+    }
+}
+
+pub const UTSLENGTH: usize = 65;
+
+// intentionally not public, only used for fd_set
+cfg_if! {
+    if #[cfg(target_pointer_width = "32")] {
+        const ULONG_SIZE: usize = 32;
+    } else if #[cfg(target_pointer_width = "64")] {
+        const ULONG_SIZE: usize = 64;
+    } else {
+        // Unknown target_pointer_width
+    }
+}
+
+// limits.h
+pub const PATH_MAX: ::c_int = 4096;
+
+// fcntl.h
+pub const F_GETLK: ::c_int = 5;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+
+// FIXME: relibc {
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+// }
+
+// dlfcn.h
+pub const RTLD_LAZY: ::c_int = 0x0001;
+pub const RTLD_NOW: ::c_int = 0x0002;
+pub const RTLD_GLOBAL: ::c_int = 0x0100;
+pub const RTLD_LOCAL: ::c_int = 0x0000;
+
+// errno.h
+pub const EPERM: ::c_int = 1; /* Operation not permitted */
+pub const ENOENT: ::c_int = 2; /* No such file or directory */
+pub const ESRCH: ::c_int = 3; /* No such process */
+pub const EINTR: ::c_int = 4; /* Interrupted system call */
+pub const EIO: ::c_int = 5; /* I/O error */
+pub const ENXIO: ::c_int = 6; /* No such device or address */
+pub const E2BIG: ::c_int = 7; /* Argument list too long */
+pub const ENOEXEC: ::c_int = 8; /* Exec format error */
+pub const EBADF: ::c_int = 9; /* Bad file number */
+pub const ECHILD: ::c_int = 10; /* No child processes */
+pub const EAGAIN: ::c_int = 11; /* Try again */
+pub const ENOMEM: ::c_int = 12; /* Out of memory */
+pub const EACCES: ::c_int = 13; /* Permission denied */
+pub const EFAULT: ::c_int = 14; /* Bad address */
+pub const ENOTBLK: ::c_int = 15; /* Block device required */
+pub const EBUSY: ::c_int = 16; /* Device or resource busy */
+pub const EEXIST: ::c_int = 17; /* File exists */
+pub const EXDEV: ::c_int = 18; /* Cross-device link */
+pub const ENODEV: ::c_int = 19; /* No such device */
+pub const ENOTDIR: ::c_int = 20; /* Not a directory */
+pub const EISDIR: ::c_int = 21; /* Is a directory */
+pub const EINVAL: ::c_int = 22; /* Invalid argument */
+pub const ENFILE: ::c_int = 23; /* File table overflow */
+pub const EMFILE: ::c_int = 24; /* Too many open files */
+pub const ENOTTY: ::c_int = 25; /* Not a typewriter */
+pub const ETXTBSY: ::c_int = 26; /* Text file busy */
+pub const EFBIG: ::c_int = 27; /* File too large */
+pub const ENOSPC: ::c_int = 28; /* No space left on device */
+pub const ESPIPE: ::c_int = 29; /* Illegal seek */
+pub const EROFS: ::c_int = 30; /* Read-only file system */
+pub const EMLINK: ::c_int = 31; /* Too many links */
+pub const EPIPE: ::c_int = 32; /* Broken pipe */
+pub const EDOM: ::c_int = 33; /* Math argument out of domain of func */
+pub const ERANGE: ::c_int = 34; /* Math result not representable */
+pub const EDEADLK: ::c_int = 35; /* Resource deadlock would occur */
+pub const ENAMETOOLONG: ::c_int = 36; /* File name too long */
+pub const ENOLCK: ::c_int = 37; /* No record locks available */
+pub const ENOSYS: ::c_int = 38; /* Function not implemented */
+pub const ENOTEMPTY: ::c_int = 39; /* Directory not empty */
+pub const ELOOP: ::c_int = 40; /* Too many symbolic links encountered */
+pub const EWOULDBLOCK: ::c_int = 41; /* Operation would block */
+pub const ENOMSG: ::c_int = 42; /* No message of desired type */
+pub const EIDRM: ::c_int = 43; /* Identifier removed */
+pub const ECHRNG: ::c_int = 44; /* Channel number out of range */
+pub const EL2NSYNC: ::c_int = 45; /* Level 2 not synchronized */
+pub const EL3HLT: ::c_int = 46; /* Level 3 halted */
+pub const EL3RST: ::c_int = 47; /* Level 3 reset */
+pub const ELNRNG: ::c_int = 48; /* Link number out of range */
+pub const EUNATCH: ::c_int = 49; /* Protocol driver not attached */
+pub const ENOCSI: ::c_int = 50; /* No CSI structure available */
+pub const EL2HLT: ::c_int = 51; /* Level 2 halted */
+pub const EBADE: ::c_int = 52; /* Invalid exchange */
+pub const EBADR: ::c_int = 53; /* Invalid request descriptor */
+pub const EXFULL: ::c_int = 54; /* Exchange full */
+pub const ENOANO: ::c_int = 55; /* No anode */
+pub const EBADRQC: ::c_int = 56; /* Invalid request code */
+pub const EBADSLT: ::c_int = 57; /* Invalid slot */
+pub const EDEADLOCK: ::c_int = 58; /* Resource deadlock would occur */
+pub const EBFONT: ::c_int = 59; /* Bad font file format */
+pub const ENOSTR: ::c_int = 60; /* Device not a stream */
+pub const ENODATA: ::c_int = 61; /* No data available */
+pub const ETIME: ::c_int = 62; /* Timer expired */
+pub const ENOSR: ::c_int = 63; /* Out of streams resources */
+pub const ENONET: ::c_int = 64; /* Machine is not on the network */
+pub const ENOPKG: ::c_int = 65; /* Package not installed */
+pub const EREMOTE: ::c_int = 66; /* Object is remote */
+pub const ENOLINK: ::c_int = 67; /* Link has been severed */
+pub const EADV: ::c_int = 68; /* Advertise error */
+pub const ESRMNT: ::c_int = 69; /* Srmount error */
+pub const ECOMM: ::c_int = 70; /* Communication error on send */
+pub const EPROTO: ::c_int = 71; /* Protocol error */
+pub const EMULTIHOP: ::c_int = 72; /* Multihop attempted */
+pub const EDOTDOT: ::c_int = 73; /* RFS specific error */
+pub const EBADMSG: ::c_int = 74; /* Not a data message */
+pub const EOVERFLOW: ::c_int = 75; /* Value too large for defined data type */
+pub const ENOTUNIQ: ::c_int = 76; /* Name not unique on network */
+pub const EBADFD: ::c_int = 77; /* File descriptor in bad state */
+pub const EREMCHG: ::c_int = 78; /* Remote address changed */
+pub const ELIBACC: ::c_int = 79; /* Can not access a needed shared library */
+pub const ELIBBAD: ::c_int = 80; /* Accessing a corrupted shared library */
+pub const ELIBSCN: ::c_int = 81; /* .lib section in a.out corrupted */
+/* Attempting to link in too many shared libraries */
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83; /* Cannot exec a shared library directly */
+pub const EILSEQ: ::c_int = 84; /* Illegal byte sequence */
+/* Interrupted system call should be restarted */
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86; /* Streams pipe error */
+pub const EUSERS: ::c_int = 87; /* Too many users */
+pub const ENOTSOCK: ::c_int = 88; /* Socket operation on non-socket */
+pub const EDESTADDRREQ: ::c_int = 89; /* Destination address required */
+pub const EMSGSIZE: ::c_int = 90; /* Message too long */
+pub const EPROTOTYPE: ::c_int = 91; /* Protocol wrong type for socket */
+pub const ENOPROTOOPT: ::c_int = 92; /* Protocol not available */
+pub const EPROTONOSUPPORT: ::c_int = 93; /* Protocol not supported */
+pub const ESOCKTNOSUPPORT: ::c_int = 94; /* Socket type not supported */
+/* Operation not supported on transport endpoint */
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const EPFNOSUPPORT: ::c_int = 96; /* Protocol family not supported */
+/* Address family not supported by protocol */
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98; /* Address already in use */
+pub const EADDRNOTAVAIL: ::c_int = 99; /* Cannot assign requested address */
+pub const ENETDOWN: ::c_int = 100; /* Network is down */
+pub const ENETUNREACH: ::c_int = 101; /* Network is unreachable */
+/* Network dropped connection because of reset */
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103; /* Software caused connection abort */
+pub const ECONNRESET: ::c_int = 104; /* Connection reset by peer */
+pub const ENOBUFS: ::c_int = 105; /* No buffer space available */
+pub const EISCONN: ::c_int = 106; /* Transport endpoint is already connected */
+pub const ENOTCONN: ::c_int = 107; /* Transport endpoint is not connected */
+/* Cannot send after transport endpoint shutdown */
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109; /* Too many references: cannot splice */
+pub const ETIMEDOUT: ::c_int = 110; /* Connection timed out */
+pub const ECONNREFUSED: ::c_int = 111; /* Connection refused */
+pub const EHOSTDOWN: ::c_int = 112; /* Host is down */
+pub const EHOSTUNREACH: ::c_int = 113; /* No route to host */
+pub const EALREADY: ::c_int = 114; /* Operation already in progress */
+pub const EINPROGRESS: ::c_int = 115; /* Operation now in progress */
+pub const ESTALE: ::c_int = 116; /* Stale NFS file handle */
+pub const EUCLEAN: ::c_int = 117; /* Structure needs cleaning */
+pub const ENOTNAM: ::c_int = 118; /* Not a XENIX named type file */
+pub const ENAVAIL: ::c_int = 119; /* No XENIX semaphores available */
+pub const EISNAM: ::c_int = 120; /* Is a named type file */
+pub const EREMOTEIO: ::c_int = 121; /* Remote I/O error */
+pub const EDQUOT: ::c_int = 122; /* Quota exceeded */
+pub const ENOMEDIUM: ::c_int = 123; /* No medium found */
+pub const EMEDIUMTYPE: ::c_int = 124; /* Wrong medium type */
+pub const ECANCELED: ::c_int = 125; /* Operation Canceled */
+pub const ENOKEY: ::c_int = 126; /* Required key not available */
+pub const EKEYEXPIRED: ::c_int = 127; /* Key has expired */
+pub const EKEYREVOKED: ::c_int = 128; /* Key has been revoked */
+pub const EKEYREJECTED: ::c_int = 129; /* Key was rejected by service */
+pub const EOWNERDEAD: ::c_int = 130; /* Owner died */
+pub const ENOTRECOVERABLE: ::c_int = 131; /* State not recoverable */
+
+// fcntl.h
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+// FIXME: relibc {
+pub const F_DUPFD_CLOEXEC: ::c_int = ::F_DUPFD;
+// }
+pub const FD_CLOEXEC: ::c_int = 0x0100_0000;
+pub const O_RDONLY: ::c_int = 0x0001_0000;
+pub const O_WRONLY: ::c_int = 0x0002_0000;
+pub const O_RDWR: ::c_int = 0x0003_0000;
+pub const O_ACCMODE: ::c_int = 0x0003_0000;
+pub const O_NONBLOCK: ::c_int = 0x0004_0000;
+pub const O_APPEND: ::c_int = 0x0008_0000;
+pub const O_SHLOCK: ::c_int = 0x0010_0000;
+pub const O_EXLOCK: ::c_int = 0x0020_0000;
+pub const O_ASYNC: ::c_int = 0x0040_0000;
+pub const O_FSYNC: ::c_int = 0x0080_0000;
+pub const O_CLOEXEC: ::c_int = 0x0100_0000;
+pub const O_CREAT: ::c_int = 0x0200_0000;
+pub const O_TRUNC: ::c_int = 0x0400_0000;
+pub const O_EXCL: ::c_int = 0x0800_0000;
+pub const O_DIRECTORY: ::c_int = 0x1000_0000;
+pub const O_PATH: ::c_int = 0x2000_0000;
+pub const O_SYMLINK: ::c_int = 0x4000_0000;
+// Negative to allow it to be used as int
+// FIXME: Fix negative values missing from includes
+pub const O_NOFOLLOW: ::c_int = -0x8000_0000;
+
+// netdb.h
+pub const EAI_SYSTEM: ::c_int = -11;
+pub const NI_MAXHOST: ::c_int = 1025;
+pub const NI_MAXSERV: ::c_int = 32;
+pub const NI_NUMERICHOST: ::c_int = 0x0001;
+pub const NI_NUMERICSERV: ::c_int = 0x0002;
+pub const NI_NOFQDN: ::c_int = 0x0004;
+pub const NI_NAMEREQD: ::c_int = 0x0008;
+pub const NI_DGRAM: ::c_int = 0x0010;
+
+// netinet/in.h
+// FIXME: relibc {
+pub const IP_TTL: ::c_int = 2;
+pub const IPV6_UNICAST_HOPS: ::c_int = 16;
+pub const IPV6_MULTICAST_IF: ::c_int = 17;
+pub const IPV6_MULTICAST_HOPS: ::c_int = 18;
+pub const IPV6_MULTICAST_LOOP: ::c_int = 19;
+pub const IPV6_ADD_MEMBERSHIP: ::c_int = 20;
+pub const IPV6_DROP_MEMBERSHIP: ::c_int = 21;
+pub const IPV6_V6ONLY: ::c_int = 26;
+pub const IP_MULTICAST_IF: ::c_int = 32;
+pub const IP_MULTICAST_TTL: ::c_int = 33;
+pub const IP_MULTICAST_LOOP: ::c_int = 34;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 35;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 36;
+// }
+
+// netinet/tcp.h
+pub const TCP_NODELAY: ::c_int = 1;
+// FIXME: relibc {
+pub const TCP_KEEPIDLE: ::c_int = 1;
+// }
+
+// poll.h
+pub const POLLIN: ::c_short = 0x001;
+pub const POLLPRI: ::c_short = 0x002;
+pub const POLLOUT: ::c_short = 0x004;
+pub const POLLERR: ::c_short = 0x008;
+pub const POLLHUP: ::c_short = 0x010;
+pub const POLLNVAL: ::c_short = 0x020;
+
+// pthread.h
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;
+pub const PTHREAD_MUTEX_INITIALIZER: ::pthread_mutex_t = -1isize as *mut _;
+pub const PTHREAD_COND_INITIALIZER: ::pthread_cond_t = -1isize as *mut _;
+pub const PTHREAD_RWLOCK_INITIALIZER: ::pthread_rwlock_t = -1isize as *mut _;
+pub const PTHREAD_STACK_MIN: ::size_t = 4096;
+
+// signal.h
+pub const SIG_BLOCK: ::c_int = 0;
+pub const SIG_UNBLOCK: ::c_int = 1;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGTRAP: ::c_int = 5;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGURG: ::c_int = 23;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGIO: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIGSYS: ::c_int = 31;
+pub const NSIG: ::c_int = 32;
+
+pub const SA_NOCLDSTOP: ::c_ulong = 0x00000001;
+pub const SA_NOCLDWAIT: ::c_ulong = 0x00000002;
+pub const SA_SIGINFO: ::c_ulong = 0x00000004;
+pub const SA_RESTORER: ::c_ulong = 0x04000000;
+pub const SA_ONSTACK: ::c_ulong = 0x08000000;
+pub const SA_RESTART: ::c_ulong = 0x10000000;
+pub const SA_NODEFER: ::c_ulong = 0x40000000;
+pub const SA_RESETHAND: ::c_ulong = 0x80000000;
+
+// sys/file.h
+pub const LOCK_SH: ::c_int = 1;
+pub const LOCK_EX: ::c_int = 2;
+pub const LOCK_NB: ::c_int = 4;
+pub const LOCK_UN: ::c_int = 8;
+
+// sys/epoll.h
+pub const EPOLL_CLOEXEC: ::c_int = 0x0100_0000;
+pub const EPOLL_CTL_ADD: ::c_int = 1;
+pub const EPOLL_CTL_DEL: ::c_int = 2;
+pub const EPOLL_CTL_MOD: ::c_int = 3;
+pub const EPOLLIN: ::c_int = 1;
+pub const EPOLLPRI: ::c_int = 0;
+pub const EPOLLOUT: ::c_int = 2;
+pub const EPOLLRDNORM: ::c_int = 0;
+pub const EPOLLNVAL: ::c_int = 0;
+pub const EPOLLRDBAND: ::c_int = 0;
+pub const EPOLLWRNORM: ::c_int = 0;
+pub const EPOLLWRBAND: ::c_int = 0;
+pub const EPOLLMSG: ::c_int = 0;
+pub const EPOLLERR: ::c_int = 0;
+pub const EPOLLHUP: ::c_int = 0;
+pub const EPOLLRDHUP: ::c_int = 0;
+pub const EPOLLEXCLUSIVE: ::c_int = 0;
+pub const EPOLLWAKEUP: ::c_int = 0;
+pub const EPOLLONESHOT: ::c_int = 0;
+pub const EPOLLET: ::c_int = 0;
+
+// sys/stat.h
+pub const S_IFMT: ::c_int = 0o0_170_000;
+pub const S_IFDIR: ::c_int = 0o040_000;
+pub const S_IFCHR: ::c_int = 0o020_000;
+pub const S_IFBLK: ::c_int = 0o060_000;
+pub const S_IFREG: ::c_int = 0o100_000;
+pub const S_IFIFO: ::c_int = 0o010_000;
+pub const S_IFLNK: ::c_int = 0o120_000;
+pub const S_IFSOCK: ::c_int = 0o140_000;
+pub const S_IRWXU: ::c_int = 0o0_700;
+pub const S_IRUSR: ::c_int = 0o0_400;
+pub const S_IWUSR: ::c_int = 0o0_200;
+pub const S_IXUSR: ::c_int = 0o0_100;
+pub const S_IRWXG: ::c_int = 0o0_070;
+pub const S_IRGRP: ::c_int = 0o0_040;
+pub const S_IWGRP: ::c_int = 0o0_020;
+pub const S_IXGRP: ::c_int = 0o0_010;
+pub const S_IRWXO: ::c_int = 0o0_007;
+pub const S_IROTH: ::c_int = 0o0_004;
+pub const S_IWOTH: ::c_int = 0o0_002;
+pub const S_IXOTH: ::c_int = 0o0_001;
+
+// stdlib.h
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const EXIT_FAILURE: ::c_int = 1;
+
+// sys/ioctl.h
+// FIXME: relibc {
+pub const FIONBIO: ::c_ulong = 0x5421;
+pub const FIOCLEX: ::c_ulong = 0x5451;
+// }
+pub const TCGETS: ::c_ulong = 0x5401;
+pub const TCSETS: ::c_ulong = 0x5402;
+pub const TCFLSH: ::c_ulong = 0x540B;
+pub const TIOCGPGRP: ::c_ulong = 0x540F;
+pub const TIOCSPGRP: ::c_ulong = 0x5410;
+pub const TIOCGWINSZ: ::c_ulong = 0x5413;
+pub const TIOCSWINSZ: ::c_ulong = 0x5414;
+
+// sys/mman.h
+pub const PROT_NONE: ::c_int = 0x0000;
+pub const PROT_READ: ::c_int = 0x0004;
+pub const PROT_WRITE: ::c_int = 0x0002;
+pub const PROT_EXEC: ::c_int = 0x0001;
+
+pub const MAP_SHARED: ::c_int = 0x0001;
+pub const MAP_PRIVATE: ::c_int = 0x0002;
+pub const MAP_ANON: ::c_int = 0x0020;
+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;
+pub const MAP_FIXED: ::c_int = 0x0010;
+pub const MAP_FAILED: *mut ::c_void = !0 as _;
+
+pub const MS_ASYNC: ::c_int = 0x0001;
+pub const MS_INVALIDATE: ::c_int = 0x0002;
+pub const MS_SYNC: ::c_int = 0x0004;
+
+// sys/select.h
+pub const FD_SETSIZE: usize = 1024;
+
+// sys/socket.h
+pub const AF_INET: ::c_int = 2;
+pub const AF_INET6: ::c_int = 10;
+pub const AF_UNIX: ::c_int = 1;
+pub const AF_UNSPEC: ::c_int = 0;
+pub const PF_INET: ::c_int = 2;
+pub const PF_INET6: ::c_int = 10;
+pub const PF_UNIX: ::c_int = 1;
+pub const PF_UNSPEC: ::c_int = 0;
+pub const MSG_CTRUNC: ::c_int = 8;
+pub const MSG_DONTROUTE: ::c_int = 4;
+pub const MSG_EOR: ::c_int = 128;
+pub const MSG_OOB: ::c_int = 1;
+pub const MSG_PEEK: ::c_int = 2;
+pub const MSG_TRUNC: ::c_int = 32;
+pub const MSG_WAITALL: ::c_int = 256;
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+pub const SO_DEBUG: ::c_int = 1;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PEERSEC: ::c_int = 31;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_NONBLOCK: ::c_int = 0o4_000;
+pub const SOCK_CLOEXEC: ::c_int = 0o2_000_000;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const SOL_SOCKET: ::c_int = 1;
+
+// sys/termios.h
+pub const NCCS: usize = 32;
+
+pub const VINTR: usize = 0;
+pub const VQUIT: usize = 1;
+pub const VERASE: usize = 2;
+pub const VKILL: usize = 3;
+pub const VEOF: usize = 4;
+pub const VTIME: usize = 5;
+pub const VMIN: usize = 6;
+pub const VSWTC: usize = 7;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VSUSP: usize = 10;
+pub const VEOL: usize = 11;
+pub const VREPRINT: usize = 12;
+pub const VDISCARD: usize = 13;
+pub const VWERASE: usize = 14;
+pub const VLNEXT: usize = 15;
+pub const VEOL2: usize = 16;
+
+pub const IGNBRK: ::tcflag_t = 0o000_001;
+pub const BRKINT: ::tcflag_t = 0o000_002;
+pub const IGNPAR: ::tcflag_t = 0o000_004;
+pub const PARMRK: ::tcflag_t = 0o000_010;
+pub const INPCK: ::tcflag_t = 0o000_020;
+pub const ISTRIP: ::tcflag_t = 0o000_040;
+pub const INLCR: ::tcflag_t = 0o000_100;
+pub const IGNCR: ::tcflag_t = 0o000_200;
+pub const ICRNL: ::tcflag_t = 0o000_400;
+pub const IUCLC: ::tcflag_t = 0o001_000;
+pub const IXON: ::tcflag_t = 0o002_000;
+pub const IXANY: ::tcflag_t = 0o004_000;
+pub const IXOFF: ::tcflag_t = 0o010_000;
+pub const IMAXBEL: ::tcflag_t = 0o020_000;
+pub const IUTF8: ::tcflag_t = 0o040_000;
+
+pub const OPOST: ::tcflag_t = 0o000_001;
+pub const OLCUC: ::tcflag_t = 0o000_002;
+pub const ONLCR: ::tcflag_t = 0o000_004;
+pub const OCRNL: ::tcflag_t = 0o000_010;
+pub const ONOCR: ::tcflag_t = 0o000_020;
+pub const ONLRET: ::tcflag_t = 0o00_0040;
+pub const OFILL: ::tcflag_t = 0o000_100;
+pub const OFDEL: ::tcflag_t = 0o000_200;
+
+pub const VTDLY: usize = 0o040_000;
+pub const VT0: usize = 0o000_000;
+pub const VT1: usize = 0o040_000;
+
+pub const B0: speed_t = 0o000_000;
+pub const B50: speed_t = 0o000_001;
+pub const B75: speed_t = 0o000_002;
+pub const B110: speed_t = 0o000_003;
+pub const B134: speed_t = 0o000_004;
+pub const B150: speed_t = 0o000_005;
+pub const B200: speed_t = 0o000_006;
+pub const B300: speed_t = 0o000_007;
+pub const B600: speed_t = 0o000_010;
+pub const B1200: speed_t = 0o000_011;
+pub const B1800: speed_t = 0o000_012;
+pub const B2400: speed_t = 0o000_013;
+pub const B4800: speed_t = 0o000_014;
+pub const B9600: speed_t = 0o000_015;
+pub const B19200: speed_t = 0o000_016;
+pub const B38400: speed_t = 0o000_017;
+
+pub const B57600: speed_t = 0o010_001;
+pub const B115200: speed_t = 0o010_002;
+pub const B230400: speed_t = 0o010_003;
+pub const B460800: speed_t = 0o010_004;
+pub const B500000: speed_t = 0o010_005;
+pub const B576000: speed_t = 0o010_006;
+pub const B921600: speed_t = 0o010_007;
+pub const B1000000: speed_t = 0o010_010;
+pub const B1152000: speed_t = 0o010_011;
+pub const B1500000: speed_t = 0o010_012;
+pub const B2000000: speed_t = 0o010_013;
+pub const B2500000: speed_t = 0o010_014;
+pub const B3000000: speed_t = 0o010_015;
+pub const B3500000: speed_t = 0o010_016;
+pub const B4000000: speed_t = 0o010_017;
+
+pub const CSIZE: ::tcflag_t = 0o000_060;
+pub const CS5: ::tcflag_t = 0o000_000;
+pub const CS6: ::tcflag_t = 0o000_020;
+pub const CS7: ::tcflag_t = 0o000_040;
+pub const CS8: ::tcflag_t = 0o000_060;
+pub const CSTOPB: ::tcflag_t = 0o000_100;
+pub const CREAD: ::tcflag_t = 0o000_200;
+pub const PARENB: ::tcflag_t = 0o000_400;
+pub const PARODD: ::tcflag_t = 0o001_000;
+pub const HUPCL: ::tcflag_t = 0o002_000;
+pub const CLOCAL: ::tcflag_t = 0o004_000;
+
+pub const ISIG: ::tcflag_t = 0o000_001;
+pub const ICANON: ::tcflag_t = 0o000_002;
+pub const ECHO: ::tcflag_t = 0o000_010;
+pub const ECHOE: ::tcflag_t = 0o000_020;
+pub const ECHOK: ::tcflag_t = 0o000_040;
+pub const ECHONL: ::tcflag_t = 0o000_100;
+pub const NOFLSH: ::tcflag_t = 0o000_200;
+pub const TOSTOP: ::tcflag_t = 0o000_400;
+pub const IEXTEN: ::tcflag_t = 0o100_000;
+
+pub const TCOOFF: ::c_int = 0;
+pub const TCOON: ::c_int = 1;
+pub const TCIOFF: ::c_int = 2;
+pub const TCION: ::c_int = 3;
+
+pub const TCIFLUSH: ::c_int = 0;
+pub const TCOFLUSH: ::c_int = 1;
+pub const TCIOFLUSH: ::c_int = 2;
+
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+
+// sys/wait.h
+pub const WNOHANG: ::c_int = 1;
+pub const WUNTRACED: ::c_int = 2;
+
+pub const WSTOPPED: ::c_int = 2;
+pub const WEXITED: ::c_int = 4;
+pub const WCONTINUED: ::c_int = 8;
+pub const WNOWAIT: ::c_int = 0x0100_0000;
+
+pub const __WNOTHREAD: ::c_int = 0x2000_0000;
+pub const __WALL: ::c_int = 0x4000_0000;
+#[allow(overflowing_literals)]
+pub const __WCLONE: ::c_int = 0x8000_0000;
+
+// time.h
+pub const CLOCK_REALTIME: ::c_int = 1;
+pub const CLOCK_MONOTONIC: ::c_int = 4;
+
+// unistd.h
+// POSIX.1 {
+pub const _SC_ARG_MAX: ::c_int = 0;
+pub const _SC_CHILD_MAX: ::c_int = 1;
+pub const _SC_CLK_TCK: ::c_int = 2;
+pub const _SC_NGROUPS_MAX: ::c_int = 3;
+pub const _SC_OPEN_MAX: ::c_int = 4;
+pub const _SC_STREAM_MAX: ::c_int = 5;
+pub const _SC_TZNAME_MAX: ::c_int = 6;
+// ...
+pub const _SC_VERSION: ::c_int = 29;
+pub const _SC_PAGESIZE: ::c_int = 30;
+pub const _SC_PAGE_SIZE: ::c_int = 30;
+// ...
+pub const _SC_RE_DUP_MAX: ::c_int = 44;
+// ...
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 71;
+pub const _SC_TTY_NAME_MAX: ::c_int = 72;
+// ...
+pub const _SC_SYMLOOP_MAX: ::c_int = 173;
+// ...
+pub const _SC_HOST_NAME_MAX: ::c_int = 180;
+// } POSIX.1
+
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+
+pub const _PC_LINK_MAX: ::c_int = 0;
+pub const _PC_MAX_CANON: ::c_int = 1;
+pub const _PC_MAX_INPUT: ::c_int = 2;
+pub const _PC_NAME_MAX: ::c_int = 3;
+pub const _PC_PATH_MAX: ::c_int = 4;
+pub const _PC_PIPE_BUF: ::c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 6;
+pub const _PC_NO_TRUNC: ::c_int = 7;
+pub const _PC_VDISABLE: ::c_int = 8;
+pub const _PC_SYNC_IO: ::c_int = 9;
+pub const _PC_ASYNC_IO: ::c_int = 10;
+pub const _PC_PRIO_IO: ::c_int = 11;
+pub const _PC_SOCK_MAXBUF: ::c_int = 12;
+pub const _PC_FILESIZEBITS: ::c_int = 13;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 17;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 18;
+pub const _PC_SYMLINK_MAX: ::c_int = 19;
+pub const _PC_2_SYMLINKS: ::c_int = 20;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+// wait.h
+f! {
+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] &= !(1 << (fd % size));
+        return
+    }
+
+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0
+    }
+
+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] |= 1 << (fd % size);
+        return
+    }
+
+    pub fn FD_ZERO(set: *mut fd_set) -> () {
+        for slot in (*set).fds_bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+}
+
+safe_f! {
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        (status & 0xff) == 0x7f
+    }
+
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        status == 0xffff
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        ((status & 0x7f) + 1) as i8 >= 2
+    }
+
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        status & 0x7f
+    }
+
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & 0x7f) == 0
+    }
+
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {
+        (status & 0x80) != 0
+    }
+}
+
+extern "C" {
+    // errno.h
+    pub fn __errno_location() -> *mut ::c_int;
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    // unistd.h
+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;
+
+    // malloc.h
+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;
+
+    // pthread.h
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn pthread_create(
+        tid: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        start: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        arg: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setclock(
+        attr: *mut pthread_condattr_t,
+        clock_id: ::clockid_t,
+    ) -> ::c_int;
+
+    // pwd.h
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+
+    // signal.h
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const ::sigset_t,
+        oldset: *mut ::sigset_t,
+    ) -> ::c_int;
+
+    // sys/epoll.h
+    pub fn epoll_create(size: ::c_int) -> ::c_int;
+    pub fn epoll_create1(flags: ::c_int) -> ::c_int;
+    pub fn epoll_wait(
+        epfd: ::c_int,
+        events: *mut ::epoll_event,
+        maxevents: ::c_int,
+        timeout: ::c_int,
+    ) -> ::c_int;
+    pub fn epoll_ctl(
+        epfd: ::c_int,
+        op: ::c_int,
+        fd: ::c_int,
+        event: *mut ::epoll_event,
+    ) -> ::c_int;
+
+    // sys/ioctl.h
+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;
+
+    // sys/mman.h
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn shm_open(
+        name: *const c_char,
+        oflag: ::c_int,
+        mode: mode_t,
+    ) -> ::c_int;
+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;
+
+    // sys/resource.h
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+
+    // sys/socket.h
+    pub fn bind(
+        socket: ::c_int,
+        address: *const ::sockaddr,
+        address_len: ::socklen_t,
+    ) -> ::c_int;
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+
+    // sys/stat.h
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+
+    // sys/uio.h
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+
+    // sys/utsname.h
+    pub fn uname(utsname: *mut utsname) -> ::c_int;
+
+    // time.h
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;
+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                    .d_name
+                    .iter()
+                    .zip(other.d_name.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for dirent {}
+
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_off", &self.d_off)
+                    .field("d_reclen", &self.d_reclen)
+                    .field("d_type", &self.d_type)
+                // FIXME: .field("d_name", &self.d_name)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for dirent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_un {
+            fn eq(&self, other: &sockaddr_un) -> bool {
+                self.sun_family == other.sun_family
+                    && self
+                    .sun_path
+                    .iter()
+                    .zip(other.sun_path.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for sockaddr_un {}
+
+        impl ::fmt::Debug for sockaddr_un {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_un")
+                    .field("sun_family", &self.sun_family)
+                // FIXME: .field("sun_path", &self.sun_path)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sockaddr_un {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sun_family.hash(state);
+                self.sun_path.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_family == other.ss_family
+                    && self.__ss_align == self.__ss_align
+                    && self
+                    .__ss_padding
+                    .iter()
+                    .zip(other.__ss_padding.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for sockaddr_storage {}
+
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_align", &self.__ss_align)
+                // FIXME: .field("__ss_padding", &self.__ss_padding)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_family.hash(state);
+                self.__ss_padding.hash(state);
+                self.__ss_align.hash(state);
+            }
+        }
+
+        impl PartialEq for utsname {
+            fn eq(&self, other: &utsname) -> bool {
+                self.sysname
+                    .iter()
+                    .zip(other.sysname.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .nodename
+                    .iter()
+                    .zip(other.nodename.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .release
+                    .iter()
+                    .zip(other.release.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .version
+                    .iter()
+                    .zip(other.version.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .machine
+                    .iter()
+                    .zip(other.machine.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .domainname
+                    .iter()
+                    .zip(other.domainname.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+
+        impl Eq for utsname {}
+
+        impl ::fmt::Debug for utsname {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utsname")
+                // FIXME: .field("sysname", &self.sysname)
+                // FIXME: .field("nodename", &self.nodename)
+                // FIXME: .field("release", &self.release)
+                // FIXME: .field("version", &self.version)
+                // FIXME: .field("machine", &self.machine)
+                // FIXME: .field("domainname", &self.domainname)
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utsname {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sysname.hash(state);
+                self.nodename.hash(state);
+                self.release.hash(state);
+                self.version.hash(state);
+                self.machine.hash(state);
+                self.domainname.hash(state);
+            }
+        }
+    }
+}
diff --git a/library/libc/src/unix/solarish/compat.rs b/library/libc/src/unix/solarish/compat.rs
new file mode 100644
index 00000000..6ada0675
--- /dev/null
+++ b/library/libc/src/unix/solarish/compat.rs
@@ -0,0 +1,183 @@
+// Common functions that are unfortunately missing on illumos and
+// Solaris, but often needed by other crates.
+
+use unix::solarish::*;
+
+const PTEM: &[u8] = b"ptem\0";
+const LDTERM: &[u8] = b"ldterm\0";
+
+pub unsafe fn cfmakeraw(termios: *mut ::termios) {
+    (*termios).c_iflag &= !(IMAXBEL
+        | IGNBRK
+        | BRKINT
+        | PARMRK
+        | ISTRIP
+        | INLCR
+        | IGNCR
+        | ICRNL
+        | IXON);
+    (*termios).c_oflag &= !OPOST;
+    (*termios).c_lflag &= !(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
+    (*termios).c_cflag &= !(CSIZE | PARENB);
+    (*termios).c_cflag |= CS8;
+
+    // By default, most software expects a pending read to block until at
+    // least one byte becomes available.  As per termio(7I), this requires
+    // setting the MIN and TIME parameters appropriately.
+    //
+    // As a somewhat unfortunate artefact of history, the MIN and TIME slots
+    // in the control character array overlap with the EOF and EOL slots used
+    // for canonical mode processing.  Because the EOF character needs to be
+    // the ASCII EOT value (aka Control-D), it has the byte value 4.  When
+    // switching to raw mode, this is interpreted as a MIN value of 4; i.e.,
+    // reads will block until at least four bytes have been input.
+    //
+    // Other platforms with a distinct MIN slot like Linux and FreeBSD appear
+    // to default to a MIN value of 1, so we'll force that value here:
+    (*termios).c_cc[VMIN] = 1;
+    (*termios).c_cc[VTIME] = 0;
+}
+
+pub unsafe fn cfsetspeed(
+    termios: *mut ::termios,
+    speed: ::speed_t,
+) -> ::c_int {
+    // Neither of these functions on illumos or Solaris actually ever
+    // return an error
+    ::cfsetispeed(termios, speed);
+    ::cfsetospeed(termios, speed);
+    0
+}
+
+unsafe fn bail(fdm: ::c_int, fds: ::c_int) -> ::c_int {
+    let e = *___errno();
+    if fds >= 0 {
+        ::close(fds);
+    }
+    if fdm >= 0 {
+        ::close(fdm);
+    }
+    *___errno() = e;
+    return -1;
+}
+
+pub unsafe fn openpty(
+    amain: *mut ::c_int,
+    asubord: *mut ::c_int,
+    name: *mut ::c_char,
+    termp: *const termios,
+    winp: *const ::winsize,
+) -> ::c_int {
+    // Open the main pseudo-terminal device, making sure not to set it as the
+    // controlling terminal for this process:
+    let fdm = ::posix_openpt(O_RDWR | O_NOCTTY);
+    if fdm < 0 {
+        return -1;
+    }
+
+    // Set permissions and ownership on the subordinate device and unlock it:
+    if ::grantpt(fdm) < 0 || ::unlockpt(fdm) < 0 {
+        return bail(fdm, -1);
+    }
+
+    // Get the path name of the subordinate device:
+    let subordpath = ::ptsname(fdm);
+    if subordpath.is_null() {
+        return bail(fdm, -1);
+    }
+
+    // Open the subordinate device without setting it as the controlling
+    // terminal for this process:
+    let fds = ::open(subordpath, O_RDWR | O_NOCTTY);
+    if fds < 0 {
+        return bail(fdm, -1);
+    }
+
+    // Check if the STREAMS modules are already pushed:
+    let setup = ::ioctl(fds, I_FIND, LDTERM.as_ptr());
+    if setup < 0 {
+        return bail(fdm, fds);
+    } else if setup == 0 {
+        // The line discipline is not present, so push the appropriate STREAMS
+        // modules for the subordinate device:
+        if ::ioctl(fds, I_PUSH, PTEM.as_ptr()) < 0
+            || ::ioctl(fds, I_PUSH, LDTERM.as_ptr()) < 0
+        {
+            return bail(fdm, fds);
+        }
+    }
+
+    // If provided, set the terminal parameters:
+    if !termp.is_null() && ::tcsetattr(fds, TCSAFLUSH, termp) != 0 {
+        return bail(fdm, fds);
+    }
+
+    // If provided, set the window size:
+    if !winp.is_null() && ::ioctl(fds, TIOCSWINSZ, winp) < 0 {
+        return bail(fdm, fds);
+    }
+
+    // If the caller wants the name of the subordinate device, copy it out.
+    //
+    // Note that this is a terrible interface: there appears to be no standard
+    // upper bound on the copy length for this pointer.  Nobody should pass
+    // anything but NULL here, preferring instead to use ptsname(3C) directly.
+    if !name.is_null() {
+        ::strcpy(name, subordpath);
+    }
+
+    *amain = fdm;
+    *asubord = fds;
+    0
+}
+
+pub unsafe fn forkpty(
+    amain: *mut ::c_int,
+    name: *mut ::c_char,
+    termp: *const termios,
+    winp: *const ::winsize,
+) -> ::pid_t {
+    let mut fds = -1;
+
+    if openpty(amain, &mut fds, name, termp, winp) != 0 {
+        return -1;
+    }
+
+    let pid = ::fork();
+    if pid < 0 {
+        return bail(*amain, fds);
+    } else if pid > 0 {
+        // In the parent process, we close the subordinate device and return the
+        // process ID of the new child:
+        ::close(fds);
+        return pid;
+    }
+
+    // The rest of this function executes in the child process.
+
+    // Close the main side of the pseudo-terminal pair:
+    ::close(*amain);
+
+    // Use TIOCSCTTY to set the subordinate device as our controlling
+    // terminal.  This will fail (with ENOTTY) if we are not the leader in
+    // our own session, so we call setsid() first.  Finally, arrange for
+    // the pseudo-terminal to occupy the standard I/O descriptors.
+    if ::setsid() < 0
+        || ::ioctl(fds, TIOCSCTTY, 0) < 0
+        || ::dup2(fds, 0) < 0
+        || ::dup2(fds, 1) < 0
+        || ::dup2(fds, 2) < 0
+    {
+        // At this stage there are no particularly good ways to handle failure.
+        // Exit as abruptly as possible, using _exit() to avoid messing with any
+        // state still shared with the parent process.
+        ::_exit(EXIT_FAILURE);
+    }
+    // Close the inherited descriptor, taking care to avoid closing the standard
+    // descriptors by mistake:
+    if fds > 2 {
+        ::close(fds);
+    }
+
+    0
+}
diff --git a/library/libc/src/unix/solarish/illumos.rs b/library/libc/src/unix/solarish/illumos.rs
new file mode 100644
index 00000000..49aeb9c9
--- /dev/null
+++ b/library/libc/src/unix/solarish/illumos.rs
@@ -0,0 +1,38 @@
+s! {
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_amp: *mut ::c_void,
+        pub shm_lkcnt: ::c_ushort,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        pub shm_cnattch: ::c_ulong,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_pad4: [i64; 4],
+    }
+}
+
+pub const AF_LOCAL: ::c_int = 1; // AF_UNIX
+pub const AF_FILE: ::c_int = 1; // AF_UNIX
+
+pub const EFD_SEMAPHORE: ::c_int = 0x1;
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const TCP_KEEPIDLE: ::c_int = 34;
+pub const TCP_KEEPCNT: ::c_int = 35;
+pub const TCP_KEEPINTVL: ::c_int = 36;
+pub const TCP_CONGESTION: ::c_int = 37;
+
+extern "C" {
+    pub fn eventfd(init: ::c_uint, flags: ::c_int) -> ::c_int;
+
+    pub fn mincore(
+        addr: ::caddr_t,
+        len: ::size_t,
+        vec: *mut ::c_char,
+    ) -> ::c_int;
+}
diff --git a/library/libc/src/unix/solarish/mod.rs b/library/libc/src/unix/solarish/mod.rs
new file mode 100644
index 00000000..0b8757e1
--- /dev/null
+++ b/library/libc/src/unix/solarish/mod.rs
@@ -0,0 +1,2722 @@
+pub type c_char = i8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type caddr_t = *mut ::c_char;
+
+pub type clockid_t = ::c_int;
+pub type blkcnt_t = ::c_long;
+pub type clock_t = ::c_long;
+pub type daddr_t = ::c_long;
+pub type dev_t = ::c_ulong;
+pub type fsblkcnt_t = ::c_ulong;
+pub type fsfilcnt_t = ::c_ulong;
+pub type ino_t = ::c_ulong;
+pub type key_t = ::c_int;
+pub type major_t = ::c_uint;
+pub type minor_t = ::c_uint;
+pub type mode_t = ::c_uint;
+pub type nlink_t = ::c_uint;
+pub type rlim_t = ::c_ulong;
+pub type speed_t = ::c_uint;
+pub type tcflag_t = ::c_uint;
+pub type time_t = ::c_long;
+pub type timer_t = ::c_int;
+pub type wchar_t = ::c_int;
+pub type nfds_t = ::c_ulong;
+pub type projid_t = ::c_int;
+pub type zoneid_t = ::c_int;
+
+pub type suseconds_t = ::c_long;
+pub type off_t = ::c_long;
+pub type useconds_t = ::c_uint;
+pub type socklen_t = ::c_uint;
+pub type sa_family_t = u16;
+pub type pthread_t = ::c_uint;
+pub type pthread_key_t = ::c_uint;
+pub type blksize_t = ::c_int;
+pub type nl_item = ::c_int;
+pub type mqd_t = *mut ::c_void;
+pub type id_t = ::c_int;
+pub type idtype_t = ::c_uint;
+pub type shmatt_t = ::c_ulong;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum ucred_t {}
+impl ::Copy for ucred_t {}
+impl ::Clone for ucred_t {
+    fn clone(&self) -> ucred_t {
+        *self
+    }
+}
+
+s! {
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct ipc_perm {
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub seq: ::c_uint,
+        pub key: ::key_t,
+    }
+
+    pub struct sockaddr {
+        pub sa_family: sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in {
+        pub sin_family: sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [::c_char; 8]
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_family: sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+        pub __sin6_src_id: u32
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_age: *mut ::c_char,
+        pub pw_comment: *mut ::c_char,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char
+    }
+
+    pub struct ifaddrs {
+        pub ifa_next: *mut ifaddrs,
+        pub ifa_name: *mut ::c_char,
+        pub ifa_flags: ::c_ulong,
+        pub ifa_addr: *mut ::sockaddr,
+        pub ifa_netmask: *mut ::sockaddr,
+        pub ifa_dstaddr: *mut ::sockaddr,
+        pub ifa_data: *mut ::c_void
+    }
+
+    pub struct itimerspec {
+        pub it_interval: ::timespec,
+        pub it_value: ::timespec,
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int
+    }
+
+     pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::socklen_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct pthread_attr_t {
+        __pthread_attrp: *mut ::c_void
+    }
+
+    pub struct pthread_mutex_t {
+        __pthread_mutex_flag1: u16,
+        __pthread_mutex_flag2: u8,
+        __pthread_mutex_ceiling: u8,
+        __pthread_mutex_type: u16,
+        __pthread_mutex_magic: u16,
+        __pthread_mutex_lock: u64,
+        __pthread_mutex_data: u64
+    }
+
+    pub struct pthread_mutexattr_t {
+        __pthread_mutexattrp: *mut ::c_void
+    }
+
+    pub struct pthread_cond_t {
+        __pthread_cond_flag: [u8; 4],
+        __pthread_cond_type: u16,
+        __pthread_cond_magic: u16,
+        __pthread_cond_data: u64
+    }
+
+    pub struct pthread_condattr_t {
+        __pthread_condattrp: *mut ::c_void,
+    }
+
+    pub struct pthread_rwlock_t {
+        __pthread_rwlock_readers: i32,
+        __pthread_rwlock_type: u16,
+        __pthread_rwlock_magic: u16,
+        __pthread_rwlock_mutex: ::pthread_mutex_t,
+        __pthread_rwlock_readercv: ::pthread_cond_t,
+        __pthread_rwlock_writercv: ::pthread_cond_t
+    }
+
+    pub struct pthread_rwlockattr_t {
+        __pthread_rwlockattrp: *mut ::c_void,
+    }
+
+    pub struct dirent {
+        pub d_ino: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: u16,
+        pub d_name: [::c_char; 3]
+    }
+
+    pub struct glob_t {
+        pub gl_pathc: ::size_t,
+        pub gl_pathv:  *mut *mut ::c_char,
+        pub gl_offs: ::size_t,
+        __unused1: *mut ::c_void,
+        __unused2: ::c_int,
+        __unused3: ::c_int,
+        __unused4: ::c_int,
+        __unused5: *mut ::c_void,
+        __unused6: *mut ::c_void,
+        __unused7: *mut ::c_void,
+        __unused8: *mut ::c_void,
+        __unused9: *mut ::c_void,
+        __unused10: *mut ::c_void,
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        #[cfg(target_arch = "sparc64")]
+        __sparcv9_pad: ::c_int,
+        pub ai_addrlen: ::socklen_t,
+        pub ai_canonname: *mut ::c_char,
+        pub ai_addr: *mut ::sockaddr,
+        pub ai_next: *mut addrinfo,
+    }
+
+    pub struct sigset_t {
+        bits: [u32; 4],
+    }
+
+    pub struct sigaction {
+        pub sa_flags: ::c_int,
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: sigset_t,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_basetype: [::c_char; 16],
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        pub f_fstr: [::c_char; 32]
+    }
+
+    pub struct sched_param {
+        pub sched_priority: ::c_int,
+        sched_pad: [::c_int; 8]
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        __unused: [::c_char; 16]
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_cc: [::cc_t; ::NCCS]
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct sem_t {
+        pub sem_count: u32,
+        pub sem_type: u16,
+        pub sem_magic: u16,
+        pub sem_pad1: [u64; 3],
+        pub sem_pad2: [u64; 2]
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_sysid: ::c_int,
+        pub l_pid: ::pid_t,
+        pub l_pad: [::c_long; 4]
+    }
+
+    pub struct if_nameindex {
+        pub if_index: ::c_uint,
+        pub if_name: *mut ::c_char,
+    }
+
+    pub struct mq_attr {
+        pub mq_flags: ::c_long,
+        pub mq_maxmsg: ::c_long,
+        pub mq_msgsize: ::c_long,
+        pub mq_curmsgs: ::c_long,
+        _pad: [::c_int; 12]
+    }
+
+    pub struct port_event {
+        pub portev_events: ::c_int,
+        pub portev_source: ::c_ushort,
+        pub portev_pad: ::c_ushort,
+        pub portev_object: ::uintptr_t,
+        pub portev_user: *mut ::c_void,
+    }
+
+    pub struct port_notify {
+        pub portnfy_port: ::c_int,
+        pub portnfy_user: *mut ::c_void,
+    }
+
+    pub struct exit_status {
+        e_termination: ::c_short,
+        e_exit: ::c_short,
+    }
+
+    pub struct utmp {
+        pub ut_user: [::c_char; 8],
+        pub ut_id: [::c_char; 4],
+        pub ut_line: [::c_char; 12],
+        pub ut_pid: ::c_short,
+        pub ut_type: ::c_short,
+        pub ut_exit: exit_status,
+        pub ut_time: ::time_t,
+    }
+
+    pub struct timex {
+        pub modes: u32,
+        pub offset: i32,
+        pub freq: i32,
+        pub maxerror: i32,
+        pub esterror: i32,
+        pub status: i32,
+        pub constant: i32,
+        pub precision: i32,
+        pub tolerance: i32,
+        pub ppsfreq: i32,
+        pub jitter: i32,
+        pub shift: i32,
+        pub stabil: i32,
+        pub jitcnt: i32,
+        pub calcnt: i32,
+        pub errcnt: i32,
+        pub stbcnt: i32,
+    }
+
+    pub struct ntptimeval {
+        pub time: ::timeval,
+        pub maxerror: i32,
+        pub esterror: i32,
+    }
+
+}
+
+s_no_extra_traits! {
+    #[cfg_attr(all(
+            any(target_arch = "x86", target_arch = "x86_64"),
+            libc_packedN
+        ), repr(packed(4)))]
+    #[cfg_attr(all(
+            any(target_arch = "x86", target_arch = "x86_64"),
+            not(libc_packedN)
+        ), repr(packed))]
+    pub struct epoll_event {
+        pub events: u32,
+        pub u64: u64,
+    }
+
+    pub struct utmpx {
+        pub ut_user: [::c_char; _UTX_USERSIZE],
+        pub ut_id: [::c_char; _UTX_IDSIZE],
+        pub ut_line: [::c_char; _UTX_LINESIZE],
+        pub ut_pid: ::pid_t,
+        pub ut_type: ::c_short,
+        pub ut_exit: exit_status,
+        pub ut_tv: ::timeval,
+        pub ut_session: ::c_int,
+        pub ut_pad: [::c_int; _UTX_PADSIZE],
+        pub ut_syslen: ::c_short,
+        pub ut_host: [::c_char; _UTX_HOSTSIZE],
+    }
+
+    pub struct sockaddr_un {
+        pub sun_family: sa_family_t,
+        pub sun_path: [c_char; 108]
+    }
+
+    pub struct utsname {
+        pub sysname: [::c_char; 257],
+        pub nodename: [::c_char; 257],
+        pub release: [::c_char; 257],
+        pub version: [::c_char; 257],
+        pub machine: [::c_char; 257],
+    }
+
+    pub struct fd_set {
+        #[cfg(target_pointer_width = "64")]
+        fds_bits: [i64; FD_SETSIZE / 64],
+        #[cfg(target_pointer_width = "32")]
+        fds_bits: [i32; FD_SETSIZE / 32],
+    }
+
+    pub struct sockaddr_storage {
+        pub ss_family: ::sa_family_t,
+        __ss_pad1: [u8; 6],
+        __ss_align: i64,
+        __ss_pad2: [u8; 240],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_pad: ::c_int,
+        pub si_addr: *mut ::c_void,
+        __pad: [u8; 232],
+    }
+
+    pub struct sockaddr_dl {
+        pub sdl_family: ::c_ushort,
+        pub sdl_index: ::c_ushort,
+        pub sdl_type: ::c_uchar,
+        pub sdl_nlen: ::c_uchar,
+        pub sdl_alen: ::c_uchar,
+        pub sdl_slen: ::c_uchar,
+        pub sdl_data: [::c_char; 244],
+    }
+
+    pub struct sigevent {
+        pub sigev_notify: ::c_int,
+        pub sigev_signo: ::c_int,
+        pub sigev_value: ::sigval,
+        pub ss_sp: *mut ::c_void,
+        pub sigev_notify_attributes: *const ::pthread_attr_t,
+        __sigev_pad2: ::c_int,
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for utmpx {
+            fn eq(&self, other: &utmpx) -> bool {
+                self.ut_type == other.ut_type
+                    && self.ut_pid == other.ut_pid
+                    && self.ut_user == other.ut_user
+                    && self.ut_line == other.ut_line
+                    && self.ut_id == other.ut_id
+                    && self.ut_exit == other.ut_exit
+                    && self.ut_session == other.ut_session
+                    && self.ut_tv == other.ut_tv
+                    && self.ut_syslen == other.ut_syslen
+                    && self.ut_pad == other.ut_pad
+                    && self
+                    .ut_host
+                    .iter()
+                    .zip(other.ut_host.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+
+        impl Eq for utmpx {}
+
+        impl ::fmt::Debug for utmpx {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utmpx")
+                    .field("ut_user", &self.ut_user)
+                    .field("ut_id", &self.ut_id)
+                    .field("ut_line", &self.ut_line)
+                    .field("ut_pid", &self.ut_pid)
+                    .field("ut_type", &self.ut_type)
+                    .field("ut_exit", &self.ut_exit)
+                    .field("ut_tv", &self.ut_tv)
+                    .field("ut_session", &self.ut_session)
+                    .field("ut_pad", &self.ut_pad)
+                    .field("ut_syslen", &self.ut_syslen)
+                    .field("ut_host", &&self.ut_host[..])
+                    .finish()
+            }
+        }
+
+        impl ::hash::Hash for utmpx {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ut_user.hash(state);
+                self.ut_type.hash(state);
+                self.ut_pid.hash(state);
+                self.ut_line.hash(state);
+                self.ut_id.hash(state);
+                self.ut_host.hash(state);
+                self.ut_exit.hash(state);
+                self.ut_session.hash(state);
+                self.ut_tv.hash(state);
+                self.ut_syslen.hash(state);
+                self.ut_pad.hash(state);
+            }
+        }
+
+        impl PartialEq for epoll_event {
+            fn eq(&self, other: &epoll_event) -> bool {
+                self.events == other.events
+                    && self.u64 == other.u64
+            }
+        }
+        impl Eq for epoll_event {}
+        impl ::fmt::Debug for epoll_event {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                let events = self.events;
+                let u64 = self.u64;
+                f.debug_struct("epoll_event")
+                    .field("events", &events)
+                    .field("u64", &u64)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for epoll_event {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                let events = self.events;
+                let u64 = self.u64;
+                events.hash(state);
+                u64.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_un {
+            fn eq(&self, other: &sockaddr_un) -> bool {
+                self.sun_family == other.sun_family
+                    && self
+                    .sun_path
+                    .iter()
+                    .zip(other.sun_path.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_un {}
+        impl ::fmt::Debug for sockaddr_un {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_un")
+                    .field("sun_family", &self.sun_family)
+                    // FIXME: .field("sun_path", &self.sun_path)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_un {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sun_family.hash(state);
+                self.sun_path.hash(state);
+            }
+        }
+
+        impl PartialEq for utsname {
+            fn eq(&self, other: &utsname) -> bool {
+                self.sysname
+                    .iter()
+                    .zip(other.sysname.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .nodename
+                    .iter()
+                    .zip(other.nodename.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .release
+                    .iter()
+                    .zip(other.release.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .version
+                    .iter()
+                    .zip(other.version.iter())
+                    .all(|(a, b)| a == b)
+                    && self
+                    .machine
+                    .iter()
+                    .zip(other.machine.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for utsname {}
+        impl ::fmt::Debug for utsname {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("utsname")
+                    // FIXME: .field("sysname", &self.sysname)
+                    // FIXME: .field("nodename", &self.nodename)
+                    // FIXME: .field("release", &self.release)
+                    // FIXME: .field("version", &self.version)
+                    // FIXME: .field("machine", &self.machine)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for utsname {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sysname.hash(state);
+                self.nodename.hash(state);
+                self.release.hash(state);
+                self.version.hash(state);
+                self.machine.hash(state);
+            }
+        }
+
+        impl PartialEq for fd_set {
+            fn eq(&self, other: &fd_set) -> bool {
+                self.fds_bits
+                    .iter()
+                    .zip(other.fds_bits.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for fd_set {}
+        impl ::fmt::Debug for fd_set {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("fd_set")
+                    // FIXME: .field("fds_bits", &self.fds_bits)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for fd_set {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.fds_bits.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_storage {
+            fn eq(&self, other: &sockaddr_storage) -> bool {
+                self.ss_family == other.ss_family
+                    && self.__ss_pad1 == other.__ss_pad1
+                    && self.__ss_align == other.__ss_align
+                    && self
+                    .__ss_pad2
+                    .iter()
+                    .zip(other.__ss_pad2.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_storage {}
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_pad1", &self.__ss_pad1)
+                    .field("__ss_align", &self.__ss_align)
+                    // FIXME: .field("__ss_pad2", &self.__ss_pad2)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_storage {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.ss_family.hash(state);
+                self.__ss_pad1.hash(state);
+                self.__ss_align.hash(state);
+                self.__ss_pad2.hash(state);
+            }
+        }
+
+        impl PartialEq for siginfo_t {
+            fn eq(&self, other: &siginfo_t) -> bool {
+                self.si_signo == other.si_signo
+                    && self.si_code == other.si_code
+                    && self.si_errno == other.si_errno
+                    && self.si_addr == other.si_addr
+                    && self
+                    .__pad
+                    .iter()
+                    .zip(other.__pad.iter())
+                    .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for siginfo_t {}
+        impl ::fmt::Debug for siginfo_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("siginfo_t")
+                    .field("si_signo", &self.si_signo)
+                    .field("si_code", &self.si_code)
+                    .field("si_errno", &self.si_errno)
+                    .field("si_addr", &self.si_addr)
+                    // FIXME: .field("__pad", &self.__pad)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for siginfo_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.si_signo.hash(state);
+                self.si_code.hash(state);
+                self.si_errno.hash(state);
+                self.si_addr.hash(state);
+                self.__pad.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_dl {
+            fn eq(&self, other: &sockaddr_dl) -> bool {
+                self.sdl_family == other.sdl_family
+                    && self.sdl_index == other.sdl_index
+                    && self.sdl_type == other.sdl_type
+                    && self.sdl_nlen == other.sdl_nlen
+                    && self.sdl_alen == other.sdl_alen
+                    && self.sdl_slen == other.sdl_slen
+                    && self
+                    .sdl_data
+                    .iter()
+                    .zip(other.sdl_data.iter())
+                    .all(|(a,b)| a == b)
+            }
+        }
+        impl Eq for sockaddr_dl {}
+        impl ::fmt::Debug for sockaddr_dl {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_dl")
+                    .field("sdl_family", &self.sdl_family)
+                    .field("sdl_index", &self.sdl_index)
+                    .field("sdl_type", &self.sdl_type)
+                    .field("sdl_nlen", &self.sdl_nlen)
+                    .field("sdl_alen", &self.sdl_alen)
+                    .field("sdl_slen", &self.sdl_slen)
+                    // FIXME: .field("sdl_data", &self.sdl_data)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_dl {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sdl_family.hash(state);
+                self.sdl_index.hash(state);
+                self.sdl_type.hash(state);
+                self.sdl_nlen.hash(state);
+                self.sdl_alen.hash(state);
+                self.sdl_slen.hash(state);
+                self.sdl_data.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_notify == other.sigev_notify
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_value == other.sigev_value
+                    && self.ss_sp == other.ss_sp
+                    && self.sigev_notify_attributes
+                        == other.sigev_notify_attributes
+            }
+        }
+        impl Eq for sigevent {}
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_value", &self.sigev_value)
+                    .field("ss_sp", &self.ss_sp)
+                    .field("sigev_notify_attributes",
+                           &self.sigev_notify_attributes)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_notify.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_value.hash(state);
+                self.ss_sp.hash(state);
+                self.sigev_notify_attributes.hash(state);
+            }
+        }
+
+    }
+}
+
+pub const LC_CTYPE: ::c_int = 0;
+pub const LC_NUMERIC: ::c_int = 1;
+pub const LC_TIME: ::c_int = 2;
+pub const LC_COLLATE: ::c_int = 3;
+pub const LC_MONETARY: ::c_int = 4;
+pub const LC_MESSAGES: ::c_int = 5;
+pub const LC_ALL: ::c_int = 6;
+pub const LC_CTYPE_MASK: ::c_int = 1 << LC_CTYPE;
+pub const LC_NUMERIC_MASK: ::c_int = 1 << LC_NUMERIC;
+pub const LC_TIME_MASK: ::c_int = 1 << LC_TIME;
+pub const LC_COLLATE_MASK: ::c_int = 1 << LC_COLLATE;
+pub const LC_MONETARY_MASK: ::c_int = 1 << LC_MONETARY;
+pub const LC_MESSAGES_MASK: ::c_int = 1 << LC_MESSAGES;
+pub const LC_ALL_MASK: ::c_int = LC_CTYPE_MASK
+    | LC_NUMERIC_MASK
+    | LC_TIME_MASK
+    | LC_COLLATE_MASK
+    | LC_MONETARY_MASK
+    | LC_MESSAGES_MASK;
+
+pub const DAY_1: ::nl_item = 1;
+pub const DAY_2: ::nl_item = 2;
+pub const DAY_3: ::nl_item = 3;
+pub const DAY_4: ::nl_item = 4;
+pub const DAY_5: ::nl_item = 5;
+pub const DAY_6: ::nl_item = 6;
+pub const DAY_7: ::nl_item = 7;
+
+pub const ABDAY_1: ::nl_item = 8;
+pub const ABDAY_2: ::nl_item = 9;
+pub const ABDAY_3: ::nl_item = 10;
+pub const ABDAY_4: ::nl_item = 11;
+pub const ABDAY_5: ::nl_item = 12;
+pub const ABDAY_6: ::nl_item = 13;
+pub const ABDAY_7: ::nl_item = 14;
+
+pub const MON_1: ::nl_item = 15;
+pub const MON_2: ::nl_item = 16;
+pub const MON_3: ::nl_item = 17;
+pub const MON_4: ::nl_item = 18;
+pub const MON_5: ::nl_item = 19;
+pub const MON_6: ::nl_item = 20;
+pub const MON_7: ::nl_item = 21;
+pub const MON_8: ::nl_item = 22;
+pub const MON_9: ::nl_item = 23;
+pub const MON_10: ::nl_item = 24;
+pub const MON_11: ::nl_item = 25;
+pub const MON_12: ::nl_item = 26;
+
+pub const ABMON_1: ::nl_item = 27;
+pub const ABMON_2: ::nl_item = 28;
+pub const ABMON_3: ::nl_item = 29;
+pub const ABMON_4: ::nl_item = 30;
+pub const ABMON_5: ::nl_item = 31;
+pub const ABMON_6: ::nl_item = 32;
+pub const ABMON_7: ::nl_item = 33;
+pub const ABMON_8: ::nl_item = 34;
+pub const ABMON_9: ::nl_item = 35;
+pub const ABMON_10: ::nl_item = 36;
+pub const ABMON_11: ::nl_item = 37;
+pub const ABMON_12: ::nl_item = 38;
+
+pub const RADIXCHAR: ::nl_item = 39;
+pub const THOUSEP: ::nl_item = 40;
+pub const YESSTR: ::nl_item = 41;
+pub const NOSTR: ::nl_item = 42;
+pub const CRNCYSTR: ::nl_item = 43;
+
+pub const D_T_FMT: ::nl_item = 44;
+pub const D_FMT: ::nl_item = 45;
+pub const T_FMT: ::nl_item = 46;
+pub const AM_STR: ::nl_item = 47;
+pub const PM_STR: ::nl_item = 48;
+
+pub const CODESET: ::nl_item = 49;
+pub const T_FMT_AMPM: ::nl_item = 50;
+pub const ERA: ::nl_item = 51;
+pub const ERA_D_FMT: ::nl_item = 52;
+pub const ERA_D_T_FMT: ::nl_item = 53;
+pub const ERA_T_FMT: ::nl_item = 54;
+pub const ALT_DIGITS: ::nl_item = 55;
+pub const YESEXPR: ::nl_item = 56;
+pub const NOEXPR: ::nl_item = 57;
+pub const _DATE_FMT: ::nl_item = 58;
+pub const MAXSTRMSG: ::nl_item = 58;
+
+pub const PATH_MAX: ::c_int = 1024;
+
+pub const SA_ONSTACK: ::c_int = 0x00000001;
+pub const SA_RESETHAND: ::c_int = 0x00000002;
+pub const SA_RESTART: ::c_int = 0x00000004;
+pub const SA_SIGINFO: ::c_int = 0x00000008;
+pub const SA_NODEFER: ::c_int = 0x00000010;
+pub const SA_NOCLDWAIT: ::c_int = 0x00010000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00020000;
+
+pub const SS_ONSTACK: ::c_int = 1;
+pub const SS_DISABLE: ::c_int = 2;
+
+pub const FIOCLEX: ::c_int = 0x20006601;
+pub const FIONCLEX: ::c_int = 0x20006602;
+pub const FIONREAD: ::c_int = 0x4004667f;
+pub const FIONBIO: ::c_int = 0x8004667e;
+pub const FIOASYNC: ::c_int = 0x8004667d;
+pub const FIOSETOWN: ::c_int = 0x8004667c;
+pub const FIOGETOWN: ::c_int = 0x4004667b;
+
+pub const SIGCHLD: ::c_int = 18;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGINFO: ::c_int = 41;
+pub const SIG_BLOCK: ::c_int = 1;
+pub const SIG_UNBLOCK: ::c_int = 2;
+pub const SIG_SETMASK: ::c_int = 3;
+
+pub const SIGEV_NONE: ::c_int = 1;
+pub const SIGEV_SIGNAL: ::c_int = 2;
+pub const SIGEV_THREAD: ::c_int = 3;
+
+pub const IPV6_UNICAST_HOPS: ::c_int = 0x5;
+pub const IPV6_MULTICAST_IF: ::c_int = 0x6;
+pub const IPV6_MULTICAST_HOPS: ::c_int = 0x7;
+pub const IPV6_MULTICAST_LOOP: ::c_int = 0x8;
+pub const IPV6_V6ONLY: ::c_int = 0x27;
+
+cfg_if! {
+    if #[cfg(target_pointer_width = "64")] {
+        pub const FD_SETSIZE: usize = 65536;
+    } else {
+        pub const FD_SETSIZE: usize = 1024;
+    }
+}
+
+pub const ST_RDONLY: ::c_ulong = 1;
+pub const ST_NOSUID: ::c_ulong = 2;
+
+pub const NI_MAXHOST: ::socklen_t = 1025;
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const RAND_MAX: ::c_int = 32767;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const SEEK_DATA: ::c_int = 3;
+pub const SEEK_HOLE: ::c_int = 4;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 4;
+pub const _IOLBF: ::c_int = 64;
+pub const BUFSIZ: ::c_uint = 1024;
+pub const FOPEN_MAX: ::c_uint = 20;
+pub const FILENAME_MAX: ::c_uint = 1024;
+pub const L_tmpnam: ::c_uint = 25;
+pub const TMP_MAX: ::c_uint = 17576;
+
+pub const O_RDONLY: ::c_int = 0;
+pub const O_WRONLY: ::c_int = 1;
+pub const O_RDWR: ::c_int = 2;
+pub const O_NDELAY: ::c_int = 0x04;
+pub const O_APPEND: ::c_int = 8;
+pub const O_DSYNC: ::c_int = 0x40;
+pub const O_CREAT: ::c_int = 256;
+pub const O_EXCL: ::c_int = 1024;
+pub const O_NOCTTY: ::c_int = 2048;
+pub const O_TRUNC: ::c_int = 512;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+pub const O_SEARCH: ::c_int = 0x200000;
+pub const O_EXEC: ::c_int = 0x400000;
+pub const O_CLOEXEC: ::c_int = 0x800000;
+pub const O_ACCMODE: ::c_int = 0x600003;
+pub const S_IFIFO: mode_t = 4096;
+pub const S_IFCHR: mode_t = 8192;
+pub const S_IFBLK: mode_t = 24576;
+pub const S_IFDIR: mode_t = 16384;
+pub const S_IFREG: mode_t = 32768;
+pub const S_IFLNK: mode_t = 40960;
+pub const S_IFSOCK: mode_t = 49152;
+pub const S_IFMT: mode_t = 61440;
+pub const S_IEXEC: mode_t = 64;
+pub const S_IWRITE: mode_t = 128;
+pub const S_IREAD: mode_t = 256;
+pub const S_IRWXU: mode_t = 448;
+pub const S_IXUSR: mode_t = 64;
+pub const S_IWUSR: mode_t = 128;
+pub const S_IRUSR: mode_t = 256;
+pub const S_IRWXG: mode_t = 56;
+pub const S_IXGRP: mode_t = 8;
+pub const S_IWGRP: mode_t = 16;
+pub const S_IRGRP: mode_t = 32;
+pub const S_IRWXO: mode_t = 7;
+pub const S_IXOTH: mode_t = 1;
+pub const S_IWOTH: mode_t = 2;
+pub const S_IROTH: mode_t = 4;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+pub const F_DUPFD_CLOEXEC: ::c_int = 37;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_GETLK: ::c_int = 14;
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGEMT: ::c_int = 7;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+pub const SIGUSR1: ::c_int = 16;
+pub const SIGUSR2: ::c_int = 17;
+pub const SIGPWR: ::c_int = 19;
+pub const SIGWINCH: ::c_int = 20;
+pub const SIGURG: ::c_int = 21;
+pub const SIGPOLL: ::c_int = 22;
+pub const SIGIO: ::c_int = SIGPOLL;
+pub const SIGSTOP: ::c_int = 23;
+pub const SIGTSTP: ::c_int = 24;
+pub const SIGCONT: ::c_int = 25;
+pub const SIGTTIN: ::c_int = 26;
+pub const SIGTTOU: ::c_int = 27;
+pub const SIGVTALRM: ::c_int = 28;
+pub const SIGPROF: ::c_int = 29;
+pub const SIGXCPU: ::c_int = 30;
+pub const SIGXFSZ: ::c_int = 31;
+
+pub const WNOHANG: ::c_int = 0x40;
+pub const WUNTRACED: ::c_int = 0x04;
+
+pub const WEXITED: ::c_int = 0x01;
+pub const WTRAPPED: ::c_int = 0x02;
+pub const WSTOPPED: ::c_int = WUNTRACED;
+pub const WCONTINUED: ::c_int = 0x08;
+pub const WNOWAIT: ::c_int = 0x80;
+
+pub const AT_FDCWD: ::c_int = 0xffd19553;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x1000;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x2000;
+pub const AT_REMOVEDIR: ::c_int = 0x1;
+pub const _AT_TRIGGER: ::c_int = 0x2;
+pub const AT_EACCESS: ::c_int = 0x4;
+
+pub const P_PID: idtype_t = 0;
+pub const P_PPID: idtype_t = 1;
+pub const P_PGID: idtype_t = 2;
+pub const P_SID: idtype_t = 3;
+pub const P_CID: idtype_t = 4;
+pub const P_UID: idtype_t = 5;
+pub const P_GID: idtype_t = 6;
+pub const P_ALL: idtype_t = 7;
+pub const P_LWPID: idtype_t = 8;
+pub const P_TASKID: idtype_t = 9;
+pub const P_PROJID: idtype_t = 10;
+pub const P_POOLID: idtype_t = 11;
+pub const P_ZONEID: idtype_t = 12;
+pub const P_CTID: idtype_t = 13;
+pub const P_CPUID: idtype_t = 14;
+pub const P_PSETID: idtype_t = 15;
+
+pub const UTIME_OMIT: c_long = -2;
+pub const UTIME_NOW: c_long = -1;
+
+pub const PROT_NONE: ::c_int = 0;
+pub const PROT_READ: ::c_int = 1;
+pub const PROT_WRITE: ::c_int = 2;
+pub const PROT_EXEC: ::c_int = 4;
+
+pub const MAP_FILE: ::c_int = 0;
+pub const MAP_SHARED: ::c_int = 0x0001;
+pub const MAP_PRIVATE: ::c_int = 0x0002;
+pub const MAP_FIXED: ::c_int = 0x0010;
+pub const MAP_NORESERVE: ::c_int = 0x40;
+pub const MAP_ANON: ::c_int = 0x0100;
+pub const MAP_ANONYMOUS: ::c_int = 0x0100;
+pub const MAP_RENAME: ::c_int = 0x20;
+pub const MAP_ALIGN: ::c_int = 0x200;
+pub const MAP_TEXT: ::c_int = 0x400;
+pub const MAP_INITDATA: ::c_int = 0x800;
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const MS_SYNC: ::c_int = 0x0004;
+pub const MS_ASYNC: ::c_int = 0x0001;
+pub const MS_INVALIDATE: ::c_int = 0x0002;
+
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const ENOMSG: ::c_int = 35;
+pub const EIDRM: ::c_int = 36;
+pub const ECHRNG: ::c_int = 37;
+pub const EL2NSYNC: ::c_int = 38;
+pub const EL3HLT: ::c_int = 39;
+pub const EL3RST: ::c_int = 40;
+pub const ELNRNG: ::c_int = 41;
+pub const EUNATCH: ::c_int = 42;
+pub const ENOCSI: ::c_int = 43;
+pub const EL2HLT: ::c_int = 44;
+pub const EDEADLK: ::c_int = 45;
+pub const ENOLCK: ::c_int = 46;
+pub const ECANCELED: ::c_int = 47;
+pub const ENOTSUP: ::c_int = 48;
+pub const EDQUOT: ::c_int = 49;
+pub const EBADE: ::c_int = 50;
+pub const EBADR: ::c_int = 51;
+pub const EXFULL: ::c_int = 52;
+pub const ENOANO: ::c_int = 53;
+pub const EBADRQC: ::c_int = 54;
+pub const EBADSLT: ::c_int = 55;
+pub const EDEADLOCK: ::c_int = 56;
+pub const EBFONT: ::c_int = 57;
+pub const EOWNERDEAD: ::c_int = 58;
+pub const ENOTRECOVERABLE: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const ELOCKUNMAPPED: ::c_int = 72;
+pub const ENOTACTIVE: ::c_int = 73;
+pub const EMULTIHOP: ::c_int = 74;
+pub const EADI: ::c_int = 75;
+pub const EBADMSG: ::c_int = 77;
+pub const ENAMETOOLONG: ::c_int = 78;
+pub const EOVERFLOW: ::c_int = 79;
+pub const ENOTUNIQ: ::c_int = 80;
+pub const EBADFD: ::c_int = 81;
+pub const EREMCHG: ::c_int = 82;
+pub const ELIBACC: ::c_int = 83;
+pub const ELIBBAD: ::c_int = 84;
+pub const ELIBSCN: ::c_int = 85;
+pub const ELIBMAX: ::c_int = 86;
+pub const ELIBEXEC: ::c_int = 87;
+pub const EILSEQ: ::c_int = 88;
+pub const ENOSYS: ::c_int = 89;
+pub const ELOOP: ::c_int = 90;
+pub const ERESTART: ::c_int = 91;
+pub const ESTRPIPE: ::c_int = 92;
+pub const ENOTEMPTY: ::c_int = 93;
+pub const EUSERS: ::c_int = 94;
+pub const ENOTSOCK: ::c_int = 95;
+pub const EDESTADDRREQ: ::c_int = 96;
+pub const EMSGSIZE: ::c_int = 97;
+pub const EPROTOTYPE: ::c_int = 98;
+pub const ENOPROTOOPT: ::c_int = 99;
+pub const EPROTONOSUPPORT: ::c_int = 120;
+pub const ESOCKTNOSUPPORT: ::c_int = 121;
+pub const EOPNOTSUPP: ::c_int = 122;
+pub const EPFNOSUPPORT: ::c_int = 123;
+pub const EAFNOSUPPORT: ::c_int = 124;
+pub const EADDRINUSE: ::c_int = 125;
+pub const EADDRNOTAVAIL: ::c_int = 126;
+pub const ENETDOWN: ::c_int = 127;
+pub const ENETUNREACH: ::c_int = 128;
+pub const ENETRESET: ::c_int = 129;
+pub const ECONNABORTED: ::c_int = 130;
+pub const ECONNRESET: ::c_int = 131;
+pub const ENOBUFS: ::c_int = 132;
+pub const EISCONN: ::c_int = 133;
+pub const ENOTCONN: ::c_int = 134;
+pub const ESHUTDOWN: ::c_int = 143;
+pub const ETOOMANYREFS: ::c_int = 144;
+pub const ETIMEDOUT: ::c_int = 145;
+pub const ECONNREFUSED: ::c_int = 146;
+pub const EHOSTDOWN: ::c_int = 147;
+pub const EHOSTUNREACH: ::c_int = 148;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+pub const EALREADY: ::c_int = 149;
+pub const EINPROGRESS: ::c_int = 150;
+pub const ESTALE: ::c_int = 151;
+
+pub const EAI_AGAIN: ::c_int = 2;
+pub const EAI_BADFLAGS: ::c_int = 3;
+pub const EAI_FAIL: ::c_int = 4;
+pub const EAI_FAMILY: ::c_int = 5;
+pub const EAI_MEMORY: ::c_int = 6;
+pub const EAI_NODATA: ::c_int = 7;
+pub const EAI_NONAME: ::c_int = 8;
+pub const EAI_SERVICE: ::c_int = 9;
+pub const EAI_SOCKTYPE: ::c_int = 10;
+pub const EAI_SYSTEM: ::c_int = 11;
+pub const EAI_OVERFLOW: ::c_int = 12;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+
+pub const SIGTRAP: ::c_int = 5;
+
+pub const GLOB_APPEND: ::c_int = 32;
+pub const GLOB_DOOFFS: ::c_int = 16;
+pub const GLOB_ERR: ::c_int = 1;
+pub const GLOB_MARK: ::c_int = 2;
+pub const GLOB_NOCHECK: ::c_int = 8;
+pub const GLOB_NOSORT: ::c_int = 4;
+pub const GLOB_NOESCAPE: ::c_int = 64;
+
+pub const GLOB_NOSPACE: ::c_int = -2;
+pub const GLOB_ABORTED: ::c_int = -1;
+pub const GLOB_NOMATCH: ::c_int = -3;
+
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLPRI: ::c_short = 0x2;
+pub const POLLOUT: ::c_short = 0x4;
+pub const POLLERR: ::c_short = 0x8;
+pub const POLLHUP: ::c_short = 0x10;
+pub const POLLNVAL: ::c_short = 0x20;
+pub const POLLNORM: ::c_short = 0x0040;
+pub const POLLRDNORM: ::c_short = 0x0040;
+pub const POLLWRNORM: ::c_short = 0x4; /* POLLOUT */
+pub const POLLRDBAND: ::c_short = 0x0080;
+pub const POLLWRBAND: ::c_short = 0x0100;
+
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+
+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;
+pub const PTHREAD_CREATE_DETACHED: ::c_int = 0x40;
+pub const PTHREAD_PROCESS_SHARED: ::c_int = 1;
+pub const PTHREAD_PROCESS_PRIVATE: ::c_ushort = 0;
+pub const PTHREAD_STACK_MIN: ::size_t = 4096;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+
+// https://illumos.org/man/3c/clock_gettime
+// https://github.com/illumos/illumos-gate/
+//   blob/HEAD/usr/src/lib/libc/amd64/sys/__clock_gettime.s
+// clock_gettime(3c) doesn't seem to accept anything other than CLOCK_REALTIME
+// or __CLOCK_REALTIME0
+//
+// https://github.com/illumos/illumos-gate/
+//   blob/HEAD/usr/src/uts/common/sys/time_impl.h
+// Confusing! CLOCK_HIGHRES==CLOCK_MONOTONIC==4
+// __CLOCK_REALTIME0==0 is an obsoleted version of CLOCK_REALTIME==3
+pub const CLOCK_REALTIME: ::clockid_t = 3;
+pub const CLOCK_MONOTONIC: ::clockid_t = 4;
+pub const TIMER_RELTIME: ::c_int = 0;
+pub const TIMER_ABSTIME: ::c_int = 1;
+
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_NOFILE: ::c_int = 5;
+pub const RLIMIT_VMEM: ::c_int = 6;
+pub const RLIMIT_AS: ::c_int = RLIMIT_VMEM;
+
+#[deprecated(since = "0.2.64", note = "Not stable across OS versions")]
+pub const RLIM_NLIMITS: rlim_t = 7;
+pub const RLIM_INFINITY: rlim_t = 0xfffffffffffffffd;
+
+pub const RUSAGE_SELF: ::c_int = 0;
+pub const RUSAGE_CHILDREN: ::c_int = -1;
+
+pub const MADV_NORMAL: ::c_int = 0;
+pub const MADV_RANDOM: ::c_int = 1;
+pub const MADV_SEQUENTIAL: ::c_int = 2;
+pub const MADV_WILLNEED: ::c_int = 3;
+pub const MADV_DONTNEED: ::c_int = 4;
+pub const MADV_FREE: ::c_int = 5;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_UNIX: ::c_int = 1;
+pub const AF_INET: ::c_int = 2;
+pub const AF_IMPLINK: ::c_int = 3;
+pub const AF_PUP: ::c_int = 4;
+pub const AF_CHAOS: ::c_int = 5;
+pub const AF_NS: ::c_int = 6;
+pub const AF_NBS: ::c_int = 7;
+pub const AF_ECMA: ::c_int = 8;
+pub const AF_DATAKIT: ::c_int = 9;
+pub const AF_CCITT: ::c_int = 10;
+pub const AF_SNA: ::c_int = 11;
+pub const AF_DECnet: ::c_int = 12;
+pub const AF_DLI: ::c_int = 13;
+pub const AF_LAT: ::c_int = 14;
+pub const AF_HYLINK: ::c_int = 15;
+pub const AF_APPLETALK: ::c_int = 16;
+pub const AF_NIT: ::c_int = 17;
+pub const AF_802: ::c_int = 18;
+pub const AF_OSI: ::c_int = 19;
+pub const AF_X25: ::c_int = 20;
+pub const AF_OSINET: ::c_int = 21;
+pub const AF_GOSIP: ::c_int = 22;
+pub const AF_IPX: ::c_int = 23;
+pub const AF_ROUTE: ::c_int = 24;
+pub const AF_LINK: ::c_int = 25;
+pub const AF_INET6: ::c_int = 26;
+pub const AF_KEY: ::c_int = 27;
+pub const AF_NCA: ::c_int = 28;
+pub const AF_POLICY: ::c_int = 29;
+pub const AF_INET_OFFLOAD: ::c_int = 30;
+pub const AF_TRILL: ::c_int = 31;
+pub const AF_PACKET: ::c_int = 32;
+
+pub const SOCK_DGRAM: ::c_int = 1;
+pub const SOCK_STREAM: ::c_int = 2;
+pub const SOCK_RAW: ::c_int = 4;
+pub const SOCK_RDM: ::c_int = 5;
+pub const SOCK_SEQPACKET: ::c_int = 6;
+pub const IP_MULTICAST_IF: ::c_int = 16;
+pub const IP_MULTICAST_TTL: ::c_int = 17;
+pub const IP_MULTICAST_LOOP: ::c_int = 18;
+pub const IP_TTL: ::c_int = 4;
+pub const IP_HDRINCL: ::c_int = 2;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 19;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 20;
+pub const IPV6_JOIN_GROUP: ::c_int = 9;
+pub const IPV6_LEAVE_GROUP: ::c_int = 10;
+
+// These TCP socket options are common between illumos and Solaris, while higher
+// numbers have generally diverged:
+pub const TCP_NODELAY: ::c_int = 0x1;
+pub const TCP_MAXSEG: ::c_int = 0x2;
+pub const TCP_KEEPALIVE: ::c_int = 0x8;
+pub const TCP_NOTIFY_THRESHOLD: ::c_int = 0x10;
+pub const TCP_ABORT_THRESHOLD: ::c_int = 0x11;
+pub const TCP_CONN_NOTIFY_THRESHOLD: ::c_int = 0x12;
+pub const TCP_CONN_ABORT_THRESHOLD: ::c_int = 0x13;
+pub const TCP_RECVDSTADDR: ::c_int = 0x14;
+pub const TCP_INIT_CWND: ::c_int = 0x15;
+pub const TCP_KEEPALIVE_THRESHOLD: ::c_int = 0x16;
+pub const TCP_KEEPALIVE_ABORT_THRESHOLD: ::c_int = 0x17;
+pub const TCP_CORK: ::c_int = 0x18;
+pub const TCP_RTO_INITIAL: ::c_int = 0x19;
+pub const TCP_RTO_MIN: ::c_int = 0x1a;
+pub const TCP_RTO_MAX: ::c_int = 0x1b;
+pub const TCP_LINGER2: ::c_int = 0x1c;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+pub const SO_DEBUG: ::c_int = 0x01;
+pub const SO_ACCEPTCONN: ::c_int = 0x0002;
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_USELOOPBACK: ::c_int = 0x0040;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_TIMESTAMP: ::c_int = 0x1013;
+
+pub const SCM_RIGHTS: ::c_int = 0x1010;
+pub const SCM_UCRED: ::c_int = 0x1012;
+pub const SCM_TIMESTAMP: ::c_int = SO_TIMESTAMP;
+
+pub const MSG_OOB: ::c_int = 0x1;
+pub const MSG_PEEK: ::c_int = 0x2;
+pub const MSG_DONTROUTE: ::c_int = 0x4;
+pub const MSG_EOR: ::c_int = 0x8;
+pub const MSG_CTRUNC: ::c_int = 0x10;
+pub const MSG_TRUNC: ::c_int = 0x20;
+pub const MSG_WAITALL: ::c_int = 0x40;
+pub const MSG_DONTWAIT: ::c_int = 0x80;
+pub const MSG_NOTIFICATION: ::c_int = 0x100;
+pub const MSG_NOSIGNAL: ::c_int = 0x200;
+pub const MSG_DUPCTRL: ::c_int = 0x800;
+pub const MSG_XPG4_2: ::c_int = 0x8000;
+pub const MSG_MAXIOVLEN: ::c_int = 16;
+
+pub const IF_NAMESIZE: ::size_t = 32;
+pub const IFNAMSIZ: ::size_t = 16;
+
+// https://docs.oracle.com/cd/E23824_01/html/821-1475/if-7p.html
+pub const IFF_UP: ::c_int = 0x0000000001; // Address is up
+pub const IFF_BROADCAST: ::c_int = 0x0000000002; // Broadcast address valid
+pub const IFF_DEBUG: ::c_int = 0x0000000004; // Turn on debugging
+pub const IFF_LOOPBACK: ::c_int = 0x0000000008; // Loopback net
+pub const IFF_POINTOPOINT: ::c_int = 0x0000000010; // Interface is p-to-p
+pub const IFF_NOTRAILERS: ::c_int = 0x0000000020; // Avoid use of trailers
+pub const IFF_RUNNING: ::c_int = 0x0000000040; // Resources allocated
+pub const IFF_NOARP: ::c_int = 0x0000000080; // No address res. protocol
+pub const IFF_PROMISC: ::c_int = 0x0000000100; // Receive all packets
+pub const IFF_ALLMULTI: ::c_int = 0x0000000200; // Receive all multicast pkts
+pub const IFF_INTELLIGENT: ::c_int = 0x0000000400; // Protocol code on board
+pub const IFF_MULTICAST: ::c_int = 0x0000000800; // Supports multicast
+
+// Multicast using broadcst. add.
+pub const IFF_MULTI_BCAST: ::c_int = 0x0000001000;
+pub const IFF_UNNUMBERED: ::c_int = 0x0000002000; // Non-unique address
+pub const IFF_DHCPRUNNING: ::c_int = 0x0000004000; // DHCP controls interface
+pub const IFF_PRIVATE: ::c_int = 0x0000008000; // Do not advertise
+pub const IFF_NOXMIT: ::c_int = 0x0000010000; // Do not transmit pkts
+
+// No address - just on-link subnet
+pub const IFF_NOLOCAL: ::c_int = 0x0000020000;
+pub const IFF_DEPRECATED: ::c_int = 0x0000040000; // Address is deprecated
+pub const IFF_ADDRCONF: ::c_int = 0x0000080000; // Addr. from stateless addrconf
+pub const IFF_ROUTER: ::c_int = 0x0000100000; // Router on interface
+pub const IFF_NONUD: ::c_int = 0x0000200000; // No NUD on interface
+pub const IFF_ANYCAST: ::c_int = 0x0000400000; // Anycast address
+pub const IFF_NORTEXCH: ::c_int = 0x0000800000; // Don't xchange rout. info
+pub const IFF_IPV4: ::c_int = 0x0001000000; // IPv4 interface
+pub const IFF_IPV6: ::c_int = 0x0002000000; // IPv6 interface
+pub const IFF_NOFAILOVER: ::c_int = 0x0008000000; // in.mpathd test address
+pub const IFF_FAILED: ::c_int = 0x0010000000; // Interface has failed
+pub const IFF_STANDBY: ::c_int = 0x0020000000; // Interface is a hot-spare
+pub const IFF_INACTIVE: ::c_int = 0x0040000000; // Functioning but not used
+pub const IFF_OFFLINE: ::c_int = 0x0080000000; // Interface is offline
+                                               // If CoS marking is supported
+pub const IFF_COS_ENABLED: ::c_longlong = 0x0200000000;
+pub const IFF_PREFERRED: ::c_longlong = 0x0400000000; // Prefer as source addr.
+pub const IFF_TEMPORARY: ::c_longlong = 0x0800000000; // RFC3041
+pub const IFF_FIXEDMTU: ::c_longlong = 0x1000000000; // MTU set with SIOCSLIFMTU
+pub const IFF_VIRTUAL: ::c_longlong = 0x2000000000; // Cannot send/receive pkts
+pub const IFF_DUPLICATE: ::c_longlong = 0x4000000000; // Local address in use
+pub const IFF_IPMP: ::c_longlong = 0x8000000000; // IPMP IP interface
+
+// sys/ipc.h:
+pub const IPC_ALLOC: ::c_int = 0x8000;
+pub const IPC_CREAT: ::c_int = 0x200;
+pub const IPC_EXCL: ::c_int = 0x400;
+pub const IPC_NOWAIT: ::c_int = 0x800;
+pub const IPC_PRIVATE: key_t = 0;
+pub const IPC_RMID: ::c_int = 10;
+pub const IPC_SET: ::c_int = 11;
+pub const IPC_SEAT: ::c_int = 12;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const LOCK_SH: ::c_int = 1;
+pub const LOCK_EX: ::c_int = 2;
+pub const LOCK_NB: ::c_int = 4;
+pub const LOCK_UN: ::c_int = 8;
+
+pub const F_RDLCK: ::c_short = 1;
+pub const F_WRLCK: ::c_short = 2;
+pub const F_UNLCK: ::c_short = 3;
+
+pub const O_SYNC: ::c_int = 16;
+pub const O_NONBLOCK: ::c_int = 128;
+
+pub const IPPROTO_RAW: ::c_int = 255;
+
+pub const _PC_LINK_MAX: ::c_int = 1;
+pub const _PC_MAX_CANON: ::c_int = 2;
+pub const _PC_MAX_INPUT: ::c_int = 3;
+pub const _PC_NAME_MAX: ::c_int = 4;
+pub const _PC_PATH_MAX: ::c_int = 5;
+pub const _PC_PIPE_BUF: ::c_int = 6;
+pub const _PC_NO_TRUNC: ::c_int = 7;
+pub const _PC_VDISABLE: ::c_int = 8;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 9;
+pub const _PC_ASYNC_IO: ::c_int = 10;
+pub const _PC_PRIO_IO: ::c_int = 11;
+pub const _PC_SYNC_IO: ::c_int = 12;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 13;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 17;
+pub const _PC_SYMLINK_MAX: ::c_int = 18;
+pub const _PC_2_SYMLINKS: ::c_int = 19;
+pub const _PC_ACL_ENABLED: ::c_int = 20;
+pub const _PC_MIN_HOLE_SIZE: ::c_int = 21;
+pub const _PC_CASE_BEHAVIOR: ::c_int = 22;
+pub const _PC_SATTR_ENABLED: ::c_int = 23;
+pub const _PC_SATTR_EXISTS: ::c_int = 24;
+pub const _PC_ACCESS_FILTERING: ::c_int = 25;
+pub const _PC_TIMESTAMP_RESOLUTION: ::c_int = 26;
+pub const _PC_FILESIZEBITS: ::c_int = 67;
+pub const _PC_XATTR_ENABLED: ::c_int = 100;
+pub const _PC_LAST: ::c_int = 101;
+pub const _PC_XATTR_EXISTS: ::c_int = 101;
+
+pub const _SC_ARG_MAX: ::c_int = 1;
+pub const _SC_CHILD_MAX: ::c_int = 2;
+pub const _SC_CLK_TCK: ::c_int = 3;
+pub const _SC_NGROUPS_MAX: ::c_int = 4;
+pub const _SC_OPEN_MAX: ::c_int = 5;
+pub const _SC_JOB_CONTROL: ::c_int = 6;
+pub const _SC_SAVED_IDS: ::c_int = 7;
+pub const _SC_VERSION: ::c_int = 8;
+pub const _SC_PASS_MAX: ::c_int = 9;
+pub const _SC_LOGNAME_MAX: ::c_int = 10;
+pub const _SC_PAGESIZE: ::c_int = 11;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_XOPEN_VERSION: ::c_int = 12;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 14;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 15;
+pub const _SC_STREAM_MAX: ::c_int = 16;
+pub const _SC_TZNAME_MAX: ::c_int = 17;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 18;
+pub const _SC_AIO_MAX: ::c_int = 19;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 20;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 21;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 22;
+pub const _SC_FSYNC: ::c_int = 23;
+pub const _SC_MAPPED_FILES: ::c_int = 24;
+pub const _SC_MEMLOCK: ::c_int = 25;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 26;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 27;
+pub const _SC_MESSAGE_PASSING: ::c_int = 28;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 29;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 30;
+pub const _SC_PRIORITIZED_IO: ::c_int = 31;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 32;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 33;
+pub const _SC_RTSIG_MAX: ::c_int = 34;
+pub const _SC_SEMAPHORES: ::c_int = 35;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 36;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 37;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 38;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 39;
+pub const _SC_SIGRT_MIN: ::c_int = 40;
+pub const _SC_SIGRT_MAX: ::c_int = 41;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 42;
+pub const _SC_TIMERS: ::c_int = 43;
+pub const _SC_TIMER_MAX: ::c_int = 44;
+pub const _SC_2_C_BIND: ::c_int = 45;
+pub const _SC_2_C_DEV: ::c_int = 46;
+pub const _SC_2_C_VERSION: ::c_int = 47;
+pub const _SC_2_FORT_DEV: ::c_int = 48;
+pub const _SC_2_FORT_RUN: ::c_int = 49;
+pub const _SC_2_LOCALEDEF: ::c_int = 50;
+pub const _SC_2_SW_DEV: ::c_int = 51;
+pub const _SC_2_UPE: ::c_int = 52;
+pub const _SC_2_VERSION: ::c_int = 53;
+pub const _SC_BC_BASE_MAX: ::c_int = 54;
+pub const _SC_BC_DIM_MAX: ::c_int = 55;
+pub const _SC_BC_SCALE_MAX: ::c_int = 56;
+pub const _SC_BC_STRING_MAX: ::c_int = 57;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 58;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 59;
+pub const _SC_LINE_MAX: ::c_int = 60;
+pub const _SC_RE_DUP_MAX: ::c_int = 61;
+pub const _SC_XOPEN_CRYPT: ::c_int = 62;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 63;
+pub const _SC_XOPEN_SHM: ::c_int = 64;
+pub const _SC_2_CHAR_TERM: ::c_int = 66;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 67;
+pub const _SC_ATEXIT_MAX: ::c_int = 76;
+pub const _SC_IOV_MAX: ::c_int = 77;
+pub const _SC_XOPEN_UNIX: ::c_int = 78;
+pub const _SC_T_IOV_MAX: ::c_int = 79;
+pub const _SC_PHYS_PAGES: ::c_int = 500;
+pub const _SC_AVPHYS_PAGES: ::c_int = 501;
+pub const _SC_COHER_BLKSZ: ::c_int = 503;
+pub const _SC_SPLIT_CACHE: ::c_int = 504;
+pub const _SC_ICACHE_SZ: ::c_int = 505;
+pub const _SC_DCACHE_SZ: ::c_int = 506;
+pub const _SC_ICACHE_LINESZ: ::c_int = 507;
+pub const _SC_DCACHE_LINESZ: ::c_int = 508;
+pub const _SC_ICACHE_BLKSZ: ::c_int = 509;
+pub const _SC_DCACHE_BLKSZ: ::c_int = 510;
+pub const _SC_DCACHE_TBLKSZ: ::c_int = 511;
+pub const _SC_ICACHE_ASSOC: ::c_int = 512;
+pub const _SC_DCACHE_ASSOC: ::c_int = 513;
+pub const _SC_MAXPID: ::c_int = 514;
+pub const _SC_STACK_PROT: ::c_int = 515;
+pub const _SC_NPROCESSORS_MAX: ::c_int = 516;
+pub const _SC_CPUID_MAX: ::c_int = 517;
+pub const _SC_EPHID_MAX: ::c_int = 518;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 568;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 569;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 570;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 571;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 572;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 573;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 574;
+pub const _SC_TTY_NAME_MAX: ::c_int = 575;
+pub const _SC_THREADS: ::c_int = 576;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 577;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 578;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 579;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 580;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 581;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 582;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 583;
+pub const _SC_XOPEN_LEGACY: ::c_int = 717;
+pub const _SC_XOPEN_REALTIME: ::c_int = 718;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 719;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 720;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 721;
+pub const _SC_XBS5_LP64_OFF64: ::c_int = 722;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 723;
+pub const _SC_2_PBS: ::c_int = 724;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 725;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 726;
+pub const _SC_2_PBS_LOCATE: ::c_int = 728;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 729;
+pub const _SC_2_PBS_TRACK: ::c_int = 730;
+pub const _SC_ADVISORY_INFO: ::c_int = 731;
+pub const _SC_BARRIERS: ::c_int = 732;
+pub const _SC_CLOCK_SELECTION: ::c_int = 733;
+pub const _SC_CPUTIME: ::c_int = 734;
+pub const _SC_HOST_NAME_MAX: ::c_int = 735;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 736;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 737;
+pub const _SC_REGEXP: ::c_int = 738;
+pub const _SC_SHELL: ::c_int = 739;
+pub const _SC_SPAWN: ::c_int = 740;
+pub const _SC_SPIN_LOCKS: ::c_int = 741;
+pub const _SC_SPORADIC_SERVER: ::c_int = 742;
+pub const _SC_SS_REPL_MAX: ::c_int = 743;
+pub const _SC_SYMLOOP_MAX: ::c_int = 744;
+pub const _SC_THREAD_CPUTIME: ::c_int = 745;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 746;
+pub const _SC_TIMEOUTS: ::c_int = 747;
+pub const _SC_TRACE: ::c_int = 748;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 749;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 750;
+pub const _SC_TRACE_INHERIT: ::c_int = 751;
+pub const _SC_TRACE_LOG: ::c_int = 752;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 753;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 754;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 755;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 756;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 757;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 758;
+pub const _SC_V6_LP64_OFF64: ::c_int = 759;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 760;
+pub const _SC_XOPEN_STREAMS: ::c_int = 761;
+pub const _SC_IPV6: ::c_int = 762;
+pub const _SC_RAW_SOCKETS: ::c_int = 763;
+
+pub const _MUTEX_MAGIC: u16 = 0x4d58; // MX
+pub const _COND_MAGIC: u16 = 0x4356; // CV
+pub const _RWL_MAGIC: u16 = 0x5257; // RW
+
+pub const NCCS: usize = 19;
+
+pub const LOG_CRON: ::c_int = 15 << 3;
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+    __pthread_mutex_flag1: 0,
+    __pthread_mutex_flag2: 0,
+    __pthread_mutex_ceiling: 0,
+    __pthread_mutex_type: PTHREAD_PROCESS_PRIVATE,
+    __pthread_mutex_magic: _MUTEX_MAGIC,
+    __pthread_mutex_lock: 0,
+    __pthread_mutex_data: 0,
+};
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+    __pthread_cond_flag: [0; 4],
+    __pthread_cond_type: PTHREAD_PROCESS_PRIVATE,
+    __pthread_cond_magic: _COND_MAGIC,
+    __pthread_cond_data: 0,
+};
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+    __pthread_rwlock_readers: 0,
+    __pthread_rwlock_type: PTHREAD_PROCESS_PRIVATE,
+    __pthread_rwlock_magic: _RWL_MAGIC,
+    __pthread_rwlock_mutex: PTHREAD_MUTEX_INITIALIZER,
+    __pthread_rwlock_readercv: PTHREAD_COND_INITIALIZER,
+    __pthread_rwlock_writercv: PTHREAD_COND_INITIALIZER,
+};
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 4;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+
+pub const RTLD_NEXT: *mut ::c_void = -1isize as *mut ::c_void;
+pub const RTLD_DEFAULT: *mut ::c_void = -2isize as *mut ::c_void;
+pub const RTLD_SELF: *mut ::c_void = -3isize as *mut ::c_void;
+pub const RTLD_PROBE: *mut ::c_void = -4isize as *mut ::c_void;
+
+pub const RTLD_LAZY: ::c_int = 0x1;
+pub const RTLD_NOW: ::c_int = 0x2;
+pub const RTLD_NOLOAD: ::c_int = 0x4;
+pub const RTLD_GLOBAL: ::c_int = 0x100;
+pub const RTLD_LOCAL: ::c_int = 0x0;
+pub const RTLD_PARENT: ::c_int = 0x200;
+pub const RTLD_GROUP: ::c_int = 0x400;
+pub const RTLD_WORLD: ::c_int = 0x800;
+pub const RTLD_NODELETE: ::c_int = 0x1000;
+pub const RTLD_FIRST: ::c_int = 0x2000;
+pub const RTLD_CONFGEN: ::c_int = 0x10000;
+
+pub const PORT_SOURCE_AIO: ::c_int = 1;
+pub const PORT_SOURCE_TIMER: ::c_int = 2;
+pub const PORT_SOURCE_USER: ::c_int = 3;
+pub const PORT_SOURCE_FD: ::c_int = 4;
+pub const PORT_SOURCE_ALERT: ::c_int = 5;
+pub const PORT_SOURCE_MQ: ::c_int = 6;
+pub const PORT_SOURCE_FILE: ::c_int = 7;
+
+pub const NONROOT_USR: ::c_short = 2;
+pub const _UTX_USERSIZE: usize = 32;
+pub const _UTX_LINESIZE: usize = 32;
+pub const _UTX_PADSIZE: usize = 5;
+pub const _UTX_IDSIZE: usize = 4;
+pub const _UTX_HOSTSIZE: usize = 257;
+pub const EMPTY: ::c_short = 0;
+pub const RUN_LVL: ::c_short = 1;
+pub const BOOT_TIME: ::c_short = 2;
+pub const OLD_TIME: ::c_short = 3;
+pub const NEW_TIME: ::c_short = 4;
+pub const INIT_PROCESS: ::c_short = 5;
+pub const LOGIN_PROCESS: ::c_short = 6;
+pub const USER_PROCESS: ::c_short = 7;
+pub const DEAD_PROCESS: ::c_short = 8;
+pub const ACCOUNTING: ::c_short = 9;
+pub const DOWN_TIME: ::c_short = 10;
+
+const _TIOC: ::c_int = ('T' as i32) << 8;
+const tIOC: ::c_int = ('t' as i32) << 8;
+pub const TCGETA: ::c_int = _TIOC | 1;
+pub const TCSETA: ::c_int = _TIOC | 2;
+pub const TCSETAW: ::c_int = _TIOC | 3;
+pub const TCSETAF: ::c_int = _TIOC | 4;
+pub const TCSBRK: ::c_int = _TIOC | 5;
+pub const TCXONC: ::c_int = _TIOC | 6;
+pub const TCFLSH: ::c_int = _TIOC | 7;
+pub const TCDSET: ::c_int = _TIOC | 32;
+pub const TCGETS: ::c_int = _TIOC | 13;
+pub const TCSETS: ::c_int = _TIOC | 14;
+pub const TCSANOW: ::c_int = _TIOC | 14;
+pub const TCSETSW: ::c_int = _TIOC | 15;
+pub const TCSADRAIN: ::c_int = _TIOC | 15;
+pub const TCSETSF: ::c_int = _TIOC | 16;
+pub const TCSAFLUSH: ::c_int = _TIOC | 16;
+pub const TCIFLUSH: ::c_int = 0;
+pub const TCOFLUSH: ::c_int = 1;
+pub const TCIOFLUSH: ::c_int = 2;
+pub const TCOOFF: ::c_int = 0;
+pub const TCOON: ::c_int = 1;
+pub const TCIOFF: ::c_int = 2;
+pub const TCION: ::c_int = 3;
+pub const TIOC: ::c_int = _TIOC;
+pub const TIOCKBON: ::c_int = _TIOC | 8;
+pub const TIOCKBOF: ::c_int = _TIOC | 9;
+pub const TIOCGWINSZ: ::c_int = _TIOC | 104;
+pub const TIOCSWINSZ: ::c_int = _TIOC | 103;
+pub const TIOCGSOFTCAR: ::c_int = _TIOC | 105;
+pub const TIOCSSOFTCAR: ::c_int = _TIOC | 106;
+pub const TIOCGPPS: ::c_int = _TIOC | 125;
+pub const TIOCSPPS: ::c_int = _TIOC | 126;
+pub const TIOCGPPSEV: ::c_int = _TIOC | 127;
+pub const TIOCGETD: ::c_int = tIOC | 0;
+pub const TIOCSETD: ::c_int = tIOC | 1;
+pub const TIOCHPCL: ::c_int = tIOC | 2;
+pub const TIOCGETP: ::c_int = tIOC | 8;
+pub const TIOCSETP: ::c_int = tIOC | 9;
+pub const TIOCSETN: ::c_int = tIOC | 10;
+pub const TIOCEXCL: ::c_int = tIOC | 13;
+pub const TIOCNXCL: ::c_int = tIOC | 14;
+pub const TIOCFLUSH: ::c_int = tIOC | 16;
+pub const TIOCSETC: ::c_int = tIOC | 17;
+pub const TIOCGETC: ::c_int = tIOC | 18;
+pub const TIOCLBIS: ::c_int = tIOC | 127;
+pub const TIOCLBIC: ::c_int = tIOC | 126;
+pub const TIOCLSET: ::c_int = tIOC | 125;
+pub const TIOCLGET: ::c_int = tIOC | 124;
+pub const TIOCSBRK: ::c_int = tIOC | 123;
+pub const TIOCCBRK: ::c_int = tIOC | 122;
+pub const TIOCSDTR: ::c_int = tIOC | 121;
+pub const TIOCCDTR: ::c_int = tIOC | 120;
+pub const TIOCSLTC: ::c_int = tIOC | 117;
+pub const TIOCGLTC: ::c_int = tIOC | 116;
+pub const TIOCOUTQ: ::c_int = tIOC | 115;
+pub const TIOCNOTTY: ::c_int = tIOC | 113;
+pub const TIOCSCTTY: ::c_int = tIOC | 132;
+pub const TIOCSTOP: ::c_int = tIOC | 111;
+pub const TIOCSTART: ::c_int = tIOC | 110;
+pub const TIOCSILOOP: ::c_int = tIOC | 109;
+pub const TIOCCILOOP: ::c_int = tIOC | 108;
+pub const TIOCGPGRP: ::c_int = tIOC | 20;
+pub const TIOCSPGRP: ::c_int = tIOC | 21;
+pub const TIOCGSID: ::c_int = tIOC | 22;
+pub const TIOCSTI: ::c_int = tIOC | 23;
+pub const TIOCMSET: ::c_int = tIOC | 26;
+pub const TIOCMBIS: ::c_int = tIOC | 27;
+pub const TIOCMBIC: ::c_int = tIOC | 28;
+pub const TIOCMGET: ::c_int = tIOC | 29;
+pub const TIOCREMOTE: ::c_int = tIOC | 30;
+pub const TIOCSIGNAL: ::c_int = tIOC | 31;
+
+pub const EPOLLIN: ::c_int = 0x1;
+pub const EPOLLPRI: ::c_int = 0x2;
+pub const EPOLLOUT: ::c_int = 0x4;
+pub const EPOLLRDNORM: ::c_int = 0x40;
+pub const EPOLLRDBAND: ::c_int = 0x80;
+pub const EPOLLWRNORM: ::c_int = 0x100;
+pub const EPOLLWRBAND: ::c_int = 0x200;
+pub const EPOLLMSG: ::c_int = 0x400;
+pub const EPOLLERR: ::c_int = 0x8;
+pub const EPOLLHUP: ::c_int = 0x10;
+pub const EPOLLET: ::c_int = 0x80000000;
+pub const EPOLLRDHUP: ::c_int = 0x2000;
+pub const EPOLLONESHOT: ::c_int = 0x40000000;
+pub const EPOLLWAKEUP: ::c_int = 0x20000000;
+pub const EPOLLEXCLUSIVE: ::c_int = 0x10000000;
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+pub const EPOLL_CTL_ADD: ::c_int = 1;
+pub const EPOLL_CTL_MOD: ::c_int = 3;
+pub const EPOLL_CTL_DEL: ::c_int = 2;
+
+/* termios */
+pub const B0: speed_t = 0;
+pub const B50: speed_t = 1;
+pub const B75: speed_t = 2;
+pub const B110: speed_t = 3;
+pub const B134: speed_t = 4;
+pub const B150: speed_t = 5;
+pub const B200: speed_t = 6;
+pub const B300: speed_t = 7;
+pub const B600: speed_t = 8;
+pub const B1200: speed_t = 9;
+pub const B1800: speed_t = 10;
+pub const B2400: speed_t = 11;
+pub const B4800: speed_t = 12;
+pub const B9600: speed_t = 13;
+pub const B19200: speed_t = 14;
+pub const B38400: speed_t = 15;
+pub const B57600: speed_t = 16;
+pub const B76800: speed_t = 17;
+pub const B115200: speed_t = 18;
+pub const B153600: speed_t = 19;
+pub const B230400: speed_t = 20;
+pub const B307200: speed_t = 21;
+pub const B460800: speed_t = 22;
+pub const B921600: speed_t = 23;
+pub const CSTART: ::tcflag_t = 0o21;
+pub const CSTOP: ::tcflag_t = 0o23;
+pub const CSWTCH: ::tcflag_t = 0o32;
+pub const CSIZE: ::tcflag_t = 0o000060;
+pub const CS5: ::tcflag_t = 0;
+pub const CS6: ::tcflag_t = 0o000020;
+pub const CS7: ::tcflag_t = 0o000040;
+pub const CS8: ::tcflag_t = 0o000060;
+pub const CSTOPB: ::tcflag_t = 0o000100;
+pub const ECHO: ::tcflag_t = 0o000010;
+pub const ECHOE: ::tcflag_t = 0o000020;
+pub const ECHOK: ::tcflag_t = 0o000040;
+pub const ECHONL: ::tcflag_t = 0o000100;
+pub const ECHOCTL: ::tcflag_t = 0o001000;
+pub const ECHOPRT: ::tcflag_t = 0o002000;
+pub const ECHOKE: ::tcflag_t = 0o004000;
+pub const EXTPROC: ::tcflag_t = 0o200000;
+pub const IGNBRK: ::tcflag_t = 0o000001;
+pub const BRKINT: ::tcflag_t = 0o000002;
+pub const IGNPAR: ::tcflag_t = 0o000004;
+pub const PARMRK: ::tcflag_t = 0o000010;
+pub const INPCK: ::tcflag_t = 0o000020;
+pub const ISTRIP: ::tcflag_t = 0o000040;
+pub const INLCR: ::tcflag_t = 0o000100;
+pub const IGNCR: ::tcflag_t = 0o000200;
+pub const ICRNL: ::tcflag_t = 0o000400;
+pub const IXON: ::tcflag_t = 0o002000;
+pub const IXOFF: ::tcflag_t = 0o010000;
+pub const IXANY: ::tcflag_t = 0o004000;
+pub const IMAXBEL: ::tcflag_t = 0o020000;
+pub const OPOST: ::tcflag_t = 0o000001;
+pub const ONLCR: ::tcflag_t = 0o000004;
+pub const OCRNL: ::tcflag_t = 0o000010;
+pub const ONOCR: ::tcflag_t = 0o000020;
+pub const ONLRET: ::tcflag_t = 0o000040;
+pub const CREAD: ::tcflag_t = 0o000200;
+pub const PARENB: ::tcflag_t = 0o000400;
+pub const PARODD: ::tcflag_t = 0o001000;
+pub const HUPCL: ::tcflag_t = 0o002000;
+pub const CLOCAL: ::tcflag_t = 0o004000;
+pub const CRTSCTS: ::tcflag_t = 0o20000000000;
+pub const ISIG: ::tcflag_t = 0o000001;
+pub const ICANON: ::tcflag_t = 0o000002;
+pub const IEXTEN: ::tcflag_t = 0o100000;
+pub const TOSTOP: ::tcflag_t = 0o000400;
+pub const FLUSHO: ::tcflag_t = 0o020000;
+pub const PENDIN: ::tcflag_t = 0o040000;
+pub const NOFLSH: ::tcflag_t = 0o000200;
+pub const VINTR: usize = 0;
+pub const VQUIT: usize = 1;
+pub const VERASE: usize = 2;
+pub const VKILL: usize = 3;
+pub const VEOF: usize = 4;
+pub const VEOL: usize = 5;
+pub const VEOL2: usize = 6;
+pub const VMIN: usize = 4;
+pub const VTIME: usize = 5;
+pub const VSWTCH: usize = 7;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VSUSP: usize = 10;
+pub const VDSUSP: usize = 11;
+pub const VREPRINT: usize = 12;
+pub const VDISCARD: usize = 13;
+pub const VWERASE: usize = 14;
+pub const VLNEXT: usize = 15;
+pub const VSTATUS: usize = 16;
+pub const VERASE2: usize = 17;
+
+// <sys/stropts.h>
+const STR: ::c_int = (b'S' as ::c_int) << 8;
+pub const I_NREAD: ::c_int = STR | 0o1;
+pub const I_PUSH: ::c_int = STR | 0o2;
+pub const I_POP: ::c_int = STR | 0o3;
+pub const I_LOOK: ::c_int = STR | 0o4;
+pub const I_FLUSH: ::c_int = STR | 0o5;
+pub const I_SRDOPT: ::c_int = STR | 0o6;
+pub const I_GRDOPT: ::c_int = STR | 0o7;
+pub const I_STR: ::c_int = STR | 0o10;
+pub const I_SETSIG: ::c_int = STR | 0o11;
+pub const I_GETSIG: ::c_int = STR | 0o12;
+pub const I_FIND: ::c_int = STR | 0o13;
+pub const I_LINK: ::c_int = STR | 0o14;
+pub const I_UNLINK: ::c_int = STR | 0o15;
+pub const I_PEEK: ::c_int = STR | 0o17;
+pub const I_FDINSERT: ::c_int = STR | 0o20;
+pub const I_SENDFD: ::c_int = STR | 0o21;
+pub const I_RECVFD: ::c_int = STR | 0o16;
+pub const I_SWROPT: ::c_int = STR | 0o23;
+pub const I_GWROPT: ::c_int = STR | 0o24;
+pub const I_LIST: ::c_int = STR | 0o25;
+pub const I_PLINK: ::c_int = STR | 0o26;
+pub const I_PUNLINK: ::c_int = STR | 0o27;
+pub const I_ANCHOR: ::c_int = STR | 0o30;
+pub const I_FLUSHBAND: ::c_int = STR | 0o34;
+pub const I_CKBAND: ::c_int = STR | 0o35;
+pub const I_GETBAND: ::c_int = STR | 0o36;
+pub const I_ATMARK: ::c_int = STR | 0o37;
+pub const I_SETCLTIME: ::c_int = STR | 0o40;
+pub const I_GETCLTIME: ::c_int = STR | 0o41;
+pub const I_CANPUT: ::c_int = STR | 0o42;
+pub const I_SERROPT: ::c_int = STR | 0o43;
+pub const I_GERROPT: ::c_int = STR | 0o44;
+pub const I_ESETSIG: ::c_int = STR | 0o45;
+pub const I_EGETSIG: ::c_int = STR | 0o46;
+pub const __I_PUSH_NOCTTY: ::c_int = STR | 0o47;
+
+// 3SOCKET flags
+pub const SOCK_CLOEXEC: ::c_int = 0x080000;
+pub const SOCK_NONBLOCK: ::c_int = 0x100000;
+pub const SOCK_NDELAY: ::c_int = 0x200000;
+
+//<sys/timex.h>
+pub const SCALE_KG: ::c_int = 1 << 6;
+pub const SCALE_KF: ::c_int = 1 << 16;
+pub const SCALE_KH: ::c_int = 1 << 2;
+pub const MAXTC: ::c_int = 1 << 6;
+pub const SCALE_PHASE: ::c_int = 1 << 22;
+pub const SCALE_USEC: ::c_int = 1 << 16;
+pub const SCALE_UPDATE: ::c_int = SCALE_KG * MAXTC;
+pub const FINEUSEC: ::c_int = 1 << 22;
+pub const MAXPHASE: ::c_int = 512000;
+pub const MAXFREQ: ::c_int = 512 * SCALE_USEC;
+pub const MAXTIME: ::c_int = 200 << PPS_AVG;
+pub const MINSEC: ::c_int = 16;
+pub const MAXSEC: ::c_int = 1200;
+pub const PPS_AVG: ::c_int = 2;
+pub const PPS_SHIFT: ::c_int = 2;
+pub const PPS_SHIFTMAX: ::c_int = 8;
+pub const PPS_VALID: ::c_int = 120;
+pub const MAXGLITCH: ::c_int = 30;
+pub const MOD_OFFSET: u32 = 0x0001;
+pub const MOD_FREQUENCY: u32 = 0x0002;
+pub const MOD_MAXERROR: u32 = 0x0004;
+pub const MOD_ESTERROR: u32 = 0x0008;
+pub const MOD_STATUS: u32 = 0x0010;
+pub const MOD_TIMECONST: u32 = 0x0020;
+pub const MOD_CLKB: u32 = 0x4000;
+pub const MOD_CLKA: u32 = 0x8000;
+pub const STA_PLL: u32 = 0x0001;
+pub const STA_PPSFREQ: i32 = 0x0002;
+pub const STA_PPSTIME: i32 = 0x0004;
+pub const STA_FLL: i32 = 0x0008;
+pub const STA_INS: i32 = 0x0010;
+pub const STA_DEL: i32 = 0x0020;
+pub const STA_UNSYNC: i32 = 0x0040;
+pub const STA_FREQHOLD: i32 = 0x0080;
+pub const STA_PPSSIGNAL: i32 = 0x0100;
+pub const STA_PPSJITTER: i32 = 0x0200;
+pub const STA_PPSWANDER: i32 = 0x0400;
+pub const STA_PPSERROR: i32 = 0x0800;
+pub const STA_CLOCKERR: i32 = 0x1000;
+pub const STA_RONLY: i32 = STA_PPSSIGNAL
+    | STA_PPSJITTER
+    | STA_PPSWANDER
+    | STA_PPSERROR
+    | STA_CLOCKERR;
+pub const TIME_OK: i32 = 0;
+pub const TIME_INS: i32 = 1;
+pub const TIME_DEL: i32 = 2;
+pub const TIME_OOP: i32 = 3;
+pub const TIME_WAIT: i32 = 4;
+pub const TIME_ERROR: i32 = 5;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+// As per sys/socket.h, header alignment must be 8 bytes on SPARC
+// and 4 bytes everywhere else:
+#[cfg(target_arch = "sparc64")]
+const _CMSG_HDR_ALIGNMENT: usize = 8;
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+const _CMSG_HDR_ALIGNMENT: usize = 4;
+
+const _CMSG_DATA_ALIGNMENT: usize = ::mem::size_of::<::c_int>();
+
+fn _CMSG_HDR_ALIGN(p: usize) -> usize {
+    (p + _CMSG_HDR_ALIGNMENT - 1) & !(_CMSG_HDR_ALIGNMENT - 1)
+}
+
+fn _CMSG_DATA_ALIGN(p: usize) -> usize {
+    (p + _CMSG_DATA_ALIGNMENT - 1) & !(_CMSG_DATA_ALIGNMENT - 1)
+}
+
+f! {
+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {
+        _CMSG_DATA_ALIGN(cmsg.offset(1) as usize) as *mut ::c_uchar
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        _CMSG_DATA_ALIGN(::mem::size_of::<::cmsghdr>()) as ::c_uint + length
+    }
+
+    pub fn CMSG_FIRSTHDR(mhdr: *const ::msghdr) -> *mut ::cmsghdr {
+        if ((*mhdr).msg_controllen as usize) < ::mem::size_of::<::cmsghdr>() {
+            0 as *mut ::cmsghdr
+        } else {
+            (*mhdr).msg_control as *mut ::cmsghdr
+        }
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)
+        -> *mut ::cmsghdr
+    {
+        if cmsg.is_null() {
+            return ::CMSG_FIRSTHDR(mhdr);
+        };
+        let next = _CMSG_HDR_ALIGN(cmsg as usize + (*cmsg).cmsg_len as usize
+            + ::mem::size_of::<::cmsghdr>());
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if next > max {
+            0 as *mut ::cmsghdr
+        } else {
+            _CMSG_HDR_ALIGN(cmsg as usize + (*cmsg).cmsg_len as usize)
+                as *mut ::cmsghdr
+        }
+    }
+
+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        _CMSG_HDR_ALIGN(::mem::size_of::<::cmsghdr>() as usize
+            + length as usize) as ::c_uint
+    }
+
+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        (*set).fds_bits[fd / bits] &= !(1 << (fd % bits));
+        return
+    }
+
+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        return ((*set).fds_bits[fd / bits] & (1 << (fd % bits))) != 0
+    }
+
+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {
+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        let fd = fd as usize;
+        (*set).fds_bits[fd / bits] |= 1 << (fd % bits);
+        return
+    }
+
+    pub fn FD_ZERO(set: *mut fd_set) -> () {
+        for slot in (*set).fds_bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+}
+
+safe_f! {
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & 0xFF) == 0
+    }
+
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xFF
+    }
+
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        status & 0x7F
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        (status & 0xffff) == 0xffff
+    }
+
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        (status & 0xff00) >> 8
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        ((status & 0xff) > 0) && (status & 0xff00 == 0)
+    }
+
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        ((status & 0xff) == 0x7f) && ((status & 0xff00) != 0)
+    }
+
+    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {
+        (status & 0x80) != 0
+    }
+}
+
+extern "C" {
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+
+    pub fn abs(i: ::c_int) -> ::c_int;
+    pub fn acct(filename: *const ::c_char) -> ::c_int;
+    pub fn atof(s: *const ::c_char) -> ::c_double;
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+    pub fn labs(i: ::c_long) -> ::c_long;
+    pub fn rand() -> ::c_int;
+    pub fn srand(seed: ::c_uint);
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn settimeofday(tp: *const ::timeval, tz: *const ::c_void) -> ::c_int;
+    pub fn getifaddrs(ifap: *mut *mut ::ifaddrs) -> ::c_int;
+    pub fn freeifaddrs(ifa: *mut ::ifaddrs);
+
+    pub fn stack_getbounds(sp: *mut ::stack_t) -> ::c_int;
+    pub fn initgroups(name: *const ::c_char, basegid: ::gid_t) -> ::c_int;
+    pub fn setgroups(ngroups: ::c_int, ptr: *const ::gid_t) -> ::c_int;
+    pub fn ioctl(fildes: ::c_int, request: ::c_int, ...) -> ::c_int;
+    pub fn mprotect(
+        addr: *const ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn ___errno() -> *mut ::c_int;
+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_nanosleep(
+        clk_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn clock_settime(
+        clk_id: ::clockid_t,
+        tp: *const ::timespec,
+    ) -> ::c_int;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::socklen_t,
+        serv: *mut ::c_char,
+        sevlen: ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn setpwent();
+    pub fn endpwent();
+    pub fn getpwent() -> *mut passwd;
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+    pub fn nl_langinfo_l(item: ::nl_item, locale: ::locale_t)
+        -> *mut ::c_char;
+    pub fn duplocale(base: ::locale_t) -> ::locale_t;
+    pub fn freelocale(loc: ::locale_t);
+    pub fn newlocale(
+        mask: ::c_int,
+        locale: *const ::c_char,
+        base: ::locale_t,
+    ) -> ::locale_t;
+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;
+    pub fn getprogname() -> *const ::c_char;
+    pub fn setprogname(name: *const ::c_char);
+    pub fn getloadavg(loadavg: *mut ::c_double, nelem: ::c_int) -> ::c_int;
+    pub fn getpriority(which: ::c_int, who: ::c_int) -> ::c_int;
+    pub fn setpriority(which: ::c_int, who: ::c_int, prio: ::c_int)
+        -> ::c_int;
+
+    pub fn mknodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: dev_t,
+    ) -> ::c_int;
+    pub fn mkfifoat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn sethostname(name: *const ::c_char, len: ::c_int) -> ::c_int;
+    pub fn if_nameindex() -> *mut if_nameindex;
+    pub fn if_freenameindex(ptr: *mut if_nameindex);
+    pub fn pthread_create(
+        native: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        f: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstack(
+        attr: *const ::pthread_attr_t,
+        stackaddr: *mut *mut ::c_void,
+        stacksize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getclock(
+        attr: *const pthread_condattr_t,
+        clock_id: *mut clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setclock(
+        attr: *mut pthread_condattr_t,
+        clock_id: ::clockid_t,
+    ) -> ::c_int;
+    pub fn sem_timedwait(
+        sem: *mut sem_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn waitid(
+        idtype: idtype_t,
+        id: id_t,
+        infop: *mut ::siginfo_t,
+        options: ::c_int,
+    ) -> ::c_int;
+
+    #[cfg_attr(target_os = "illumos", link_name = "_glob_ext")]
+    pub fn glob(
+        pattern: *const ::c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut ::glob_t,
+    ) -> ::c_int;
+
+    #[cfg_attr(target_os = "illumos", link_name = "_globfree_ext")]
+    pub fn globfree(pglob: *mut ::glob_t);
+
+    pub fn posix_madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn shmat(
+        shmid: ::c_int,
+        shmaddr: *const ::c_void,
+        shmflg: ::c_int,
+    ) -> *mut ::c_void;
+
+    pub fn shmctl(
+        shmid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::shmid_ds,
+    ) -> ::c_int;
+
+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;
+
+    pub fn shmget(key: key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;
+
+    pub fn shm_open(
+        name: *const ::c_char,
+        oflag: ::c_int,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;
+
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+    pub fn madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;
+
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;
+    pub fn futimesat(
+        fd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timeval,
+    ) -> ::c_int;
+    pub fn futimens(dirfd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn utimensat(
+        dirfd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;
+
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_bind")]
+    pub fn bind(
+        socket: ::c_int,
+        address: *const ::sockaddr,
+        address_len: ::socklen_t,
+    ) -> ::c_int;
+
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_sendmsg")]
+    pub fn sendmsg(
+        fd: ::c_int,
+        msg: *const ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    #[cfg_attr(target_os = "illumos", link_name = "__xnet_recvmsg")]
+    pub fn recvmsg(
+        fd: ::c_int,
+        msg: *mut ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn accept4(
+        fd: ::c_int,
+        address: *mut sockaddr,
+        address_len: *mut socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;
+    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;
+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn mq_receive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mq_timedreceive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::ssize_t;
+    pub fn mq_send(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+    ) -> ::c_int;
+    pub fn mq_timedsend(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;
+    pub fn mq_setattr(
+        mqd: ::mqd_t,
+        newattr: *const ::mq_attr,
+        oldattr: *mut ::mq_attr,
+    ) -> ::c_int;
+    pub fn port_create() -> ::c_int;
+    pub fn port_associate(
+        port: ::c_int,
+        source: ::c_int,
+        object: ::uintptr_t,
+        events: ::c_int,
+        user: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn port_dissociate(
+        port: ::c_int,
+        source: ::c_int,
+        object: ::uintptr_t,
+    ) -> ::c_int;
+    pub fn port_get(
+        port: ::c_int,
+        pe: *mut port_event,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn port_getn(
+        port: ::c_int,
+        pe_list: *mut port_event,
+        max: ::c_uint,
+        nget: *mut ::c_uint,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn port_send(
+        port: ::c_int,
+        events: ::c_int,
+        user: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn port_sendn(
+        port_list: *mut ::c_int,
+        error_list: *mut ::c_int,
+        nent: ::c_uint,
+        events: ::c_int,
+        user: *mut ::c_void,
+    ) -> ::c_int;
+    #[cfg_attr(
+        any(target_os = "solaris", target_os = "illumos"),
+        link_name = "__posix_getgrgid_r"
+    )]
+    pub fn getgrgid_r(
+        gid: ::gid_t,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;
+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;
+    pub fn getdtablesize() -> ::c_int;
+
+    // The epoll functions are actually only present on illumos.  However,
+    // there are things using epoll on illumos (built using the
+    // x86_64-sun-solaris target) which would break until the illumos target is
+    // present in rustc.
+    pub fn epoll_pwait(
+        epfd: ::c_int,
+        events: *mut ::epoll_event,
+        maxevents: ::c_int,
+        timeout: ::c_int,
+        sigmask: *const ::sigset_t,
+    ) -> ::c_int;
+
+    pub fn epoll_create(size: ::c_int) -> ::c_int;
+    pub fn epoll_create1(flags: ::c_int) -> ::c_int;
+    pub fn epoll_wait(
+        epfd: ::c_int,
+        events: *mut ::epoll_event,
+        maxevents: ::c_int,
+        timeout: ::c_int,
+    ) -> ::c_int;
+    pub fn epoll_ctl(
+        epfd: ::c_int,
+        op: ::c_int,
+        fd: ::c_int,
+        event: *mut ::epoll_event,
+    ) -> ::c_int;
+
+    #[cfg_attr(
+        any(target_os = "solaris", target_os = "illumos"),
+        link_name = "__posix_getgrnam_r"
+    )]
+    pub fn getgrnam_r(
+        name: *const ::c_char,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;
+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;
+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;
+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    #[cfg_attr(
+        any(target_os = "solaris", target_os = "illumos"),
+        link_name = "__posix_getpwnam_r"
+    )]
+    pub fn getpwnam_r(
+        name: *const ::c_char,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    #[cfg_attr(
+        any(target_os = "solaris", target_os = "illumos"),
+        link_name = "__posix_getpwuid_r"
+    )]
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    #[cfg_attr(
+        any(target_os = "solaris", target_os = "illumos"),
+        link_name = "__posix_getpwent_r"
+    )]
+    pub fn getpwent_r(
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    #[cfg_attr(
+        any(target_os = "solaris", target_os = "illumos"),
+        link_name = "__posix_getgrent_r"
+    )]
+    pub fn getgrent_r(
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    #[cfg_attr(
+        any(target_os = "solaris", target_os = "illumos"),
+        link_name = "__posix_sigwait"
+    )]
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;
+    pub fn setgrent();
+    pub fn endgrent();
+    pub fn getgrent() -> *mut ::group;
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+
+    pub fn dup3(src: ::c_int, dst: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;
+
+    pub fn makeutx(ux: *const utmpx) -> *mut utmpx;
+    pub fn modutx(ux: *const utmpx) -> *mut utmpx;
+    pub fn updwtmpx(file: *const ::c_char, ut: *const utmpx) -> ::c_int;
+    pub fn utmpxname(file: *const ::c_char) -> ::c_int;
+    pub fn getutxent() -> *mut utmpx;
+    pub fn getutxid(ut: *const utmpx) -> *mut utmpx;
+    pub fn getutxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn pututxline(ut: *const utmpx) -> *mut utmpx;
+    pub fn setutxent();
+    pub fn endutxent();
+
+    pub fn endutent();
+    pub fn getutent() -> *mut utmp;
+    pub fn getutid(u: *const utmp) -> *mut utmp;
+    pub fn getutline(u: *const utmp) -> *mut utmp;
+    pub fn pututline(u: *const utmp) -> *mut utmp;
+    pub fn setutent();
+    pub fn utmpname(file: *const ::c_char) -> ::c_int;
+
+    pub fn getutmp(ux: *const utmpx, u: *mut utmp);
+    pub fn getutmpx(u: *const utmp, ux: *mut utmpx);
+    pub fn updwtmp(file: *const ::c_char, u: *mut utmp);
+
+    pub fn ntp_adjtime(buf: *mut timex) -> ::c_int;
+    pub fn ntp_gettime(buf: *mut ntptimeval) -> ::c_int;
+
+    pub fn timer_create(
+        clock_id: clockid_t,
+        evp: *mut sigevent,
+        timerid: *mut timer_t,
+    ) -> ::c_int;
+    pub fn timer_delete(timerid: timer_t) -> ::c_int;
+    pub fn timer_getoverrun(timerid: timer_t) -> ::c_int;
+    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::c_int;
+    pub fn timer_settime(
+        timerid: timer_t,
+        flags: ::c_int,
+        value: *const itimerspec,
+        ovalue: *mut itimerspec,
+    ) -> ::c_int;
+
+    pub fn ucred_get(pid: ::pid_t) -> *mut ucred_t;
+    pub fn getpeerucred(fd: ::c_int, ucred: *mut *mut ucred_t) -> ::c_int;
+
+    pub fn ucred_free(ucred: *mut ucred_t);
+
+    pub fn ucred_geteuid(ucred: *const ucred_t) -> ::uid_t;
+    pub fn ucred_getruid(ucred: *const ucred_t) -> ::uid_t;
+    pub fn ucred_getsuid(ucred: *const ucred_t) -> ::uid_t;
+    pub fn ucred_getegid(ucred: *const ucred_t) -> ::gid_t;
+    pub fn ucred_getrgid(ucred: *const ucred_t) -> ::gid_t;
+    pub fn ucred_getsgid(ucred: *const ucred_t) -> ::gid_t;
+    pub fn ucred_getgroups(
+        ucred: *const ucred_t,
+        groups: *mut *const ::gid_t,
+    ) -> ::c_int;
+    pub fn ucred_getpid(ucred: *const ucred_t) -> ::pid_t;
+    pub fn ucred_getprojid(ucred: *const ucred_t) -> projid_t;
+    pub fn ucred_getzoneid(ucred: *const ucred_t) -> zoneid_t;
+    pub fn ucred_getpflags(ucred: *const ucred_t, flags: ::c_uint)
+        -> ::c_uint;
+
+    pub fn ucred_size() -> ::size_t;
+}
+
+mod compat;
+pub use self::compat::*;
+
+cfg_if! {
+    if #[cfg(target_os = "illumos")] {
+        mod illumos;
+        pub use self::illumos::*;
+    } else if #[cfg(target_os = "solaris")] {
+        mod solaris;
+        pub use self::solaris::*;
+    } else {
+        // Unknown target_os
+    }
+}
diff --git a/library/libc/src/unix/solarish/solaris.rs b/library/libc/src/unix/solarish/solaris.rs
new file mode 100644
index 00000000..a07bc88a
--- /dev/null
+++ b/library/libc/src/unix/solarish/solaris.rs
@@ -0,0 +1,101 @@
+pub type door_attr_t = ::c_uint;
+pub type door_id_t = ::c_ulonglong;
+
+s! {
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_flags: ::uintptr_t,
+        pub shm_lkcnt: ::c_ushort,
+        pub shm_lpid: ::pid_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        pub shm_cnattch: ::c_ulong,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_amp: *mut ::c_void,
+        pub shm_gransize: u64,
+        pub shm_allocated: u64,
+        pub shm_pad4: [i64; 1],
+    }
+
+    pub struct door_desc_t__d_data__d_desc {
+        pub d_descriptor: ::c_int,
+        pub d_id: ::door_id_t
+    }
+}
+
+pub const PORT_SOURCE_POSTWAIT: ::c_int = 8;
+pub const PORT_SOURCE_SIGNAL: ::c_int = 9;
+
+pub const AF_LOCAL: ::c_int = 0;
+pub const AF_FILE: ::c_int = 0;
+
+pub const TCP_KEEPIDLE: ::c_int = 0x1d;
+pub const TCP_KEEPCNT: ::c_int = 0x1e;
+pub const TCP_KEEPINTVL: ::c_int = 0x1f;
+
+extern "C" {
+    pub fn fexecve(
+        fd: ::c_int,
+        argv: *const *const ::c_char,
+        envp: *const *const ::c_char,
+    ) -> ::c_int;
+
+    pub fn mincore(
+        addr: *const ::c_void,
+        len: ::size_t,
+        vec: *mut ::c_char,
+    ) -> ::c_int;
+
+    pub fn door_call(d: ::c_int, params: *const door_arg_t) -> ::c_int;
+    pub fn door_return(
+        data_ptr: *const ::c_char,
+        data_size: ::size_t,
+        desc_ptr: *const door_desc_t,
+        num_desc: ::c_uint,
+    );
+    pub fn door_create(
+        server_procedure: extern "C" fn(
+            cookie: *const ::c_void,
+            argp: *const ::c_char,
+            arg_size: ::size_t,
+            dp: *const door_desc_t,
+            n_desc: ::c_uint,
+        ),
+        cookie: *const ::c_void,
+        attributes: door_attr_t,
+    ) -> ::c_int;
+
+    pub fn fattach(fildes: ::c_int, path: *const ::c_char) -> ::c_int;
+
+    pub fn pthread_getattr_np(
+        thread: ::pthread_t,
+        attr: *mut ::pthread_attr_t,
+    ) -> ::c_int;
+}
+
+s_no_extra_traits! {
+    #[cfg_attr(feature = "extra_traits", allow(missing_debug_implementations))]
+    pub union door_desc_t__d_data {
+        pub d_desc: door_desc_t__d_data__d_desc,
+        d_resv: [::c_int; 5], /* Check out /usr/include/sys/door.h */
+    }
+
+    #[cfg_attr(feature = "extra_traits", allow(missing_debug_implementations))]
+    pub struct door_desc_t {
+        pub d_attributes: door_attr_t,
+        pub d_data: door_desc_t__d_data,
+    }
+
+    #[cfg_attr(feature = "extra_traits", allow(missing_debug_implementations))]
+    pub struct door_arg_t {
+        pub data_ptr: *const ::c_char,
+        pub data_size: ::size_t,
+        pub desc_ptr: *const door_desc_t,
+        pub dec_num: ::c_uint,
+        pub rbuf: *const ::c_char,
+        pub rsize: ::size_t,
+    }
+}
diff --git a/library/libc/src/unix/uclibc/align.rs b/library/libc/src/unix/uclibc/align.rs
new file mode 100644
index 00000000..76b524d0
--- /dev/null
+++ b/library/libc/src/unix/uclibc/align.rs
@@ -0,0 +1,66 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            #[cfg_attr(any(target_pointer_width = "32",
+                           target_arch = "x86_64",
+                           target_arch = "powerpc64",
+                           target_arch = "mips64",
+                           target_arch = "s390x",
+                           target_arch = "sparc64"),
+                       repr(align(4)))]
+            #[cfg_attr(not(any(target_pointer_width = "32",
+                               target_arch = "x86_64",
+                               target_arch = "powerpc64",
+                               target_arch = "mips64",
+                               target_arch = "s390x",
+                               target_arch = "sparc64")),
+                       repr(align(8)))]
+            pub struct pthread_mutexattr_t {
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_condattr_t {
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+
+        s_no_extra_traits! {
+            #[repr(align(8))]
+            #[allow(missing_debug_implementations)]
+            pub struct pthread_cond_t {
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "mips",
+                               target_arch = "arm",
+                               target_arch = "powerpc")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "mips",
+                                   target_arch = "arm",
+                                   target_arch = "powerpc"))),
+                       repr(align(8)))]
+            #[allow(missing_debug_implementations)]
+            pub struct pthread_mutex_t {
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "mips",
+                               target_arch = "arm",
+                               target_arch = "powerpc")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "mips",
+                                   target_arch = "arm",
+                                   target_arch = "powerpc"))),
+                       repr(align(8)))]
+            #[allow(missing_debug_implementations)]
+            pub struct pthread_rwlock_t {
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+        }
+    };
+}
diff --git a/library/libc/src/unix/uclibc/arm/align.rs b/library/libc/src/unix/uclibc/arm/align.rs
new file mode 100644
index 00000000..4a0e0746
--- /dev/null
+++ b/library/libc/src/unix/uclibc/arm/align.rs
@@ -0,0 +1,13 @@
+s! {
+    // FIXME this is actually a union
+    #[cfg_attr(target_pointer_width = "32",
+               repr(align(4)))]
+    #[cfg_attr(target_pointer_width = "64",
+               repr(align(8)))]
+    pub struct sem_t {
+        #[cfg(target_pointer_width = "32")]
+        __size: [::c_char; 16],
+        #[cfg(target_pointer_width = "64")]
+        __size: [::c_char; 32],
+    }
+}
diff --git a/library/libc/src/unix/uclibc/arm/mod.rs b/library/libc/src/unix/uclibc/arm/mod.rs
new file mode 100644
index 00000000..613a11fb
--- /dev/null
+++ b/library/libc/src/unix/uclibc/arm/mod.rs
@@ -0,0 +1,1049 @@
+pub type c_char = u8;
+pub type wchar_t = ::c_uint;
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type time_t = ::c_long;
+
+pub type clock_t = ::c_long;
+pub type fsblkcnt_t = ::c_ulong;
+pub type fsfilcnt_t = ::c_ulong;
+pub type ino_t = ::c_ulong;
+pub type off_t = ::c_long;
+pub type pthread_t = ::c_ulong;
+pub type rlim_t = ::c_ulong;
+pub type suseconds_t = ::c_long;
+
+pub type nlink_t = ::c_uint;
+pub type blksize_t = ::c_long;
+pub type blkcnt_t = ::c_long;
+
+s! {
+    pub struct cmsghdr {
+        pub cmsg_len: ::size_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct pthread_attr_t {
+        __size: [::c_long; 9],
+    }
+
+    pub struct stat {
+        pub st_dev: ::c_ulonglong,
+        pub __pad1: ::c_ushort,
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulonglong,
+        pub __pad2: ::c_ushort,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_ulong,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_ulong,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_ulong,
+        pub __unused4: ::c_ulong,
+        pub __unused5: ::c_ulong,
+    }
+
+    pub struct stat64
+    {
+        pub st_dev: ::c_ulonglong,
+        pub __pad1: ::c_uint,
+        pub __st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulonglong,
+        pub __pad2: ::c_uint,
+        pub st_size: ::off64_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_ulong,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_ulong,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_ulong,
+        pub st_ino: ::ino64_t,
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_int,
+        pub f_bsize: ::c_int,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_int,
+        pub f_frsize: ::c_int,
+        pub f_spare: [::c_int; 5],
+    }
+
+    pub struct sigset_t {
+        __val: [::c_ulong; 2],
+    }
+
+    pub struct sigaction {
+        pub sa_sigaction: ::sighandler_t,
+        // uClibc defines sa_flags as `unsigned long int`,
+        // but nix crate expects `int`
+        pub sa_flags: ::c_int,
+        pub sa_restorer: *mut ::c_void,
+        pub sa_mask: sigset_t,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+        pub c_ispeed: ::speed_t,
+        pub c_ospeed: ::speed_t,
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub _pad: [::c_int; 29],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t,
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_ushort,
+        pub __pad1: ::c_ushort,
+        pub __seq: ::c_ushort,
+        pub __pad2: ::c_ushort,
+        pub __unused1: ::c_ulong,
+        pub __unused2: ::c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        pub __unused1: ::c_ulong,
+        pub msg_rtime: ::time_t,
+        pub __unused2: ::c_ulong,
+        pub msg_ctime: ::time_t,
+        pub __unused3: ::c_ulong,
+        pub __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        pub __unused4: ::c_ulong,
+        pub __unused5: ::c_ulong,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub __unused1: ::c_ulong,
+        pub shm_dtime: ::time_t,
+        pub __unused2: ::c_ulong,
+        pub shm_ctime: ::time_t,
+        pub __unused3: ::c_ulong,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        pub __unused4: ::c_ulong,
+        pub __unused5: ::c_ulong,
+    }
+
+    pub struct ucred {
+        pub pid: ::pid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+    }
+
+}
+
+pub const O_CLOEXEC: ::c_int = 0o2000000;
+pub const RLIM_INFINITY: rlim_t = !0;
+pub const __SIZEOF_PTHREAD_ATTR_T: usize = 36;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 24;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_COND_COMPAT_T: usize = 12;
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+pub const __SIZEOF_PTHREAD_BARRIER_T: usize = 20;
+pub const __SIZEOF_PTHREAD_BARRIERATTR_T: usize = 4;
+pub const NCCS: usize = 32;
+
+// I wasn't able to find those constants
+// in uclibc build environment for armv7
+pub const AIO_ALLDONE: ::c_int = 2; // from linux/mod.rs
+pub const AIO_CANCELED: ::c_int = 0; // from linux/mod.rs
+pub const AIO_NOTCANCELED: ::c_int = 1; // from linux/mod.rs
+pub const CLONE_NEWCGROUP: ::c_int = 0x02000000; // from linux/mod.rs
+pub const EPOLLEXCLUSIVE: ::c_int = 0x10000000; // from linux/mod.rs
+pub const EPOLLWAKEUP: ::c_int = 0x20000000; // from linux/other/mod.rs
+pub const EXTPROC: ::tcflag_t = 0o200000; // from asm-generic/termbits.h
+pub const F_GETPIPE_SZ: ::c_int = 1032; // from linux_like/mod.rs
+pub const F_SETPIPE_SZ: ::c_int = 1031; // from linux_like/mod.rs
+pub const LIO_NOP: ::c_int = 2; // from linux/mod.rs
+pub const LIO_NOWAIT: ::c_int = 1; // from linux/mod.rs
+pub const LIO_READ: ::c_int = 0; // from linux/mod.rs
+pub const LIO_WAIT: ::c_int = 0; // from linux/mod.rs
+pub const LIO_WRITE: ::c_int = 1; // from linux/mod.rs
+pub const MAP_HUGETLB: ::c_int = 0x040000; // from linux/other/mod.rs
+pub const O_TMPFILE: ::c_int = 0o20000000 | O_DIRECTORY;
+pub const RB_KEXEC: ::c_int = 0x45584543u32 as i32; // from linux/mod.rs
+pub const RB_SW_SUSPEND: ::c_int = 0xd000fce2u32 as i32; // from linux/mod.rs
+pub const SO_BUSY_POLL: ::c_int = 46; // from src/unix/linux_like/mod.rs
+pub const SO_PEEK_OFF: ::c_int = 42; // from src/unix/linux_like/mod.rs
+pub const SO_REUSEPORT: ::c_int = 15; // from src/unix/linux_like/mod.rs
+pub const SOL_NETLINK: ::c_int = 270; // from src/unix/linux_like/mod.rs
+pub const _POSIX_VDISABLE: ::cc_t = 0; // from linux/mod.rs
+pub const AT_EMPTY_PATH: ::c_int = 0x1000; // from linux_like/mod.rs
+
+// autogenerated constants with hand tuned types
+pub const AT_NO_AUTOMOUNT: ::c_int = 0x800;
+pub const B0: ::speed_t = 0;
+pub const B1000000: ::speed_t = 0x1008;
+pub const B110: ::speed_t = 0x3;
+pub const B115200: ::speed_t = 0x1002;
+pub const B1152000: ::speed_t = 0x1009;
+pub const B1200: ::speed_t = 0x9;
+pub const B134: ::speed_t = 0x4;
+pub const B150: ::speed_t = 0x5;
+pub const B1500000: ::speed_t = 0x100a;
+pub const B1800: ::speed_t = 0xa;
+pub const B19200: ::speed_t = 0xe;
+pub const B200: ::speed_t = 0x6;
+pub const B2000000: ::speed_t = 0x100b;
+pub const B230400: ::speed_t = 0x1003;
+pub const B2400: ::speed_t = 0xb;
+pub const B2500000: ::speed_t = 0x100c;
+pub const B300: ::speed_t = 0x7;
+pub const B3000000: ::speed_t = 0x100d;
+pub const B3500000: ::speed_t = 0x100e;
+pub const B38400: ::speed_t = 0xf;
+pub const B4000000: ::speed_t = 0x100f;
+pub const B460800: ::speed_t = 0x1004;
+pub const B4800: ::speed_t = 0xc;
+pub const B50: ::speed_t = 0x1;
+pub const B500000: ::speed_t = 0x1005;
+pub const B57600: ::speed_t = 0x1001;
+pub const B576000: ::speed_t = 0x1006;
+pub const B600: ::speed_t = 0x8;
+pub const B75: ::speed_t = 0x2;
+pub const B921600: ::speed_t = 0x1007;
+pub const B9600: ::speed_t = 0xd;
+pub const BS1: ::c_int = 0x2000;
+pub const BSDLY: ::c_int = 0x2000;
+pub const CBAUD: ::tcflag_t = 0x100f;
+pub const CBAUDEX: ::tcflag_t = 0x1000;
+pub const CIBAUD: ::tcflag_t = 0x100f0000;
+pub const CLOCAL: ::tcflag_t = 0x800;
+pub const CMSPAR: ::tcflag_t = 0x40000000;
+pub const CPU_SETSIZE: ::c_int = 0x400;
+pub const CR1: ::c_int = 0x200;
+pub const CR2: ::c_int = 0x400;
+pub const CR3: ::c_int = 0x600;
+pub const CRDLY: ::c_int = 0x600;
+pub const CREAD: ::tcflag_t = 0x80;
+pub const CS6: ::tcflag_t = 0x10;
+pub const CS7: ::tcflag_t = 0x20;
+pub const CS8: ::tcflag_t = 0x30;
+pub const CSIZE: ::tcflag_t = 0x30;
+pub const CSTOPB: ::tcflag_t = 0x40;
+pub const EADDRINUSE: ::c_int = 0x62;
+pub const EADDRNOTAVAIL: ::c_int = 0x63;
+pub const EADV: ::c_int = 0x44;
+pub const EAFNOSUPPORT: ::c_int = 0x61;
+pub const EALREADY: ::c_int = 0x72;
+pub const EBADE: ::c_int = 0x34;
+pub const EBADFD: ::c_int = 0x4d;
+pub const EBADMSG: ::c_int = 0x4a;
+pub const EBADR: ::c_int = 0x35;
+pub const EBADRQC: ::c_int = 0x38;
+pub const EBADSLT: ::c_int = 0x39;
+pub const EBFONT: ::c_int = 0x3b;
+pub const ECANCELED: ::c_int = 0x7d;
+pub const ECHOCTL: ::tcflag_t = 0x200;
+pub const ECHOE: ::tcflag_t = 0x10;
+pub const ECHOK: ::tcflag_t = 0x20;
+pub const ECHOKE: ::tcflag_t = 0x800;
+pub const ECHONL: ::tcflag_t = 0x40;
+pub const ECHOPRT: ::tcflag_t = 0x400;
+pub const ECHRNG: ::c_int = 0x2c;
+pub const ECOMM: ::c_int = 0x46;
+pub const ECONNABORTED: ::c_int = 0x67;
+pub const ECONNREFUSED: ::c_int = 0x6f;
+pub const ECONNRESET: ::c_int = 0x68;
+pub const EDEADLK: ::c_int = 0x23;
+pub const EDESTADDRREQ: ::c_int = 0x59;
+pub const EDOTDOT: ::c_int = 0x49;
+pub const EDQUOT: ::c_int = 0x7a;
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+pub const EFD_NONBLOCK: ::c_int = 0x800;
+pub const EHOSTDOWN: ::c_int = 0x70;
+pub const EHOSTUNREACH: ::c_int = 0x71;
+pub const EHWPOISON: ::c_int = 0x85;
+pub const EIDRM: ::c_int = 0x2b;
+pub const EILSEQ: ::c_int = 0x54;
+pub const EINPROGRESS: ::c_int = 0x73;
+pub const EISCONN: ::c_int = 0x6a;
+pub const EISNAM: ::c_int = 0x78;
+pub const EKEYEXPIRED: ::c_int = 0x7f;
+pub const EKEYREJECTED: ::c_int = 0x81;
+pub const EKEYREVOKED: ::c_int = 0x80;
+pub const EL2HLT: ::c_int = 0x33;
+pub const EL2NSYNC: ::c_int = 0x2d;
+pub const EL3HLT: ::c_int = 0x2e;
+pub const EL3RST: ::c_int = 0x2f;
+pub const ELIBACC: ::c_int = 0x4f;
+pub const ELIBBAD: ::c_int = 0x50;
+pub const ELIBEXEC: ::c_int = 0x53;
+pub const ELIBMAX: ::c_int = 0x52;
+pub const ELIBSCN: ::c_int = 0x51;
+pub const ELNRNG: ::c_int = 0x30;
+pub const ELOOP: ::c_int = 0x28;
+pub const EMEDIUMTYPE: ::c_int = 0x7c;
+pub const EMSGSIZE: ::c_int = 0x5a;
+pub const EMULTIHOP: ::c_int = 0x48;
+pub const ENAMETOOLONG: ::c_int = 0x24;
+pub const ENAVAIL: ::c_int = 0x77;
+pub const ENETDOWN: ::c_int = 0x64;
+pub const ENETRESET: ::c_int = 0x66;
+pub const ENETUNREACH: ::c_int = 0x65;
+pub const ENOANO: ::c_int = 0x37;
+pub const ENOBUFS: ::c_int = 0x69;
+pub const ENOCSI: ::c_int = 0x32;
+pub const ENODATA: ::c_int = 0x3d;
+pub const ENOKEY: ::c_int = 0x7e;
+pub const ENOLCK: ::c_int = 0x25;
+pub const ENOLINK: ::c_int = 0x43;
+pub const ENOMEDIUM: ::c_int = 0x7b;
+pub const ENOMSG: ::c_int = 0x2a;
+pub const ENONET: ::c_int = 0x40;
+pub const ENOPKG: ::c_int = 0x41;
+pub const ENOPROTOOPT: ::c_int = 0x5c;
+pub const ENOSR: ::c_int = 0x3f;
+pub const ENOSTR: ::c_int = 0x3c;
+pub const ENOSYS: ::c_int = 0x26;
+pub const ENOTCONN: ::c_int = 0x6b;
+pub const ENOTEMPTY: ::c_int = 0x27;
+pub const ENOTNAM: ::c_int = 0x76;
+pub const ENOTRECOVERABLE: ::c_int = 0x83;
+pub const ENOTSOCK: ::c_int = 0x58;
+pub const ENOTUNIQ: ::c_int = 0x4c;
+pub const EOPNOTSUPP: ::c_int = 0x5f;
+pub const EOVERFLOW: ::c_int = 0x4b;
+pub const EOWNERDEAD: ::c_int = 0x82;
+pub const EPFNOSUPPORT: ::c_int = 0x60;
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+pub const EPROTO: ::c_int = 0x47;
+pub const EPROTONOSUPPORT: ::c_int = 0x5d;
+pub const EPROTOTYPE: ::c_int = 0x5b;
+pub const EREMCHG: ::c_int = 0x4e;
+pub const EREMOTE: ::c_int = 0x42;
+pub const EREMOTEIO: ::c_int = 0x79;
+pub const ERESTART: ::c_int = 0x55;
+pub const ERFKILL: ::c_int = 0x84;
+pub const ESHUTDOWN: ::c_int = 0x6c;
+pub const ESOCKTNOSUPPORT: ::c_int = 0x5e;
+pub const ESRMNT: ::c_int = 0x45;
+pub const ESTALE: ::c_int = 0x74;
+pub const ESTRPIPE: ::c_int = 0x56;
+pub const ETIME: ::c_int = 0x3e;
+pub const ETIMEDOUT: ::c_int = 0x6e;
+pub const ETOOMANYREFS: ::c_int = 0x6d;
+pub const EUCLEAN: ::c_int = 0x75;
+pub const EUNATCH: ::c_int = 0x31;
+pub const EUSERS: ::c_int = 0x57;
+pub const EXFULL: ::c_int = 0x36;
+pub const FF1: ::c_int = 0x8000;
+pub const FFDLY: ::c_int = 0x8000;
+pub const FIONBIO: ::c_ulong = 0x5421;
+pub const FIOCLEX: ::c_ulong = 0x5451;
+pub const FIONCLEX: ::c_ulong = 0x5450;
+pub const FLUSHO: ::tcflag_t = 0x1000;
+pub const F_GETLK: ::c_int = 0x5;
+pub const F_SETLK: ::c_int = 0x6;
+pub const F_SETLKW: ::c_int = 0x7;
+pub const HUPCL: ::tcflag_t = 0x400;
+pub const ICANON: ::tcflag_t = 0x2;
+pub const IEXTEN: ::tcflag_t = 0x8000;
+pub const ISIG: ::tcflag_t = 0x1;
+pub const IUTF8: ::tcflag_t = 0x4000;
+pub const IXOFF: ::tcflag_t = 0x1000;
+pub const IXON: ::tcflag_t = 0x400;
+pub const MAP_ANON: ::c_int = 0x20;
+pub const MAP_ANONYMOUS: ::c_int = 0x20;
+pub const MAP_DENYWRITE: ::c_int = 0x800;
+pub const MAP_EXECUTABLE: ::c_int = 0x1000;
+pub const MAP_GROWSDOWN: ::c_int = 0x100;
+pub const MAP_LOCKED: ::c_int = 0x2000;
+pub const MAP_NONBLOCK: ::c_int = 0x10000;
+pub const MAP_NORESERVE: ::c_int = 0x4000;
+pub const MAP_POPULATE: ::c_int = 0x8000;
+pub const MAP_STACK: ::c_int = 0x20000;
+pub const MS_ACTIVE: u32 = 0x40000000;
+pub const MS_DIRSYNC: u32 = 0x80;
+pub const MS_I_VERSION: u32 = 0x800000;
+pub const MS_KERNMOUNT: u32 = 0x400000;
+pub const MS_MOVE: u32 = 0x2000;
+pub const MS_POSIXACL: u32 = 0x10000;
+pub const MS_PRIVATE: u32 = 0x40000;
+pub const MS_REC: u32 = 0x4000;
+pub const MS_RELATIME: u32 = 0x200000;
+pub const MS_SHARED: u32 = 0x100000;
+pub const MS_SILENT: u32 = 0x8000;
+pub const MS_SLAVE: u32 = 0x80000;
+pub const MS_STRICTATIME: u32 = 0x1000000;
+pub const MS_UNBINDABLE: u32 = 0x20000;
+pub const NLDLY: ::tcflag_t = 0x100;
+pub const NOFLSH: ::tcflag_t = 0x80;
+pub const OCRNL: ::c_int = 0x8;
+pub const OFDEL: ::c_int = 0x80;
+pub const OFILL: ::c_int = 0x40;
+pub const OLCUC: ::tcflag_t = 0x2;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const ONLRET: ::tcflag_t = 0x20;
+pub const ONOCR: ::tcflag_t = 0x10;
+pub const O_ACCMODE: ::c_int = 0x3;
+pub const O_APPEND: ::c_int = 0x400;
+pub const O_CREAT: ::c_int = 0x40;
+pub const O_DIRECT: ::c_int = 0x10000;
+pub const O_DIRECTORY: ::c_int = 0x4000;
+pub const O_DSYNC: ::c_int = 0x1000;
+pub const O_EXCL: ::c_int = 0x80;
+pub const O_NDELAY: ::c_int = 0x800;
+pub const O_NOCTTY: ::c_int = 0x100;
+pub const O_NOFOLLOW: ::c_int = 0x8000;
+pub const O_NONBLOCK: ::c_int = 0x800;
+pub const O_SYNC: ::c_int = 0o10000;
+pub const O_TRUNC: ::c_int = 0x200;
+pub const PARENB: ::tcflag_t = 0x100;
+pub const PARODD: ::tcflag_t = 0x200;
+pub const PENDIN: ::tcflag_t = 0x4000;
+pub const POLLRDBAND: ::c_short = 0x80;
+pub const POLLRDNORM: ::c_short = 0x40;
+pub const POLLWRBAND: ::c_short = 0x200;
+pub const POLLWRNORM: ::c_short = 0x100;
+pub const PTHREAD_STACK_MIN: ::size_t = 16384;
+pub const QIF_ALL: u32 = 0x3f;
+pub const QIF_BLIMITS: u32 = 0x1;
+pub const QIF_BTIME: u32 = 0x10;
+pub const QIF_ILIMITS: u32 = 0x4;
+pub const QIF_INODES: u32 = 0x8;
+pub const QIF_ITIME: u32 = 0x20;
+pub const QIF_LIMITS: u32 = 0x5;
+pub const QIF_SPACE: u32 = 0x2;
+pub const QIF_TIMES: u32 = 0x30;
+pub const QIF_USAGE: u32 = 0xa;
+pub const SA_NOCLDSTOP: ::c_int = 0x1;
+pub const SA_NOCLDWAIT: ::c_int = 0x2;
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_ONSTACK: ::c_int = 0x8000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_SIGINFO: ::c_int = 0x4;
+pub const SFD_CLOEXEC: ::c_int = 0x80000;
+pub const SFD_NONBLOCK: ::c_int = 0x800;
+pub const SIGBUS: ::c_int = 0x7;
+pub const SIGCHLD: ::c_int = 0x11;
+pub const SIGCONT: ::c_int = 0x12;
+pub const SIGIO: ::c_int = 0x1d;
+pub const SIGPROF: ::c_int = 0x1b;
+pub const SIGPWR: ::c_int = 0x1e;
+pub const SIGSTKFLT: ::c_int = 0x10;
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const SIGSTOP: ::c_int = 0x13;
+pub const SIGSYS: ::c_int = 0x1f;
+pub const SIGTSTP: ::c_int = 0x14;
+pub const SIGTTIN: ::c_int = 0x15;
+pub const SIGTTOU: ::c_int = 0x16;
+pub const SIGURG: ::c_int = 0x17;
+pub const SIGUSR1: ::c_int = 0xa;
+pub const SIGUSR2: ::c_int = 0xc;
+pub const SIGVTALRM: ::c_int = 0x1a;
+pub const SIGWINCH: ::c_int = 0x1c;
+pub const SIGXCPU: ::c_int = 0x18;
+pub const SIGXFSZ: ::c_int = 0x19;
+pub const SIG_BLOCK: ::c_int = 0;
+pub const SIG_SETMASK: ::c_int = 0x2;
+pub const SIG_UNBLOCK: ::c_int = 0x1;
+pub const SOCK_DGRAM: ::c_int = 0x2;
+pub const SOCK_NONBLOCK: ::c_int = 0o0004000;
+pub const SOCK_SEQPACKET: ::c_int = 0x5;
+pub const SOCK_STREAM: ::c_int = 0x1;
+pub const SOL_SOCKET: ::c_int = 0x1;
+pub const SO_ACCEPTCONN: ::c_int = 0x1e;
+pub const SO_BINDTODEVICE: ::c_int = 0x19;
+pub const SO_BROADCAST: ::c_int = 0x6;
+pub const SO_BSDCOMPAT: ::c_int = 0xe;
+pub const SO_DOMAIN: ::c_int = 0x27;
+pub const SO_DONTROUTE: ::c_int = 0x5;
+pub const SO_ERROR: ::c_int = 0x4;
+pub const SO_KEEPALIVE: ::c_int = 0x9;
+pub const SO_LINGER: ::c_int = 0xd;
+pub const SO_MARK: ::c_int = 0x24;
+pub const SO_OOBINLINE: ::c_int = 0xa;
+pub const SO_PASSCRED: ::c_int = 0x10;
+pub const SO_PEERCRED: ::c_int = 0x11;
+pub const SO_PRIORITY: ::c_int = 0xc;
+pub const SO_PROTOCOL: ::c_int = 0x26;
+pub const SO_RCVBUF: ::c_int = 0x8;
+pub const SO_RCVLOWAT: ::c_int = 0x12;
+pub const SO_RCVTIMEO: ::c_int = 0x14;
+pub const SO_REUSEADDR: ::c_int = 0x2;
+pub const SO_RXQ_OVFL: ::c_int = 0x28;
+pub const SO_SNDBUF: ::c_int = 0x7;
+pub const SO_SNDBUFFORCE: ::c_int = 0x20;
+pub const SO_SNDLOWAT: ::c_int = 0x13;
+pub const SO_SNDTIMEO: ::c_int = 0x15;
+pub const SO_TIMESTAMP: ::c_int = 0x1d;
+pub const SO_TYPE: ::c_int = 0x3;
+pub const TAB1: ::c_int = 0x800;
+pub const TAB2: ::c_int = 0x1000;
+pub const TAB3: ::c_int = 0x1800;
+pub const TABDLY: ::c_int = 0x1800;
+pub const TCSADRAIN: ::c_int = 0x1;
+pub const TCSAFLUSH: ::c_int = 0x2;
+pub const TCSANOW: ::c_int = 0;
+pub const TOSTOP: ::tcflag_t = 0x100;
+pub const VDISCARD: usize = 0xd;
+pub const VEOF: usize = 0x4;
+pub const VEOL: usize = 0xb;
+pub const VEOL2: usize = 0x10;
+pub const VMIN: usize = 0x6;
+pub const VREPRINT: usize = 0xc;
+pub const VSTART: usize = 0x8;
+pub const VSTOP: usize = 0x9;
+pub const VSUSP: usize = 0xa;
+pub const VSWTC: usize = 0x7;
+pub const VT1: ::c_int = 0x4000;
+pub const VTDLY: ::c_int = 0x4000;
+pub const VTIME: usize = 0x5;
+pub const VWERASE: usize = 0xe;
+pub const XTABS: ::tcflag_t = 0x1800;
+pub const _PC_2_SYMLINKS: ::c_int = 0x14;
+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 0x12;
+pub const _PC_ASYNC_IO: ::c_int = 0xa;
+pub const _PC_FILESIZEBITS: ::c_int = 0xd;
+pub const _PC_PRIO_IO: ::c_int = 0xb;
+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 0xe;
+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 0xf;
+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 0x10;
+pub const _PC_REC_XFER_ALIGN: ::c_int = 0x11;
+pub const _PC_SYMLINK_MAX: ::c_int = 0x13;
+pub const _PC_SYNC_IO: ::c_int = 0x9;
+pub const _SC_2_PBS: ::c_int = 0xa8;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 0xa9;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 0xaf;
+pub const _SC_2_PBS_LOCATE: ::c_int = 0xaa;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 0xab;
+pub const _SC_2_PBS_TRACK: ::c_int = 0xac;
+pub const _SC_ADVISORY_INFO: ::c_int = 0x84;
+pub const _SC_BARRIERS: ::c_int = 0x85;
+pub const _SC_CLOCK_SELECTION: ::c_int = 0x89;
+pub const _SC_CPUTIME: ::c_int = 0x8a;
+pub const _SC_IPV6: ::c_int = 0xeb;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 0x95;
+pub const _SC_RAW_SOCKETS: ::c_int = 0xec;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 0x99;
+pub const _SC_REGEXP: ::c_int = 0x9b;
+pub const _SC_SHELL: ::c_int = 0x9d;
+pub const _SC_SPAWN: ::c_int = 0x9f;
+pub const _SC_SPIN_LOCKS: ::c_int = 0x9a;
+pub const _SC_SPORADIC_SERVER: ::c_int = 0xa0;
+pub const _SC_SS_REPL_MAX: ::c_int = 0xf1;
+pub const _SC_SYMLOOP_MAX: ::c_int = 0xad;
+pub const _SC_THREAD_CPUTIME: ::c_int = 0x8b;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 0x52;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 0xf7;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 0xf8;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 0xa1;
+pub const _SC_TIMEOUTS: ::c_int = 0xa4;
+pub const _SC_TRACE: ::c_int = 0xb5;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 0xb6;
+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 0xf2;
+pub const _SC_TRACE_INHERIT: ::c_int = 0xb7;
+pub const _SC_TRACE_LOG: ::c_int = 0xb8;
+pub const _SC_TRACE_NAME_MAX: ::c_int = 0xf3;
+pub const _SC_TRACE_SYS_MAX: ::c_int = 0xf4;
+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 0xf5;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 0xa5;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 0xb0;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 0xb1;
+pub const _SC_V6_LP64_OFF64: ::c_int = 0xb2;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 0xb3;
+pub const _SC_XOPEN_STREAMS: ::c_int = 0xf6;
+
+// Syscall table is copied from src/unix/notbsd/linux/musl/b32/arm.rs
+pub const SYS_restart_syscall: ::c_long = 0;
+pub const SYS_exit: ::c_long = 1;
+pub const SYS_fork: ::c_long = 2;
+pub const SYS_read: ::c_long = 3;
+pub const SYS_write: ::c_long = 4;
+pub const SYS_open: ::c_long = 5;
+pub const SYS_close: ::c_long = 6;
+pub const SYS_creat: ::c_long = 8;
+pub const SYS_link: ::c_long = 9;
+pub const SYS_unlink: ::c_long = 10;
+pub const SYS_execve: ::c_long = 11;
+pub const SYS_chdir: ::c_long = 12;
+pub const SYS_mknod: ::c_long = 14;
+pub const SYS_chmod: ::c_long = 15;
+pub const SYS_lchown: ::c_long = 16;
+pub const SYS_lseek: ::c_long = 19;
+pub const SYS_getpid: ::c_long = 20;
+pub const SYS_mount: ::c_long = 21;
+pub const SYS_setuid: ::c_long = 23;
+pub const SYS_getuid: ::c_long = 24;
+pub const SYS_ptrace: ::c_long = 26;
+pub const SYS_pause: ::c_long = 29;
+pub const SYS_access: ::c_long = 33;
+pub const SYS_nice: ::c_long = 34;
+pub const SYS_sync: ::c_long = 36;
+pub const SYS_kill: ::c_long = 37;
+pub const SYS_rename: ::c_long = 38;
+pub const SYS_mkdir: ::c_long = 39;
+pub const SYS_rmdir: ::c_long = 40;
+pub const SYS_dup: ::c_long = 41;
+pub const SYS_pipe: ::c_long = 42;
+pub const SYS_times: ::c_long = 43;
+pub const SYS_brk: ::c_long = 45;
+pub const SYS_setgid: ::c_long = 46;
+pub const SYS_getgid: ::c_long = 47;
+pub const SYS_geteuid: ::c_long = 49;
+pub const SYS_getegid: ::c_long = 50;
+pub const SYS_acct: ::c_long = 51;
+pub const SYS_umount2: ::c_long = 52;
+pub const SYS_ioctl: ::c_long = 54;
+pub const SYS_fcntl: ::c_long = 55;
+pub const SYS_setpgid: ::c_long = 57;
+pub const SYS_umask: ::c_long = 60;
+pub const SYS_chroot: ::c_long = 61;
+pub const SYS_ustat: ::c_long = 62;
+pub const SYS_dup2: ::c_long = 63;
+pub const SYS_getppid: ::c_long = 64;
+pub const SYS_getpgrp: ::c_long = 65;
+pub const SYS_setsid: ::c_long = 66;
+pub const SYS_sigaction: ::c_long = 67;
+pub const SYS_setreuid: ::c_long = 70;
+pub const SYS_setregid: ::c_long = 71;
+pub const SYS_sigsuspend: ::c_long = 72;
+pub const SYS_sigpending: ::c_long = 73;
+pub const SYS_sethostname: ::c_long = 74;
+pub const SYS_setrlimit: ::c_long = 75;
+pub const SYS_getrusage: ::c_long = 77;
+pub const SYS_gettimeofday: ::c_long = 78;
+pub const SYS_settimeofday: ::c_long = 79;
+pub const SYS_getgroups: ::c_long = 80;
+pub const SYS_setgroups: ::c_long = 81;
+pub const SYS_symlink: ::c_long = 83;
+pub const SYS_readlink: ::c_long = 85;
+pub const SYS_uselib: ::c_long = 86;
+pub const SYS_swapon: ::c_long = 87;
+pub const SYS_reboot: ::c_long = 88;
+pub const SYS_munmap: ::c_long = 91;
+pub const SYS_truncate: ::c_long = 92;
+pub const SYS_ftruncate: ::c_long = 93;
+pub const SYS_fchmod: ::c_long = 94;
+pub const SYS_fchown: ::c_long = 95;
+pub const SYS_getpriority: ::c_long = 96;
+pub const SYS_setpriority: ::c_long = 97;
+pub const SYS_statfs: ::c_long = 99;
+pub const SYS_fstatfs: ::c_long = 100;
+pub const SYS_syslog: ::c_long = 103;
+pub const SYS_setitimer: ::c_long = 104;
+pub const SYS_getitimer: ::c_long = 105;
+pub const SYS_stat: ::c_long = 106;
+pub const SYS_lstat: ::c_long = 107;
+pub const SYS_fstat: ::c_long = 108;
+pub const SYS_vhangup: ::c_long = 111;
+pub const SYS_wait4: ::c_long = 114;
+pub const SYS_swapoff: ::c_long = 115;
+pub const SYS_sysinfo: ::c_long = 116;
+pub const SYS_fsync: ::c_long = 118;
+pub const SYS_sigreturn: ::c_long = 119;
+pub const SYS_clone: ::c_long = 120;
+pub const SYS_setdomainname: ::c_long = 121;
+pub const SYS_uname: ::c_long = 122;
+pub const SYS_adjtimex: ::c_long = 124;
+pub const SYS_mprotect: ::c_long = 125;
+pub const SYS_sigprocmask: ::c_long = 126;
+pub const SYS_init_module: ::c_long = 128;
+pub const SYS_delete_module: ::c_long = 129;
+pub const SYS_quotactl: ::c_long = 131;
+pub const SYS_getpgid: ::c_long = 132;
+pub const SYS_fchdir: ::c_long = 133;
+pub const SYS_bdflush: ::c_long = 134;
+pub const SYS_sysfs: ::c_long = 135;
+pub const SYS_personality: ::c_long = 136;
+pub const SYS_setfsuid: ::c_long = 138;
+pub const SYS_setfsgid: ::c_long = 139;
+pub const SYS__llseek: ::c_long = 140;
+pub const SYS_getdents: ::c_long = 141;
+pub const SYS__newselect: ::c_long = 142;
+pub const SYS_flock: ::c_long = 143;
+pub const SYS_msync: ::c_long = 144;
+pub const SYS_readv: ::c_long = 145;
+pub const SYS_writev: ::c_long = 146;
+pub const SYS_getsid: ::c_long = 147;
+pub const SYS_fdatasync: ::c_long = 148;
+pub const SYS__sysctl: ::c_long = 149;
+pub const SYS_mlock: ::c_long = 150;
+pub const SYS_munlock: ::c_long = 151;
+pub const SYS_mlockall: ::c_long = 152;
+pub const SYS_munlockall: ::c_long = 153;
+pub const SYS_sched_setparam: ::c_long = 154;
+pub const SYS_sched_getparam: ::c_long = 155;
+pub const SYS_sched_setscheduler: ::c_long = 156;
+pub const SYS_sched_getscheduler: ::c_long = 157;
+pub const SYS_sched_yield: ::c_long = 158;
+pub const SYS_sched_get_priority_max: ::c_long = 159;
+pub const SYS_sched_get_priority_min: ::c_long = 160;
+pub const SYS_sched_rr_get_interval: ::c_long = 161;
+pub const SYS_nanosleep: ::c_long = 162;
+pub const SYS_mremap: ::c_long = 163;
+pub const SYS_setresuid: ::c_long = 164;
+pub const SYS_getresuid: ::c_long = 165;
+pub const SYS_poll: ::c_long = 168;
+pub const SYS_nfsservctl: ::c_long = 169;
+pub const SYS_setresgid: ::c_long = 170;
+pub const SYS_getresgid: ::c_long = 171;
+pub const SYS_prctl: ::c_long = 172;
+pub const SYS_rt_sigreturn: ::c_long = 173;
+pub const SYS_rt_sigaction: ::c_long = 174;
+pub const SYS_rt_sigprocmask: ::c_long = 175;
+pub const SYS_rt_sigpending: ::c_long = 176;
+pub const SYS_rt_sigtimedwait: ::c_long = 177;
+pub const SYS_rt_sigqueueinfo: ::c_long = 178;
+pub const SYS_rt_sigsuspend: ::c_long = 179;
+pub const SYS_pread64: ::c_long = 180;
+pub const SYS_pwrite64: ::c_long = 181;
+pub const SYS_chown: ::c_long = 182;
+pub const SYS_getcwd: ::c_long = 183;
+pub const SYS_capget: ::c_long = 184;
+pub const SYS_capset: ::c_long = 185;
+pub const SYS_sigaltstack: ::c_long = 186;
+pub const SYS_sendfile: ::c_long = 187;
+pub const SYS_vfork: ::c_long = 190;
+pub const SYS_ugetrlimit: ::c_long = 191;
+pub const SYS_mmap2: ::c_long = 192;
+pub const SYS_truncate64: ::c_long = 193;
+pub const SYS_ftruncate64: ::c_long = 194;
+pub const SYS_stat64: ::c_long = 195;
+pub const SYS_lstat64: ::c_long = 196;
+pub const SYS_fstat64: ::c_long = 197;
+pub const SYS_lchown32: ::c_long = 198;
+pub const SYS_getuid32: ::c_long = 199;
+pub const SYS_getgid32: ::c_long = 200;
+pub const SYS_geteuid32: ::c_long = 201;
+pub const SYS_getegid32: ::c_long = 202;
+pub const SYS_setreuid32: ::c_long = 203;
+pub const SYS_setregid32: ::c_long = 204;
+pub const SYS_getgroups32: ::c_long = 205;
+pub const SYS_setgroups32: ::c_long = 206;
+pub const SYS_fchown32: ::c_long = 207;
+pub const SYS_setresuid32: ::c_long = 208;
+pub const SYS_getresuid32: ::c_long = 209;
+pub const SYS_setresgid32: ::c_long = 210;
+pub const SYS_getresgid32: ::c_long = 211;
+pub const SYS_chown32: ::c_long = 212;
+pub const SYS_setuid32: ::c_long = 213;
+pub const SYS_setgid32: ::c_long = 214;
+pub const SYS_setfsuid32: ::c_long = 215;
+pub const SYS_setfsgid32: ::c_long = 216;
+pub const SYS_getdents64: ::c_long = 217;
+pub const SYS_pivot_root: ::c_long = 218;
+pub const SYS_mincore: ::c_long = 219;
+pub const SYS_madvise: ::c_long = 220;
+pub const SYS_fcntl64: ::c_long = 221;
+pub const SYS_gettid: ::c_long = 224;
+pub const SYS_readahead: ::c_long = 225;
+pub const SYS_setxattr: ::c_long = 226;
+pub const SYS_lsetxattr: ::c_long = 227;
+pub const SYS_fsetxattr: ::c_long = 228;
+pub const SYS_getxattr: ::c_long = 229;
+pub const SYS_lgetxattr: ::c_long = 230;
+pub const SYS_fgetxattr: ::c_long = 231;
+pub const SYS_listxattr: ::c_long = 232;
+pub const SYS_llistxattr: ::c_long = 233;
+pub const SYS_flistxattr: ::c_long = 234;
+pub const SYS_removexattr: ::c_long = 235;
+pub const SYS_lremovexattr: ::c_long = 236;
+pub const SYS_fremovexattr: ::c_long = 237;
+pub const SYS_tkill: ::c_long = 238;
+pub const SYS_sendfile64: ::c_long = 239;
+pub const SYS_futex: ::c_long = 240;
+pub const SYS_sched_setaffinity: ::c_long = 241;
+pub const SYS_sched_getaffinity: ::c_long = 242;
+pub const SYS_io_setup: ::c_long = 243;
+pub const SYS_io_destroy: ::c_long = 244;
+pub const SYS_io_getevents: ::c_long = 245;
+pub const SYS_io_submit: ::c_long = 246;
+pub const SYS_io_cancel: ::c_long = 247;
+pub const SYS_exit_group: ::c_long = 248;
+pub const SYS_lookup_dcookie: ::c_long = 249;
+pub const SYS_epoll_create: ::c_long = 250;
+pub const SYS_epoll_ctl: ::c_long = 251;
+pub const SYS_epoll_wait: ::c_long = 252;
+pub const SYS_remap_file_pages: ::c_long = 253;
+pub const SYS_set_tid_address: ::c_long = 256;
+pub const SYS_timer_create: ::c_long = 257;
+pub const SYS_timer_settime: ::c_long = 258;
+pub const SYS_timer_gettime: ::c_long = 259;
+pub const SYS_timer_getoverrun: ::c_long = 260;
+pub const SYS_timer_delete: ::c_long = 261;
+pub const SYS_clock_settime: ::c_long = 262;
+pub const SYS_clock_gettime: ::c_long = 263;
+pub const SYS_clock_getres: ::c_long = 264;
+pub const SYS_clock_nanosleep: ::c_long = 265;
+pub const SYS_statfs64: ::c_long = 266;
+pub const SYS_fstatfs64: ::c_long = 267;
+pub const SYS_tgkill: ::c_long = 268;
+pub const SYS_utimes: ::c_long = 269;
+pub const SYS_pciconfig_iobase: ::c_long = 271;
+pub const SYS_pciconfig_read: ::c_long = 272;
+pub const SYS_pciconfig_write: ::c_long = 273;
+pub const SYS_mq_open: ::c_long = 274;
+pub const SYS_mq_unlink: ::c_long = 275;
+pub const SYS_mq_timedsend: ::c_long = 276;
+pub const SYS_mq_timedreceive: ::c_long = 277;
+pub const SYS_mq_notify: ::c_long = 278;
+pub const SYS_mq_getsetattr: ::c_long = 279;
+pub const SYS_waitid: ::c_long = 280;
+pub const SYS_socket: ::c_long = 281;
+pub const SYS_bind: ::c_long = 282;
+pub const SYS_connect: ::c_long = 283;
+pub const SYS_listen: ::c_long = 284;
+pub const SYS_accept: ::c_long = 285;
+pub const SYS_getsockname: ::c_long = 286;
+pub const SYS_getpeername: ::c_long = 287;
+pub const SYS_socketpair: ::c_long = 288;
+pub const SYS_send: ::c_long = 289;
+pub const SYS_sendto: ::c_long = 290;
+pub const SYS_recv: ::c_long = 291;
+pub const SYS_recvfrom: ::c_long = 292;
+pub const SYS_shutdown: ::c_long = 293;
+pub const SYS_setsockopt: ::c_long = 294;
+pub const SYS_getsockopt: ::c_long = 295;
+pub const SYS_sendmsg: ::c_long = 296;
+pub const SYS_recvmsg: ::c_long = 297;
+pub const SYS_semop: ::c_long = 298;
+pub const SYS_semget: ::c_long = 299;
+pub const SYS_semctl: ::c_long = 300;
+pub const SYS_msgsnd: ::c_long = 301;
+pub const SYS_msgrcv: ::c_long = 302;
+pub const SYS_msgget: ::c_long = 303;
+pub const SYS_msgctl: ::c_long = 304;
+pub const SYS_shmat: ::c_long = 305;
+pub const SYS_shmdt: ::c_long = 306;
+pub const SYS_shmget: ::c_long = 307;
+pub const SYS_shmctl: ::c_long = 308;
+pub const SYS_add_key: ::c_long = 309;
+pub const SYS_request_key: ::c_long = 310;
+pub const SYS_keyctl: ::c_long = 311;
+pub const SYS_semtimedop: ::c_long = 312;
+pub const SYS_vserver: ::c_long = 313;
+pub const SYS_ioprio_set: ::c_long = 314;
+pub const SYS_ioprio_get: ::c_long = 315;
+pub const SYS_inotify_init: ::c_long = 316;
+pub const SYS_inotify_add_watch: ::c_long = 317;
+pub const SYS_inotify_rm_watch: ::c_long = 318;
+pub const SYS_mbind: ::c_long = 319;
+pub const SYS_get_mempolicy: ::c_long = 320;
+pub const SYS_set_mempolicy: ::c_long = 321;
+pub const SYS_openat: ::c_long = 322;
+pub const SYS_mkdirat: ::c_long = 323;
+pub const SYS_mknodat: ::c_long = 324;
+pub const SYS_fchownat: ::c_long = 325;
+pub const SYS_futimesat: ::c_long = 326;
+pub const SYS_fstatat64: ::c_long = 327;
+pub const SYS_unlinkat: ::c_long = 328;
+pub const SYS_renameat: ::c_long = 329;
+pub const SYS_linkat: ::c_long = 330;
+pub const SYS_symlinkat: ::c_long = 331;
+pub const SYS_readlinkat: ::c_long = 332;
+pub const SYS_fchmodat: ::c_long = 333;
+pub const SYS_faccessat: ::c_long = 334;
+pub const SYS_pselect6: ::c_long = 335;
+pub const SYS_ppoll: ::c_long = 336;
+pub const SYS_unshare: ::c_long = 337;
+pub const SYS_set_robust_list: ::c_long = 338;
+pub const SYS_get_robust_list: ::c_long = 339;
+pub const SYS_splice: ::c_long = 340;
+pub const SYS_tee: ::c_long = 342;
+pub const SYS_vmsplice: ::c_long = 343;
+pub const SYS_move_pages: ::c_long = 344;
+pub const SYS_getcpu: ::c_long = 345;
+pub const SYS_epoll_pwait: ::c_long = 346;
+pub const SYS_kexec_load: ::c_long = 347;
+pub const SYS_utimensat: ::c_long = 348;
+pub const SYS_signalfd: ::c_long = 349;
+pub const SYS_timerfd_create: ::c_long = 350;
+pub const SYS_eventfd: ::c_long = 351;
+pub const SYS_fallocate: ::c_long = 352;
+pub const SYS_timerfd_settime: ::c_long = 353;
+pub const SYS_timerfd_gettime: ::c_long = 354;
+pub const SYS_signalfd4: ::c_long = 355;
+pub const SYS_eventfd2: ::c_long = 356;
+pub const SYS_epoll_create1: ::c_long = 357;
+pub const SYS_dup3: ::c_long = 358;
+pub const SYS_pipe2: ::c_long = 359;
+pub const SYS_inotify_init1: ::c_long = 360;
+pub const SYS_preadv: ::c_long = 361;
+pub const SYS_pwritev: ::c_long = 362;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 363;
+pub const SYS_perf_event_open: ::c_long = 364;
+pub const SYS_recvmmsg: ::c_long = 365;
+pub const SYS_accept4: ::c_long = 366;
+pub const SYS_fanotify_init: ::c_long = 367;
+pub const SYS_fanotify_mark: ::c_long = 368;
+pub const SYS_prlimit64: ::c_long = 369;
+pub const SYS_name_to_handle_at: ::c_long = 370;
+pub const SYS_open_by_handle_at: ::c_long = 371;
+pub const SYS_clock_adjtime: ::c_long = 372;
+pub const SYS_syncfs: ::c_long = 373;
+pub const SYS_sendmmsg: ::c_long = 374;
+pub const SYS_setns: ::c_long = 375;
+pub const SYS_process_vm_readv: ::c_long = 376;
+pub const SYS_process_vm_writev: ::c_long = 377;
+pub const SYS_kcmp: ::c_long = 378;
+pub const SYS_finit_module: ::c_long = 379;
+pub const SYS_sched_setattr: ::c_long = 380;
+pub const SYS_sched_getattr: ::c_long = 381;
+pub const SYS_renameat2: ::c_long = 382;
+pub const SYS_seccomp: ::c_long = 383;
+pub const SYS_getrandom: ::c_long = 384;
+pub const SYS_memfd_create: ::c_long = 385;
+pub const SYS_bpf: ::c_long = 386;
+pub const SYS_execveat: ::c_long = 387;
+pub const SYS_userfaultfd: ::c_long = 388;
+pub const SYS_membarrier: ::c_long = 389;
+pub const SYS_mlock2: ::c_long = 390;
+pub const SYS_copy_file_range: ::c_long = 391;
+pub const SYS_preadv2: ::c_long = 392;
+pub const SYS_pwritev2: ::c_long = 393;
+pub const SYS_pkey_mprotect: ::c_long = 394;
+pub const SYS_pkey_alloc: ::c_long = 395;
+pub const SYS_pkey_free: ::c_long = 396;
+
+fn CMSG_ALIGN(len: usize) -> usize {
+    len + ::mem::size_of::<usize>() - 1 & !(::mem::size_of::<usize>() - 1)
+}
+
+f! {
+    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {
+        if (*mhdr).msg_controllen as usize >= ::mem::size_of::<cmsghdr>() {
+            (*mhdr).msg_control as *mut cmsghdr
+        } else {
+            0 as *mut cmsghdr
+        }
+    }
+
+    pub fn CMSG_DATA(cmsg: *const cmsghdr) -> *mut ::c_uchar {
+        cmsg.offset(1) as *mut ::c_uchar
+    }
+
+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        (CMSG_ALIGN(length as usize) + CMSG_ALIGN(::mem::size_of::<cmsghdr>()))
+            as ::c_uint
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        CMSG_ALIGN(::mem::size_of::<cmsghdr>()) as ::c_uint + length
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr,
+                       cmsg: *const cmsghdr) -> *mut cmsghdr {
+        if ((*cmsg).cmsg_len as usize) < ::mem::size_of::<cmsghdr>() {
+            return 0 as *mut cmsghdr;
+        };
+        let next = (cmsg as usize +
+                    CMSG_ALIGN((*cmsg).cmsg_len as usize))
+            as *mut cmsghdr;
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if (next.offset(1)) as usize > max ||
+            next as usize + CMSG_ALIGN((*next).cmsg_len as usize) > max
+        {
+            0 as *mut cmsghdr
+        } else {
+            next as *mut cmsghdr
+        }
+    }
+
+}
+
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;
+    pub fn openpty(
+        amaster: *mut ::c_int,
+        aslave: *mut ::c_int,
+        name: *mut ::c_char,
+        termp: *mut termios,
+        winp: *mut ::winsize,
+    ) -> ::c_int;
+    pub fn setns(fd: ::c_int, nstype: ::c_int) -> ::c_int;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    } else {
+        mod no_align;
+        pub use self::no_align::*;
+    }
+}
diff --git a/library/libc/src/unix/uclibc/arm/no_align.rs b/library/libc/src/unix/uclibc/arm/no_align.rs
new file mode 100644
index 00000000..e32bf673
--- /dev/null
+++ b/library/libc/src/unix/uclibc/arm/no_align.rs
@@ -0,0 +1,10 @@
+s! {
+    // FIXME this is actually a union
+    pub struct sem_t {
+        #[cfg(target_pointer_width = "32")]
+        __size: [::c_char; 16],
+        #[cfg(target_pointer_width = "64")]
+        __size: [::c_char; 32],
+        __align: [::c_long; 0],
+    }
+}
diff --git a/library/libc/src/unix/uclibc/mips/mips32/align.rs b/library/libc/src/unix/uclibc/mips/mips32/align.rs
new file mode 100644
index 00000000..4a0e0746
--- /dev/null
+++ b/library/libc/src/unix/uclibc/mips/mips32/align.rs
@@ -0,0 +1,13 @@
+s! {
+    // FIXME this is actually a union
+    #[cfg_attr(target_pointer_width = "32",
+               repr(align(4)))]
+    #[cfg_attr(target_pointer_width = "64",
+               repr(align(8)))]
+    pub struct sem_t {
+        #[cfg(target_pointer_width = "32")]
+        __size: [::c_char; 16],
+        #[cfg(target_pointer_width = "64")]
+        __size: [::c_char; 32],
+    }
+}
diff --git a/library/libc/src/unix/uclibc/mips/mips32/mod.rs b/library/libc/src/unix/uclibc/mips/mips32/mod.rs
new file mode 100644
index 00000000..31bca589
--- /dev/null
+++ b/library/libc/src/unix/uclibc/mips/mips32/mod.rs
@@ -0,0 +1,633 @@
+pub type c_char = i8;
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type clock_t = i32;
+pub type time_t = i32;
+pub type suseconds_t = i32;
+pub type wchar_t = i32;
+pub type off_t = i32;
+pub type ino_t = u32;
+pub type blkcnt_t = i32;
+pub type blksize_t = i32;
+pub type nlink_t = u32;
+pub type fsblkcnt_t = ::c_ulong;
+pub type fsfilcnt_t = ::c_ulong;
+pub type rlim_t = c_ulong;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        st_pad1: [::c_long; 2],
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        pub st_pad2: [::c_long; 1],
+        pub st_size: ::off_t,
+        st_pad3: ::c_long,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        st_pad5: [::c_long; 14],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::dev_t,
+        st_pad1: [::c_long; 2],
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::dev_t,
+        st_pad2: [::c_long; 2],
+        pub st_size: ::off64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        st_pad3: ::c_long,
+        pub st_blocks: ::blkcnt64_t,
+        st_pad5: [::c_long; 14],
+    }
+
+    pub struct pthread_attr_t {
+        __size: [u32; 9]
+    }
+
+    pub struct sigaction {
+        pub sa_flags: ::c_uint,
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: sigset_t,
+        _restorer: *mut ::c_void,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct sigset_t {
+        __val: [::c_ulong; 4],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        pub _pad: [::c_int; 29],
+    }
+
+    pub struct glob64_t {
+        pub gl_pathc: ::size_t,
+        pub gl_pathv: *mut *mut ::c_char,
+        pub gl_offs: ::size_t,
+        pub gl_flags: ::c_int,
+
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_uint,
+        pub __seq: ::c_ushort,
+        __pad1: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        #[cfg(target_endian = "big")]
+        __glibc_reserved1: ::c_ulong,
+        pub msg_stime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __glibc_reserved1: ::c_ulong,
+        #[cfg(target_endian = "big")]
+        __glibc_reserved2: ::c_ulong,
+        pub msg_rtime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __glibc_reserved2: ::c_ulong,
+        #[cfg(target_endian = "big")]
+        __glibc_reserved3: ::c_ulong,
+        pub msg_ctime: ::time_t,
+        #[cfg(target_endian = "little")]
+        __glibc_reserved3: ::c_ulong,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved4: ::c_ulong,
+        __glibc_reserved5: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_files: ::fsblkcnt_t,
+        pub f_ffree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::c_long,
+        f_spare: [::c_long; 6],
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::size_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::size_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+    }
+
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_sysid: ::c_long,
+        pub l_pid: ::pid_t,
+        pad: [::c_long; 4],
+    }
+
+    pub struct sysinfo {
+        pub uptime: ::c_long,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub _f: [::c_char; 8],
+    }
+}
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 24;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+
+pub const RLIM_INFINITY: ::rlim_t = 0x7fffffff;
+
+pub const SYS_syscall: ::c_long = 4000 + 0;
+pub const SYS_exit: ::c_long = 4000 + 1;
+pub const SYS_fork: ::c_long = 4000 + 2;
+pub const SYS_read: ::c_long = 4000 + 3;
+pub const SYS_write: ::c_long = 4000 + 4;
+pub const SYS_open: ::c_long = 4000 + 5;
+pub const SYS_close: ::c_long = 4000 + 6;
+pub const SYS_waitpid: ::c_long = 4000 + 7;
+pub const SYS_creat: ::c_long = 4000 + 8;
+pub const SYS_link: ::c_long = 4000 + 9;
+pub const SYS_unlink: ::c_long = 4000 + 10;
+pub const SYS_execve: ::c_long = 4000 + 11;
+pub const SYS_chdir: ::c_long = 4000 + 12;
+pub const SYS_time: ::c_long = 4000 + 13;
+pub const SYS_mknod: ::c_long = 4000 + 14;
+pub const SYS_chmod: ::c_long = 4000 + 15;
+pub const SYS_lchown: ::c_long = 4000 + 16;
+pub const SYS_break: ::c_long = 4000 + 17;
+pub const SYS_lseek: ::c_long = 4000 + 19;
+pub const SYS_getpid: ::c_long = 4000 + 20;
+pub const SYS_mount: ::c_long = 4000 + 21;
+pub const SYS_umount: ::c_long = 4000 + 22;
+pub const SYS_setuid: ::c_long = 4000 + 23;
+pub const SYS_getuid: ::c_long = 4000 + 24;
+pub const SYS_stime: ::c_long = 4000 + 25;
+pub const SYS_ptrace: ::c_long = 4000 + 26;
+pub const SYS_alarm: ::c_long = 4000 + 27;
+pub const SYS_pause: ::c_long = 4000 + 29;
+pub const SYS_utime: ::c_long = 4000 + 30;
+pub const SYS_stty: ::c_long = 4000 + 31;
+pub const SYS_gtty: ::c_long = 4000 + 32;
+pub const SYS_access: ::c_long = 4000 + 33;
+pub const SYS_nice: ::c_long = 4000 + 34;
+pub const SYS_ftime: ::c_long = 4000 + 35;
+pub const SYS_sync: ::c_long = 4000 + 36;
+pub const SYS_kill: ::c_long = 4000 + 37;
+pub const SYS_rename: ::c_long = 4000 + 38;
+pub const SYS_mkdir: ::c_long = 4000 + 39;
+pub const SYS_rmdir: ::c_long = 4000 + 40;
+pub const SYS_dup: ::c_long = 4000 + 41;
+pub const SYS_pipe: ::c_long = 4000 + 42;
+pub const SYS_times: ::c_long = 4000 + 43;
+pub const SYS_prof: ::c_long = 4000 + 44;
+pub const SYS_brk: ::c_long = 4000 + 45;
+pub const SYS_setgid: ::c_long = 4000 + 46;
+pub const SYS_getgid: ::c_long = 4000 + 47;
+pub const SYS_signal: ::c_long = 4000 + 48;
+pub const SYS_geteuid: ::c_long = 4000 + 49;
+pub const SYS_getegid: ::c_long = 4000 + 50;
+pub const SYS_acct: ::c_long = 4000 + 51;
+pub const SYS_umount2: ::c_long = 4000 + 52;
+pub const SYS_lock: ::c_long = 4000 + 53;
+pub const SYS_ioctl: ::c_long = 4000 + 54;
+pub const SYS_fcntl: ::c_long = 4000 + 55;
+pub const SYS_mpx: ::c_long = 4000 + 56;
+pub const SYS_setpgid: ::c_long = 4000 + 57;
+pub const SYS_ulimit: ::c_long = 4000 + 58;
+pub const SYS_umask: ::c_long = 4000 + 60;
+pub const SYS_chroot: ::c_long = 4000 + 61;
+pub const SYS_ustat: ::c_long = 4000 + 62;
+pub const SYS_dup2: ::c_long = 4000 + 63;
+pub const SYS_getppid: ::c_long = 4000 + 64;
+pub const SYS_getpgrp: ::c_long = 4000 + 65;
+pub const SYS_setsid: ::c_long = 4000 + 66;
+pub const SYS_sigaction: ::c_long = 4000 + 67;
+pub const SYS_sgetmask: ::c_long = 4000 + 68;
+pub const SYS_ssetmask: ::c_long = 4000 + 69;
+pub const SYS_setreuid: ::c_long = 4000 + 70;
+pub const SYS_setregid: ::c_long = 4000 + 71;
+pub const SYS_sigsuspend: ::c_long = 4000 + 72;
+pub const SYS_sigpending: ::c_long = 4000 + 73;
+pub const SYS_sethostname: ::c_long = 4000 + 74;
+pub const SYS_setrlimit: ::c_long = 4000 + 75;
+pub const SYS_getrlimit: ::c_long = 4000 + 76;
+pub const SYS_getrusage: ::c_long = 4000 + 77;
+pub const SYS_gettimeofday: ::c_long = 4000 + 78;
+pub const SYS_settimeofday: ::c_long = 4000 + 79;
+pub const SYS_getgroups: ::c_long = 4000 + 80;
+pub const SYS_setgroups: ::c_long = 4000 + 81;
+pub const SYS_symlink: ::c_long = 4000 + 83;
+pub const SYS_readlink: ::c_long = 4000 + 85;
+pub const SYS_uselib: ::c_long = 4000 + 86;
+pub const SYS_swapon: ::c_long = 4000 + 87;
+pub const SYS_reboot: ::c_long = 4000 + 88;
+pub const SYS_readdir: ::c_long = 4000 + 89;
+pub const SYS_mmap: ::c_long = 4000 + 90;
+pub const SYS_munmap: ::c_long = 4000 + 91;
+pub const SYS_truncate: ::c_long = 4000 + 92;
+pub const SYS_ftruncate: ::c_long = 4000 + 93;
+pub const SYS_fchmod: ::c_long = 4000 + 94;
+pub const SYS_fchown: ::c_long = 4000 + 95;
+pub const SYS_getpriority: ::c_long = 4000 + 96;
+pub const SYS_setpriority: ::c_long = 4000 + 97;
+pub const SYS_profil: ::c_long = 4000 + 98;
+pub const SYS_statfs: ::c_long = 4000 + 99;
+pub const SYS_fstatfs: ::c_long = 4000 + 100;
+pub const SYS_ioperm: ::c_long = 4000 + 101;
+pub const SYS_socketcall: ::c_long = 4000 + 102;
+pub const SYS_syslog: ::c_long = 4000 + 103;
+pub const SYS_setitimer: ::c_long = 4000 + 104;
+pub const SYS_getitimer: ::c_long = 4000 + 105;
+pub const SYS_stat: ::c_long = 4000 + 106;
+pub const SYS_lstat: ::c_long = 4000 + 107;
+pub const SYS_fstat: ::c_long = 4000 + 108;
+pub const SYS_iopl: ::c_long = 4000 + 110;
+pub const SYS_vhangup: ::c_long = 4000 + 111;
+pub const SYS_idle: ::c_long = 4000 + 112;
+pub const SYS_vm86: ::c_long = 4000 + 113;
+pub const SYS_wait4: ::c_long = 4000 + 114;
+pub const SYS_swapoff: ::c_long = 4000 + 115;
+pub const SYS_sysinfo: ::c_long = 4000 + 116;
+pub const SYS_ipc: ::c_long = 4000 + 117;
+pub const SYS_fsync: ::c_long = 4000 + 118;
+pub const SYS_sigreturn: ::c_long = 4000 + 119;
+pub const SYS_clone: ::c_long = 4000 + 120;
+pub const SYS_setdomainname: ::c_long = 4000 + 121;
+pub const SYS_uname: ::c_long = 4000 + 122;
+pub const SYS_modify_ldt: ::c_long = 4000 + 123;
+pub const SYS_adjtimex: ::c_long = 4000 + 124;
+pub const SYS_mprotect: ::c_long = 4000 + 125;
+pub const SYS_sigprocmask: ::c_long = 4000 + 126;
+pub const SYS_create_module: ::c_long = 4000 + 127;
+pub const SYS_init_module: ::c_long = 4000 + 128;
+pub const SYS_delete_module: ::c_long = 4000 + 129;
+pub const SYS_get_kernel_syms: ::c_long = 4000 + 130;
+pub const SYS_quotactl: ::c_long = 4000 + 131;
+pub const SYS_getpgid: ::c_long = 4000 + 132;
+pub const SYS_fchdir: ::c_long = 4000 + 133;
+pub const SYS_bdflush: ::c_long = 4000 + 134;
+pub const SYS_sysfs: ::c_long = 4000 + 135;
+pub const SYS_personality: ::c_long = 4000 + 136;
+pub const SYS_afs_syscall: ::c_long = 4000 + 137;
+pub const SYS_setfsuid: ::c_long = 4000 + 138;
+pub const SYS_setfsgid: ::c_long = 4000 + 139;
+pub const SYS__llseek: ::c_long = 4000 + 140;
+pub const SYS_getdents: ::c_long = 4000 + 141;
+pub const SYS__newselect: ::c_long = 4000 + 142;
+pub const SYS_flock: ::c_long = 4000 + 143;
+pub const SYS_msync: ::c_long = 4000 + 144;
+pub const SYS_readv: ::c_long = 4000 + 145;
+pub const SYS_writev: ::c_long = 4000 + 146;
+pub const SYS_cacheflush: ::c_long = 4000 + 147;
+pub const SYS_cachectl: ::c_long = 4000 + 148;
+pub const SYS_sysmips: ::c_long = 4000 + 149;
+pub const SYS_getsid: ::c_long = 4000 + 151;
+pub const SYS_fdatasync: ::c_long = 4000 + 152;
+pub const SYS__sysctl: ::c_long = 4000 + 153;
+pub const SYS_mlock: ::c_long = 4000 + 154;
+pub const SYS_munlock: ::c_long = 4000 + 155;
+pub const SYS_mlockall: ::c_long = 4000 + 156;
+pub const SYS_munlockall: ::c_long = 4000 + 157;
+pub const SYS_sched_setparam: ::c_long = 4000 + 158;
+pub const SYS_sched_getparam: ::c_long = 4000 + 159;
+pub const SYS_sched_setscheduler: ::c_long = 4000 + 160;
+pub const SYS_sched_getscheduler: ::c_long = 4000 + 161;
+pub const SYS_sched_yield: ::c_long = 4000 + 162;
+pub const SYS_sched_get_priority_max: ::c_long = 4000 + 163;
+pub const SYS_sched_get_priority_min: ::c_long = 4000 + 164;
+pub const SYS_sched_rr_get_interval: ::c_long = 4000 + 165;
+pub const SYS_nanosleep: ::c_long = 4000 + 166;
+pub const SYS_mremap: ::c_long = 4000 + 167;
+pub const SYS_accept: ::c_long = 4000 + 168;
+pub const SYS_bind: ::c_long = 4000 + 169;
+pub const SYS_connect: ::c_long = 4000 + 170;
+pub const SYS_getpeername: ::c_long = 4000 + 171;
+pub const SYS_getsockname: ::c_long = 4000 + 172;
+pub const SYS_getsockopt: ::c_long = 4000 + 173;
+pub const SYS_listen: ::c_long = 4000 + 174;
+pub const SYS_recv: ::c_long = 4000 + 175;
+pub const SYS_recvfrom: ::c_long = 4000 + 176;
+pub const SYS_recvmsg: ::c_long = 4000 + 177;
+pub const SYS_send: ::c_long = 4000 + 178;
+pub const SYS_sendmsg: ::c_long = 4000 + 179;
+pub const SYS_sendto: ::c_long = 4000 + 180;
+pub const SYS_setsockopt: ::c_long = 4000 + 181;
+pub const SYS_shutdown: ::c_long = 4000 + 182;
+pub const SYS_socket: ::c_long = 4000 + 183;
+pub const SYS_socketpair: ::c_long = 4000 + 184;
+pub const SYS_setresuid: ::c_long = 4000 + 185;
+pub const SYS_getresuid: ::c_long = 4000 + 186;
+pub const SYS_query_module: ::c_long = 4000 + 187;
+pub const SYS_poll: ::c_long = 4000 + 188;
+pub const SYS_nfsservctl: ::c_long = 4000 + 189;
+pub const SYS_setresgid: ::c_long = 4000 + 190;
+pub const SYS_getresgid: ::c_long = 4000 + 191;
+pub const SYS_prctl: ::c_long = 4000 + 192;
+pub const SYS_rt_sigreturn: ::c_long = 4000 + 193;
+pub const SYS_rt_sigaction: ::c_long = 4000 + 194;
+pub const SYS_rt_sigprocmask: ::c_long = 4000 + 195;
+pub const SYS_rt_sigpending: ::c_long = 4000 + 196;
+pub const SYS_rt_sigtimedwait: ::c_long = 4000 + 197;
+pub const SYS_rt_sigqueueinfo: ::c_long = 4000 + 198;
+pub const SYS_rt_sigsuspend: ::c_long = 4000 + 199;
+pub const SYS_pread64: ::c_long = 4000 + 200;
+pub const SYS_pwrite64: ::c_long = 4000 + 201;
+pub const SYS_chown: ::c_long = 4000 + 202;
+pub const SYS_getcwd: ::c_long = 4000 + 203;
+pub const SYS_capget: ::c_long = 4000 + 204;
+pub const SYS_capset: ::c_long = 4000 + 205;
+pub const SYS_sigaltstack: ::c_long = 4000 + 206;
+pub const SYS_sendfile: ::c_long = 4000 + 207;
+pub const SYS_getpmsg: ::c_long = 4000 + 208;
+pub const SYS_putpmsg: ::c_long = 4000 + 209;
+pub const SYS_mmap2: ::c_long = 4000 + 210;
+pub const SYS_truncate64: ::c_long = 4000 + 211;
+pub const SYS_ftruncate64: ::c_long = 4000 + 212;
+pub const SYS_stat64: ::c_long = 4000 + 213;
+pub const SYS_lstat64: ::c_long = 4000 + 214;
+pub const SYS_fstat64: ::c_long = 4000 + 215;
+pub const SYS_pivot_root: ::c_long = 4000 + 216;
+pub const SYS_mincore: ::c_long = 4000 + 217;
+pub const SYS_madvise: ::c_long = 4000 + 218;
+pub const SYS_getdents64: ::c_long = 4000 + 219;
+pub const SYS_fcntl64: ::c_long = 4000 + 220;
+pub const SYS_gettid: ::c_long = 4000 + 222;
+pub const SYS_readahead: ::c_long = 4000 + 223;
+pub const SYS_setxattr: ::c_long = 4000 + 224;
+pub const SYS_lsetxattr: ::c_long = 4000 + 225;
+pub const SYS_fsetxattr: ::c_long = 4000 + 226;
+pub const SYS_getxattr: ::c_long = 4000 + 227;
+pub const SYS_lgetxattr: ::c_long = 4000 + 228;
+pub const SYS_fgetxattr: ::c_long = 4000 + 229;
+pub const SYS_listxattr: ::c_long = 4000 + 230;
+pub const SYS_llistxattr: ::c_long = 4000 + 231;
+pub const SYS_flistxattr: ::c_long = 4000 + 232;
+pub const SYS_removexattr: ::c_long = 4000 + 233;
+pub const SYS_lremovexattr: ::c_long = 4000 + 234;
+pub const SYS_fremovexattr: ::c_long = 4000 + 235;
+pub const SYS_tkill: ::c_long = 4000 + 236;
+pub const SYS_sendfile64: ::c_long = 4000 + 237;
+pub const SYS_futex: ::c_long = 4000 + 238;
+pub const SYS_sched_setaffinity: ::c_long = 4000 + 239;
+pub const SYS_sched_getaffinity: ::c_long = 4000 + 240;
+pub const SYS_io_setup: ::c_long = 4000 + 241;
+pub const SYS_io_destroy: ::c_long = 4000 + 242;
+pub const SYS_io_getevents: ::c_long = 4000 + 243;
+pub const SYS_io_submit: ::c_long = 4000 + 244;
+pub const SYS_io_cancel: ::c_long = 4000 + 245;
+pub const SYS_exit_group: ::c_long = 4000 + 246;
+pub const SYS_lookup_dcookie: ::c_long = 4000 + 247;
+pub const SYS_epoll_create: ::c_long = 4000 + 248;
+pub const SYS_epoll_ctl: ::c_long = 4000 + 249;
+pub const SYS_epoll_wait: ::c_long = 4000 + 250;
+pub const SYS_remap_file_pages: ::c_long = 4000 + 251;
+pub const SYS_set_tid_address: ::c_long = 4000 + 252;
+pub const SYS_restart_syscall: ::c_long = 4000 + 253;
+pub const SYS_fadvise64: ::c_long = 4000 + 254;
+pub const SYS_statfs64: ::c_long = 4000 + 255;
+pub const SYS_fstatfs64: ::c_long = 4000 + 256;
+pub const SYS_timer_create: ::c_long = 4000 + 257;
+pub const SYS_timer_settime: ::c_long = 4000 + 258;
+pub const SYS_timer_gettime: ::c_long = 4000 + 259;
+pub const SYS_timer_getoverrun: ::c_long = 4000 + 260;
+pub const SYS_timer_delete: ::c_long = 4000 + 261;
+pub const SYS_clock_settime: ::c_long = 4000 + 262;
+pub const SYS_clock_gettime: ::c_long = 4000 + 263;
+pub const SYS_clock_getres: ::c_long = 4000 + 264;
+pub const SYS_clock_nanosleep: ::c_long = 4000 + 265;
+pub const SYS_tgkill: ::c_long = 4000 + 266;
+pub const SYS_utimes: ::c_long = 4000 + 267;
+pub const SYS_mbind: ::c_long = 4000 + 268;
+pub const SYS_get_mempolicy: ::c_long = 4000 + 269;
+pub const SYS_set_mempolicy: ::c_long = 4000 + 270;
+pub const SYS_mq_open: ::c_long = 4000 + 271;
+pub const SYS_mq_unlink: ::c_long = 4000 + 272;
+pub const SYS_mq_timedsend: ::c_long = 4000 + 273;
+pub const SYS_mq_timedreceive: ::c_long = 4000 + 274;
+pub const SYS_mq_notify: ::c_long = 4000 + 275;
+pub const SYS_mq_getsetattr: ::c_long = 4000 + 276;
+pub const SYS_vserver: ::c_long = 4000 + 277;
+pub const SYS_waitid: ::c_long = 4000 + 278;
+/* pub const SYS_sys_setaltroot: ::c_long = 4000 + 279; */
+pub const SYS_add_key: ::c_long = 4000 + 280;
+pub const SYS_request_key: ::c_long = 4000 + 281;
+pub const SYS_keyctl: ::c_long = 4000 + 282;
+pub const SYS_set_thread_area: ::c_long = 4000 + 283;
+pub const SYS_inotify_init: ::c_long = 4000 + 284;
+pub const SYS_inotify_add_watch: ::c_long = 4000 + 285;
+pub const SYS_inotify_rm_watch: ::c_long = 4000 + 286;
+pub const SYS_migrate_pages: ::c_long = 4000 + 287;
+pub const SYS_openat: ::c_long = 4000 + 288;
+pub const SYS_mkdirat: ::c_long = 4000 + 289;
+pub const SYS_mknodat: ::c_long = 4000 + 290;
+pub const SYS_fchownat: ::c_long = 4000 + 291;
+pub const SYS_futimesat: ::c_long = 4000 + 292;
+pub const SYS_fstatat64: ::c_long = 4000 + 293;
+pub const SYS_unlinkat: ::c_long = 4000 + 294;
+pub const SYS_renameat: ::c_long = 4000 + 295;
+pub const SYS_linkat: ::c_long = 4000 + 296;
+pub const SYS_symlinkat: ::c_long = 4000 + 297;
+pub const SYS_readlinkat: ::c_long = 4000 + 298;
+pub const SYS_fchmodat: ::c_long = 4000 + 299;
+pub const SYS_faccessat: ::c_long = 4000 + 300;
+pub const SYS_pselect6: ::c_long = 4000 + 301;
+pub const SYS_ppoll: ::c_long = 4000 + 302;
+pub const SYS_unshare: ::c_long = 4000 + 303;
+pub const SYS_splice: ::c_long = 4000 + 304;
+pub const SYS_sync_file_range: ::c_long = 4000 + 305;
+pub const SYS_tee: ::c_long = 4000 + 306;
+pub const SYS_vmsplice: ::c_long = 4000 + 307;
+pub const SYS_move_pages: ::c_long = 4000 + 308;
+pub const SYS_set_robust_list: ::c_long = 4000 + 309;
+pub const SYS_get_robust_list: ::c_long = 4000 + 310;
+pub const SYS_kexec_load: ::c_long = 4000 + 311;
+pub const SYS_getcpu: ::c_long = 4000 + 312;
+pub const SYS_epoll_pwait: ::c_long = 4000 + 313;
+pub const SYS_ioprio_set: ::c_long = 4000 + 314;
+pub const SYS_ioprio_get: ::c_long = 4000 + 315;
+pub const SYS_utimensat: ::c_long = 4000 + 316;
+pub const SYS_signalfd: ::c_long = 4000 + 317;
+pub const SYS_timerfd: ::c_long = 4000 + 318;
+pub const SYS_eventfd: ::c_long = 4000 + 319;
+pub const SYS_fallocate: ::c_long = 4000 + 320;
+pub const SYS_timerfd_create: ::c_long = 4000 + 321;
+pub const SYS_timerfd_gettime: ::c_long = 4000 + 322;
+pub const SYS_timerfd_settime: ::c_long = 4000 + 323;
+pub const SYS_signalfd4: ::c_long = 4000 + 324;
+pub const SYS_eventfd2: ::c_long = 4000 + 325;
+pub const SYS_epoll_create1: ::c_long = 4000 + 326;
+pub const SYS_dup3: ::c_long = 4000 + 327;
+pub const SYS_pipe2: ::c_long = 4000 + 328;
+pub const SYS_inotify_init1: ::c_long = 4000 + 329;
+pub const SYS_preadv: ::c_long = 4000 + 330;
+pub const SYS_pwritev: ::c_long = 4000 + 331;
+pub const SYS_rt_tgsigqueueinfo: ::c_long = 4000 + 332;
+pub const SYS_perf_event_open: ::c_long = 4000 + 333;
+pub const SYS_accept4: ::c_long = 4000 + 334;
+pub const SYS_recvmmsg: ::c_long = 4000 + 335;
+pub const SYS_fanotify_init: ::c_long = 4000 + 336;
+pub const SYS_fanotify_mark: ::c_long = 4000 + 337;
+pub const SYS_prlimit64: ::c_long = 4000 + 338;
+pub const SYS_name_to_handle_at: ::c_long = 4000 + 339;
+pub const SYS_open_by_handle_at: ::c_long = 4000 + 340;
+pub const SYS_clock_adjtime: ::c_long = 4000 + 341;
+pub const SYS_syncfs: ::c_long = 4000 + 342;
+pub const SYS_sendmmsg: ::c_long = 4000 + 343;
+pub const SYS_setns: ::c_long = 4000 + 344;
+pub const SYS_process_vm_readv: ::c_long = 4000 + 345;
+pub const SYS_process_vm_writev: ::c_long = 4000 + 346;
+pub const SYS_kcmp: ::c_long = 4000 + 347;
+pub const SYS_finit_module: ::c_long = 4000 + 348;
+pub const SYS_sched_setattr: ::c_long = 4000 + 349;
+pub const SYS_sched_getattr: ::c_long = 4000 + 350;
+pub const SYS_renameat2: ::c_long = 4000 + 351;
+pub const SYS_seccomp: ::c_long = 4000 + 352;
+pub const SYS_getrandom: ::c_long = 4000 + 353;
+pub const SYS_memfd_create: ::c_long = 4000 + 354;
+pub const SYS_bpf: ::c_long = 4000 + 355;
+pub const SYS_execveat: ::c_long = 4000 + 356;
+pub const SYS_userfaultfd: ::c_long = 4000 + 357;
+pub const SYS_membarrier: ::c_long = 4000 + 358;
+pub const SYS_mlock2: ::c_long = 4000 + 359;
+pub const SYS_copy_file_range: ::c_long = 4000 + 360;
+pub const SYS_preadv2: ::c_long = 4000 + 361;
+pub const SYS_pwritev2: ::c_long = 4000 + 362;
+pub const SYS_pkey_mprotect: ::c_long = 4000 + 363;
+pub const SYS_pkey_alloc: ::c_long = 4000 + 364;
+pub const SYS_pkey_free: ::c_long = 4000 + 365;
+
+#[link(name = "util")]
+extern "C" {
+    pub fn sysctl(
+        name: *mut ::c_int,
+        namelen: ::c_int,
+        oldp: *mut ::c_void,
+        oldlenp: *mut ::size_t,
+        newp: *mut ::c_void,
+        newlen: ::size_t,
+    ) -> ::c_int;
+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;
+    pub fn backtrace(buf: *mut *mut ::c_void, sz: ::c_int) -> ::c_int;
+    pub fn glob64(
+        pattern: *const ::c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut glob64_t,
+    ) -> ::c_int;
+    pub fn globfree64(pglob: *mut glob64_t);
+    pub fn ptrace(request: ::c_uint, ...) -> ::c_long;
+    pub fn pthread_attr_getaffinity_np(
+        attr: *const ::pthread_attr_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_setaffinity_np(
+        attr: *mut ::pthread_attr_t,
+        cpusetsize: ::size_t,
+        cpuset: *const ::cpu_set_t,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    } else {
+        mod no_align;
+        pub use self::no_align::*;
+    }
+}
diff --git a/library/libc/src/unix/uclibc/mips/mips32/no_align.rs b/library/libc/src/unix/uclibc/mips/mips32/no_align.rs
new file mode 100644
index 00000000..e32bf673
--- /dev/null
+++ b/library/libc/src/unix/uclibc/mips/mips32/no_align.rs
@@ -0,0 +1,10 @@
+s! {
+    // FIXME this is actually a union
+    pub struct sem_t {
+        #[cfg(target_pointer_width = "32")]
+        __size: [::c_char; 16],
+        #[cfg(target_pointer_width = "64")]
+        __size: [::c_char; 32],
+        __align: [::c_long; 0],
+    }
+}
diff --git a/library/libc/src/unix/uclibc/mips/mips64/align.rs b/library/libc/src/unix/uclibc/mips/mips64/align.rs
new file mode 100644
index 00000000..21e21907
--- /dev/null
+++ b/library/libc/src/unix/uclibc/mips/mips64/align.rs
@@ -0,0 +1,10 @@
+s! {
+    // FIXME this is actually a union
+    #[cfg_attr(target_pointer_width = "32",
+               repr(align(4)))]
+    #[cfg_attr(target_pointer_width = "64",
+               repr(align(8)))]
+    pub struct sem_t {
+        __size: [::c_char; 32],
+    }
+}
diff --git a/library/libc/src/unix/uclibc/mips/mips64/mod.rs b/library/libc/src/unix/uclibc/mips/mips64/mod.rs
new file mode 100644
index 00000000..735eb851
--- /dev/null
+++ b/library/libc/src/unix/uclibc/mips/mips64/mod.rs
@@ -0,0 +1,213 @@
+pub type blkcnt_t = i64;
+pub type blksize_t = i64;
+pub type c_char = i8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type fsblkcnt_t = ::c_ulong;
+pub type fsfilcnt_t = ::c_ulong;
+pub type ino_t = u64;
+pub type nlink_t = u64;
+pub type off_t = i64;
+pub type rlim_t = ::c_ulong;
+pub type suseconds_t = i64;
+pub type time_t = i64;
+pub type wchar_t = i32;
+
+s! {
+    pub struct stat {
+        pub st_dev: ::c_ulong,
+        st_pad1: [::c_long; 2],
+        pub st_ino: ::ino_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulong,
+        st_pad2: [::c_ulong; 1],
+        pub st_size: ::off_t,
+        st_pad3: ::c_long,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        st_pad4: ::c_long,
+        pub st_blocks: ::blkcnt_t,
+        st_pad5: [::c_long; 7],
+    }
+
+    pub struct stat64 {
+        pub st_dev: ::c_ulong,
+        st_pad1: [::c_long; 2],
+        pub st_ino: ::ino64_t,
+        pub st_mode: ::mode_t,
+        pub st_nlink: ::nlink_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulong,
+        st_pad2: [::c_long; 2],
+        pub st_size: ::off64_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_long,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_long,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_long,
+        pub st_blksize: ::blksize_t,
+        st_pad3: ::c_long,
+        pub st_blocks: ::blkcnt64_t,
+        st_pad5: [::c_long; 7],
+    }
+
+    pub struct pthread_attr_t {
+        __size: [::c_ulong; 7]
+    }
+
+    pub struct sigaction {
+        pub sa_flags: ::c_int,
+        pub sa_sigaction: ::sighandler_t,
+        pub sa_mask: sigset_t,
+        _restorer: *mut ::c_void,
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut ::c_void,
+        pub ss_size: ::size_t,
+        pub ss_flags: ::c_int,
+    }
+
+    pub struct sigset_t {
+        __size: [::c_ulong; 16],
+    }
+
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_code: ::c_int,
+        pub si_errno: ::c_int,
+        _pad: ::c_int,
+        _pad2: [::c_long; 14],
+    }
+
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_uint,
+        pub __seq: ::c_ushort,
+        __pad1: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused4: ::c_ulong,
+        __unused5: ::c_ulong
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        pub msg_rtime: ::time_t,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __glibc_reserved4: ::c_ulong,
+        __glibc_reserved5: ::c_ulong,
+    }
+
+    pub struct statfs {
+        pub f_type: ::c_long,
+        pub f_bsize: ::c_long,
+        pub f_frsize: ::c_long,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_files: ::fsblkcnt_t,
+        pub f_ffree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_fsid: ::fsid_t,
+
+        pub f_namelen: ::c_long,
+        f_spare: [::c_long; 6],
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::size_t,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::size_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: ::size_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+    }
+
+    pub struct sysinfo {
+        pub uptime: ::c_long,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub _f: [::c_char; 0],
+    }
+}
+
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+pub const RLIM_INFINITY: ::rlim_t = 0xffff_ffff_ffff_ffff;
+
+pub const SYS_gettid: ::c_long = 5178; // Valid for n64
+
+#[link(name = "util")]
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    } else {
+        mod no_align;
+        pub use self::no_align::*;
+    }
+}
diff --git a/library/libc/src/unix/uclibc/mips/mips64/no_align.rs b/library/libc/src/unix/uclibc/mips/mips64/no_align.rs
new file mode 100644
index 00000000..8909114c
--- /dev/null
+++ b/library/libc/src/unix/uclibc/mips/mips64/no_align.rs
@@ -0,0 +1,7 @@
+s! {
+    // FIXME this is actually a union
+    pub struct sem_t {
+        __size: [::c_char; 32],
+        __align: [::c_long; 0],
+    }
+}
diff --git a/library/libc/src/unix/uclibc/mips/mod.rs b/library/libc/src/unix/uclibc/mips/mod.rs
new file mode 100644
index 00000000..de76971a
--- /dev/null
+++ b/library/libc/src/unix/uclibc/mips/mod.rs
@@ -0,0 +1,481 @@
+pub type pthread_t = ::c_ulong;
+
+pub const SFD_CLOEXEC: ::c_int = 0x080000;
+
+pub const NCCS: usize = 32;
+
+pub const O_TRUNC: ::c_int = 512;
+
+pub const O_CLOEXEC: ::c_int = 0x80000;
+
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EDOTDOT: ::c_int = 73;
+
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NOCLDSTOP: ::c_int = 0x00000001;
+
+pub const EPOLLEXCLUSIVE: ::c_int = 0x10000000; // from linux/mod.rs
+pub const EPOLLWAKEUP: ::c_int = 0x20000000; // from linux/other/mod.rs
+pub const EPOLL_CLOEXEC: ::c_int = 0x80000;
+
+pub const EFD_CLOEXEC: ::c_int = 0x80000;
+
+pub const BUFSIZ: ::c_uint = 4096;
+pub const TMP_MAX: ::c_uint = 238328;
+pub const FOPEN_MAX: ::c_uint = 16;
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+pub const _SC_2_C_VERSION: ::c_int = 96;
+pub const O_ACCMODE: ::c_int = 3;
+pub const O_DIRECT: ::c_int = 0x8000;
+pub const O_DIRECTORY: ::c_int = 0x10000;
+pub const O_NOFOLLOW: ::c_int = 0x20000;
+pub const ST_RELATIME: ::c_ulong = 4096;
+pub const NI_MAXHOST: ::socklen_t = 1025;
+
+pub const RLIMIT_NOFILE: ::c_int = 5;
+pub const RLIMIT_AS: ::c_int = 6;
+pub const RLIMIT_RSS: ::c_int = 7;
+pub const RLIMIT_NPROC: ::c_int = 8;
+pub const RLIMIT_MEMLOCK: ::c_int = 9;
+pub const RLIMIT_NLIMITS: ::c_int = 15;
+
+pub const O_APPEND: ::c_int = 8;
+pub const O_CREAT: ::c_int = 256;
+pub const O_EXCL: ::c_int = 1024;
+pub const O_NOCTTY: ::c_int = 2048;
+pub const O_NONBLOCK: ::c_int = 128;
+pub const O_SYNC: ::c_int = 0x10;
+pub const O_RSYNC: ::c_int = 0x10;
+pub const O_DSYNC: ::c_int = 0x10;
+pub const O_FSYNC: ::c_int = 0x10;
+pub const O_ASYNC: ::c_int = 0x1000;
+pub const O_NDELAY: ::c_int = 0x80;
+
+pub const SOCK_NONBLOCK: ::c_int = 128;
+
+pub const EDEADLK: ::c_int = 45;
+pub const ENAMETOOLONG: ::c_int = 78;
+pub const ENOLCK: ::c_int = 46;
+pub const ENOSYS: ::c_int = 89;
+pub const ENOTEMPTY: ::c_int = 93;
+pub const ELOOP: ::c_int = 90;
+pub const ENOMSG: ::c_int = 35;
+pub const EIDRM: ::c_int = 36;
+pub const ECHRNG: ::c_int = 37;
+pub const EL2NSYNC: ::c_int = 38;
+pub const EL3HLT: ::c_int = 39;
+pub const EL3RST: ::c_int = 40;
+pub const ELNRNG: ::c_int = 41;
+pub const EUNATCH: ::c_int = 42;
+pub const ENOCSI: ::c_int = 43;
+pub const EL2HLT: ::c_int = 44;
+pub const EBADE: ::c_int = 50;
+pub const EBADR: ::c_int = 51;
+pub const EXFULL: ::c_int = 52;
+pub const ENOANO: ::c_int = 53;
+pub const EBADRQC: ::c_int = 54;
+pub const EBADSLT: ::c_int = 55;
+pub const EDEADLOCK: ::c_int = 56;
+pub const EMULTIHOP: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 79;
+pub const ENOTUNIQ: ::c_int = 80;
+pub const EBADFD: ::c_int = 81;
+pub const EBADMSG: ::c_int = 77;
+pub const EREMCHG: ::c_int = 82;
+pub const ELIBACC: ::c_int = 83;
+pub const ELIBBAD: ::c_int = 84;
+pub const ELIBSCN: ::c_int = 85;
+pub const ELIBMAX: ::c_int = 86;
+pub const ELIBEXEC: ::c_int = 87;
+pub const EILSEQ: ::c_int = 88;
+pub const ERESTART: ::c_int = 91;
+pub const ESTRPIPE: ::c_int = 92;
+pub const EUSERS: ::c_int = 94;
+pub const ENOTSOCK: ::c_int = 95;
+pub const EDESTADDRREQ: ::c_int = 96;
+pub const EMSGSIZE: ::c_int = 97;
+pub const EPROTOTYPE: ::c_int = 98;
+pub const ENOPROTOOPT: ::c_int = 99;
+pub const EPROTONOSUPPORT: ::c_int = 120;
+pub const ESOCKTNOSUPPORT: ::c_int = 121;
+pub const EOPNOTSUPP: ::c_int = 122;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 123;
+pub const EAFNOSUPPORT: ::c_int = 124;
+pub const EADDRINUSE: ::c_int = 125;
+pub const EADDRNOTAVAIL: ::c_int = 126;
+pub const ENETDOWN: ::c_int = 127;
+pub const ENETUNREACH: ::c_int = 128;
+pub const ENETRESET: ::c_int = 129;
+pub const ECONNABORTED: ::c_int = 130;
+pub const ECONNRESET: ::c_int = 131;
+pub const ENOBUFS: ::c_int = 132;
+pub const EISCONN: ::c_int = 133;
+pub const ENOTCONN: ::c_int = 134;
+pub const ESHUTDOWN: ::c_int = 143;
+pub const ETOOMANYREFS: ::c_int = 144;
+pub const ETIMEDOUT: ::c_int = 145;
+pub const ECONNREFUSED: ::c_int = 146;
+pub const EHOSTDOWN: ::c_int = 147;
+pub const EHOSTUNREACH: ::c_int = 148;
+pub const EALREADY: ::c_int = 149;
+pub const EINPROGRESS: ::c_int = 150;
+pub const ESTALE: ::c_int = 151;
+pub const EUCLEAN: ::c_int = 135;
+pub const ENOTNAM: ::c_int = 137;
+pub const ENAVAIL: ::c_int = 138;
+pub const EISNAM: ::c_int = 139;
+pub const EREMOTEIO: ::c_int = 140;
+pub const EDQUOT: ::c_int = 1133;
+pub const ENOMEDIUM: ::c_int = 159;
+pub const EMEDIUMTYPE: ::c_int = 160;
+pub const ECANCELED: ::c_int = 158;
+pub const ENOKEY: ::c_int = 161;
+pub const EKEYEXPIRED: ::c_int = 162;
+pub const EKEYREVOKED: ::c_int = 163;
+pub const EKEYREJECTED: ::c_int = 164;
+pub const EOWNERDEAD: ::c_int = 165;
+pub const ENOTRECOVERABLE: ::c_int = 166;
+pub const ERFKILL: ::c_int = 167;
+
+pub const MAP_NORESERVE: ::c_int = 0x400;
+pub const MAP_ANON: ::c_int = 0x800;
+pub const MAP_ANONYMOUS: ::c_int = 0x800;
+pub const MAP_GROWSDOWN: ::c_int = 0x1000;
+pub const MAP_DENYWRITE: ::c_int = 0x2000;
+pub const MAP_EXECUTABLE: ::c_int = 0x4000;
+pub const MAP_LOCKED: ::c_int = 0x8000;
+pub const MAP_POPULATE: ::c_int = 0x10000;
+pub const MAP_NONBLOCK: ::c_int = 0x20000;
+pub const MAP_STACK: ::c_int = 0x40000;
+
+pub const SOCK_STREAM: ::c_int = 2;
+pub const SOCK_DGRAM: ::c_int = 1;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+
+pub const SOL_SOCKET: ::c_int = 0xffff;
+
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_OOBINLINE: ::c_int = 0x0100;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_STYLE: ::c_int = SO_TYPE;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_SNDLOWAT: ::c_int = 0x1003;
+pub const SO_RCVLOWAT: ::c_int = 0x1004;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ACCEPTCONN: ::c_int = 0x1009;
+pub const SO_PROTOCOL: ::c_int = 0x1028;
+pub const SO_DOMAIN: ::c_int = 0x1029;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_PASSCRED: ::c_int = 17;
+pub const SO_PEERCRED: ::c_int = 18;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SCM_TIMESTAMP: ::c_int = SO_TIMESTAMP;
+pub const SO_PEERSEC: ::c_int = 30;
+pub const SO_SNDBUFFORCE: ::c_int = 31;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
+pub const SO_MARK: ::c_int = 36;
+pub const SO_TIMESTAMPING: ::c_int = 37;
+pub const SCM_TIMESTAMPING: ::c_int = SO_TIMESTAMPING;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_BUSY_POLL: ::c_int = 46;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+
+pub const FIOCLEX: ::c_ulong = 0x6601;
+pub const FIONCLEX: ::c_ulong = 0x6602;
+pub const FIONBIO: ::c_ulong = 0x667e;
+
+pub const SA_ONSTACK: ::c_uint = 0x08000000;
+pub const SA_SIGINFO: ::c_uint = 0x00000008;
+pub const SA_NOCLDWAIT: ::c_int = 0x00010000;
+
+pub const SIGCHLD: ::c_int = 18;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGTTIN: ::c_int = 26;
+pub const SIGTTOU: ::c_int = 27;
+pub const SIGXCPU: ::c_int = 30;
+pub const SIGXFSZ: ::c_int = 31;
+pub const SIGVTALRM: ::c_int = 28;
+pub const SIGPROF: ::c_int = 29;
+pub const SIGWINCH: ::c_int = 20;
+pub const SIGUSR1: ::c_int = 16;
+pub const SIGUSR2: ::c_int = 17;
+pub const SIGCONT: ::c_int = 25;
+pub const SIGSTOP: ::c_int = 23;
+pub const SIGTSTP: ::c_int = 24;
+pub const SIGURG: ::c_int = 21;
+pub const SIGIO: ::c_int = 22;
+pub const SIGSYS: ::c_int = 12;
+pub const SIGPOLL: ::c_int = 22;
+pub const SIGPWR: ::c_int = 19;
+pub const SIG_SETMASK: ::c_int = 3;
+pub const SIG_BLOCK: ::c_int = 0x1;
+pub const SIG_UNBLOCK: ::c_int = 0x2;
+
+pub const POLLRDNORM: ::c_short = 0x040;
+pub const POLLWRNORM: ::c_short = 0x004;
+pub const POLLRDBAND: ::c_short = 0x080;
+pub const POLLWRBAND: ::c_short = 0x100;
+
+pub const PTHREAD_STACK_MIN: ::size_t = 16384;
+
+pub const ADFS_SUPER_MAGIC: ::c_long = 0x0000adf5;
+pub const AFFS_SUPER_MAGIC: ::c_long = 0x0000adff;
+pub const CODA_SUPER_MAGIC: ::c_long = 0x73757245;
+pub const CRAMFS_MAGIC: ::c_long = 0x28cd3d45;
+pub const EFS_SUPER_MAGIC: ::c_long = 0x00414a53;
+pub const EXT2_SUPER_MAGIC: ::c_long = 0x0000ef53;
+pub const EXT3_SUPER_MAGIC: ::c_long = 0x0000ef53;
+pub const EXT4_SUPER_MAGIC: ::c_long = 0x0000ef53;
+pub const HPFS_SUPER_MAGIC: ::c_long = 0xf995e849;
+pub const HUGETLBFS_MAGIC: ::c_long = 0x958458f6;
+pub const ISOFS_SUPER_MAGIC: ::c_long = 0x00009660;
+pub const JFFS2_SUPER_MAGIC: ::c_long = 0x000072b6;
+pub const MINIX_SUPER_MAGIC: ::c_long = 0x0000137f;
+pub const MINIX_SUPER_MAGIC2: ::c_long = 0x0000138f;
+pub const MINIX2_SUPER_MAGIC: ::c_long = 0x00002468;
+pub const MINIX2_SUPER_MAGIC2: ::c_long = 0x00002478;
+pub const MSDOS_SUPER_MAGIC: ::c_long = 0x00004d44;
+pub const NCP_SUPER_MAGIC: ::c_long = 0x0000564c;
+pub const NFS_SUPER_MAGIC: ::c_long = 0x00006969;
+pub const OPENPROM_SUPER_MAGIC: ::c_long = 0x00009fa1;
+pub const PROC_SUPER_MAGIC: ::c_long = 0x00009fa0;
+pub const QNX4_SUPER_MAGIC: ::c_long = 0x0000002f;
+pub const REISERFS_SUPER_MAGIC: ::c_long = 0x52654973;
+pub const SMB_SUPER_MAGIC: ::c_long = 0x0000517b;
+pub const TMPFS_MAGIC: ::c_long = 0x01021994;
+pub const USBDEVICE_SUPER_MAGIC: ::c_long = 0x00009fa2;
+
+pub const VEOF: usize = 16;
+pub const VEOL: usize = 17;
+pub const VEOL2: usize = 6;
+pub const VMIN: usize = 4;
+pub const IEXTEN: ::tcflag_t = 0x00000100;
+pub const TOSTOP: ::tcflag_t = 0x00008000;
+pub const FLUSHO: ::tcflag_t = 0x00002000;
+pub const IUTF8: ::tcflag_t = 0x00004000;
+pub const TCSANOW: ::c_int = 0x540e;
+pub const TCSADRAIN: ::c_int = 0x540f;
+pub const TCSAFLUSH: ::c_int = 0x5410;
+
+pub const CPU_SETSIZE: ::c_int = 0x400;
+
+pub const PTRACE_TRACEME: ::c_uint = 0;
+pub const PTRACE_PEEKTEXT: ::c_uint = 1;
+pub const PTRACE_PEEKDATA: ::c_uint = 2;
+pub const PTRACE_PEEKUSER: ::c_uint = 3;
+pub const PTRACE_POKETEXT: ::c_uint = 4;
+pub const PTRACE_POKEDATA: ::c_uint = 5;
+pub const PTRACE_POKEUSER: ::c_uint = 6;
+pub const PTRACE_CONT: ::c_uint = 7;
+pub const PTRACE_KILL: ::c_uint = 8;
+pub const PTRACE_SINGLESTEP: ::c_uint = 9;
+pub const PTRACE_ATTACH: ::c_uint = 16;
+pub const PTRACE_DETACH: ::c_uint = 17;
+pub const PTRACE_SYSCALL: ::c_uint = 24;
+pub const PTRACE_SETOPTIONS: ::c_uint = 0x4200;
+pub const PTRACE_GETEVENTMSG: ::c_uint = 0x4201;
+pub const PTRACE_GETSIGINFO: ::c_uint = 0x4202;
+pub const PTRACE_SETSIGINFO: ::c_uint = 0x4203;
+pub const PTRACE_GETFPREGS: ::c_uint = 14;
+pub const PTRACE_SETFPREGS: ::c_uint = 15;
+pub const PTRACE_GETFPXREGS: ::c_uint = 18;
+pub const PTRACE_SETFPXREGS: ::c_uint = 19;
+pub const PTRACE_GETREGS: ::c_uint = 12;
+pub const PTRACE_SETREGS: ::c_uint = 13;
+
+pub const EFD_NONBLOCK: ::c_int = 0x80;
+
+pub const F_GETLK: ::c_int = 14;
+pub const F_GETOWN: ::c_int = 23;
+pub const F_SETOWN: ::c_int = 24;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+
+pub const SFD_NONBLOCK: ::c_int = 0x80;
+
+pub const TCGETS: ::c_ulong = 0x540d;
+pub const TCSETS: ::c_ulong = 0x540e;
+pub const TCSETSW: ::c_ulong = 0x540f;
+pub const TCSETSF: ::c_ulong = 0x5410;
+pub const TCGETA: ::c_ulong = 0x5401;
+pub const TCSETA: ::c_ulong = 0x5402;
+pub const TCSETAW: ::c_ulong = 0x5403;
+pub const TCSETAF: ::c_ulong = 0x5404;
+pub const TCSBRK: ::c_ulong = 0x5405;
+pub const TCXONC: ::c_ulong = 0x5406;
+pub const TCFLSH: ::c_ulong = 0x5407;
+pub const TIOCGSOFTCAR: ::c_ulong = 0x5481;
+pub const TIOCSSOFTCAR: ::c_ulong = 0x5482;
+pub const TIOCINQ: ::c_ulong = 0x467f;
+pub const TIOCLINUX: ::c_ulong = 0x5483;
+pub const TIOCGSERIAL: ::c_ulong = 0x5484;
+pub const TIOCEXCL: ::c_ulong = 0x740d;
+pub const TIOCNXCL: ::c_ulong = 0x740e;
+pub const TIOCSCTTY: ::c_ulong = 0x5480;
+pub const TIOCGPGRP: ::c_ulong = 0x40047477;
+pub const TIOCSPGRP: ::c_ulong = 0x80047476;
+pub const TIOCOUTQ: ::c_ulong = 0x7472;
+pub const TIOCSTI: ::c_ulong = 0x5472;
+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;
+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;
+pub const TIOCMGET: ::c_ulong = 0x741d;
+pub const TIOCMBIS: ::c_ulong = 0x741b;
+pub const TIOCMBIC: ::c_ulong = 0x741c;
+pub const TIOCMSET: ::c_ulong = 0x741a;
+pub const FIONREAD: ::c_ulong = 0x467f;
+pub const TIOCCONS: ::c_ulong = 0x80047478;
+
+pub const RTLD_DEEPBIND: ::c_int = 0x10;
+pub const RTLD_GLOBAL: ::c_int = 0x4;
+pub const RTLD_NOLOAD: ::c_int = 0x8;
+
+pub const LINUX_REBOOT_MAGIC1: ::c_int = 0xfee1dead;
+pub const LINUX_REBOOT_MAGIC2: ::c_int = 672274793;
+pub const LINUX_REBOOT_MAGIC2A: ::c_int = 85072278;
+pub const LINUX_REBOOT_MAGIC2B: ::c_int = 369367448;
+pub const LINUX_REBOOT_MAGIC2C: ::c_int = 537993216;
+
+pub const LINUX_REBOOT_CMD_RESTART: ::c_int = 0x01234567;
+pub const LINUX_REBOOT_CMD_HALT: ::c_int = 0xCDEF0123;
+pub const LINUX_REBOOT_CMD_CAD_ON: ::c_int = 0x89ABCDEF;
+pub const LINUX_REBOOT_CMD_CAD_OFF: ::c_int = 0x00000000;
+pub const LINUX_REBOOT_CMD_POWER_OFF: ::c_int = 0x4321FEDC;
+pub const LINUX_REBOOT_CMD_RESTART2: ::c_int = 0xA1B2C3D4;
+pub const LINUX_REBOOT_CMD_SW_SUSPEND: ::c_int = 0xD000FCE2;
+pub const LINUX_REBOOT_CMD_KEXEC: ::c_int = 0x45584543;
+
+pub const MCL_CURRENT: ::c_int = 0x0001;
+pub const MCL_FUTURE: ::c_int = 0x0002;
+
+pub const SIGSTKSZ: ::size_t = 8192;
+pub const CBAUD: ::tcflag_t = 0o0010017;
+pub const TAB1: ::tcflag_t = 0x00000800;
+pub const TAB2: ::tcflag_t = 0x00001000;
+pub const TAB3: ::tcflag_t = 0x00001800;
+pub const CR1: ::tcflag_t = 0x00000200;
+pub const CR2: ::tcflag_t = 0x00000400;
+pub const CR3: ::tcflag_t = 0x00000600;
+pub const FF1: ::tcflag_t = 0x00008000;
+pub const BS1: ::tcflag_t = 0x00002000;
+pub const VT1: ::tcflag_t = 0x00004000;
+pub const VWERASE: usize = 14;
+pub const VREPRINT: usize = 12;
+pub const VSUSP: usize = 10;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VDISCARD: usize = 13;
+pub const VTIME: usize = 5;
+pub const IXON: ::tcflag_t = 0x00000400;
+pub const IXOFF: ::tcflag_t = 0x00001000;
+pub const ONLCR: ::tcflag_t = 0x4;
+pub const CSIZE: ::tcflag_t = 0x00000030;
+pub const CS6: ::tcflag_t = 0x00000010;
+pub const CS7: ::tcflag_t = 0x00000020;
+pub const CS8: ::tcflag_t = 0x00000030;
+pub const CSTOPB: ::tcflag_t = 0x00000040;
+pub const CREAD: ::tcflag_t = 0x00000080;
+pub const PARENB: ::tcflag_t = 0x00000100;
+pub const PARODD: ::tcflag_t = 0x00000200;
+pub const HUPCL: ::tcflag_t = 0x00000400;
+pub const CLOCAL: ::tcflag_t = 0x00000800;
+pub const ECHOKE: ::tcflag_t = 0x00000800;
+pub const ECHOE: ::tcflag_t = 0x00000010;
+pub const ECHOK: ::tcflag_t = 0x00000020;
+pub const ECHONL: ::tcflag_t = 0x00000040;
+pub const ECHOPRT: ::tcflag_t = 0x00000400;
+pub const ECHOCTL: ::tcflag_t = 0x00000200;
+pub const ISIG: ::tcflag_t = 0x00000001;
+pub const ICANON: ::tcflag_t = 0x00000002;
+pub const PENDIN: ::tcflag_t = 0x00004000;
+pub const NOFLSH: ::tcflag_t = 0x00000080;
+
+pub const B0: ::speed_t = 0o000000;
+pub const B50: ::speed_t = 0o000001;
+pub const B75: ::speed_t = 0o000002;
+pub const B110: ::speed_t = 0o000003;
+pub const B134: ::speed_t = 0o000004;
+pub const B150: ::speed_t = 0o000005;
+pub const B200: ::speed_t = 0o000006;
+pub const B300: ::speed_t = 0o000007;
+pub const B600: ::speed_t = 0o000010;
+pub const B1200: ::speed_t = 0o000011;
+pub const B1800: ::speed_t = 0o000012;
+pub const B2400: ::speed_t = 0o000013;
+pub const B4800: ::speed_t = 0o000014;
+pub const B9600: ::speed_t = 0o000015;
+pub const B19200: ::speed_t = 0o000016;
+pub const B38400: ::speed_t = 0o000017;
+pub const EXTA: ::speed_t = B19200;
+pub const EXTB: ::speed_t = B38400;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+
+cfg_if! {
+    if #[cfg(target_arch = "mips")] {
+        mod mips32;
+        pub use self::mips32::*;
+    } else if #[cfg(target_arch = "mips64")] {
+        mod mips64;
+        pub use self::mips64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/unix/uclibc/mod.rs b/library/libc/src/unix/uclibc/mod.rs
new file mode 100644
index 00000000..9b9a0bf5
--- /dev/null
+++ b/library/libc/src/unix/uclibc/mod.rs
@@ -0,0 +1,2365 @@
+pub type sa_family_t = u16;
+pub type pthread_key_t = ::c_uint;
+pub type speed_t = ::c_uint;
+pub type tcflag_t = ::c_uint;
+pub type loff_t = ::c_longlong;
+pub type clockid_t = ::c_int;
+pub type key_t = ::c_int;
+pub type id_t = ::c_uint;
+pub type useconds_t = u32;
+pub type dev_t = u64;
+pub type socklen_t = u32;
+pub type mode_t = u32;
+pub type ino64_t = u64;
+pub type off64_t = i64;
+pub type blkcnt64_t = i64;
+pub type rlim64_t = u64;
+pub type shmatt_t = ::c_ulong;
+pub type mqd_t = ::c_int;
+pub type msgqnum_t = ::c_ulong;
+pub type msglen_t = ::c_ulong;
+pub type nfds_t = ::c_ulong;
+pub type nl_item = ::c_int;
+pub type idtype_t = ::c_uint;
+pub type Elf32_Half = u16;
+pub type Elf32_Word = u32;
+pub type Elf32_Off = u32;
+pub type Elf32_Addr = u32;
+pub type Elf64_Half = u16;
+pub type Elf64_Word = u32;
+pub type Elf64_Off = u64;
+pub type Elf64_Addr = u64;
+pub type Elf64_Xword = u64;
+pub type Elf64_Sxword = i64;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum fpos64_t {} // FIXME: fill this out with a struct
+impl ::Copy for fpos64_t {}
+impl ::Clone for fpos64_t {
+    fn clone(&self) -> fpos64_t {
+        *self
+    }
+}
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+
+s! {
+    pub struct in_addr {
+        pub s_addr: ::in_addr_t,
+    }
+
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    pub struct sockaddr {
+        pub sa_family: sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in {
+        pub sin_family: sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [u8; 8],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_family: sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct addrinfo {
+        pub ai_flags: ::c_int,
+        pub ai_family: ::c_int,
+        pub ai_socktype: ::c_int,
+        pub ai_protocol: ::c_int,
+        pub ai_addrlen: socklen_t,
+
+        pub ai_addr: *mut ::sockaddr,
+
+        pub ai_canonname: *mut c_char,
+
+        pub ai_next: *mut addrinfo,
+    }
+
+    pub struct sockaddr_ll {
+        pub sll_family: ::c_ushort,
+        pub sll_protocol: ::c_ushort,
+        pub sll_ifindex: ::c_int,
+        pub sll_hatype: ::c_ushort,
+        pub sll_pkttype: ::c_uchar,
+        pub sll_halen: ::c_uchar,
+        pub sll_addr: [::c_uchar; 8]
+    }
+
+    pub struct fd_set {
+        fds_bits: [::c_ulong; FD_SETSIZE / ULONG_SIZE],
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+        pub tm_gmtoff: ::c_long,
+        pub tm_zone: *const ::c_char,
+    }
+
+    pub struct sched_param {
+        pub sched_priority: ::c_int,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut ::c_char,
+        pub thousands_sep: *mut ::c_char,
+        pub grouping: *mut ::c_char,
+        pub int_curr_symbol: *mut ::c_char,
+        pub currency_symbol: *mut ::c_char,
+        pub mon_decimal_point: *mut ::c_char,
+        pub mon_thousands_sep: *mut ::c_char,
+        pub mon_grouping: *mut ::c_char,
+        pub positive_sign: *mut ::c_char,
+        pub negative_sign: *mut ::c_char,
+        pub int_frac_digits: ::c_char,
+        pub frac_digits: ::c_char,
+        pub p_cs_precedes: ::c_char,
+        pub p_sep_by_space: ::c_char,
+        pub n_cs_precedes: ::c_char,
+        pub n_sep_by_space: ::c_char,
+        pub p_sign_posn: ::c_char,
+        pub n_sign_posn: ::c_char,
+        pub int_p_cs_precedes: ::c_char,
+        pub int_p_sep_by_space: ::c_char,
+        pub int_n_cs_precedes: ::c_char,
+        pub int_n_sep_by_space: ::c_char,
+        pub int_p_sign_posn: ::c_char,
+        pub int_n_sign_posn: ::c_char,
+    }
+
+    pub struct rlimit64 {
+        pub rlim_cur: rlim64_t,
+        pub rlim_max: rlim64_t,
+    }
+
+    pub struct glob_t {
+        pub gl_pathc: ::size_t,
+        pub gl_pathv: *mut *mut c_char,
+        pub gl_offs: ::size_t,
+        pub gl_flags: ::c_int,
+
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+    }
+
+    pub struct ifaddrs {
+        pub ifa_next: *mut ifaddrs,
+        pub ifa_name: *mut c_char,
+        pub ifa_flags: ::c_uint,
+        pub ifa_addr: *mut ::sockaddr,
+        pub ifa_netmask: *mut ::sockaddr,
+        pub ifa_ifu: *mut ::sockaddr, // FIXME This should be a union
+        pub ifa_data: *mut ::c_void
+    }
+
+    pub struct pthread_rwlockattr_t {
+        __lockkind: ::c_int,
+        __pshared: ::c_int,
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+
+    pub struct spwd {
+        pub sp_namp: *mut ::c_char,
+        pub sp_pwdp: *mut ::c_char,
+        pub sp_lstchg: ::c_long,
+        pub sp_min: ::c_long,
+        pub sp_max: ::c_long,
+        pub sp_warn: ::c_long,
+        pub sp_inact: ::c_long,
+        pub sp_expire: ::c_long,
+        pub sp_flag: ::c_ulong,
+    }
+
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        #[cfg(target_endian = "little")]
+        pub f_fsid: ::c_ulong,
+        #[cfg(target_pointer_width = "32")]
+        __f_unused: ::c_int,
+        #[cfg(target_endian = "big")]
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+        __f_spare: [::c_int; 6],
+    }
+
+    pub struct dqblk {
+        pub dqb_bhardlimit: u32,
+        pub dqb_bsoftlimit: u32,
+        pub dqb_curblocks: u32,
+        pub dqb_ihardlimit: u32,
+        pub dqb_isoftlimit: u32,
+        pub dqb_curinodes: u32,
+        pub dqb_btime: ::time_t,
+        pub dqb_itime: ::time_t,
+    }
+
+    pub struct signalfd_siginfo {
+        pub ssi_signo: u32,
+        pub ssi_errno: i32,
+        pub ssi_code: i32,
+        pub ssi_pid: u32,
+        pub ssi_uid: u32,
+        pub ssi_fd: i32,
+        pub ssi_tid: u32,
+        pub ssi_band: u32,
+        pub ssi_overrun: u32,
+        pub ssi_trapno: u32,
+        pub ssi_status: i32,
+        pub ssi_int: i32,
+        pub ssi_ptr: u64,
+        pub ssi_utime: u64,
+        pub ssi_stime: u64,
+        pub ssi_addr: u64,
+        pub ssi_addr_lsb: u16,
+        _pad2: u16,
+        pub ssi_syscall: i32,
+        pub ssi_call_addr: u64,
+        pub ssi_arch: u32,
+        _pad: [u8; 28],
+    }
+
+    pub struct fsid_t {
+        __val: [::c_int; 2],
+    }
+
+    pub struct cpu_set_t {
+        #[cfg(target_pointer_width = "32")]
+        bits: [u32; 32],
+        #[cfg(target_pointer_width = "64")]
+        bits: [u64; 16],
+    }
+
+    pub struct if_nameindex {
+        pub if_index: ::c_uint,
+        pub if_name: *mut ::c_char,
+    }
+
+    // System V IPC
+    pub struct msginfo {
+        pub msgpool: ::c_int,
+        pub msgmap: ::c_int,
+        pub msgmax: ::c_int,
+        pub msgmnb: ::c_int,
+        pub msgmni: ::c_int,
+        pub msgssz: ::c_int,
+        pub msgtql: ::c_int,
+        pub msgseg: ::c_ushort,
+    }
+
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    pub struct dl_phdr_info {
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_addr: Elf64_Addr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_addr: Elf32_Addr,
+        pub dlpi_name: *const ::c_char,
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phdr: *const Elf64_Phdr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phdr: *const Elf32_Phdr,
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phnum: Elf64_Half,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phnum: Elf32_Half,
+        // As of uClibc 1.0.36, the following fields are
+        // gated behind a "#if 0" block which always evaluates
+        // to false. So I'm just commenting these out and if uClibc changes
+        // the #if block in the future to include the following fields, these
+        // will probably need including here. tsidea
+        //
+        // pub dlpi_adds: ::c_ulonglong,
+        // pub dlpi_subs: ::c_ulonglong,
+        // pub dlpi_tls_modid: ::size_t,
+        // pub dlpi_tls_data: *mut ::c_void,
+    }
+
+    pub struct ucred {
+        pub pid: ::pid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+    }
+}
+
+s_no_extra_traits! {
+    #[cfg_attr(
+        any(target_arch = "x86", target_arch = "x86_64"),
+        repr(packed)
+    )]
+    #[allow(missing_debug_implementations)]
+    pub struct epoll_event {
+        pub events: u32,
+        pub u64: u64,
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct sockaddr_un {
+        pub sun_family: sa_family_t,
+        pub sun_path: [::c_char; 108]
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct sockaddr_storage {
+        pub ss_family: sa_family_t,
+        __ss_align: ::size_t,
+        #[cfg(target_pointer_width = "32")]
+        __ss_pad2: [u8; 128 - 2 * 4],
+        #[cfg(target_pointer_width = "64")]
+        __ss_pad2: [u8; 128 - 2 * 8],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct utsname {
+        pub sysname: [::c_char; 65],
+        pub nodename: [::c_char; 65],
+        pub release: [::c_char; 65],
+        pub version: [::c_char; 65],
+        pub machine: [::c_char; 65],
+        pub domainname: [::c_char; 65]
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct dirent {
+        pub d_ino: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct dirent64 {
+        pub d_ino: ::ino64_t,
+        pub d_off: ::off64_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 256],
+    }
+
+    pub struct mq_attr {
+        pub mq_flags: ::c_long,
+        pub mq_maxmsg: ::c_long,
+        pub mq_msgsize: ::c_long,
+        pub mq_curmsgs: ::c_long,
+        pad: [::c_long; 4]
+    }
+
+    pub struct sockaddr_nl {
+        pub nl_family: ::sa_family_t,
+        nl_pad: ::c_ushort,
+        pub nl_pid: u32,
+        pub nl_groups: u32
+    }
+
+    pub struct sigevent {
+        pub sigev_value: ::sigval,
+        pub sigev_signo: ::c_int,
+        pub sigev_notify: ::c_int,
+        // Actually a union.  We only expose sigev_notify_thread_id because it's
+        // the most useful member
+        pub sigev_notify_thread_id: ::c_int,
+        #[cfg(target_pointer_width = "64")]
+        __unused1: [::c_int; 11],
+        #[cfg(target_pointer_width = "32")]
+        __unused1: [::c_int; 12]
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl PartialEq for mq_attr {
+            fn eq(&self, other: &mq_attr) -> bool {
+                self.mq_flags == other.mq_flags &&
+                self.mq_maxmsg == other.mq_maxmsg &&
+                self.mq_msgsize == other.mq_msgsize &&
+                self.mq_curmsgs == other.mq_curmsgs
+            }
+        }
+        impl Eq for mq_attr {}
+        impl ::fmt::Debug for mq_attr {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("mq_attr")
+                    .field("mq_flags", &self.mq_flags)
+                    .field("mq_maxmsg", &self.mq_maxmsg)
+                    .field("mq_msgsize", &self.mq_msgsize)
+                    .field("mq_curmsgs", &self.mq_curmsgs)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for mq_attr {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.mq_flags.hash(state);
+                self.mq_maxmsg.hash(state);
+                self.mq_msgsize.hash(state);
+                self.mq_curmsgs.hash(state);
+            }
+        }
+
+        impl PartialEq for sockaddr_nl {
+            fn eq(&self, other: &sockaddr_nl) -> bool {
+                self.nl_family == other.nl_family &&
+                self.nl_pid == other.nl_pid &&
+                self.nl_groups == other.nl_groups
+            }
+        }
+        impl Eq for sockaddr_nl {}
+        impl ::fmt::Debug for sockaddr_nl {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_nl")
+                    .field("nl_family", &self.nl_family)
+                    .field("nl_pid", &self.nl_pid)
+                    .field("nl_groups", &self.nl_groups)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sockaddr_nl {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.nl_family.hash(state);
+                self.nl_pid.hash(state);
+                self.nl_groups.hash(state);
+            }
+        }
+
+        impl PartialEq for sigevent {
+            fn eq(&self, other: &sigevent) -> bool {
+                self.sigev_value == other.sigev_value
+                    && self.sigev_signo == other.sigev_signo
+                    && self.sigev_notify == other.sigev_notify
+                    && self.sigev_notify_thread_id
+                        == other.sigev_notify_thread_id
+            }
+        }
+        impl Eq for sigevent {}
+        impl ::fmt::Debug for sigevent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigevent")
+                    .field("sigev_value", &self.sigev_value)
+                    .field("sigev_signo", &self.sigev_signo)
+                    .field("sigev_notify", &self.sigev_notify)
+                    .field("sigev_notify_thread_id",
+                           &self.sigev_notify_thread_id)
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigevent {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                self.sigev_value.hash(state);
+                self.sigev_signo.hash(state);
+                self.sigev_notify.hash(state);
+                self.sigev_notify_thread_id.hash(state);
+            }
+        }
+    }
+}
+
+// intentionally not public, only used for fd_set
+cfg_if! {
+    if #[cfg(target_pointer_width = "32")] {
+        const ULONG_SIZE: usize = 32;
+    } else if #[cfg(target_pointer_width = "64")] {
+        const ULONG_SIZE: usize = 64;
+    } else {
+        // Unknown target_pointer_width
+    }
+}
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const RAND_MAX: ::c_int = 2147483647;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 2;
+pub const _IOLBF: ::c_int = 1;
+
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+
+// Linux-specific fcntls
+pub const F_SETLEASE: ::c_int = 1024;
+pub const F_GETLEASE: ::c_int = 1025;
+pub const F_NOTIFY: ::c_int = 1026;
+pub const F_DUPFD_CLOEXEC: ::c_int = 1030;
+
+// FIXME(#235): Include file sealing fcntls once we have a way to verify them.
+
+pub const SIGTRAP: ::c_int = 5;
+
+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;
+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;
+
+pub const CLOCK_REALTIME: ::clockid_t = 0;
+pub const CLOCK_MONOTONIC: ::clockid_t = 1;
+pub const CLOCK_PROCESS_CPUTIME_ID: ::clockid_t = 2;
+pub const CLOCK_THREAD_CPUTIME_ID: ::clockid_t = 3;
+// FIXME: Add these constants once uclibc gets them.
+// pub const CLOCK_SGI_CYCLE: ::clockid_t = 10;
+// pub const CLOCK_TAI: ::clockid_t = 11;
+pub const TIMER_ABSTIME: ::c_int = 1;
+
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_LOCKS: ::c_int = 10;
+pub const RLIMIT_SIGPENDING: ::c_int = 11;
+pub const RLIMIT_MSGQUEUE: ::c_int = 12;
+pub const RLIMIT_NICE: ::c_int = 13;
+pub const RLIMIT_RTPRIO: ::c_int = 14;
+
+pub const RUSAGE_SELF: ::c_int = 0;
+
+pub const O_RDONLY: ::c_int = 0;
+pub const O_WRONLY: ::c_int = 1;
+pub const O_RDWR: ::c_int = 2;
+
+pub const SOCK_CLOEXEC: ::c_int = O_CLOEXEC;
+
+pub const S_IFIFO: ::mode_t = 4096;
+pub const S_IFCHR: ::mode_t = 8192;
+pub const S_IFBLK: ::mode_t = 24576;
+pub const S_IFDIR: ::mode_t = 16384;
+pub const S_IFREG: ::mode_t = 32768;
+pub const S_IFLNK: ::mode_t = 40960;
+pub const S_IFSOCK: ::mode_t = 49152;
+pub const S_IFMT: ::mode_t = 61440;
+pub const S_IRWXU: ::mode_t = 448;
+pub const S_IXUSR: ::mode_t = 64;
+pub const S_IWUSR: ::mode_t = 128;
+pub const S_IRUSR: ::mode_t = 256;
+pub const S_IRWXG: ::mode_t = 56;
+pub const S_IXGRP: ::mode_t = 8;
+pub const S_IWGRP: ::mode_t = 16;
+pub const S_IRGRP: ::mode_t = 32;
+pub const S_IRWXO: ::mode_t = 7;
+pub const S_IXOTH: ::mode_t = 1;
+pub const S_IWOTH: ::mode_t = 2;
+pub const S_IROTH: ::mode_t = 4;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+
+pub const PROT_NONE: ::c_int = 0;
+pub const PROT_READ: ::c_int = 1;
+pub const PROT_WRITE: ::c_int = 2;
+pub const PROT_EXEC: ::c_int = 4;
+
+pub const LC_CTYPE: ::c_int = 0;
+pub const LC_NUMERIC: ::c_int = 1;
+pub const LC_MONETARY: ::c_int = 2;
+pub const LC_TIME: ::c_int = 3;
+pub const LC_COLLATE: ::c_int = 4;
+pub const LC_MESSAGES: ::c_int = 5;
+pub const LC_ALL: ::c_int = 6;
+pub const LC_CTYPE_MASK: ::c_int = 1 << LC_CTYPE;
+pub const LC_NUMERIC_MASK: ::c_int = 1 << LC_NUMERIC;
+pub const LC_TIME_MASK: ::c_int = 1 << LC_TIME;
+pub const LC_COLLATE_MASK: ::c_int = 1 << LC_COLLATE;
+pub const LC_MONETARY_MASK: ::c_int = 1 << LC_MONETARY;
+pub const LC_MESSAGES_MASK: ::c_int = 1 << LC_MESSAGES;
+// LC_ALL_MASK defined per platform
+
+pub const MAP_FILE: ::c_int = 0x0000;
+pub const MAP_SHARED: ::c_int = 0x0001;
+pub const MAP_PRIVATE: ::c_int = 0x0002;
+pub const MAP_FIXED: ::c_int = 0x0010;
+
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+// MS_ flags for msync(2)
+pub const MS_ASYNC: ::c_int = 0x0001;
+pub const MS_INVALIDATE: ::c_int = 0x0002;
+pub const MS_SYNC: ::c_int = 0x0004;
+
+// MS_ flags for mount(2)
+pub const MS_RDONLY: ::c_ulong = 0x01;
+pub const MS_NOSUID: ::c_ulong = 0x02;
+pub const MS_NODEV: ::c_ulong = 0x04;
+pub const MS_NOEXEC: ::c_ulong = 0x08;
+pub const MS_SYNCHRONOUS: ::c_ulong = 0x10;
+pub const MS_REMOUNT: ::c_ulong = 0x20;
+pub const MS_MANDLOCK: ::c_ulong = 0x40;
+pub const MS_NOATIME: ::c_ulong = 0x0400;
+pub const MS_NODIRATIME: ::c_ulong = 0x0800;
+pub const MS_BIND: ::c_ulong = 0x1000;
+pub const MS_NOUSER: ::c_ulong = 0x80000000;
+pub const MS_MGC_VAL: ::c_ulong = 0xc0ed0000;
+pub const MS_MGC_MSK: ::c_ulong = 0xffff0000;
+pub const MS_RMT_MASK: ::c_ulong = 0x800051;
+
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+
+pub const SCM_RIGHTS: ::c_int = 0x01;
+pub const SCM_CREDENTIALS: ::c_int = 0x02;
+
+// netinet/in.h
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+// IPPROTO_IP defined in src/unix/mod.rs
+/// Hop-by-hop option header
+pub const IPPROTO_HOPOPTS: ::c_int = 0;
+// IPPROTO_ICMP defined in src/unix/mod.rs
+/// group mgmt protocol
+pub const IPPROTO_IGMP: ::c_int = 2;
+/// for compatibility
+pub const IPPROTO_IPIP: ::c_int = 4;
+// IPPROTO_TCP defined in src/unix/mod.rs
+/// exterior gateway protocol
+pub const IPPROTO_EGP: ::c_int = 8;
+/// pup
+pub const IPPROTO_PUP: ::c_int = 12;
+// IPPROTO_UDP defined in src/unix/mod.rs
+/// xns idp
+pub const IPPROTO_IDP: ::c_int = 22;
+/// tp-4 w/ class negotiation
+pub const IPPROTO_TP: ::c_int = 29;
+/// DCCP
+pub const IPPROTO_DCCP: ::c_int = 33;
+// IPPROTO_IPV6 defined in src/unix/mod.rs
+/// IP6 routing header
+pub const IPPROTO_ROUTING: ::c_int = 43;
+/// IP6 fragmentation header
+pub const IPPROTO_FRAGMENT: ::c_int = 44;
+/// resource reservation
+pub const IPPROTO_RSVP: ::c_int = 46;
+/// General Routing Encap.
+pub const IPPROTO_GRE: ::c_int = 47;
+/// IP6 Encap Sec. Payload
+pub const IPPROTO_ESP: ::c_int = 50;
+/// IP6 Auth Header
+pub const IPPROTO_AH: ::c_int = 51;
+// IPPROTO_ICMPV6 defined in src/unix/mod.rs
+/// IP6 no next header
+pub const IPPROTO_NONE: ::c_int = 59;
+/// IP6 destination option
+pub const IPPROTO_DSTOPTS: ::c_int = 60;
+pub const IPPROTO_MTP: ::c_int = 92;
+pub const IPPROTO_BEETPH: ::c_int = 94;
+/// encapsulation header
+pub const IPPROTO_ENCAP: ::c_int = 98;
+/// Protocol indep. multicast
+pub const IPPROTO_PIM: ::c_int = 103;
+/// IP Payload Comp. Protocol
+pub const IPPROTO_COMP: ::c_int = 108;
+/// SCTP
+pub const IPPROTO_SCTP: ::c_int = 132;
+pub const IPPROTO_MH: ::c_int = 135;
+pub const IPPROTO_UDPLITE: ::c_int = 136;
+pub const IPPROTO_MPLS: ::c_int = 137;
+/// raw IP packet
+pub const IPPROTO_RAW: ::c_int = 255;
+pub const IPPROTO_MAX: ::c_int = 256;
+
+pub const PROT_GROWSDOWN: ::c_int = 0x1000000;
+pub const PROT_GROWSUP: ::c_int = 0x2000000;
+
+pub const MAP_TYPE: ::c_int = 0x000f;
+
+pub const MADV_NORMAL: ::c_int = 0;
+pub const MADV_RANDOM: ::c_int = 1;
+pub const MADV_SEQUENTIAL: ::c_int = 2;
+pub const MADV_WILLNEED: ::c_int = 3;
+pub const MADV_DONTNEED: ::c_int = 4;
+pub const MADV_REMOVE: ::c_int = 9;
+pub const MADV_DONTFORK: ::c_int = 10;
+pub const MADV_DOFORK: ::c_int = 11;
+pub const MADV_MERGEABLE: ::c_int = 12;
+pub const MADV_UNMERGEABLE: ::c_int = 13;
+pub const MADV_HWPOISON: ::c_int = 100;
+
+// https://github.com/kraj/uClibc/blob/master/include/net/if.h#L44
+pub const IFF_UP: ::c_int = 0x1; // Interface is up.
+pub const IFF_BROADCAST: ::c_int = 0x2; // Broadcast address valid.
+pub const IFF_DEBUG: ::c_int = 0x4; // Turn on debugging.
+pub const IFF_LOOPBACK: ::c_int = 0x8; // Is a loopback net.
+pub const IFF_POINTOPOINT: ::c_int = 0x10; // Interface is point-to-point link.
+pub const IFF_NOTRAILERS: ::c_int = 0x20; // Avoid use of trailers.
+pub const IFF_RUNNING: ::c_int = 0x40; // Resources allocated.
+pub const IFF_NOARP: ::c_int = 0x80; // No address resolution protocol.
+pub const IFF_PROMISC: ::c_int = 0x100; // Receive all packets.
+
+// Not supported
+pub const IFF_ALLMULTI: ::c_int = 0x200; // Receive all multicast packets.
+pub const IFF_MASTER: ::c_int = 0x400; // Master of a load balancer.
+pub const IFF_SLAVE: ::c_int = 0x800; // Slave of a load balancer.
+pub const IFF_MULTICAST: ::c_int = 0x1000; // Supports multicast.
+pub const IFF_PORTSEL: ::c_int = 0x2000; // Can set media type.
+pub const IFF_AUTOMEDIA: ::c_int = 0x4000; // Auto media select active.
+
+// Dialup device with changing addresses.
+pub const IFF_DYNAMIC: ::c_int = 0x8000;
+
+pub const SOL_IP: ::c_int = 0;
+pub const SOL_TCP: ::c_int = 6;
+pub const SOL_IPV6: ::c_int = 41;
+pub const SOL_ICMPV6: ::c_int = 58;
+pub const SOL_RAW: ::c_int = 255;
+pub const SOL_DECNET: ::c_int = 261;
+pub const SOL_X25: ::c_int = 262;
+pub const SOL_PACKET: ::c_int = 263;
+pub const SOL_ATM: ::c_int = 264;
+pub const SOL_AAL: ::c_int = 265;
+pub const SOL_IRDA: ::c_int = 266;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_UNIX: ::c_int = 1;
+pub const AF_LOCAL: ::c_int = 1;
+pub const AF_INET: ::c_int = 2;
+pub const AF_AX25: ::c_int = 3;
+pub const AF_IPX: ::c_int = 4;
+pub const AF_APPLETALK: ::c_int = 5;
+pub const AF_NETROM: ::c_int = 6;
+pub const AF_BRIDGE: ::c_int = 7;
+pub const AF_ATMPVC: ::c_int = 8;
+pub const AF_X25: ::c_int = 9;
+pub const AF_INET6: ::c_int = 10;
+pub const AF_ROSE: ::c_int = 11;
+pub const AF_DECnet: ::c_int = 12;
+pub const AF_NETBEUI: ::c_int = 13;
+pub const AF_SECURITY: ::c_int = 14;
+pub const AF_KEY: ::c_int = 15;
+pub const AF_NETLINK: ::c_int = 16;
+pub const AF_ROUTE: ::c_int = AF_NETLINK;
+pub const AF_PACKET: ::c_int = 17;
+pub const AF_ASH: ::c_int = 18;
+pub const AF_ECONET: ::c_int = 19;
+pub const AF_ATMSVC: ::c_int = 20;
+pub const AF_SNA: ::c_int = 22;
+pub const AF_IRDA: ::c_int = 23;
+pub const AF_PPPOX: ::c_int = 24;
+pub const AF_WANPIPE: ::c_int = 25;
+pub const AF_LLC: ::c_int = 26;
+pub const AF_CAN: ::c_int = 29;
+pub const AF_TIPC: ::c_int = 30;
+pub const AF_BLUETOOTH: ::c_int = 31;
+pub const AF_IUCV: ::c_int = 32;
+pub const AF_RXRPC: ::c_int = 33;
+pub const AF_ISDN: ::c_int = 34;
+pub const AF_PHONET: ::c_int = 35;
+pub const AF_IEEE802154: ::c_int = 36;
+pub const AF_CAIF: ::c_int = 37;
+pub const AF_ALG: ::c_int = 38;
+
+pub const PF_UNSPEC: ::c_int = AF_UNSPEC;
+pub const PF_UNIX: ::c_int = AF_UNIX;
+pub const PF_LOCAL: ::c_int = AF_LOCAL;
+pub const PF_INET: ::c_int = AF_INET;
+pub const PF_AX25: ::c_int = AF_AX25;
+pub const PF_IPX: ::c_int = AF_IPX;
+pub const PF_APPLETALK: ::c_int = AF_APPLETALK;
+pub const PF_NETROM: ::c_int = AF_NETROM;
+pub const PF_BRIDGE: ::c_int = AF_BRIDGE;
+pub const PF_ATMPVC: ::c_int = AF_ATMPVC;
+pub const PF_X25: ::c_int = AF_X25;
+pub const PF_INET6: ::c_int = AF_INET6;
+pub const PF_ROSE: ::c_int = AF_ROSE;
+pub const PF_DECnet: ::c_int = AF_DECnet;
+pub const PF_NETBEUI: ::c_int = AF_NETBEUI;
+pub const PF_SECURITY: ::c_int = AF_SECURITY;
+pub const PF_KEY: ::c_int = AF_KEY;
+pub const PF_NETLINK: ::c_int = AF_NETLINK;
+pub const PF_ROUTE: ::c_int = AF_ROUTE;
+pub const PF_PACKET: ::c_int = AF_PACKET;
+pub const PF_ASH: ::c_int = AF_ASH;
+pub const PF_ECONET: ::c_int = AF_ECONET;
+pub const PF_ATMSVC: ::c_int = AF_ATMSVC;
+pub const PF_SNA: ::c_int = AF_SNA;
+pub const PF_IRDA: ::c_int = AF_IRDA;
+pub const PF_PPPOX: ::c_int = AF_PPPOX;
+pub const PF_WANPIPE: ::c_int = AF_WANPIPE;
+pub const PF_LLC: ::c_int = AF_LLC;
+pub const PF_CAN: ::c_int = AF_CAN;
+pub const PF_TIPC: ::c_int = AF_TIPC;
+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;
+pub const PF_IUCV: ::c_int = AF_IUCV;
+pub const PF_RXRPC: ::c_int = AF_RXRPC;
+pub const PF_ISDN: ::c_int = AF_ISDN;
+pub const PF_PHONET: ::c_int = AF_PHONET;
+pub const PF_IEEE802154: ::c_int = AF_IEEE802154;
+pub const PF_CAIF: ::c_int = AF_CAIF;
+pub const PF_ALG: ::c_int = AF_ALG;
+
+pub const SOMAXCONN: ::c_int = 128;
+
+pub const MSG_OOB: ::c_int = 1;
+pub const MSG_PEEK: ::c_int = 2;
+pub const MSG_DONTROUTE: ::c_int = 4;
+pub const MSG_CTRUNC: ::c_int = 8;
+pub const MSG_TRUNC: ::c_int = 0x20;
+pub const MSG_DONTWAIT: ::c_int = 0x40;
+pub const MSG_EOR: ::c_int = 0x80;
+pub const MSG_WAITALL: ::c_int = 0x100;
+pub const MSG_FIN: ::c_int = 0x200;
+pub const MSG_SYN: ::c_int = 0x400;
+pub const MSG_CONFIRM: ::c_int = 0x800;
+pub const MSG_RST: ::c_int = 0x1000;
+pub const MSG_ERRQUEUE: ::c_int = 0x2000;
+pub const MSG_NOSIGNAL: ::c_int = 0x4000;
+pub const MSG_MORE: ::c_int = 0x8000;
+pub const MSG_WAITFORONE: ::c_int = 0x10000;
+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x40000000;
+
+pub const SOCK_RAW: ::c_int = 3;
+pub const SOCK_RDM: ::c_int = 4;
+pub const IP_MULTICAST_TTL: ::c_int = 33;
+pub const IP_MULTICAST_LOOP: ::c_int = 34;
+pub const IP_TTL: ::c_int = 2;
+pub const IP_HDRINCL: ::c_int = 3;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 35;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 36;
+pub const IPV6_ADD_MEMBERSHIP: ::c_int = 20;
+pub const IPV6_DROP_MEMBERSHIP: ::c_int = 21;
+
+pub const IPV6_JOIN_GROUP: ::c_int = 20;
+pub const IPV6_LEAVE_GROUP: ::c_int = 21;
+
+pub const TCP_NODELAY: ::c_int = 1;
+pub const TCP_MAXSEG: ::c_int = 2;
+pub const TCP_CORK: ::c_int = 3;
+pub const TCP_KEEPIDLE: ::c_int = 4;
+pub const TCP_KEEPINTVL: ::c_int = 5;
+pub const TCP_KEEPCNT: ::c_int = 6;
+pub const TCP_SYNCNT: ::c_int = 7;
+pub const TCP_LINGER2: ::c_int = 8;
+pub const TCP_DEFER_ACCEPT: ::c_int = 9;
+pub const TCP_WINDOW_CLAMP: ::c_int = 10;
+pub const TCP_INFO: ::c_int = 11;
+pub const TCP_QUICKACK: ::c_int = 12;
+pub const TCP_CONGESTION: ::c_int = 13;
+
+// Source:
+// https://github.com/kraj/uClibc/blob/ca1c74d67dd115d059a875150e10b8560a9c35a8
+// /libc/sysdeps/linux/common/bits/in.h
+// Same for all architectures
+pub const IPV6_MULTICAST_HOPS: ::c_int = 18;
+pub const IP_MULTICAST_IF: ::c_int = 32;
+pub const IPV6_MULTICAST_IF: ::c_int = 17;
+pub const IPV6_UNICAST_HOPS: ::c_int = 16;
+
+// Source:
+// https://github.com/kraj/uClibc/tree/ca1c74d67dd115d059a875150e10b8560a9c35a8
+// Same for all architectures
+pub const FUTEX_WAIT: ::c_int = 0;
+pub const FUTEX_PRIVATE_FLAG: ::c_int = 128;
+pub const FUTEX_WAKE: ::c_int = 1;
+
+pub const IPV6_MULTICAST_LOOP: ::c_int = 19;
+pub const IPV6_V6ONLY: ::c_int = 26;
+
+pub const SO_DEBUG: ::c_int = 1;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const LOCK_SH: ::c_int = 1;
+pub const LOCK_EX: ::c_int = 2;
+pub const LOCK_NB: ::c_int = 4;
+pub const LOCK_UN: ::c_int = 8;
+
+pub const SS_ONSTACK: ::c_int = 1;
+pub const SS_DISABLE: ::c_int = 2;
+
+pub const PATH_MAX: ::c_int = 4096;
+
+pub const UIO_MAXIOV: ::c_int = 1024;
+
+pub const FD_SETSIZE: usize = 1024;
+
+pub const EPOLLIN: ::c_int = 0x1;
+pub const EPOLLPRI: ::c_int = 0x2;
+pub const EPOLLOUT: ::c_int = 0x4;
+pub const EPOLLRDNORM: ::c_int = 0x40;
+pub const EPOLLRDBAND: ::c_int = 0x80;
+pub const EPOLLWRNORM: ::c_int = 0x100;
+pub const EPOLLWRBAND: ::c_int = 0x200;
+pub const EPOLLMSG: ::c_int = 0x400;
+pub const EPOLLERR: ::c_int = 0x8;
+pub const EPOLLHUP: ::c_int = 0x10;
+pub const EPOLLET: ::c_int = 0x80000000;
+
+pub const EPOLL_CTL_ADD: ::c_int = 1;
+pub const EPOLL_CTL_MOD: ::c_int = 3;
+pub const EPOLL_CTL_DEL: ::c_int = 2;
+
+pub const MNT_DETACH: ::c_int = 0x2;
+pub const MNT_EXPIRE: ::c_int = 0x4;
+
+pub const MNT_FORCE: ::c_int = 0x1;
+
+pub const Q_SYNC: ::c_int = 0x600;
+pub const Q_QUOTAON: ::c_int = 0x100;
+pub const Q_QUOTAOFF: ::c_int = 0x200;
+pub const Q_GETQUOTA: ::c_int = 0x300;
+pub const Q_SETQUOTA: ::c_int = 0x400;
+
+pub const TCIOFF: ::c_int = 2;
+pub const TCION: ::c_int = 3;
+pub const TCOOFF: ::c_int = 0;
+pub const TCOON: ::c_int = 1;
+pub const TCIFLUSH: ::c_int = 0;
+pub const TCOFLUSH: ::c_int = 1;
+pub const TCIOFLUSH: ::c_int = 2;
+pub const NL0: ::tcflag_t = 0x00000000;
+pub const NL1: ::tcflag_t = 0x00000100;
+pub const TAB0: ::tcflag_t = 0x00000000;
+pub const CR0: ::tcflag_t = 0x00000000;
+pub const FF0: ::tcflag_t = 0x00000000;
+pub const BS0: ::tcflag_t = 0x00000000;
+pub const VT0: ::tcflag_t = 0x00000000;
+pub const VERASE: usize = 2;
+pub const VKILL: usize = 3;
+pub const VINTR: usize = 0;
+pub const VQUIT: usize = 1;
+pub const VLNEXT: usize = 15;
+pub const IGNBRK: ::tcflag_t = 0x00000001;
+pub const BRKINT: ::tcflag_t = 0x00000002;
+pub const IGNPAR: ::tcflag_t = 0x00000004;
+pub const PARMRK: ::tcflag_t = 0x00000008;
+pub const INPCK: ::tcflag_t = 0x00000010;
+pub const ISTRIP: ::tcflag_t = 0x00000020;
+pub const INLCR: ::tcflag_t = 0x00000040;
+pub const IGNCR: ::tcflag_t = 0x00000080;
+pub const ICRNL: ::tcflag_t = 0x00000100;
+pub const IXANY: ::tcflag_t = 0x00000800;
+pub const IMAXBEL: ::tcflag_t = 0x00002000;
+pub const OPOST: ::tcflag_t = 0x1;
+pub const CS5: ::tcflag_t = 0x00000000;
+pub const CRTSCTS: ::tcflag_t = 0x80000000;
+pub const ECHO: ::tcflag_t = 0x00000008;
+
+pub const CLONE_VM: ::c_int = 0x100;
+pub const CLONE_FS: ::c_int = 0x200;
+pub const CLONE_FILES: ::c_int = 0x400;
+pub const CLONE_SIGHAND: ::c_int = 0x800;
+pub const CLONE_PTRACE: ::c_int = 0x2000;
+pub const CLONE_VFORK: ::c_int = 0x4000;
+pub const CLONE_PARENT: ::c_int = 0x8000;
+pub const CLONE_THREAD: ::c_int = 0x10000;
+pub const CLONE_NEWNS: ::c_int = 0x20000;
+pub const CLONE_SYSVSEM: ::c_int = 0x40000;
+pub const CLONE_SETTLS: ::c_int = 0x80000;
+pub const CLONE_PARENT_SETTID: ::c_int = 0x100000;
+pub const CLONE_CHILD_CLEARTID: ::c_int = 0x200000;
+pub const CLONE_DETACHED: ::c_int = 0x400000;
+pub const CLONE_UNTRACED: ::c_int = 0x800000;
+pub const CLONE_CHILD_SETTID: ::c_int = 0x01000000;
+pub const CLONE_NEWUTS: ::c_int = 0x04000000;
+pub const CLONE_NEWIPC: ::c_int = 0x08000000;
+pub const CLONE_NEWUSER: ::c_int = 0x10000000;
+pub const CLONE_NEWPID: ::c_int = 0x20000000;
+pub const CLONE_NEWNET: ::c_int = 0x40000000;
+pub const CLONE_IO: ::c_int = 0x80000000;
+
+pub const WNOHANG: ::c_int = 0x00000001;
+pub const WUNTRACED: ::c_int = 0x00000002;
+pub const WSTOPPED: ::c_int = WUNTRACED;
+pub const WEXITED: ::c_int = 0x00000004;
+pub const WCONTINUED: ::c_int = 0x00000008;
+pub const WNOWAIT: ::c_int = 0x01000000;
+
+pub const __WNOTHREAD: ::c_int = 0x20000000;
+pub const __WALL: ::c_int = 0x40000000;
+pub const __WCLONE: ::c_int = 0x80000000;
+
+pub const SPLICE_F_MOVE: ::c_uint = 0x01;
+pub const SPLICE_F_NONBLOCK: ::c_uint = 0x02;
+pub const SPLICE_F_MORE: ::c_uint = 0x04;
+pub const SPLICE_F_GIFT: ::c_uint = 0x08;
+
+pub const RTLD_LOCAL: ::c_int = 0;
+pub const RTLD_LAZY: ::c_int = 1;
+
+pub const POSIX_FADV_NORMAL: ::c_int = 0;
+pub const POSIX_FADV_RANDOM: ::c_int = 1;
+pub const POSIX_FADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_FADV_WILLNEED: ::c_int = 3;
+
+pub const AT_FDCWD: ::c_int = -100;
+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x100;
+pub const AT_REMOVEDIR: ::c_int = 0x200;
+pub const AT_EACCESS: ::c_int = 0x200;
+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x400;
+
+pub const LOG_CRON: ::c_int = 9 << 3;
+pub const LOG_AUTHPRIV: ::c_int = 10 << 3;
+pub const LOG_FTP: ::c_int = 11 << 3;
+pub const LOG_PERROR: ::c_int = 0x20;
+
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLPRI: ::c_short = 0x2;
+pub const POLLOUT: ::c_short = 0x4;
+pub const POLLERR: ::c_short = 0x8;
+pub const POLLHUP: ::c_short = 0x10;
+pub const POLLNVAL: ::c_short = 0x20;
+
+pub const PIPE_BUF: usize = 4096;
+
+pub const SI_LOAD_SHIFT: ::c_uint = 16;
+
+pub const CLD_EXITED: ::c_int = 1;
+pub const CLD_KILLED: ::c_int = 2;
+pub const CLD_DUMPED: ::c_int = 3;
+pub const CLD_TRAPPED: ::c_int = 4;
+pub const CLD_STOPPED: ::c_int = 5;
+pub const CLD_CONTINUED: ::c_int = 6;
+
+pub const SIGEV_SIGNAL: ::c_int = 0;
+pub const SIGEV_NONE: ::c_int = 1;
+pub const SIGEV_THREAD: ::c_int = 2;
+
+pub const P_ALL: idtype_t = 0;
+pub const P_PID: idtype_t = 1;
+pub const P_PGID: idtype_t = 2;
+
+pub const UTIME_OMIT: c_long = 1073741822;
+pub const UTIME_NOW: c_long = 1073741823;
+
+pub const L_tmpnam: ::c_uint = 20;
+pub const _PC_LINK_MAX: ::c_int = 0;
+pub const _PC_MAX_CANON: ::c_int = 1;
+pub const _PC_MAX_INPUT: ::c_int = 2;
+pub const _PC_NAME_MAX: ::c_int = 3;
+pub const _PC_PATH_MAX: ::c_int = 4;
+pub const _PC_PIPE_BUF: ::c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 6;
+pub const _PC_NO_TRUNC: ::c_int = 7;
+pub const _PC_VDISABLE: ::c_int = 8;
+
+pub const _SC_ARG_MAX: ::c_int = 0;
+pub const _SC_CHILD_MAX: ::c_int = 1;
+pub const _SC_CLK_TCK: ::c_int = 2;
+pub const _SC_NGROUPS_MAX: ::c_int = 3;
+pub const _SC_OPEN_MAX: ::c_int = 4;
+pub const _SC_STREAM_MAX: ::c_int = 5;
+pub const _SC_TZNAME_MAX: ::c_int = 6;
+pub const _SC_JOB_CONTROL: ::c_int = 7;
+pub const _SC_SAVED_IDS: ::c_int = 8;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 9;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 10;
+pub const _SC_TIMERS: ::c_int = 11;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 12;
+pub const _SC_PRIORITIZED_IO: ::c_int = 13;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 14;
+pub const _SC_FSYNC: ::c_int = 15;
+pub const _SC_MAPPED_FILES: ::c_int = 16;
+pub const _SC_MEMLOCK: ::c_int = 17;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 18;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 19;
+pub const _SC_MESSAGE_PASSING: ::c_int = 20;
+pub const _SC_SEMAPHORES: ::c_int = 21;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 22;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 23;
+pub const _SC_AIO_MAX: ::c_int = 24;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 25;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 26;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 27;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 28;
+pub const _SC_VERSION: ::c_int = 29;
+pub const _SC_PAGESIZE: ::c_int = 30;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_RTSIG_MAX: ::c_int = 31;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 32;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 33;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 34;
+pub const _SC_TIMER_MAX: ::c_int = 35;
+pub const _SC_BC_BASE_MAX: ::c_int = 36;
+pub const _SC_BC_DIM_MAX: ::c_int = 37;
+pub const _SC_BC_SCALE_MAX: ::c_int = 38;
+pub const _SC_BC_STRING_MAX: ::c_int = 39;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 40;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 42;
+pub const _SC_LINE_MAX: ::c_int = 43;
+pub const _SC_RE_DUP_MAX: ::c_int = 44;
+pub const _SC_2_VERSION: ::c_int = 46;
+pub const _SC_2_C_BIND: ::c_int = 47;
+pub const _SC_2_C_DEV: ::c_int = 48;
+pub const _SC_2_FORT_DEV: ::c_int = 49;
+pub const _SC_2_FORT_RUN: ::c_int = 50;
+pub const _SC_2_SW_DEV: ::c_int = 51;
+pub const _SC_2_LOCALEDEF: ::c_int = 52;
+pub const _SC_IOV_MAX: ::c_int = 60;
+pub const _SC_THREADS: ::c_int = 67;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 68;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 69;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 70;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 71;
+pub const _SC_TTY_NAME_MAX: ::c_int = 72;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 73;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 74;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 75;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 79;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 80;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 81;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 84;
+pub const _SC_ATEXIT_MAX: ::c_int = 87;
+pub const _SC_XOPEN_VERSION: ::c_int = 89;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 90;
+pub const _SC_XOPEN_UNIX: ::c_int = 91;
+pub const _SC_XOPEN_CRYPT: ::c_int = 92;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 93;
+pub const _SC_XOPEN_SHM: ::c_int = 94;
+pub const _SC_2_CHAR_TERM: ::c_int = 95;
+pub const _SC_2_UPE: ::c_int = 97;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 125;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 126;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 128;
+pub const _SC_XOPEN_LEGACY: ::c_int = 129;
+pub const _SC_XOPEN_REALTIME: ::c_int = 130;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 131;
+pub const _SC_HOST_NAME_MAX: ::c_int = 180;
+
+pub const RLIM_SAVED_MAX: ::rlim_t = RLIM_INFINITY;
+pub const RLIM_SAVED_CUR: ::rlim_t = RLIM_INFINITY;
+
+pub const GLOB_ERR: ::c_int = 1 << 0;
+pub const GLOB_MARK: ::c_int = 1 << 1;
+pub const GLOB_NOSORT: ::c_int = 1 << 2;
+pub const GLOB_DOOFFS: ::c_int = 1 << 3;
+pub const GLOB_NOCHECK: ::c_int = 1 << 4;
+pub const GLOB_APPEND: ::c_int = 1 << 5;
+pub const GLOB_NOESCAPE: ::c_int = 1 << 6;
+
+pub const GLOB_NOSPACE: ::c_int = 1;
+pub const GLOB_ABORTED: ::c_int = 2;
+pub const GLOB_NOMATCH: ::c_int = 3;
+
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+
+pub const S_IEXEC: mode_t = 64;
+pub const S_IWRITE: mode_t = 128;
+pub const S_IREAD: mode_t = 256;
+
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 3;
+pub const F_TLOCK: ::c_int = 2;
+pub const F_ULOCK: ::c_int = 0;
+
+pub const ST_RDONLY: ::c_ulong = 1;
+pub const ST_NOSUID: ::c_ulong = 2;
+pub const ST_NODEV: ::c_ulong = 4;
+pub const ST_NOEXEC: ::c_ulong = 8;
+pub const ST_SYNCHRONOUS: ::c_ulong = 16;
+pub const ST_MANDLOCK: ::c_ulong = 64;
+pub const ST_WRITE: ::c_ulong = 128;
+pub const ST_APPEND: ::c_ulong = 256;
+pub const ST_IMMUTABLE: ::c_ulong = 512;
+pub const ST_NOATIME: ::c_ulong = 1024;
+pub const ST_NODIRATIME: ::c_ulong = 2048;
+
+pub const RTLD_NEXT: *mut ::c_void = -1i64 as *mut ::c_void;
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+pub const RTLD_NODELETE: ::c_int = 0x1000;
+pub const RTLD_NOW: ::c_int = 0x2;
+
+pub const TCP_MD5SIG: ::c_int = 14;
+
+align_const! {
+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+        size: [0; __SIZEOF_PTHREAD_MUTEX_T],
+    };
+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+        size: [0; __SIZEOF_PTHREAD_COND_T],
+    };
+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+        size: [0; __SIZEOF_PTHREAD_RWLOCK_T],
+    };
+}
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 1;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+
+pub const SCHED_OTHER: ::c_int = 0;
+pub const SCHED_FIFO: ::c_int = 1;
+pub const SCHED_RR: ::c_int = 2;
+pub const SCHED_BATCH: ::c_int = 3;
+pub const SCHED_IDLE: ::c_int = 5;
+
+// System V IPC
+pub const IPC_PRIVATE: ::key_t = 0;
+
+pub const IPC_CREAT: ::c_int = 0o1000;
+pub const IPC_EXCL: ::c_int = 0o2000;
+pub const IPC_NOWAIT: ::c_int = 0o4000;
+
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+pub const IPC_INFO: ::c_int = 3;
+pub const MSG_STAT: ::c_int = 11;
+pub const MSG_INFO: ::c_int = 12;
+
+pub const MSG_NOERROR: ::c_int = 0o10000;
+pub const MSG_EXCEPT: ::c_int = 0o20000;
+
+pub const SHM_R: ::c_int = 0o400;
+pub const SHM_W: ::c_int = 0o200;
+
+pub const SHM_RDONLY: ::c_int = 0o10000;
+pub const SHM_RND: ::c_int = 0o20000;
+pub const SHM_REMAP: ::c_int = 0o40000;
+
+pub const SHM_LOCK: ::c_int = 11;
+pub const SHM_UNLOCK: ::c_int = 12;
+
+pub const SHM_HUGETLB: ::c_int = 0o4000;
+pub const SHM_NORESERVE: ::c_int = 0o10000;
+
+pub const EPOLLRDHUP: ::c_int = 0x2000;
+pub const EPOLLONESHOT: ::c_int = 0x40000000;
+
+pub const QFMT_VFS_OLD: ::c_int = 1;
+pub const QFMT_VFS_V0: ::c_int = 2;
+
+pub const EFD_SEMAPHORE: ::c_int = 0x1;
+
+pub const LOG_NFACILITIES: ::c_int = 24;
+
+pub const SEM_FAILED: *mut ::sem_t = 0 as *mut sem_t;
+
+pub const RB_AUTOBOOT: ::c_int = 0x01234567u32 as i32;
+pub const RB_HALT_SYSTEM: ::c_int = 0xcdef0123u32 as i32;
+pub const RB_ENABLE_CAD: ::c_int = 0x89abcdefu32 as i32;
+pub const RB_DISABLE_CAD: ::c_int = 0x00000000u32 as i32;
+pub const RB_POWER_OFF: ::c_int = 0x4321fedcu32 as i32;
+
+pub const AI_PASSIVE: ::c_int = 0x0001;
+pub const AI_CANONNAME: ::c_int = 0x0002;
+pub const AI_NUMERICHOST: ::c_int = 0x0004;
+pub const AI_V4MAPPED: ::c_int = 0x0008;
+pub const AI_ALL: ::c_int = 0x0010;
+pub const AI_ADDRCONFIG: ::c_int = 0x0020;
+
+pub const AI_NUMERICSERV: ::c_int = 0x0400;
+
+pub const EAI_BADFLAGS: ::c_int = -1;
+pub const EAI_NONAME: ::c_int = -2;
+pub const EAI_AGAIN: ::c_int = -3;
+pub const EAI_FAIL: ::c_int = -4;
+pub const EAI_NODATA: ::c_int = -5;
+pub const EAI_FAMILY: ::c_int = -6;
+pub const EAI_SOCKTYPE: ::c_int = -7;
+pub const EAI_SERVICE: ::c_int = -8;
+pub const EAI_MEMORY: ::c_int = -10;
+pub const EAI_OVERFLOW: ::c_int = -12;
+
+pub const NI_NUMERICHOST: ::c_int = 1;
+pub const NI_NUMERICSERV: ::c_int = 2;
+pub const NI_NOFQDN: ::c_int = 4;
+pub const NI_NAMEREQD: ::c_int = 8;
+pub const NI_DGRAM: ::c_int = 16;
+
+pub const SYNC_FILE_RANGE_WAIT_BEFORE: ::c_uint = 1;
+pub const SYNC_FILE_RANGE_WRITE: ::c_uint = 2;
+pub const SYNC_FILE_RANGE_WAIT_AFTER: ::c_uint = 4;
+
+pub const EAI_SYSTEM: ::c_int = -11;
+
+pub const MREMAP_MAYMOVE: ::c_int = 1;
+pub const MREMAP_FIXED: ::c_int = 2;
+
+pub const PR_SET_PDEATHSIG: ::c_int = 1;
+pub const PR_GET_PDEATHSIG: ::c_int = 2;
+
+pub const PR_GET_DUMPABLE: ::c_int = 3;
+pub const PR_SET_DUMPABLE: ::c_int = 4;
+
+pub const PR_GET_UNALIGN: ::c_int = 5;
+pub const PR_SET_UNALIGN: ::c_int = 6;
+pub const PR_UNALIGN_NOPRINT: ::c_int = 1;
+pub const PR_UNALIGN_SIGBUS: ::c_int = 2;
+
+pub const PR_GET_KEEPCAPS: ::c_int = 7;
+pub const PR_SET_KEEPCAPS: ::c_int = 8;
+
+pub const PR_GET_FPEMU: ::c_int = 9;
+pub const PR_SET_FPEMU: ::c_int = 10;
+pub const PR_FPEMU_NOPRINT: ::c_int = 1;
+pub const PR_FPEMU_SIGFPE: ::c_int = 2;
+
+pub const PR_GET_FPEXC: ::c_int = 11;
+pub const PR_SET_FPEXC: ::c_int = 12;
+pub const PR_FP_EXC_SW_ENABLE: ::c_int = 0x80;
+pub const PR_FP_EXC_DIV: ::c_int = 0x010000;
+pub const PR_FP_EXC_OVF: ::c_int = 0x020000;
+pub const PR_FP_EXC_UND: ::c_int = 0x040000;
+pub const PR_FP_EXC_RES: ::c_int = 0x080000;
+pub const PR_FP_EXC_INV: ::c_int = 0x100000;
+pub const PR_FP_EXC_DISABLED: ::c_int = 0;
+pub const PR_FP_EXC_NONRECOV: ::c_int = 1;
+pub const PR_FP_EXC_ASYNC: ::c_int = 2;
+pub const PR_FP_EXC_PRECISE: ::c_int = 3;
+
+pub const PR_GET_TIMING: ::c_int = 13;
+pub const PR_SET_TIMING: ::c_int = 14;
+pub const PR_TIMING_STATISTICAL: ::c_int = 0;
+pub const PR_TIMING_TIMESTAMP: ::c_int = 1;
+
+pub const PR_SET_NAME: ::c_int = 15;
+pub const PR_GET_NAME: ::c_int = 16;
+
+pub const PR_GET_ENDIAN: ::c_int = 19;
+pub const PR_SET_ENDIAN: ::c_int = 20;
+pub const PR_ENDIAN_BIG: ::c_int = 0;
+pub const PR_ENDIAN_LITTLE: ::c_int = 1;
+pub const PR_ENDIAN_PPC_LITTLE: ::c_int = 2;
+
+pub const PR_GET_SECCOMP: ::c_int = 21;
+pub const PR_SET_SECCOMP: ::c_int = 22;
+
+pub const PR_CAPBSET_READ: ::c_int = 23;
+pub const PR_CAPBSET_DROP: ::c_int = 24;
+
+pub const PR_GET_TSC: ::c_int = 25;
+pub const PR_SET_TSC: ::c_int = 26;
+pub const PR_TSC_ENABLE: ::c_int = 1;
+pub const PR_TSC_SIGSEGV: ::c_int = 2;
+
+pub const PR_GET_SECUREBITS: ::c_int = 27;
+pub const PR_SET_SECUREBITS: ::c_int = 28;
+
+pub const PR_SET_TIMERSLACK: ::c_int = 29;
+pub const PR_GET_TIMERSLACK: ::c_int = 30;
+
+pub const PR_TASK_PERF_EVENTS_DISABLE: ::c_int = 31;
+pub const PR_TASK_PERF_EVENTS_ENABLE: ::c_int = 32;
+
+pub const PR_MCE_KILL: ::c_int = 33;
+pub const PR_MCE_KILL_CLEAR: ::c_int = 0;
+pub const PR_MCE_KILL_SET: ::c_int = 1;
+
+pub const PR_MCE_KILL_LATE: ::c_int = 0;
+pub const PR_MCE_KILL_EARLY: ::c_int = 1;
+pub const PR_MCE_KILL_DEFAULT: ::c_int = 2;
+
+pub const PR_MCE_KILL_GET: ::c_int = 34;
+
+pub const PR_SET_MM: ::c_int = 35;
+pub const PR_SET_MM_START_CODE: ::c_int = 1;
+pub const PR_SET_MM_END_CODE: ::c_int = 2;
+pub const PR_SET_MM_START_DATA: ::c_int = 3;
+pub const PR_SET_MM_END_DATA: ::c_int = 4;
+pub const PR_SET_MM_START_STACK: ::c_int = 5;
+pub const PR_SET_MM_START_BRK: ::c_int = 6;
+pub const PR_SET_MM_BRK: ::c_int = 7;
+pub const PR_SET_MM_ARG_START: ::c_int = 8;
+pub const PR_SET_MM_ARG_END: ::c_int = 9;
+pub const PR_SET_MM_ENV_START: ::c_int = 10;
+pub const PR_SET_MM_ENV_END: ::c_int = 11;
+pub const PR_SET_MM_AUXV: ::c_int = 12;
+pub const PR_SET_MM_EXE_FILE: ::c_int = 13;
+pub const PR_SET_MM_MAP: ::c_int = 14;
+pub const PR_SET_MM_MAP_SIZE: ::c_int = 15;
+
+pub const PR_SET_PTRACER: ::c_int = 0x59616d61;
+
+pub const PR_SET_CHILD_SUBREAPER: ::c_int = 36;
+pub const PR_GET_CHILD_SUBREAPER: ::c_int = 37;
+
+pub const PR_SET_NO_NEW_PRIVS: ::c_int = 38;
+pub const PR_GET_NO_NEW_PRIVS: ::c_int = 39;
+
+pub const PR_GET_TID_ADDRESS: ::c_int = 40;
+
+pub const PR_SET_THP_DISABLE: ::c_int = 41;
+pub const PR_GET_THP_DISABLE: ::c_int = 42;
+
+pub const GRND_NONBLOCK: ::c_uint = 0x0001;
+pub const GRND_RANDOM: ::c_uint = 0x0002;
+
+pub const ABDAY_1: ::nl_item = 0x300;
+pub const ABDAY_2: ::nl_item = 0x301;
+pub const ABDAY_3: ::nl_item = 0x302;
+pub const ABDAY_4: ::nl_item = 0x303;
+pub const ABDAY_5: ::nl_item = 0x304;
+pub const ABDAY_6: ::nl_item = 0x305;
+pub const ABDAY_7: ::nl_item = 0x306;
+
+pub const DAY_1: ::nl_item = 0x307;
+pub const DAY_2: ::nl_item = 0x308;
+pub const DAY_3: ::nl_item = 0x309;
+pub const DAY_4: ::nl_item = 0x30A;
+pub const DAY_5: ::nl_item = 0x30B;
+pub const DAY_6: ::nl_item = 0x30C;
+pub const DAY_7: ::nl_item = 0x30D;
+
+pub const ABMON_1: ::nl_item = 0x30E;
+pub const ABMON_2: ::nl_item = 0x30F;
+pub const ABMON_3: ::nl_item = 0x310;
+pub const ABMON_4: ::nl_item = 0x311;
+pub const ABMON_5: ::nl_item = 0x312;
+pub const ABMON_6: ::nl_item = 0x313;
+pub const ABMON_7: ::nl_item = 0x314;
+pub const ABMON_8: ::nl_item = 0x315;
+pub const ABMON_9: ::nl_item = 0x316;
+pub const ABMON_10: ::nl_item = 0x317;
+pub const ABMON_11: ::nl_item = 0x318;
+pub const ABMON_12: ::nl_item = 0x319;
+
+pub const MON_1: ::nl_item = 0x31A;
+pub const MON_2: ::nl_item = 0x31B;
+pub const MON_3: ::nl_item = 0x31C;
+pub const MON_4: ::nl_item = 0x31D;
+pub const MON_5: ::nl_item = 0x31E;
+pub const MON_6: ::nl_item = 0x31F;
+pub const MON_7: ::nl_item = 0x320;
+pub const MON_8: ::nl_item = 0x321;
+pub const MON_9: ::nl_item = 0x322;
+pub const MON_10: ::nl_item = 0x323;
+pub const MON_11: ::nl_item = 0x324;
+pub const MON_12: ::nl_item = 0x325;
+
+pub const AM_STR: ::nl_item = 0x326;
+pub const PM_STR: ::nl_item = 0x327;
+
+pub const D_T_FMT: ::nl_item = 0x328;
+pub const D_FMT: ::nl_item = 0x329;
+pub const T_FMT: ::nl_item = 0x32A;
+pub const T_FMT_AMPM: ::nl_item = 0x32B;
+
+pub const ERA: ::nl_item = 0x32C;
+pub const ERA_D_FMT: ::nl_item = 0x32E;
+pub const ALT_DIGITS: ::nl_item = 0x32F;
+pub const ERA_D_T_FMT: ::nl_item = 0x330;
+pub const ERA_T_FMT: ::nl_item = 0x331;
+
+pub const CODESET: ::nl_item = 10;
+
+pub const CRNCYSTR: ::nl_item = 0x215;
+
+pub const RADIXCHAR: ::nl_item = 0x100;
+pub const THOUSEP: ::nl_item = 0x101;
+
+pub const NOEXPR: ::nl_item = 0x501;
+pub const YESSTR: ::nl_item = 0x502;
+pub const NOSTR: ::nl_item = 0x503;
+
+pub const FILENAME_MAX: ::c_uint = 4095;
+
+pub const PRIO_PROCESS: ::c_int = 0;
+pub const PRIO_PGRP: ::c_int = 1;
+pub const PRIO_USER: ::c_int = 2;
+
+f! {
+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] &= !(1 << (fd % size));
+        return
+    }
+
+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0
+    }
+
+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {
+        let fd = fd as usize;
+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        (*set).fds_bits[fd / size] |= 1 << (fd % size);
+        return
+    }
+
+    pub fn FD_ZERO(set: *mut fd_set) -> () {
+        for slot in (*set).fds_bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+
+    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {
+        for slot in cpuset.bits.iter_mut() {
+            *slot = 0;
+        }
+    }
+
+    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits
+            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] |= 1 << offset;
+        ()
+    }
+
+    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits
+            = 8 * ::mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] &= !(1 << offset);
+        ()
+    }
+
+    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {
+        let size_in_bits = 8 * ::mem::size_of_val(&cpuset.bits[0]);
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        0 != (cpuset.bits[idx] & (1 << offset))
+    }
+
+    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {
+        set1.bits == set2.bits
+    }
+}
+
+safe_f! {
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        (status & 0xff) == 0x7f
+    }
+
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WIFCONTINUED(status: ::c_int) -> bool {
+        status == 0xffff
+    }
+
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        ((status & 0x7f) + 1) as i8 >= 2
+    }
+
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        status & 0x7f
+    }
+
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & 0x7f) == 0
+    }
+
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xff
+    }
+
+    pub {const} fn WCOREDUMP(status: ::c_int) -> bool {
+        (status & 0x80) != 0
+    }
+
+    pub {const} fn QCMD(cmd: ::c_int, type_: ::c_int) -> ::c_int {
+        (cmd << 8) | (type_ & 0x00ff)
+    }
+}
+
+extern "C" {
+    #[cfg_attr(target_os = "linux", link_name = "__xpg_strerror_r")]
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;
+    pub fn sem_init(
+        sem: *mut sem_t,
+        pshared: ::c_int,
+        value: ::c_uint,
+    ) -> ::c_int;
+
+    pub fn abs(i: ::c_int) -> ::c_int;
+    pub fn atof(s: *const ::c_char) -> ::c_double;
+    pub fn labs(i: ::c_long) -> ::c_long;
+    pub fn rand() -> ::c_int;
+    pub fn srand(seed: ::c_uint);
+
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;
+    pub fn mincore(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        vec: *mut ::c_uchar,
+    ) -> ::c_int;
+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
+    pub fn clock_nanosleep(
+        clk_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn clock_settime(
+        clk_id: ::clockid_t,
+        tp: *const ::timespec,
+    ) -> ::c_int;
+    pub fn prctl(option: ::c_int, ...) -> ::c_int;
+    pub fn pthread_getattr_np(
+        native: ::pthread_t,
+        attr: *mut ::pthread_attr_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const ::pthread_attr_t,
+        guardsize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstack(
+        attr: *const ::pthread_attr_t,
+        stackaddr: *mut *mut ::c_void,
+        stacksize: *mut ::size_t,
+    ) -> ::c_int;
+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;
+    pub fn setgroups(ngroups: ::size_t, ptr: *const ::gid_t) -> ::c_int;
+    pub fn initgroups(user: *const ::c_char, group: ::gid_t) -> ::c_int;
+    pub fn sched_setscheduler(
+        pid: ::pid_t,
+        policy: ::c_int,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;
+    pub fn sched_get_priority_max(policy: ::c_int) -> ::c_int;
+    pub fn sched_get_priority_min(policy: ::c_int) -> ::c_int;
+    pub fn epoll_create(size: ::c_int) -> ::c_int;
+    pub fn epoll_create1(flags: ::c_int) -> ::c_int;
+    pub fn epoll_ctl(
+        epfd: ::c_int,
+        op: ::c_int,
+        fd: ::c_int,
+        event: *mut ::epoll_event,
+    ) -> ::c_int;
+    pub fn epoll_wait(
+        epfd: ::c_int,
+        events: *mut ::epoll_event,
+        maxevents: ::c_int,
+        timeout: ::c_int,
+    ) -> ::c_int;
+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn mount(
+        src: *const ::c_char,
+        target: *const ::c_char,
+        fstype: *const ::c_char,
+        flags: ::c_ulong,
+        data: *const ::c_void,
+    ) -> ::c_int;
+    pub fn umount(target: *const ::c_char) -> ::c_int;
+    pub fn umount2(target: *const ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn clone(
+        cb: extern "C" fn(*mut ::c_void) -> ::c_int,
+        child_stack: *mut ::c_void,
+        flags: ::c_int,
+        arg: *mut ::c_void,
+        ...
+    ) -> ::c_int;
+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;
+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;
+    pub fn memrchr(
+        cx: *const ::c_void,
+        c: ::c_int,
+        n: ::size_t,
+    ) -> *mut ::c_void;
+    pub fn syscall(num: ::c_long, ...) -> ::c_long;
+    pub fn sendfile(
+        out_fd: ::c_int,
+        in_fd: ::c_int,
+        offset: *mut off_t,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    pub fn splice(
+        fd_in: ::c_int,
+        off_in: *mut ::loff_t,
+        fd_out: ::c_int,
+        off_out: *mut ::loff_t,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn tee(
+        fd_in: ::c_int,
+        fd_out: ::c_int,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn vmsplice(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        nr_segs: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+
+    pub fn posix_fadvise(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+        advise: ::c_int,
+    ) -> ::c_int;
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn utimensat(
+        dirfd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn duplocale(base: ::locale_t) -> ::locale_t;
+    pub fn freelocale(loc: ::locale_t);
+    pub fn newlocale(
+        mask: ::c_int,
+        locale: *const ::c_char,
+        base: ::locale_t,
+    ) -> ::locale_t;
+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;
+    pub fn creat64(path: *const c_char, mode: mode_t) -> ::c_int;
+    pub fn fstat64(fildes: ::c_int, buf: *mut stat64) -> ::c_int;
+    pub fn fstatat64(
+        fildes: ::c_int,
+        path: *const ::c_char,
+        buf: *mut stat64,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn ftruncate64(fd: ::c_int, length: off64_t) -> ::c_int;
+    pub fn getrlimit64(resource: ::c_int, rlim: *mut rlimit64) -> ::c_int;
+    pub fn lseek64(fd: ::c_int, offset: off64_t, whence: ::c_int) -> off64_t;
+    pub fn lstat64(path: *const c_char, buf: *mut stat64) -> ::c_int;
+    pub fn mmap64(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+        flags: ::c_int,
+        fd: ::c_int,
+        offset: off64_t,
+    ) -> *mut ::c_void;
+    pub fn open64(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;
+    pub fn openat64(
+        fd: ::c_int,
+        path: *const c_char,
+        oflag: ::c_int,
+        ...
+    ) -> ::c_int;
+    pub fn pread64(
+        fd: ::c_int,
+        buf: *mut ::c_void,
+        count: ::size_t,
+        offset: off64_t,
+    ) -> ::ssize_t;
+    pub fn pwrite64(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::size_t,
+        offset: off64_t,
+    ) -> ::ssize_t;
+    pub fn readdir64(dirp: *mut ::DIR) -> *mut ::dirent64;
+    pub fn readdir64_r(
+        dirp: *mut ::DIR,
+        entry: *mut ::dirent64,
+        result: *mut *mut ::dirent64,
+    ) -> ::c_int;
+    pub fn setrlimit64(resource: ::c_int, rlim: *const rlimit64) -> ::c_int;
+    pub fn stat64(path: *const c_char, buf: *mut stat64) -> ::c_int;
+    pub fn truncate64(path: *const c_char, length: off64_t) -> ::c_int;
+    pub fn eventfd(init: ::c_uint, flags: ::c_int) -> ::c_int;
+
+    pub fn mknodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: dev_t,
+    ) -> ::c_int;
+    pub fn ppoll(
+        fds: *mut ::pollfd,
+        nfds: nfds_t,
+        timeout: *const ::timespec,
+        sigmask: *const sigset_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getclock(
+        attr: *const pthread_condattr_t,
+        clock_id: *mut clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setclock(
+        attr: *mut pthread_condattr_t,
+        clock_id: ::clockid_t,
+    ) -> ::c_int;
+    pub fn pthread_condattr_setpshared(
+        attr: *mut pthread_condattr_t,
+        pshared: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_condattr_getpshared(
+        attr: *const pthread_condattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn sched_getaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut cpu_set_t,
+    ) -> ::c_int;
+    pub fn sched_setaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        cpuset: *const cpu_set_t,
+    ) -> ::c_int;
+    pub fn unshare(flags: ::c_int) -> ::c_int;
+    pub fn sem_timedwait(
+        sem: *mut sem_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;
+    pub fn accept4(
+        fd: ::c_int,
+        addr: *mut ::sockaddr,
+        len: *mut ::socklen_t,
+        flg: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        lock: *mut pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_setpshared(
+        attr: *mut pthread_mutexattr_t,
+        pshared: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_getpshared(
+        attr: *const pthread_mutexattr_t,
+        pshared: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_getkind_np(
+        attr: *const pthread_rwlockattr_t,
+        val: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_setkind_np(
+        attr: *mut pthread_rwlockattr_t,
+        val: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_getpshared(
+        attr: *const pthread_rwlockattr_t,
+        val: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_rwlockattr_setpshared(
+        attr: *mut pthread_rwlockattr_t,
+        val: ::c_int,
+    ) -> ::c_int;
+    pub fn ptsname_r(
+        fd: ::c_int,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+    pub fn clearenv() -> ::c_int;
+    pub fn waitid(
+        idtype: idtype_t,
+        id: id_t,
+        infop: *mut ::siginfo_t,
+        options: ::c_int,
+    ) -> ::c_int;
+
+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;
+
+    pub fn setpwent();
+    pub fn endpwent();
+    pub fn getpwent() -> *mut passwd;
+    pub fn setspent();
+    pub fn endspent();
+    pub fn getspent() -> *mut spwd;
+    pub fn getspnam(__name: *const ::c_char) -> *mut spwd;
+
+    pub fn shm_open(
+        name: *const c_char,
+        oflag: ::c_int,
+        mode: mode_t,
+    ) -> ::c_int;
+
+    // System V IPC
+    pub fn shmget(key: ::key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;
+    pub fn shmat(
+        shmid: ::c_int,
+        shmaddr: *const ::c_void,
+        shmflg: ::c_int,
+    ) -> *mut ::c_void;
+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;
+    pub fn shmctl(
+        shmid: ::c_int,
+        cmd: ::c_int,
+        buf: *mut ::shmid_ds,
+    ) -> ::c_int;
+    pub fn ftok(pathname: *const ::c_char, proj_id: ::c_int) -> ::key_t;
+    pub fn msgctl(msqid: ::c_int, cmd: ::c_int, buf: *mut msqid_ds)
+        -> ::c_int;
+    pub fn msgget(key: ::key_t, msgflg: ::c_int) -> ::c_int;
+    pub fn msgrcv(
+        msqid: ::c_int,
+        msgp: *mut ::c_void,
+        msgsz: ::size_t,
+        msgtyp: ::c_long,
+        msgflg: ::c_int,
+    ) -> ::ssize_t;
+    pub fn msgsnd(
+        msqid: ::c_int,
+        msgp: *const ::c_void,
+        msgsz: ::size_t,
+        msgflg: ::c_int,
+    ) -> ::c_int;
+
+    pub fn mprotect(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+    ) -> ::c_int;
+    pub fn __errno_location() -> *mut ::c_int;
+
+    pub fn fopen64(
+        filename: *const c_char,
+        mode: *const c_char,
+    ) -> *mut ::FILE;
+    pub fn freopen64(
+        filename: *const c_char,
+        mode: *const c_char,
+        file: *mut ::FILE,
+    ) -> *mut ::FILE;
+    pub fn tmpfile64() -> *mut ::FILE;
+    pub fn fgetpos64(stream: *mut ::FILE, ptr: *mut fpos64_t) -> ::c_int;
+    pub fn fsetpos64(stream: *mut ::FILE, ptr: *const fpos64_t) -> ::c_int;
+    pub fn fseeko64(
+        stream: *mut ::FILE,
+        offset: ::off64_t,
+        whence: ::c_int,
+    ) -> ::c_int;
+    pub fn ftello64(stream: *mut ::FILE) -> ::off64_t;
+    pub fn readahead(
+        fd: ::c_int,
+        offset: ::off64_t,
+        count: ::size_t,
+    ) -> ::ssize_t;
+    pub fn getxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn lgetxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn fgetxattr(
+        filedes: ::c_int,
+        name: *const c_char,
+        value: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn setxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn lsetxattr(
+        path: *const c_char,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn fsetxattr(
+        filedes: ::c_int,
+        name: *const c_char,
+        value: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn listxattr(
+        path: *const c_char,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn llistxattr(
+        path: *const c_char,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn flistxattr(
+        filedes: ::c_int,
+        list: *mut c_char,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn removexattr(path: *const c_char, name: *const c_char) -> ::c_int;
+    pub fn lremovexattr(path: *const c_char, name: *const c_char) -> ::c_int;
+    pub fn fremovexattr(filedes: ::c_int, name: *const c_char) -> ::c_int;
+    pub fn signalfd(
+        fd: ::c_int,
+        mask: *const ::sigset_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn quotactl(
+        cmd: ::c_int,
+        special: *const ::c_char,
+        id: ::c_int,
+        data: *mut ::c_char,
+    ) -> ::c_int;
+    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;
+    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;
+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn mq_receive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mq_send(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+    ) -> ::c_int;
+    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;
+    pub fn mq_setattr(
+        mqd: ::mqd_t,
+        newattr: *const ::mq_attr,
+        oldattr: *mut ::mq_attr,
+    ) -> ::c_int;
+    pub fn epoll_pwait(
+        epfd: ::c_int,
+        events: *mut ::epoll_event,
+        maxevents: ::c_int,
+        timeout: ::c_int,
+        sigmask: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn sigtimedwait(
+        set: *const sigset_t,
+        info: *mut siginfo_t,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> ::c_int;
+    pub fn nl_langinfo_l(item: ::nl_item, locale: ::locale_t)
+        -> *mut ::c_char;
+    pub fn prlimit(
+        pid: ::pid_t,
+        resource: ::c_int,
+        new_limit: *const ::rlimit,
+        old_limit: *mut ::rlimit,
+    ) -> ::c_int;
+    pub fn prlimit64(
+        pid: ::pid_t,
+        resource: ::c_int,
+        new_limit: *const ::rlimit64,
+        old_limit: *mut ::rlimit64,
+    ) -> ::c_int;
+    pub fn reboot(how_to: ::c_int) -> ::c_int;
+    pub fn setfsgid(gid: ::gid_t) -> ::c_int;
+    pub fn setfsuid(uid: ::uid_t) -> ::c_int;
+    pub fn setresgid(rgid: ::gid_t, egid: ::gid_t, sgid: ::gid_t) -> ::c_int;
+    pub fn setresuid(ruid: ::uid_t, euid: ::uid_t, suid: ::uid_t) -> ::c_int;
+
+    // Not available now on Android
+    pub fn mkfifoat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn if_nameindex() -> *mut if_nameindex;
+    pub fn if_freenameindex(ptr: *mut if_nameindex);
+    pub fn sync_file_range(
+        fd: ::c_int,
+        offset: ::off64_t,
+        nbytes: ::off64_t,
+        flags: ::c_uint,
+    ) -> ::c_int;
+    pub fn getifaddrs(ifap: *mut *mut ::ifaddrs) -> ::c_int;
+    pub fn freeifaddrs(ifa: *mut ::ifaddrs);
+
+    pub fn mremap(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        new_len: ::size_t,
+        flags: ::c_int,
+        ...
+    ) -> *mut ::c_void;
+
+    pub fn glob(
+        pattern: *const c_char,
+        flags: ::c_int,
+        errfunc: ::Option<
+            extern "C" fn(epath: *const c_char, errno: ::c_int) -> ::c_int,
+        >,
+        pglob: *mut ::glob_t,
+    ) -> ::c_int;
+    pub fn globfree(pglob: *mut ::glob_t);
+
+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;
+
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+    pub fn madvise(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        advice: ::c_int,
+    ) -> ::c_int;
+
+    pub fn msync(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn recvfrom(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;
+
+    pub fn bind(
+        socket: ::c_int,
+        address: *const ::sockaddr,
+        address_len: ::socklen_t,
+    ) -> ::c_int;
+
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+
+    pub fn sendmsg(
+        fd: ::c_int,
+        msg: *const ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn recvmsg(
+        fd: ::c_int,
+        msg: *mut ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn getgrgid_r(
+        gid: ::gid_t,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;
+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;
+    pub fn getdtablesize() -> ::c_int;
+    pub fn getgrnam_r(
+        name: *const ::c_char,
+        grp: *mut ::group,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn pthread_sigmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;
+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;
+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;
+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;
+    pub fn getpwnam_r(
+        name: *const ::c_char,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn getpwuid_r(
+        uid: ::uid_t,
+        pwd: *mut passwd,
+        buf: *mut ::c_char,
+        buflen: ::size_t,
+        result: *mut *mut passwd,
+    ) -> ::c_int;
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    pub fn pthread_create(
+        native: *mut ::pthread_t,
+        attr: *const ::pthread_attr_t,
+        f: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn dl_iterate_phdr(
+        callback: ::Option<
+            unsafe extern "C" fn(
+                info: *mut ::dl_phdr_info,
+                size: ::size_t,
+                data: *mut ::c_void,
+            ) -> ::c_int,
+        >,
+        data: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+    pub fn getnameinfo(
+        sa: *const ::sockaddr,
+        salen: ::socklen_t,
+        host: *mut ::c_char,
+        hostlen: ::socklen_t,
+        serv: *mut ::c_char,
+        sevlen: ::socklen_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+}
+
+cfg_if! {
+    if #[cfg(any(target_arch = "mips", target_arch = "mips64"))] {
+        mod mips;
+        pub use self::mips::*;
+    } else if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(target_arch = "arm")] {
+        mod arm;
+        pub use self::arm::*;
+    } else {
+        pub use unsupported_target;
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        #[macro_use]
+        mod align;
+    } else {
+        #[macro_use]
+        mod no_align;
+    }
+}
+
+expand_align!();
diff --git a/library/libc/src/unix/uclibc/no_align.rs b/library/libc/src/unix/uclibc/no_align.rs
new file mode 100644
index 00000000..a73dbded
--- /dev/null
+++ b/library/libc/src/unix/uclibc/no_align.rs
@@ -0,0 +1,53 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            pub struct pthread_mutex_t {
+                #[cfg(any(target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc"))]
+                __align: [::c_long; 0],
+                #[cfg(any(libc_align,
+                          target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc"))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            pub struct pthread_rwlock_t {
+                #[cfg(any(target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc"))]
+                __align: [::c_long; 0],
+                #[cfg(not(any(
+                    target_arch = "mips",
+                    target_arch = "arm",
+                    target_arch = "powerpc")))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+
+            pub struct pthread_mutexattr_t {
+                #[cfg(any(target_arch = "x86_64", target_arch = "powerpc64",
+                          target_arch = "mips64", target_arch = "s390x",
+                          target_arch = "sparc64"))]
+                __align: [::c_int; 0],
+                #[cfg(not(any(target_arch = "x86_64", target_arch = "powerpc64",
+                              target_arch = "mips64", target_arch = "s390x",
+                              target_arch = "sparc64")))]
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            pub struct pthread_cond_t {
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            pub struct pthread_condattr_t {
+                __align: [::c_int; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+    }
+}
diff --git a/library/libc/src/unix/uclibc/x86_64/align.rs b/library/libc/src/unix/uclibc/x86_64/align.rs
new file mode 100644
index 00000000..e2d829b5
--- /dev/null
+++ b/library/libc/src/unix/uclibc/x86_64/align.rs
@@ -0,0 +1,77 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            #[cfg_attr(target_pointer_width = "32",
+                       repr(align(4)))]
+            #[cfg_attr(target_pointer_width = "64",
+                       repr(align(8)))]
+            pub struct sem_t { // FIXME
+                #[cfg(target_pointer_width = "32")]
+                __size: [::c_char; 16],
+                #[cfg(target_pointer_width = "64")]
+                __size: [::c_char; 32],
+            }
+
+            #[cfg_attr(any(target_pointer_width = "32",
+                           target_arch = "x86_64",
+                           target_arch = "powerpc64",
+                           target_arch = "mips64",
+                           target_arch = "s390x",
+                           target_arch = "sparc64"),
+                       repr(align(4)))]
+            #[cfg_attr(not(any(target_pointer_width = "32",
+                               target_arch = "x86_64",
+                               target_arch = "powerpc64",
+                               target_arch = "mips64",
+                               target_arch = "s390x",
+                               target_arch = "sparc64")),
+                       repr(align(8)))]
+            pub struct pthread_mutexattr_t { // FIXME
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            #[repr(align(4))]
+            pub struct pthread_condattr_t { // FIXME
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+        }
+
+        s_no_extra_traits! {
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "mips",
+                               target_arch = "arm",
+                               target_arch = "powerpc")),
+                       repr(align(4)))]
+            #[cfg_attr(all(any(target_pointer_width = "64",
+                               not(any(target_arch = "mips",
+                                       target_arch = "arm",
+                                       target_arch = "powerpc")))),
+                       repr(align(8)))]
+            #[allow(missing_debug_implementations)]
+            pub struct pthread_mutex_t { // FIXME
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            #[repr(align(8))]
+            #[allow(missing_debug_implementations)]
+            pub struct pthread_cond_t { // FIXME
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            #[cfg_attr(all(target_pointer_width = "32",
+                           any(target_arch = "mips",
+                               target_arch = "arm",
+                               target_arch = "powerpc")),
+                       repr(align(4)))]
+            #[cfg_attr(any(target_pointer_width = "64",
+                           not(any(target_arch = "mips",
+                                   target_arch = "arm",
+                                   target_arch = "powerpc"))),
+                       repr(align(8)))]
+            #[allow(missing_debug_implementations)]
+            pub struct pthread_rwlock_t { // FIXME
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+        }
+    };
+}
diff --git a/library/libc/src/unix/uclibc/x86_64/l4re.rs b/library/libc/src/unix/uclibc/x86_64/l4re.rs
new file mode 100644
index 00000000..16ec0ef9
--- /dev/null
+++ b/library/libc/src/unix/uclibc/x86_64/l4re.rs
@@ -0,0 +1,48 @@
+/// L4Re specifics
+/// This module contains definitions required by various L4Re libc backends.
+/// Some of them are formally not part of the libc, but are a dependency of the
+/// libc and hence we should provide them here.
+
+pub type l4_umword_t = ::c_ulong; // Unsigned machine word.
+pub type pthread_t = *mut ::c_void;
+
+s! {
+    /// CPU sets.
+    pub struct l4_sched_cpu_set_t {
+        // from the L4Re docs
+        /// Combination of granularity and offset.
+        ///
+        /// The granularity defines how many CPUs each bit in map describes.
+        /// The offset is the numer of the first CPU described by the first
+        /// bit in the bitmap.
+        /// offset must be a multiple of 2^graularity.
+        ///
+        /// | MSB              |                 LSB |
+        /// | ---------------- | ------------------- |
+        /// | 8bit granularity | 24bit offset ..     |
+        gran_offset: l4_umword_t ,
+        /// Bitmap of CPUs.
+        map: l4_umword_t ,
+    }
+}
+
+#[cfg(target_os = "l4re")]
+#[allow(missing_debug_implementations)]
+pub struct pthread_attr_t {
+    pub __detachstate: ::c_int,
+    pub __schedpolicy: ::c_int,
+    pub __schedparam: super::__sched_param,
+    pub __inheritsched: ::c_int,
+    pub __scope: ::c_int,
+    pub __guardsize: ::size_t,
+    pub __stackaddr_set: ::c_int,
+    pub __stackaddr: *mut ::c_void, // better don't use it
+    pub __stacksize: ::size_t,
+    // L4Re specifics
+    pub affinity: l4_sched_cpu_set_t,
+    pub create_flags: ::c_uint,
+}
+
+// L4Re requires a min stack size of 64k; that isn't defined in uClibc, but
+// somewhere in the core libraries. uClibc wants 16k, but that's not enough.
+pub const PTHREAD_STACK_MIN: usize = 65536;
diff --git a/library/libc/src/unix/uclibc/x86_64/mod.rs b/library/libc/src/unix/uclibc/x86_64/mod.rs
new file mode 100644
index 00000000..26eca9e7
--- /dev/null
+++ b/library/libc/src/unix/uclibc/x86_64/mod.rs
@@ -0,0 +1,312 @@
+//! Definitions for uclibc on 64bit systems
+pub type blkcnt_t = i64;
+pub type blksize_t = i64;
+pub type clock_t = i64;
+pub type c_char = u8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type fsblkcnt_t = ::c_ulong;
+pub type fsfilcnt_t = ::c_ulong;
+pub type fsword_t = ::c_long;
+pub type ino_t = ::c_ulong;
+pub type nlink_t = ::c_uint;
+pub type off_t = ::c_long;
+pub type rlim_t = c_ulong;
+pub type rlim64_t = u64;
+// [uClibc docs] Note stat64 has the same shape as stat for x86-64.
+pub type stat64 = stat;
+pub type suseconds_t = ::c_long;
+pub type time_t = ::c_int;
+pub type wchar_t = ::c_int;
+
+s! {
+    pub struct ipc_perm {
+        pub __key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::c_ushort, // read / write
+        __pad1: ::c_ushort,
+        pub __seq: ::c_ushort,
+        __pad2: ::c_ushort,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    #[cfg(not(target_os = "l4re"))]
+    pub struct pthread_attr_t {
+        __detachstate: ::c_int,
+        __schedpolicy: ::c_int,
+        __schedparam: __sched_param,
+        __inheritsched: ::c_int,
+        __scope: ::c_int,
+        __guardsize: ::size_t,
+        __stackaddr_set: ::c_int,
+        __stackaddr: *mut ::c_void, // better don't use it
+        __stacksize: ::size_t,
+    }
+
+    pub struct __sched_param {
+        __sched_priority: ::c_int,
+    }
+
+    pub struct siginfo_t {
+        si_signo: ::c_int, // signal number
+        si_errno: ::c_int, // if not zero: error value of signal, see errno.h
+        si_code: ::c_int,  // signal code
+        pub _pad: [::c_int; 28], // unported union
+        _align: [usize; 0],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc_perm,
+        pub shm_segsz: ::size_t, // segment size in bytes
+        pub shm_atime: ::time_t, // time of last shmat()
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::shmatt_t,
+        __unused1: ::c_ulong,
+        __unused2: ::c_ulong
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: ::ipc_perm,
+        pub msg_stime: ::time_t,
+        pub msg_rtime: ::time_t,
+        pub msg_ctime: ::time_t,
+        __msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        __ignored1: ::c_ulong,
+        __ignored2: ::c_ulong,
+    }
+
+    pub struct sockaddr {
+        pub sa_family: ::sa_family_t,
+        pub sa_data: [::c_char; 14],
+    }
+
+    pub struct sockaddr_in {
+        pub sin_family: ::sa_family_t,
+        pub sin_port: ::in_port_t,
+        pub sin_addr: ::in_addr,
+        pub sin_zero: [u8; 8],
+    }
+
+    pub struct sockaddr_in6 {
+        pub sin6_family: ::sa_family_t,
+        pub sin6_port: ::in_port_t,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr: ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    // ------------------------------------------------------------
+    // definitions below are *unverified* and might **break** the software
+//    pub struct in_addr {
+//        pub s_addr: in_addr_t,
+//    }
+//
+//    pub struct in6_addr {
+//        pub s6_addr: [u8; 16],
+//        #[cfg(not(libc_align))]
+//        __align: [u32; 0],
+//    }
+
+    pub struct stat {
+        pub st_dev: ::c_ulong,
+        pub st_ino: ::ino_t,
+        // According to uclibc/libc/sysdeps/linux/x86_64/bits/stat.h, order of
+        // nlink and mode are swapped on 64 bit systems.
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub st_rdev: ::c_ulong, // dev_t
+        pub st_size: off_t, // file size
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: ::c_ulong,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: ::c_ulong,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: ::c_ulong,
+        st_pad4: [::c_long; 3]
+    }
+
+    pub struct sigaction {
+        pub sa_handler: ::sighandler_t,
+        pub sa_flags: ::c_ulong,
+        pub sa_restorer: *mut ::c_void,
+        pub sa_mask: ::sigset_t,
+    }
+
+    pub struct stack_t { // FIXME
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t
+    }
+
+    pub struct statfs { // FIXME
+        pub f_type: fsword_t,
+        pub f_bsize: fsword_t,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: fsword_t,
+        pub f_frsize: fsword_t,
+        f_spare: [fsword_t; 5],
+    }
+
+    pub struct msghdr { // FIXME
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::size_t,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::size_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct termios { // FIXME
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; ::NCCS],
+    }
+
+    pub struct sigset_t { // FIXME
+        __val: [::c_ulong; 16],
+    }
+
+    pub struct sysinfo { // FIXME
+        pub uptime: ::c_long,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub pad: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub _f: [::c_char; 0],
+    }
+
+    pub struct glob_t { // FIXME
+        pub gl_pathc: ::size_t,
+        pub gl_pathv: *mut *mut c_char,
+        pub gl_offs: ::size_t,
+        pub gl_flags: ::c_int,
+        __unused1: *mut ::c_void,
+        __unused2: *mut ::c_void,
+        __unused3: *mut ::c_void,
+        __unused4: *mut ::c_void,
+        __unused5: *mut ::c_void,
+    }
+
+    pub struct rlimit64 { // FIXME
+        pub rlim_cur: rlim64_t,
+        pub rlim_max: rlim64_t,
+    }
+
+    pub struct cpu_set_t { // FIXME
+        #[cfg(target_pointer_width = "32")]
+        bits: [u32; 32],
+        #[cfg(target_pointer_width = "64")]
+        bits: [u64; 16],
+    }
+
+    pub struct fsid_t { // FIXME
+        __val: [::c_int; 2],
+    }
+}
+
+s_no_extra_traits! {
+    #[allow(missing_debug_implementations)]
+    pub struct dirent {
+        pub d_ino: ::ino64_t,
+        pub d_off: ::off64_t,
+        pub d_reclen: u16,
+        pub d_type: u8,
+        pub d_name: [::c_char; 256],
+    }
+    #[allow(missing_debug_implementations)]
+    pub struct dirent64 {
+        pub d_ino: ::ino64_t,
+        pub d_off: ::off64_t,
+        pub d_reclen: u16,
+        pub d_type: u8,
+        pub d_name: [::c_char; 256],
+    }
+}
+
+// constants
+pub const EADDRINUSE: ::c_int = 98; // Address already in use
+pub const EADDRNOTAVAIL: ::c_int = 99; // Cannot assign requested address
+pub const ECONNABORTED: ::c_int = 103; // Software caused connection abort
+pub const ECONNREFUSED: ::c_int = 111; // Connection refused
+pub const ECONNRESET: ::c_int = 104; // Connection reset by peer
+pub const EDEADLK: ::c_int = 35; // Resource deadlock would occur
+pub const ENOSYS: ::c_int = 38; // Function not implemented
+pub const ENOTCONN: ::c_int = 107; // Transport endpoint is not connected
+pub const ETIMEDOUT: ::c_int = 110; // connection timed out
+pub const O_APPEND: ::c_int = 02000;
+pub const O_ACCMODE: ::c_int = 0003;
+pub const O_CLOEXEC: ::c_int = 0x80000;
+pub const O_CREAT: ::c_int = 0100;
+pub const O_DIRECTORY: ::c_int = 0200000;
+pub const O_EXCL: ::c_int = 0200;
+pub const O_NONBLOCK: ::c_int = 04000;
+pub const O_TRUNC: ::c_int = 01000;
+pub const NCCS: usize = 32;
+pub const SIG_SETMASK: ::c_int = 2; // Set the set of blocked signals
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SOCK_DGRAM: ::c_int = 2; // connectionless, unreliable datagrams
+pub const SOCK_STREAM: ::c_int = 1; // /common/bits/socket_type.h
+pub const SO_ERROR: ::c_int = 4;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const RLIM_INFINITY: u64 = 0xffffffffffffffff;
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+
+cfg_if! {
+    if #[cfg(target_os = "l4re")] {
+        mod l4re;
+        pub use self::l4re::*;
+    } else {
+        mod other;
+        pub use other::*;
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        #[macro_use]
+        mod align;
+    } else {
+        #[macro_use]
+        mod no_align;
+    }
+}
+expand_align!();
diff --git a/library/libc/src/unix/uclibc/x86_64/no_align.rs b/library/libc/src/unix/uclibc/x86_64/no_align.rs
new file mode 100644
index 00000000..ffa4e523
--- /dev/null
+++ b/library/libc/src/unix/uclibc/x86_64/no_align.rs
@@ -0,0 +1,59 @@
+macro_rules! expand_align {
+    () => {
+        s! {
+            pub struct sem_t { // FIXME
+                #[cfg(target_pointer_width = "32")]
+                __size: [::c_char; 16],
+                #[cfg(target_pointer_width = "64")]
+                __size: [::c_char; 32],
+                __align: [::c_long; 0],
+            }
+
+            pub struct pthread_mutex_t { // FIXME
+                #[cfg(any(target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc"))]
+                __align: [::c_long; 0],
+                #[cfg(not(any(target_arch = "mips",
+                              target_arch = "arm",
+                              target_arch = "powerpc")))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],
+            }
+
+            pub struct pthread_mutexattr_t { // FIXME
+                #[cfg(any(target_arch = "x86_64", target_arch = "powerpc64",
+                          target_arch = "mips64", target_arch = "s390x",
+                          target_arch = "sparc64"))]
+                __align: [::c_int; 0],
+                #[cfg(not(any(target_arch = "x86_64", target_arch = "powerpc64",
+                              target_arch = "mips64", target_arch = "s390x",
+                              target_arch = "sparc64")))]
+                __align: [::c_long; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],
+            }
+
+            pub struct pthread_cond_t { // FIXME
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],
+            }
+
+            pub struct pthread_condattr_t { // FIXME
+                __align: [::c_int; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],
+            }
+
+            pub struct pthread_rwlock_t { // FIXME
+                #[cfg(any(target_arch = "mips",
+                          target_arch = "arm",
+                          target_arch = "powerpc"))]
+                __align: [::c_long; 0],
+                #[cfg(not(any(target_arch = "mips",
+                              target_arch = "arm",
+                              target_arch = "powerpc")))]
+                __align: [::c_longlong; 0],
+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],
+            }
+        }
+    }
+}
diff --git a/library/libc/src/unix/uclibc/x86_64/other.rs b/library/libc/src/unix/uclibc/x86_64/other.rs
new file mode 100644
index 00000000..481577cf
--- /dev/null
+++ b/library/libc/src/unix/uclibc/x86_64/other.rs
@@ -0,0 +1,5 @@
+// Thestyle checker discourages the use of #[cfg], so this has to go into a
+// separate module
+pub type pthread_t = ::c_ulong;
+
+pub const PTHREAD_STACK_MIN: usize = 16384;
diff --git a/library/libc/src/vxworks/aarch64.rs b/library/libc/src/vxworks/aarch64.rs
new file mode 100644
index 00000000..4032488b
--- /dev/null
+++ b/library/libc/src/vxworks/aarch64.rs
@@ -0,0 +1,4 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+pub type c_long = i64;
+pub type c_ulong = u64;
diff --git a/library/libc/src/vxworks/arm.rs b/library/libc/src/vxworks/arm.rs
new file mode 100644
index 00000000..55240068
--- /dev/null
+++ b/library/libc/src/vxworks/arm.rs
@@ -0,0 +1,4 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+pub type c_long = i32;
+pub type c_ulong = u32;
diff --git a/library/libc/src/vxworks/mod.rs b/library/libc/src/vxworks/mod.rs
new file mode 100755
index 00000000..668a7fcc
--- /dev/null
+++ b/library/libc/src/vxworks/mod.rs
@@ -0,0 +1,2158 @@
+//! Interface to VxWorks C library
+
+use core::mem::size_of;
+use core::ptr::null_mut;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum DIR {}
+impl ::Copy for DIR {}
+impl ::Clone for DIR {
+    fn clone(&self) -> DIR {
+        *self
+    }
+}
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_float = f32;
+pub type c_double = f64;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+
+pub type uintptr_t = usize;
+pub type intptr_t = isize;
+pub type ptrdiff_t = isize;
+pub type size_t = ::uintptr_t;
+pub type ssize_t = ::intptr_t;
+
+pub type pid_t = ::c_int;
+pub type in_addr_t = u32;
+pub type sighandler_t = ::size_t;
+pub type cpuset_t = u32;
+
+pub type blkcnt_t = ::c_long;
+pub type blksize_t = ::c_long;
+pub type ino_t = ::c_ulong;
+
+pub type rlim_t = ::c_ulong;
+pub type suseconds_t = ::c_long;
+pub type time_t = ::c_long;
+
+pub type errno_t = ::c_int;
+
+pub type useconds_t = ::c_ulong;
+
+pub type socklen_t = ::c_uint;
+
+pub type pthread_t = ::c_ulong;
+
+pub type clockid_t = ::c_int;
+
+//defined for the structs
+pub type dev_t = ::c_ulong;
+pub type mode_t = ::c_int;
+pub type nlink_t = ::c_ulong;
+pub type uid_t = ::c_ushort;
+pub type gid_t = ::c_ushort;
+pub type sigset_t = ::c_ulonglong;
+pub type key_t = ::c_long;
+
+pub type nfds_t = ::c_uint;
+pub type stat64 = ::stat;
+
+pub type pthread_key_t = ::c_ulong;
+
+// From b_off_t.h
+pub type off_t = ::c_longlong;
+pub type off64_t = off_t;
+
+// From b_BOOL.h
+pub type BOOL = ::c_int;
+
+// From vxWind.h ..
+pub type _Vx_OBJ_HANDLE = ::c_int;
+pub type _Vx_TASK_ID = ::_Vx_OBJ_HANDLE;
+pub type _Vx_MSG_Q_ID = ::_Vx_OBJ_HANDLE;
+pub type _Vx_SEM_ID_KERNEL = ::_Vx_OBJ_HANDLE;
+pub type _Vx_RTP_ID = ::_Vx_OBJ_HANDLE;
+pub type _Vx_SD_ID = ::_Vx_OBJ_HANDLE;
+pub type _Vx_CONDVAR_ID = ::_Vx_OBJ_HANDLE;
+pub type _Vx_SEM_ID = *mut ::_Vx_semaphore;
+pub type OBJ_HANDLE = ::_Vx_OBJ_HANDLE;
+pub type TASK_ID = ::OBJ_HANDLE;
+pub type MSG_Q_ID = ::OBJ_HANDLE;
+pub type SEM_ID_KERNEL = ::OBJ_HANDLE;
+pub type RTP_ID = ::OBJ_HANDLE;
+pub type SD_ID = ::OBJ_HANDLE;
+pub type CONDVAR_ID = ::OBJ_HANDLE;
+
+// From vxTypes.h
+pub type _Vx_usr_arg_t = isize;
+pub type _Vx_exit_code_t = isize;
+pub type _Vx_ticks_t = ::c_uint;
+pub type _Vx_ticks64_t = ::c_ulonglong;
+
+pub type sa_family_t = ::c_uchar;
+
+// mqueue.h
+pub type mqd_t = ::c_int;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum _Vx_semaphore {}
+impl ::Copy for _Vx_semaphore {}
+impl ::Clone for _Vx_semaphore {
+    fn clone(&self) -> _Vx_semaphore {
+        *self
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_addr(&self) -> *mut ::c_void {
+        self.si_addr
+    }
+
+    pub unsafe fn si_value(&self) -> ::sigval {
+        self.si_value
+    }
+
+    pub unsafe fn si_pid(&self) -> ::pid_t {
+        self.si_pid
+    }
+
+    pub unsafe fn si_uid(&self) -> ::uid_t {
+        self.si_uid
+    }
+
+    pub unsafe fn si_status(&self) -> ::c_int {
+        self.si_status
+    }
+}
+
+s! {
+    // b_pthread_condattr_t.h
+    pub struct pthread_condattr_t {
+        pub condAttrStatus: ::c_int,
+        pub condAttrPshared: ::c_int,
+        pub condAttrClockId: ::clockid_t,
+    }
+
+    // b_pthread_cond_t.h
+    pub struct pthread_cond_t{
+        pub condSemId: ::_Vx_SEM_ID,
+        pub condValid: ::c_int,
+        pub condInitted: ::c_int,
+        pub condRefCount: ::c_int,
+        pub condMutex: *mut ::pthread_mutex_t,
+        pub condAttr: ::pthread_condattr_t,
+        pub condSemName: [::c_char; _PTHREAD_SHARED_SEM_NAME_MAX]
+    }
+
+    // b_pthread_rwlockattr_t.h
+    pub struct pthread_rwlockattr_t {
+        pub rwlockAttrStatus: ::c_int,
+        pub rwlockAttrPshared: ::c_int,
+        pub rwlockAttrMaxReaders: ::c_uint,
+        pub rwlockAttrConformOpt: ::c_uint,
+    }
+
+    // b_pthread_rwlock_t.h
+    pub struct pthread_rwlock_t {
+        pub rwlockSemId: :: _Vx_SEM_ID,
+        pub rwlockReadersRefCount: ::c_uint,
+        pub rwlockValid: ::c_int,
+        pub rwlockInitted: ::c_int,
+        pub rwlockAttr: ::pthread_rwlockattr_t,
+        pub rwlockSemName: [::c_char; _PTHREAD_SHARED_SEM_NAME_MAX]
+    }
+
+    // b_struct_timeval.h
+    pub struct timeval {
+        pub tv_sec: ::time_t,
+        pub tv_usec: ::suseconds_t,
+    }
+
+    // socket.h
+    pub struct linger {
+        pub l_onoff: ::c_int,
+        pub l_linger: ::c_int,
+    }
+
+    pub struct sockaddr {
+        pub sa_len    : ::c_uchar,
+        pub sa_family : sa_family_t,
+        pub sa_data   : [::c_char; 14],
+    }
+
+    pub struct iovec {
+        pub iov_base: *mut ::c_void,
+        pub iov_len: ::size_t,
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut c_void,
+        pub msg_namelen: socklen_t,
+        pub msg_iov: *mut iovec,
+        pub msg_iovlen: ::c_int,
+        pub msg_control: *mut c_void,
+        pub msg_controllen: socklen_t,
+        pub msg_flags: ::c_int,
+    }
+
+    pub struct cmsghdr {
+        pub cmsg_len: socklen_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+
+    // poll.h
+    pub struct pollfd {
+        pub fd      : ::c_int,
+        pub events  : ::c_short,
+        pub revents : ::c_short,
+    }
+
+    // resource.h
+    pub struct rlimit {
+                           pub rlim_cur : ::rlim_t,
+                           pub rlim_max : ::rlim_t,
+    }
+
+    // stat.h
+    pub struct stat {
+                         pub st_dev       : ::dev_t,
+                         pub st_ino       : ::ino_t,
+                         pub st_mode      : ::mode_t,
+                         pub st_nlink     : ::nlink_t,
+                         pub st_uid       : ::uid_t,
+                         pub st_gid       : ::gid_t,
+                         pub st_rdev      : ::dev_t,
+                         pub st_size      : ::off_t,
+                         pub st_atime     : ::time_t,
+                         pub st_mtime     : ::time_t,
+                         pub st_ctime     : ::time_t,
+                         pub st_blksize   : ::blksize_t,
+                         pub st_blocks    : ::blkcnt_t,
+                         pub st_attrib    : ::c_uchar,
+                         pub st_reserved1 : ::c_int,
+                         pub st_reserved2 : ::c_int,
+                         pub st_reserved3 : ::c_int,
+                         pub st_reserved4 : ::c_int,
+    }
+
+    //b_struct__Timespec.h
+    pub struct _Timespec {
+        pub tv_sec  : ::time_t,
+        pub tv_nsec : ::c_long,
+    }
+
+    // b_struct__Sched_param.h
+    pub struct _Sched_param {
+        pub sched_priority: ::c_int, /* scheduling priority */
+        pub sched_ss_low_priority: ::c_int,    /* low scheduling priority */
+        pub sched_ss_repl_period: ::_Timespec, /* replenishment period */
+        pub sched_ss_init_budget: ::_Timespec, /* initial budget */
+        pub sched_ss_max_repl: ::c_int,        /* max pending replenishment */
+
+    }
+
+    // b_pthread_attr_t.h
+    pub struct pthread_attr_t {
+        pub threadAttrStatus          : ::c_int,
+        pub threadAttrStacksize       : ::size_t,
+        pub threadAttrStackaddr       : *mut ::c_void,
+        pub threadAttrGuardsize       : ::size_t,
+        pub threadAttrDetachstate     : ::c_int,
+        pub threadAttrContentionscope : ::c_int,
+        pub threadAttrInheritsched    : ::c_int,
+        pub threadAttrSchedpolicy     : ::c_int,
+        pub threadAttrName            : *mut ::c_char,
+        pub threadAttrOptions         : ::c_int,
+        pub threadAttrSchedparam      : ::_Sched_param,
+    }
+
+    // signal.h
+
+    pub struct sigaction {
+        pub sa_u     : ::sa_u_t,
+        pub sa_mask  : ::sigset_t,
+        pub sa_flags : ::c_int,
+    }
+
+    // b_stack_t.h
+    pub struct stack_t {
+        pub ss_sp    : *mut ::c_void,
+        pub ss_size  : ::size_t,
+        pub ss_flags : ::c_int,
+    }
+
+    // signal.h
+    pub struct siginfo_t {
+        pub si_signo : ::c_int,
+        pub si_code  : ::c_int,
+        pub si_value : ::sigval,
+        pub si_errno : ::c_int,
+        pub si_status: ::c_int,
+        pub si_addr: *mut ::c_void,
+        pub si_uid: ::uid_t,
+        pub si_pid: ::pid_t,
+    }
+
+    // pthread.h (krnl)
+    // b_pthread_mutexattr_t.h (usr)
+    pub struct pthread_mutexattr_t {
+        mutexAttrStatus      : ::c_int,
+        mutexAttrPshared     : ::c_int,
+        mutexAttrProtocol    : ::c_int,
+        mutexAttrPrioceiling : ::c_int,
+        mutexAttrType        : ::c_int,
+    }
+
+    // pthread.h (krnl)
+    // b_pthread_mutex_t.h (usr)
+    pub struct pthread_mutex_t  {
+        pub mutexSemId: ::_Vx_SEM_ID, /*_Vx_SEM_ID ..*/
+        pub mutexValid: ::c_int,
+        pub mutexInitted: ::c_int,
+        pub mutexCondRefCount: ::c_int,
+        pub mutexSavPriority: ::c_int,
+        pub mutexAttr: ::pthread_mutexattr_t,
+        pub mutexSemName: [::c_char; _PTHREAD_SHARED_SEM_NAME_MAX],
+    }
+
+    // b_struct_timespec.h
+    pub struct timespec {
+        pub tv_sec: ::time_t,
+        pub tv_nsec: ::c_long,
+    }
+
+    // time.h
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+    }
+
+    // in.h
+    pub struct in_addr {
+        pub s_addr: in_addr_t,
+    }
+
+    // in.h
+    pub struct ip_mreq {
+        pub imr_multiaddr: in_addr,
+        pub imr_interface: in_addr,
+    }
+
+    // in6.h
+    #[repr(align(4))]
+    pub struct in6_addr {
+        pub s6_addr: [u8; 16],
+    }
+
+    // in6.h
+    pub struct ipv6_mreq {
+        pub ipv6mr_multiaddr: in6_addr,
+        pub ipv6mr_interface: ::c_uint,
+    }
+
+    // netdb.h
+    pub struct addrinfo {
+        pub ai_flags    : ::c_int,
+        pub ai_family   : ::c_int,
+        pub ai_socktype : ::c_int,
+        pub ai_protocol : ::c_int,
+        pub ai_addrlen  : ::size_t,
+        pub ai_canonname: *mut ::c_char,
+        pub ai_addr     : *mut ::sockaddr,
+        pub ai_next     : *mut ::addrinfo,
+    }
+
+    // in.h
+    pub struct sockaddr_in {
+        pub sin_len   : u8,
+        pub sin_family: u8,
+        pub sin_port  : u16,
+        pub sin_addr  : ::in_addr,
+        pub sin_zero  : [::c_char; 8],
+    }
+
+    // in6.h
+    pub struct sockaddr_in6 {
+        pub sin6_len     : u8,
+        pub sin6_family  : u8,
+        pub sin6_port    : u16,
+        pub sin6_flowinfo: u32,
+        pub sin6_addr    : ::in6_addr,
+        pub sin6_scope_id: u32,
+    }
+
+    pub struct Dl_info {
+        pub dli_fname: *const ::c_char,
+        pub dli_fbase: *mut ::c_void,
+        pub dli_sname: *const ::c_char,
+        pub dli_saddr: *mut ::c_void,
+    }
+
+    pub struct mq_attr {
+        pub mq_maxmsg:  ::c_long,
+        pub mq_msgsize: ::c_long,
+        pub mq_flags:   ::c_long,
+        pub mq_curmsgs: ::c_long,
+    }
+}
+
+s_no_extra_traits! {
+    // dirent.h
+    pub struct dirent {
+        pub d_ino  : ::ino_t,
+        pub d_name : [::c_char; _PARM_NAME_MAX as usize + 1],
+    }
+
+    pub struct sockaddr_un {
+        pub sun_len: u8,
+        pub sun_family: sa_family_t,
+        pub sun_path: [::c_char; 104]
+    }
+
+    // rtpLibCommon.h
+    pub struct RTP_DESC {
+        pub status    : ::c_int,
+        pub options   : u32,
+        pub entrAddr  : *mut ::c_void,
+        pub initTaskId: ::TASK_ID,
+        pub parentId  : ::RTP_ID,
+        pub pathName  : [::c_char; VX_RTP_NAME_LENGTH as usize + 1],
+        pub taskCnt   : ::c_int,
+        pub textStart : *mut ::c_void,
+        pub textEnd   : *mut ::c_void,
+    }
+    // socket.h
+    pub struct sockaddr_storage {
+        pub ss_len     : ::c_uchar,
+        pub ss_family  : ::sa_family_t,
+        pub __ss_pad1  : [::c_char; _SS_PAD1SIZE],
+        pub __ss_align : i32,
+        pub __ss_pad2  : [::c_char; _SS_PAD2SIZE],
+    }
+
+    pub union sa_u_t {
+        pub sa_handler : ::Option<unsafe extern "C" fn(::c_int) -> !>,
+        pub sa_sigaction: ::Option<unsafe extern "C" fn(::c_int,
+                                                        *mut ::siginfo_t,
+                                                        *mut ::c_void) -> !>,
+    }
+
+    pub union sigval {
+        pub sival_int : ::c_int,
+        pub sival_ptr : *mut ::c_void,
+    }
+}
+
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
+        impl ::fmt::Debug for dirent {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("dirent")
+                    .field("d_ino", &self.d_ino)
+                    .field("d_name", &&self.d_name[..])
+                    .finish()
+            }
+        }
+
+        impl ::fmt::Debug for sockaddr_un {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_un")
+                    .field("sun_len", &self.sun_len)
+                    .field("sun_family", &self.sun_family)
+                    .field("sun_path", &&self.sun_path[..])
+                    .finish()
+            }
+        }
+
+        impl ::fmt::Debug for RTP_DESC {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("RTP_DESC")
+                    .field("status", &self.status)
+                    .field("options", &self.options)
+                    .field("entrAddr", &self.entrAddr)
+                    .field("initTaskId", &self.initTaskId)
+                    .field("parentId", &self.parentId)
+                    .field("pathName", &&self.pathName[..])
+                    .field("taskCnt", &self.taskCnt)
+                    .field("textStart", &self.textStart)
+                    .field("textEnd", &self.textEnd)
+                    .finish()
+            }
+        }
+        impl ::fmt::Debug for sockaddr_storage {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sockaddr_storage")
+                    .field("ss_len", &self.ss_len)
+                    .field("ss_family", &self.ss_family)
+                    .field("__ss_pad1", &&self.__ss_pad1[..])
+                    .field("__ss_align", &self.__ss_align)
+                    .field("__ss_pad2", &&self.__ss_pad2[..])
+                    .finish()
+            }
+        }
+
+        impl PartialEq for sa_u_t {
+            fn eq(&self, other: &sa_u_t) -> bool {
+                unsafe {
+                    let h1 = match self.sa_handler {
+                        Some(handler) => handler as usize,
+                        None => 0 as usize,
+                    };
+                    let h2 = match other.sa_handler {
+                        Some(handler) => handler as usize,
+                        None => 0 as usize,
+                    };
+                    h1 == h2
+                }
+            }
+        }
+        impl Eq for sa_u_t {}
+        impl ::fmt::Debug for sa_u_t {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                unsafe {
+                    let h = match self.sa_handler {
+                        Some(handler) => handler as usize,
+                        None => 0 as usize,
+                    };
+
+                    f.debug_struct("sa_u_t")
+                        .field("sa_handler", &h)
+                        .finish()
+                }
+            }
+        }
+        impl ::hash::Hash for sa_u_t {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                unsafe {
+                    let h = match self.sa_handler {
+                        Some(handler) => handler as usize,
+                        None => 0 as usize,
+                    };
+                    h.hash(state)
+                }
+            }
+        }
+
+        impl PartialEq for sigval {
+            fn eq(&self, other: &sigval) -> bool {
+                unsafe { self.sival_ptr as usize == other.sival_ptr as usize }
+            }
+        }
+        impl Eq for sigval {}
+        impl ::fmt::Debug for sigval {
+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
+                f.debug_struct("sigval")
+                    .field("sival_ptr", unsafe { &(self.sival_ptr as usize) })
+                    .finish()
+            }
+        }
+        impl ::hash::Hash for sigval {
+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
+                unsafe { (self.sival_ptr as usize).hash(state) };
+            }
+        }
+    }
+}
+
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const EXIT_FAILURE: ::c_int = 1;
+
+pub const EAI_SERVICE: ::c_int = 9;
+pub const EAI_SOCKTYPE: ::c_int = 10;
+pub const EAI_SYSTEM: ::c_int = 11;
+
+// This is not defined in vxWorks, but we have to define it here
+// to make the building pass for getrandom and libstd, FIXME
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+
+//Clock Lib Stuff
+pub const CLOCK_REALTIME: ::c_int = 0x0;
+pub const CLOCK_MONOTONIC: ::c_int = 0x1;
+pub const CLOCK_PROCESS_CPUTIME_ID: ::c_int = 0x2;
+pub const CLOCK_THREAD_CPUTIME_ID: ::c_int = 0x3;
+pub const TIMER_ABSTIME: ::c_int = 0x1;
+pub const TIMER_RELTIME: ::c_int = 0x0;
+
+// PTHREAD STUFF
+pub const PTHREAD_INITIALIZED_OBJ: ::c_int = 0xF70990EF;
+pub const PTHREAD_DESTROYED_OBJ: ::c_int = -1;
+pub const PTHREAD_VALID_OBJ: ::c_int = 0xEC542A37;
+pub const PTHREAD_INVALID_OBJ: ::c_int = -1;
+pub const PTHREAD_UNUSED_YET_OBJ: ::c_int = -1;
+
+pub const PTHREAD_PRIO_NONE: ::c_int = 0;
+pub const PTHREAD_PRIO_INHERIT: ::c_int = 1;
+pub const PTHREAD_PRIO_PROTECT: ::c_int = 2;
+
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;
+pub const PTHREAD_STACK_MIN: usize = 4096;
+pub const _PTHREAD_SHARED_SEM_NAME_MAX: usize = 30;
+
+// ERRNO STUFF
+pub const OK: ::c_int = 0;
+pub const EPERM: ::c_int = 1; /* Not owner */
+pub const ENOENT: ::c_int = 2; /* No such file or directory */
+pub const ESRCH: ::c_int = 3; /* No such process */
+pub const EINTR: ::c_int = 4; /* Interrupted system call */
+pub const EIO: ::c_int = 5; /* I/O error */
+pub const ENXIO: ::c_int = 6; /* No such device or address */
+pub const E2BIG: ::c_int = 7; /* Arg list too long */
+pub const ENOEXEC: ::c_int = 8; /* Exec format error */
+pub const EBADF: ::c_int = 9; /* Bad file number */
+pub const ECHILD: ::c_int = 10; /* No children */
+pub const EAGAIN: ::c_int = 11; /* No more processes */
+pub const ENOMEM: ::c_int = 12; /* Not enough core */
+pub const EACCES: ::c_int = 13; /* Permission denied */
+pub const EFAULT: ::c_int = 14;
+pub const ENOTEMPTY: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENAMETOOLONG: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const EROFS: ::c_int = 30;
+pub const EPIPE: ::c_int = 32;
+pub const EDEADLK: ::c_int = 33;
+pub const ERANGE: ::c_int = 38;
+pub const EDESTADDRREQ: ::c_int = 40;
+pub const EPROTOTYPE: ::c_int = 41;
+pub const ENOPROTOOPT: ::c_int = 42;
+pub const EPROTONOSUPPORT: ::c_int = 43;
+pub const ESOCKTNOSUPPORT: ::c_int = 44;
+pub const EOPNOTSUPP: ::c_int = 45;
+pub const EPFNOSUPPORT: ::c_int = 46;
+pub const EAFNOSUPPORT: ::c_int = 47;
+pub const EADDRINUSE: ::c_int = 48;
+pub const EADDRNOTAVAIL: ::c_int = 49;
+pub const ENOTSOCK: ::c_int = 50;
+pub const ENETUNREACH: ::c_int = 51;
+pub const ENETRESET: ::c_int = 52;
+pub const ECONNABORTED: ::c_int = 53;
+pub const ECONNRESET: ::c_int = 54;
+pub const ENOBUFS: ::c_int = 55;
+pub const EISCONN: ::c_int = 56;
+pub const ENOTCONN: ::c_int = 57;
+pub const ESHUTDOWN: ::c_int = 58;
+pub const ETOOMANYREFS: ::c_int = 59;
+pub const ETIMEDOUT: ::c_int = 60;
+pub const ECONNREFUSED: ::c_int = 61;
+pub const EINPROGRESS: ::c_int = 68;
+pub const EALREADY: ::c_int = 69;
+pub const EWOULDBLOCK: ::c_int = 70;
+pub const ENOSYS: ::c_int = 71;
+pub const EDQUOT: ::c_int = 83;
+pub const ESTALE: ::c_int = 88;
+
+// NFS errnos: Refer to pkgs_v2/storage/fs/nfs/h/nfs/nfsCommon.h
+const M_nfsStat: ::c_int = 48 << 16;
+enum nfsstat {
+    NFSERR_REMOTE = 71,
+    NFSERR_WFLUSH = 99,
+    NFSERR_BADHANDLE = 10001,
+    NFSERR_NOT_SYNC = 10002,
+    NFSERR_BAD_COOKIE = 10003,
+    NFSERR_TOOSMALL = 10005,
+    NFSERR_BADTYPE = 10007,
+    NFSERR_JUKEBOX = 10008,
+}
+
+pub const S_nfsLib_NFS_OK: ::c_int = OK;
+pub const S_nfsLib_NFSERR_PERM: ::c_int = EPERM;
+pub const S_nfsLib_NFSERR_NOENT: ::c_int = ENOENT;
+pub const S_nfsLib_NFSERR_IO: ::c_int = EIO;
+pub const S_nfsLib_NFSERR_NXIO: ::c_int = ENXIO;
+pub const S_nfsLib_NFSERR_ACCESS: ::c_int = EACCES;
+pub const S_nfsLib_NFSERR_EXIST: ::c_int = EEXIST;
+pub const S_nfsLib_NFSERR_ENODEV: ::c_int = ENODEV;
+pub const S_nfsLib_NFSERR_NOTDIR: ::c_int = ENOTDIR;
+pub const S_nfsLib_NFSERR_ISDIR: ::c_int = EISDIR;
+pub const S_nfsLib_NFSERR_INVAL: ::c_int = EINVAL;
+pub const S_nfsLib_NFSERR_FBIG: ::c_int = EFBIG;
+pub const S_nfsLib_NFSERR_NOSPC: ::c_int = ENOSPC;
+pub const S_nfsLib_NFSERR_ROFS: ::c_int = EROFS;
+pub const S_nfsLib_NFSERR_NAMETOOLONG: ::c_int = ENAMETOOLONG;
+pub const S_nfsLib_NFSERR_NOTEMPTY: ::c_int = ENOTEMPTY;
+pub const S_nfsLib_NFSERR_DQUOT: ::c_int = EDQUOT;
+pub const S_nfsLib_NFSERR_STALE: ::c_int = ESTALE;
+pub const S_nfsLib_NFSERR_WFLUSH: ::c_int =
+    M_nfsStat | nfsstat::NFSERR_WFLUSH as ::c_int;
+pub const S_nfsLib_NFSERR_REMOTE: ::c_int =
+    M_nfsStat | nfsstat::NFSERR_REMOTE as ::c_int;
+pub const S_nfsLib_NFSERR_BADHANDLE: ::c_int =
+    M_nfsStat | nfsstat::NFSERR_BADHANDLE as ::c_int;
+pub const S_nfsLib_NFSERR_NOT_SYNC: ::c_int =
+    M_nfsStat | nfsstat::NFSERR_NOT_SYNC as ::c_int;
+pub const S_nfsLib_NFSERR_BAD_COOKIE: ::c_int =
+    M_nfsStat | nfsstat::NFSERR_BAD_COOKIE as ::c_int;
+pub const S_nfsLib_NFSERR_NOTSUPP: ::c_int = EOPNOTSUPP;
+pub const S_nfsLib_NFSERR_TOOSMALL: ::c_int =
+    M_nfsStat | nfsstat::NFSERR_TOOSMALL as ::c_int;
+pub const S_nfsLib_NFSERR_SERVERFAULT: ::c_int = EIO;
+pub const S_nfsLib_NFSERR_BADTYPE: ::c_int =
+    M_nfsStat | nfsstat::NFSERR_BADTYPE as ::c_int;
+pub const S_nfsLib_NFSERR_JUKEBOX: ::c_int =
+    M_nfsStat | nfsstat::NFSERR_JUKEBOX as ::c_int;
+
+// in.h
+pub const IPPROTO_IP: ::c_int = 0;
+pub const IPPROTO_IPV6: ::c_int = 41;
+
+pub const IP_TTL: ::c_int = 4;
+pub const IP_MULTICAST_IF: ::c_int = 9;
+pub const IP_MULTICAST_TTL: ::c_int = 10;
+pub const IP_MULTICAST_LOOP: ::c_int = 11;
+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;
+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;
+
+// in6.h
+pub const IPV6_V6ONLY: ::c_int = 1;
+pub const IPV6_UNICAST_HOPS: ::c_int = 4;
+pub const IPV6_MULTICAST_IF: ::c_int = 9;
+pub const IPV6_MULTICAST_HOPS: ::c_int = 10;
+pub const IPV6_MULTICAST_LOOP: ::c_int = 11;
+pub const IPV6_ADD_MEMBERSHIP: ::c_int = 12;
+pub const IPV6_DROP_MEMBERSHIP: ::c_int = 13;
+
+// STAT Stuff
+pub const S_IFMT: ::c_int = 0xf000;
+pub const S_IFIFO: ::c_int = 0x1000;
+pub const S_IFCHR: ::c_int = 0x2000;
+pub const S_IFDIR: ::c_int = 0x4000;
+pub const S_IFBLK: ::c_int = 0x6000;
+pub const S_IFREG: ::c_int = 0x8000;
+pub const S_IFLNK: ::c_int = 0xa000;
+pub const S_IFSHM: ::c_int = 0xb000;
+pub const S_IFSOCK: ::c_int = 0xc000;
+pub const S_ISUID: ::c_int = 0x0800;
+pub const S_ISGID: ::c_int = 0x0400;
+pub const S_ISTXT: ::c_int = 0x0200;
+pub const S_IRUSR: ::c_int = 0x0100;
+pub const S_IWUSR: ::c_int = 0x0080;
+pub const S_IXUSR: ::c_int = 0x0040;
+pub const S_IRWXU: ::c_int = 0x01c0;
+pub const S_IRGRP: ::c_int = 0x0020;
+pub const S_IWGRP: ::c_int = 0x0010;
+pub const S_IXGRP: ::c_int = 0x0008;
+pub const S_IRWXG: ::c_int = 0x0038;
+pub const S_IROTH: ::c_int = 0x0004;
+pub const S_IWOTH: ::c_int = 0x0002;
+pub const S_IXOTH: ::c_int = 0x0001;
+pub const S_IRWXO: ::c_int = 0x0007;
+
+// socket.h
+pub const SOL_SOCKET: ::c_int = 0xffff;
+
+pub const SO_DEBUG: ::c_int = 0x0001;
+pub const SO_REUSEADDR: ::c_int = 0x0004;
+pub const SO_KEEPALIVE: ::c_int = 0x0008;
+pub const SO_DONTROUTE: ::c_int = 0x0010;
+pub const SO_RCVLOWAT: ::c_int = 0x0012;
+pub const SO_SNDLOWAT: ::c_int = 0x0013;
+pub const SO_SNDTIMEO: ::c_int = 0x1005;
+pub const SO_ACCEPTCONN: ::c_int = 0x001e;
+pub const SO_BROADCAST: ::c_int = 0x0020;
+pub const SO_USELOOPBACK: ::c_int = 0x0040;
+pub const SO_LINGER: ::c_int = 0x0080;
+pub const SO_REUSEPORT: ::c_int = 0x0200;
+
+pub const SO_VLAN: ::c_int = 0x8000;
+
+pub const SO_SNDBUF: ::c_int = 0x1001;
+pub const SO_RCVBUF: ::c_int = 0x1002;
+pub const SO_RCVTIMEO: ::c_int = 0x1006;
+pub const SO_ERROR: ::c_int = 0x1007;
+pub const SO_TYPE: ::c_int = 0x1008;
+pub const SO_BINDTODEVICE: ::c_int = 0x1010;
+pub const SO_OOBINLINE: ::c_int = 0x1011;
+pub const SO_CONNTIMEO: ::c_int = 0x100a;
+
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_RAW: ::c_int = 3;
+pub const SOCK_RDM: ::c_int = 4;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const SOCK_PACKET: ::c_int = 10;
+
+pub const _SS_MAXSIZE: usize = 128;
+pub const _SS_ALIGNSIZE: usize = size_of::<u32>();
+pub const _SS_PAD1SIZE: usize =
+    _SS_ALIGNSIZE - size_of::<::c_uchar>() - size_of::<::sa_family_t>();
+pub const _SS_PAD2SIZE: usize = _SS_MAXSIZE
+    - size_of::<::c_uchar>()
+    - size_of::<::sa_family_t>()
+    - _SS_PAD1SIZE
+    - _SS_ALIGNSIZE;
+
+pub const MSG_OOB: ::c_int = 0x0001;
+pub const MSG_PEEK: ::c_int = 0x0002;
+pub const MSG_DONTROUTE: ::c_int = 0x0004;
+pub const MSG_EOR: ::c_int = 0x0008;
+pub const MSG_TRUNC: ::c_int = 0x0010;
+pub const MSG_CTRUNC: ::c_int = 0x0020;
+pub const MSG_WAITALL: ::c_int = 0x0040;
+pub const MSG_DONTWAIT: ::c_int = 0x0080;
+pub const MSG_EOF: ::c_int = 0x0100;
+pub const MSG_EXP: ::c_int = 0x0200;
+pub const MSG_MBUF: ::c_int = 0x0400;
+pub const MSG_NOTIFICATION: ::c_int = 0x0800;
+pub const MSG_COMPAT: ::c_int = 0x8000;
+
+pub const AF_UNSPEC: ::c_int = 0;
+pub const AF_LOCAL: ::c_int = 1;
+pub const AF_UNIX: ::c_int = AF_LOCAL;
+pub const AF_INET: ::c_int = 2;
+pub const AF_NETLINK: ::c_int = 16;
+pub const AF_ROUTE: ::c_int = 17;
+pub const AF_LINK: ::c_int = 18;
+pub const AF_PACKET: ::c_int = 19;
+pub const pseudo_AF_KEY: ::c_int = 27;
+pub const AF_KEY: ::c_int = pseudo_AF_KEY;
+pub const AF_INET6: ::c_int = 28;
+pub const AF_SOCKDEV: ::c_int = 31;
+pub const AF_TIPC: ::c_int = 33;
+pub const AF_MIPC: ::c_int = 34;
+pub const AF_MIPC_SAFE: ::c_int = 35;
+pub const AF_MAX: ::c_int = 37;
+
+pub const SHUT_RD: ::c_int = 0;
+pub const SHUT_WR: ::c_int = 1;
+pub const SHUT_RDWR: ::c_int = 2;
+
+pub const IPPROTO_TCP: ::c_int = 6;
+pub const TCP_NODELAY: ::c_int = 1;
+pub const TCP_MAXSEG: ::c_int = 2;
+pub const TCP_NOPUSH: ::c_int = 3;
+pub const TCP_KEEPIDLE: ::c_int = 4;
+pub const TCP_KEEPINTVL: ::c_int = 5;
+pub const TCP_KEEPCNT: ::c_int = 6;
+
+// ioLib.h
+pub const FIONREAD: ::c_int = 0x40040001;
+pub const FIOFLUSH: ::c_int = 2;
+pub const FIOOPTIONS: ::c_int = 3;
+pub const FIOBAUDRATE: ::c_int = 4;
+pub const FIODISKFORMAT: ::c_int = 5;
+pub const FIODISKINIT: ::c_int = 6;
+pub const FIOSEEK: ::c_int = 7;
+pub const FIOWHERE: ::c_int = 8;
+pub const FIODIRENTRY: ::c_int = 9;
+pub const FIORENAME: ::c_int = 10;
+pub const FIOREADYCHANGE: ::c_int = 11;
+pub const FIODISKCHANGE: ::c_int = 13;
+pub const FIOCANCEL: ::c_int = 14;
+pub const FIOSQUEEZE: ::c_int = 15;
+pub const FIOGETNAME: ::c_int = 18;
+pub const FIONBIO: ::c_int = 0x90040010;
+
+// limits.h
+pub const PATH_MAX: ::c_int = _PARM_PATH_MAX;
+pub const _POSIX_PATH_MAX: ::c_int = 256;
+
+// Some poll stuff
+pub const POLLIN: ::c_short = 0x0001;
+pub const POLLPRI: ::c_short = 0x0002;
+pub const POLLOUT: ::c_short = 0x0004;
+pub const POLLRDNORM: ::c_short = 0x0040;
+pub const POLLWRNORM: ::c_short = POLLOUT;
+pub const POLLRDBAND: ::c_short = 0x0080;
+pub const POLLWRBAND: ::c_short = 0x0100;
+pub const POLLERR: ::c_short = 0x0008;
+pub const POLLHUP: ::c_short = 0x0010;
+pub const POLLNVAL: ::c_short = 0x0020;
+
+// fnctlcom.h
+pub const FD_CLOEXEC: ::c_int = 1;
+pub const F_DUPFD: ::c_int = 0;
+pub const F_GETFD: ::c_int = 1;
+pub const F_SETFD: ::c_int = 2;
+pub const F_GETFL: ::c_int = 3;
+pub const F_SETFL: ::c_int = 4;
+pub const F_GETOWN: ::c_int = 5;
+pub const F_SETOWN: ::c_int = 6;
+pub const F_GETLK: ::c_int = 7;
+pub const F_SETLK: ::c_int = 8;
+pub const F_SETLKW: ::c_int = 9;
+pub const F_DUPFD_CLOEXEC: ::c_int = 14;
+
+// signal.h
+pub const SIG_DFL: sighandler_t = 0 as sighandler_t;
+pub const SIG_IGN: sighandler_t = 1 as sighandler_t;
+pub const SIG_ERR: sighandler_t = -1 as isize as sighandler_t;
+
+pub const SIGHUP: ::c_int = 1;
+pub const SIGINT: ::c_int = 2;
+pub const SIGQUIT: ::c_int = 3;
+pub const SIGILL: ::c_int = 4;
+pub const SIGTRAP: ::c_int = 5;
+pub const SIGABRT: ::c_int = 6;
+pub const SIGEMT: ::c_int = 7;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGKILL: ::c_int = 9;
+pub const SIGBUS: ::c_int = 10;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGFMT: ::c_int = 12;
+pub const SIGPIPE: ::c_int = 13;
+pub const SIGALRM: ::c_int = 14;
+pub const SIGTERM: ::c_int = 15;
+pub const SIGCNCL: ::c_int = 16;
+pub const SIGSTOP: ::c_int = 17;
+pub const SIGTSTP: ::c_int = 18;
+pub const SIGCONT: ::c_int = 19;
+pub const SIGCHLD: ::c_int = 20;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+
+pub const SIG_BLOCK: ::c_int = 1;
+pub const SIG_UNBLOCK: ::c_int = 2;
+pub const SIG_SETMASK: ::c_int = 3;
+
+pub const SI_SYNC: ::c_int = 0;
+pub const SI_USER: ::c_int = -1;
+pub const SI_QUEUE: ::c_int = -2;
+pub const SI_TIMER: ::c_int = -3;
+pub const SI_ASYNCIO: ::c_int = -4;
+pub const SI_MESGQ: ::c_int = -5;
+pub const SI_CHILD: ::c_int = -6;
+pub const SI_KILL: ::c_int = SI_USER;
+
+// vxParams.h definitions
+pub const _PARM_NAME_MAX: ::c_int = 255;
+pub const _PARM_PATH_MAX: ::c_int = 1024;
+
+// WAIT STUFF
+pub const WNOHANG: ::c_int = 0x01;
+pub const WUNTRACED: ::c_int = 0x02;
+
+const PTHREAD_MUTEXATTR_INITIALIZER: pthread_mutexattr_t =
+    pthread_mutexattr_t {
+        mutexAttrStatus: PTHREAD_INITIALIZED_OBJ,
+        mutexAttrProtocol: PTHREAD_PRIO_NONE,
+        mutexAttrPrioceiling: 0,
+        mutexAttrType: PTHREAD_MUTEX_DEFAULT,
+        mutexAttrPshared: 1,
+    };
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+    mutexSemId: null_mut(),
+    mutexValid: PTHREAD_VALID_OBJ,
+    mutexInitted: PTHREAD_UNUSED_YET_OBJ,
+    mutexCondRefCount: 0,
+    mutexSavPriority: -1,
+    mutexAttr: PTHREAD_MUTEXATTR_INITIALIZER,
+    mutexSemName: [0; _PTHREAD_SHARED_SEM_NAME_MAX],
+};
+
+const PTHREAD_CONDATTR_INITIALIZER: pthread_condattr_t = pthread_condattr_t {
+    condAttrStatus: 0xf70990ef,
+    condAttrPshared: 1,
+    condAttrClockId: CLOCK_REALTIME,
+};
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+    condSemId: null_mut(),
+    condValid: PTHREAD_VALID_OBJ,
+    condInitted: PTHREAD_UNUSED_YET_OBJ,
+    condRefCount: 0,
+    condMutex: null_mut(),
+    condAttr: PTHREAD_CONDATTR_INITIALIZER,
+    condSemName: [0; _PTHREAD_SHARED_SEM_NAME_MAX],
+};
+
+const PTHREAD_RWLOCKATTR_INITIALIZER: pthread_rwlockattr_t =
+    pthread_rwlockattr_t {
+        rwlockAttrStatus: PTHREAD_INITIALIZED_OBJ,
+        rwlockAttrPshared: 1,
+        rwlockAttrMaxReaders: 0,
+        rwlockAttrConformOpt: 1,
+    };
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+    rwlockSemId: null_mut(),
+    rwlockReadersRefCount: 0,
+    rwlockValid: PTHREAD_VALID_OBJ,
+    rwlockInitted: PTHREAD_UNUSED_YET_OBJ,
+    rwlockAttr: PTHREAD_RWLOCKATTR_INITIALIZER,
+    rwlockSemName: [0; _PTHREAD_SHARED_SEM_NAME_MAX],
+};
+
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+
+// rtpLibCommon.h
+pub const VX_RTP_NAME_LENGTH: ::c_int = 255;
+pub const RTP_ID_ERROR: ::RTP_ID = -1;
+
+// h/public/unistd.h
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 21; // Via unistd.h
+pub const _SC_PAGESIZE: ::c_int = 39;
+pub const O_ACCMODE: ::c_int = 3;
+pub const O_CLOEXEC: ::c_int = 0x100000; // fcntlcom
+pub const O_EXCL: ::c_int = 0x0800;
+pub const O_CREAT: ::c_int = 0x0200;
+pub const O_TRUNC: ::c_int = 0x0400;
+pub const O_APPEND: ::c_int = 0x0008;
+pub const O_RDWR: ::c_int = 0x0002;
+pub const O_WRONLY: ::c_int = 0x0001;
+pub const O_RDONLY: ::c_int = 0;
+pub const O_NONBLOCK: ::c_int = 0x4000;
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum FILE {}
+impl ::Copy for FILE {}
+impl ::Clone for FILE {
+    fn clone(&self) -> FILE {
+        *self
+    }
+}
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum fpos_t {} // FIXME: fill this out with a struct
+impl ::Copy for fpos_t {}
+impl ::Clone for fpos_t {
+    fn clone(&self) -> fpos_t {
+        *self
+    }
+}
+
+f! {
+    pub fn CMSG_ALIGN(len: usize) -> usize {
+        len + ::mem::size_of::<usize>() - 1 & !(::mem::size_of::<usize>() - 1)
+    }
+
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr,
+                       cmsg: *const cmsghdr) -> *mut cmsghdr {
+        let next = cmsg as usize + CMSG_ALIGN((*cmsg).cmsg_len as usize)
+            + CMSG_ALIGN(::mem::size_of::<::cmsghdr>());
+        let max = (*mhdr).msg_control as usize
+            + (*mhdr).msg_controllen as usize;
+        if next <= max {
+            (cmsg as usize + CMSG_ALIGN((*cmsg).cmsg_len as usize))
+                as *mut ::cmsghdr
+        } else {
+            0 as *mut ::cmsghdr
+        }
+    }
+
+    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {
+        if (*mhdr).msg_controllen as usize > 0  {
+            (*mhdr).msg_control as *mut cmsghdr
+        } else {
+            0 as *mut cmsghdr
+        }
+    }
+
+    pub fn CMSG_DATA(cmsg: *const cmsghdr) -> *mut ::c_uchar {
+        (cmsg as *mut ::c_uchar)
+            .offset(CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)
+    }
+
+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {
+        (CMSG_ALIGN(length as usize) + CMSG_ALIGN(::mem::size_of::<cmsghdr>()))
+            as ::c_uint
+    }
+
+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {
+        CMSG_ALIGN(::mem::size_of::<cmsghdr>()) as ::c_uint + length
+    }
+}
+
+extern "C" {
+    pub fn isalnum(c: c_int) -> c_int;
+    pub fn isalpha(c: c_int) -> c_int;
+    pub fn iscntrl(c: c_int) -> c_int;
+    pub fn isdigit(c: c_int) -> c_int;
+    pub fn isgraph(c: c_int) -> c_int;
+    pub fn islower(c: c_int) -> c_int;
+    pub fn isprint(c: c_int) -> c_int;
+    pub fn ispunct(c: c_int) -> c_int;
+    pub fn isspace(c: c_int) -> c_int;
+    pub fn isupper(c: c_int) -> c_int;
+    pub fn isxdigit(c: c_int) -> c_int;
+    pub fn isblank(c: c_int) -> c_int;
+    pub fn tolower(c: c_int) -> c_int;
+    pub fn toupper(c: c_int) -> c_int;
+    pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;
+    pub fn freopen(
+        filename: *const c_char,
+        mode: *const c_char,
+        file: *mut FILE,
+    ) -> *mut FILE;
+    pub fn fflush(file: *mut FILE) -> c_int;
+    pub fn fclose(file: *mut FILE) -> c_int;
+    pub fn remove(filename: *const c_char) -> c_int;
+    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;
+    pub fn tmpfile() -> *mut FILE;
+    pub fn setvbuf(
+        stream: *mut FILE,
+        buffer: *mut c_char,
+        mode: c_int,
+        size: size_t,
+    ) -> c_int;
+    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);
+    pub fn getchar() -> c_int;
+    pub fn putchar(c: c_int) -> c_int;
+    pub fn fgetc(stream: *mut FILE) -> c_int;
+    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE)
+        -> *mut c_char;
+    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;
+    pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;
+    pub fn puts(s: *const c_char) -> c_int;
+    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;
+    pub fn fread(
+        ptr: *mut c_void,
+        size: size_t,
+        nobj: size_t,
+        stream: *mut FILE,
+    ) -> size_t;
+    pub fn fwrite(
+        ptr: *const c_void,
+        size: size_t,
+        nobj: size_t,
+        stream: *mut FILE,
+    ) -> size_t;
+    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;
+    pub fn ftell(stream: *mut FILE) -> c_long;
+    pub fn rewind(stream: *mut FILE);
+    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;
+    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;
+    pub fn feof(stream: *mut FILE) -> c_int;
+    pub fn ferror(stream: *mut FILE) -> c_int;
+    pub fn perror(s: *const c_char);
+    pub fn atoi(s: *const c_char) -> c_int;
+    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;
+    pub fn strtol(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_long;
+    pub fn strtoul(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_ulong;
+    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;
+    pub fn malloc(size: size_t) -> *mut c_void;
+    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;
+    pub fn free(p: *mut c_void);
+    pub fn abort() -> !;
+    pub fn exit(status: c_int) -> !;
+    pub fn atexit(cb: extern "C" fn()) -> c_int;
+    pub fn system(s: *const c_char) -> c_int;
+    pub fn getenv(s: *const c_char) -> *mut c_char;
+
+    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;
+    pub fn strncpy(
+        dst: *mut c_char,
+        src: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strncat(
+        s: *mut c_char,
+        ct: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;
+    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strdup(cs: *const c_char) -> *mut c_char;
+    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
+    pub fn strncasecmp(
+        s1: *const c_char,
+        s2: *const c_char,
+        n: size_t,
+    ) -> c_int;
+    pub fn strlen(cs: *const c_char) -> size_t;
+    pub fn strerror(n: c_int) -> *mut c_char;
+    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;
+    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;
+    pub fn wcslen(buf: *const wchar_t) -> size_t;
+    pub fn wcstombs(
+        dest: *mut c_char,
+        src: *const wchar_t,
+        n: size_t,
+    ) -> ::size_t;
+
+    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;
+    pub fn wmemchr(cx: *const wchar_t, c: wchar_t, n: size_t) -> *mut wchar_t;
+    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;
+    pub fn memcpy(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memmove(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;
+}
+
+extern "C" {
+    pub fn fprintf(
+        stream: *mut ::FILE,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn printf(format: *const ::c_char, ...) -> ::c_int;
+    pub fn snprintf(
+        s: *mut ::c_char,
+        n: ::size_t,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn sprintf(s: *mut ::c_char, format: *const ::c_char, ...) -> ::c_int;
+    pub fn fscanf(
+        stream: *mut ::FILE,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn scanf(format: *const ::c_char, ...) -> ::c_int;
+    pub fn sscanf(s: *const ::c_char, format: *const ::c_char, ...)
+        -> ::c_int;
+    pub fn getchar_unlocked() -> ::c_int;
+    pub fn putchar_unlocked(c: ::c_int) -> ::c_int;
+    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;
+    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;
+    pub fn fileno(stream: *mut ::FILE) -> ::c_int;
+    pub fn creat(path: *const c_char, mode: mode_t) -> ::c_int;
+    pub fn rewinddir(dirp: *mut ::DIR);
+    pub fn fchown(fd: ::c_int, owner: ::uid_t, group: ::gid_t) -> ::c_int;
+    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;
+    pub fn alarm(seconds: ::c_uint) -> ::c_uint;
+    pub fn fchdir(dirfd: ::c_int) -> ::c_int;
+    pub fn chown(path: *const c_char, uid: uid_t, gid: gid_t) -> ::c_int;
+    pub fn fpathconf(filedes: ::c_int, name: ::c_int) -> c_long;
+    pub fn getegid() -> gid_t;
+    pub fn geteuid() -> uid_t;
+    pub fn getgroups(ngroups_max: ::c_int, groups: *mut gid_t) -> ::c_int;
+    pub fn getlogin() -> *mut c_char;
+    pub fn getopt(
+        argc: ::c_int,
+        argv: *const *mut c_char,
+        optstr: *const c_char,
+    ) -> ::c_int;
+    pub fn pathconf(path: *const c_char, name: ::c_int) -> c_long;
+    pub fn pause() -> ::c_int;
+    pub fn seteuid(uid: uid_t) -> ::c_int;
+    pub fn setegid(gid: gid_t) -> ::c_int;
+    pub fn sleep(secs: ::c_uint) -> ::c_uint;
+    pub fn ttyname(fd: ::c_int) -> *mut c_char;
+    pub fn wait(status: *mut ::c_int) -> pid_t;
+    pub fn umask(mask: mode_t) -> mode_t;
+    pub fn mlock(addr: *const ::c_void, len: ::size_t) -> ::c_int;
+    pub fn mlockall(flags: ::c_int) -> ::c_int;
+    pub fn munlockall() -> ::c_int;
+
+    pub fn mmap(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+        flags: ::c_int,
+        fd: ::c_int,
+        offset: off_t,
+    ) -> *mut ::c_void;
+    pub fn munmap(addr: *mut ::c_void, len: ::size_t) -> ::c_int;
+    pub fn truncate(path: *const c_char, length: off_t) -> ::c_int;
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn pthread_exit(value: *mut ::c_void) -> !;
+    pub fn pthread_attr_setdetachstate(
+        attr: *mut ::pthread_attr_t,
+        state: ::c_int,
+    ) -> ::c_int;
+
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn sigaction(
+        signum: ::c_int,
+        act: *const sigaction,
+        oldact: *mut sigaction,
+    ) -> ::c_int;
+
+    pub fn utimes(
+        filename: *const ::c_char,
+        times: *const ::timeval,
+    ) -> ::c_int;
+
+    #[link_name = "_rtld_dlopen"]
+    pub fn dlopen(filename: *const ::c_char, flag: ::c_int) -> *mut ::c_void;
+
+    #[link_name = "_rtld_dlerror"]
+    pub fn dlerror() -> *mut ::c_char;
+
+    #[link_name = "_rtld_dlsym"]
+    pub fn dlsym(
+        handle: *mut ::c_void,
+        symbol: *const ::c_char,
+    ) -> *mut ::c_void;
+
+    #[link_name = "_rtld_dlclose"]
+    pub fn dlclose(handle: *mut ::c_void) -> ::c_int;
+
+    #[link_name = "_rtld_dladdr"]
+    pub fn dladdr(addr: *mut ::c_void, info: *mut Dl_info) -> ::c_int;
+
+    // time.h
+    pub fn gmtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;
+    pub fn localtime_r(time_p: *const time_t, result: *mut tm) -> *mut tm;
+    pub fn mktime(tm: *mut tm) -> time_t;
+    pub fn time(time: *mut time_t) -> time_t;
+    pub fn gmtime(time_p: *const time_t) -> *mut tm;
+    pub fn localtime(time_p: *const time_t) -> *mut tm;
+    pub fn timegm(tm: *mut tm) -> time_t;
+    pub fn difftime(time1: time_t, time0: time_t) -> ::c_double;
+    pub fn gethostname(name: *mut ::c_char, len: ::size_t) -> ::c_int;
+    pub fn usleep(secs: ::useconds_t) -> ::c_int;
+    pub fn putenv(string: *mut c_char) -> ::c_int;
+    pub fn setlocale(
+        category: ::c_int,
+        locale: *const ::c_char,
+    ) -> *mut ::c_char;
+
+    pub fn sigprocmask(
+        how: ::c_int,
+        set: *const sigset_t,
+        oldset: *mut sigset_t,
+    ) -> ::c_int;
+    pub fn sigpending(set: *mut sigset_t) -> ::c_int;
+
+    pub fn mkfifo(path: *const c_char, mode: mode_t) -> ::c_int;
+
+    pub fn fseeko(
+        stream: *mut ::FILE,
+        offset: ::off_t,
+        whence: ::c_int,
+    ) -> ::c_int;
+    pub fn ftello(stream: *mut ::FILE) -> ::off_t;
+    pub fn mkstemp(template: *mut ::c_char) -> ::c_int;
+
+    pub fn tmpnam(ptr: *mut ::c_char) -> *mut ::c_char;
+
+    pub fn openlog(ident: *const ::c_char, logopt: ::c_int, facility: ::c_int);
+    pub fn closelog();
+    pub fn setlogmask(maskpri: ::c_int) -> ::c_int;
+    pub fn syslog(priority: ::c_int, message: *const ::c_char, ...);
+    pub fn getline(
+        lineptr: *mut *mut c_char,
+        n: *mut size_t,
+        stream: *mut FILE,
+    ) -> ssize_t;
+
+}
+
+extern "C" {
+    // stdlib.h
+    pub fn memalign(block_size: ::size_t, size_arg: ::size_t)
+        -> *mut ::c_void;
+
+    // ioLib.h
+    pub fn getcwd(buf: *mut ::c_char, size: ::size_t) -> *mut ::c_char;
+
+    // ioLib.h
+    pub fn chdir(attr: *const ::c_char) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutexattr_destroy(
+        attr: *mut pthread_mutexattr_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutexattr_settype(
+        pAttr: *mut ::pthread_mutexattr_t,
+        pType: ::c_int,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutex_init(
+        mutex: *mut pthread_mutex_t,
+        attr: *const pthread_mutexattr_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutex_destroy(mutex: *mut pthread_mutex_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutex_lock(mutex: *mut pthread_mutex_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutex_trylock(mutex: *mut pthread_mutex_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutex_timedlock(
+        attr: *mut pthread_mutex_t,
+        spec: *const timespec,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_mutex_unlock(mutex: *mut pthread_mutex_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_attr_setname(
+        pAttr: *mut ::pthread_attr_t,
+        name: *mut ::c_char,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_attr_setstacksize(
+        attr: *mut ::pthread_attr_t,
+        stacksize: ::size_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_attr_getstacksize(
+        attr: *const ::pthread_attr_t,
+        size: *mut ::size_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_attr_init(attr: *mut ::pthread_attr_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_create(
+        pThread: *mut ::pthread_t,
+        pAttr: *const ::pthread_attr_t,
+        start_routine: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        value: *mut ::c_void,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_attr_destroy(thread: *mut ::pthread_attr_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_detach(thread: ::pthread_t) -> ::c_int;
+
+    // int pthread_atfork (void (*)(void), void (*)(void), void (*)(void));
+    pub fn pthread_atfork(
+        prepare: ::Option<unsafe extern "C" fn()>,
+        parent: ::Option<unsafe extern "C" fn()>,
+        child: ::Option<unsafe extern "C" fn()>,
+    ) -> ::c_int;
+    // stat.h
+    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;
+
+    // stat.h
+    pub fn lstat(path: *const ::c_char, buf: *mut stat) -> ::c_int;
+
+    // unistd.h
+    pub fn ftruncate(fd: ::c_int, length: off_t) -> ::c_int;
+
+    // dirent.h
+    pub fn readdir_r(
+        pDir: *mut ::DIR,
+        entry: *mut ::dirent,
+        result: *mut *mut ::dirent,
+    ) -> ::c_int;
+
+    // dirent.h
+    pub fn readdir(pDir: *mut ::DIR) -> *mut ::dirent;
+
+    // fcntl.h or
+    // ioLib.h
+    pub fn open(path: *const ::c_char, oflag: ::c_int, ...) -> ::c_int;
+
+    // poll.h
+    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::c_int) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_condattr_init(attr: *mut ::pthread_condattr_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_condattr_destroy(
+        attr: *mut ::pthread_condattr_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_condattr_getclock(
+        pAttr: *const ::pthread_condattr_t,
+        pClockId: *mut ::clockid_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_condattr_setclock(
+        pAttr: *mut ::pthread_condattr_t,
+        clockId: ::clockid_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_cond_init(
+        cond: *mut ::pthread_cond_t,
+        attr: *const ::pthread_condattr_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_cond_signal(cond: *mut ::pthread_cond_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_cond_broadcast(cond: *mut ::pthread_cond_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_cond_wait(
+        cond: *mut ::pthread_cond_t,
+        mutex: *mut ::pthread_mutex_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlockattr_init(
+        attr: *mut ::pthread_rwlockattr_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlockattr_destroy(
+        attr: *mut ::pthread_rwlockattr_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlockattr_setmaxreaders(
+        attr: *mut ::pthread_rwlockattr_t,
+        attr2: ::c_uint,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_init(
+        attr: *mut ::pthread_rwlock_t,
+        host: *const ::pthread_rwlockattr_t,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_destroy(attr: *mut ::pthread_rwlock_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_rdlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_tryrdlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_timedrdlock(
+        attr: *mut ::pthread_rwlock_t,
+        host: *const ::timespec,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_wrlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_trywrlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_timedwrlock(
+        attr: *mut ::pthread_rwlock_t,
+        host: *const ::timespec,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_rwlock_unlock(attr: *mut ::pthread_rwlock_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_key_create(
+        key: *mut ::pthread_key_t,
+        dtor: ::Option<unsafe extern "C" fn(*mut ::c_void)>,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_key_delete(key: ::pthread_key_t) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_setspecific(
+        key: ::pthread_key_t,
+        value: *const ::c_void,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_getspecific(key: ::pthread_key_t) -> *mut ::c_void;
+
+    // pthread.h
+    pub fn pthread_cond_timedwait(
+        cond: *mut ::pthread_cond_t,
+        mutex: *mut ::pthread_mutex_t,
+        abstime: *const ::timespec,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_attr_getname(
+        attr: *mut ::pthread_attr_t,
+        name: *mut *mut ::c_char,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_join(
+        thread: ::pthread_t,
+        status: *mut *mut ::c_void,
+    ) -> ::c_int;
+
+    // pthread.h
+    pub fn pthread_self() -> ::pthread_t;
+
+    // clockLib.h
+    pub fn clock_gettime(
+        clock_id: ::clockid_t,
+        tp: *mut ::timespec,
+    ) -> ::c_int;
+
+    // clockLib.h
+    pub fn clock_settime(
+        clock_id: ::clockid_t,
+        tp: *const ::timespec,
+    ) -> ::c_int;
+
+    // clockLib.h
+    pub fn clock_getres(
+        clock_id: ::clockid_t,
+        res: *mut ::timespec,
+    ) -> ::c_int;
+
+    // clockLib.h
+    pub fn clock_nanosleep(
+        clock_id: ::clockid_t,
+        flags: ::c_int,
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+
+    // timerLib.h
+    pub fn nanosleep(
+        rqtp: *const ::timespec,
+        rmtp: *mut ::timespec,
+    ) -> ::c_int;
+
+    // socket.h
+    pub fn accept(
+        s: ::c_int,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::socklen_t,
+    ) -> ::c_int;
+
+    // socket.h
+    pub fn bind(fd: ::c_int, addr: *const sockaddr, len: socklen_t)
+        -> ::c_int;
+
+    // socket.h
+    pub fn connect(
+        s: ::c_int,
+        name: *const ::sockaddr,
+        namelen: ::socklen_t,
+    ) -> ::c_int;
+
+    // socket.h
+    pub fn getpeername(
+        s: ::c_int,
+        name: *mut ::sockaddr,
+        namelen: *mut ::socklen_t,
+    ) -> ::c_int;
+
+    // socket.h
+    pub fn getsockname(
+        socket: ::c_int,
+        address: *mut sockaddr,
+        address_len: *mut socklen_t,
+    ) -> ::c_int;
+
+    // socket.h
+    pub fn getsockopt(
+        sockfd: ::c_int,
+        level: ::c_int,
+        optname: ::c_int,
+        optval: *mut ::c_void,
+        optlen: *mut ::socklen_t,
+    ) -> ::c_int;
+
+    // socket.h
+    pub fn listen(socket: ::c_int, backlog: ::c_int) -> ::c_int;
+
+    // socket.h
+    pub fn recv(
+        s: ::c_int,
+        buf: *mut ::c_void,
+        bufLen: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+
+    // socket.h
+    pub fn recvfrom(
+        s: ::c_int,
+        buf: *mut ::c_void,
+        bufLen: ::size_t,
+        flags: ::c_int,
+        from: *mut ::sockaddr,
+        pFromLen: *mut ::socklen_t,
+    ) -> ::ssize_t;
+
+    pub fn recvmsg(
+        socket: ::c_int,
+        mp: *mut ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+
+    // socket.h
+    pub fn send(
+        socket: ::c_int,
+        buf: *const ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+
+    pub fn sendmsg(
+        socket: ::c_int,
+        mp: *const ::msghdr,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+
+    // socket.h
+    pub fn sendto(
+        socket: ::c_int,
+        buf: *const ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+        addr: *const sockaddr,
+        addrlen: socklen_t,
+    ) -> ::ssize_t;
+
+    // socket.h
+    pub fn setsockopt(
+        socket: ::c_int,
+        level: ::c_int,
+        name: ::c_int,
+        value: *const ::c_void,
+        option_len: socklen_t,
+    ) -> ::c_int;
+
+    // socket.h
+    pub fn shutdown(s: ::c_int, how: ::c_int) -> ::c_int;
+
+    // socket.h
+    pub fn socket(
+        domain: ::c_int,
+        _type: ::c_int,
+        protocol: ::c_int,
+    ) -> ::c_int;
+
+    // icotl.h
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+
+    // fcntl.h
+    pub fn fcntl(fd: ::c_int, cmd: ::c_int, ...) -> ::c_int;
+
+    // ntp_rfc2553.h for kernel
+    // netdb.h for user
+    pub fn gai_strerror(errcode: ::c_int) -> *mut ::c_char;
+
+    // ioLib.h or
+    // unistd.h
+    pub fn close(fd: ::c_int) -> ::c_int;
+
+    // ioLib.h or
+    // unistd.h
+    pub fn read(fd: ::c_int, buf: *mut ::c_void, count: ::size_t)
+        -> ::ssize_t;
+
+    // ioLib.h or
+    // unistd.h
+    pub fn write(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::size_t,
+    ) -> ::ssize_t;
+
+    // ioLib.h or
+    // unistd.h
+    pub fn isatty(fd: ::c_int) -> ::c_int;
+
+    // ioLib.h or
+    // unistd.h
+    pub fn dup(src: ::c_int) -> ::c_int;
+
+    // ioLib.h or
+    // unistd.h
+    pub fn dup2(src: ::c_int, dst: ::c_int) -> ::c_int;
+
+    // ioLib.h or
+    // unistd.h
+    pub fn pipe(fds: *mut ::c_int) -> ::c_int;
+
+    // ioLib.h or
+    // unistd.h
+    pub fn unlink(pathname: *const ::c_char) -> ::c_int;
+
+    // unistd.h and
+    // ioLib.h
+    pub fn lseek(fd: ::c_int, offset: off_t, whence: ::c_int) -> off_t;
+
+    // netdb.h
+    pub fn getaddrinfo(
+        node: *const ::c_char,
+        service: *const ::c_char,
+        hints: *const addrinfo,
+        res: *mut *mut addrinfo,
+    ) -> ::c_int;
+
+    // netdb.h
+    pub fn freeaddrinfo(res: *mut addrinfo);
+
+    // signal.h
+    pub fn signal(signum: ::c_int, handler: sighandler_t) -> sighandler_t;
+
+    // unistd.h
+    pub fn getpid() -> pid_t;
+
+    // unistd.h
+    pub fn getppid() -> pid_t;
+
+    // wait.h
+    pub fn waitpid(pid: pid_t, status: *mut ::c_int, optons: ::c_int)
+        -> pid_t;
+
+    // unistd.h
+    pub fn sysconf(attr: ::c_int) -> ::c_long;
+
+    // stdlib.h
+    pub fn setenv(
+        // setenv.c
+        envVarName: *const ::c_char,
+        envVarValue: *const ::c_char,
+        overwrite: ::c_int,
+    ) -> ::c_int;
+
+    // stdlib.h
+    pub fn unsetenv(
+        // setenv.c
+        envVarName: *const ::c_char,
+    ) -> ::c_int;
+
+    // stdlib.h
+    pub fn realpath(
+        fileName: *const ::c_char,
+        resolvedName: *mut ::c_char,
+    ) -> *mut ::c_char;
+
+    // unistd.h
+    pub fn link(src: *const ::c_char, dst: *const ::c_char) -> ::c_int;
+
+    // unistd.h
+    pub fn readlink(
+        path: *const ::c_char,
+        buf: *mut ::c_char,
+        bufsize: ::size_t,
+    ) -> ::ssize_t;
+
+    // unistd.h
+    pub fn symlink(path1: *const ::c_char, path2: *const ::c_char) -> ::c_int;
+
+    // dirent.h
+    pub fn opendir(name: *const ::c_char) -> *mut ::DIR;
+
+    // unistd.h
+    pub fn rmdir(path: *const ::c_char) -> ::c_int;
+
+    // stat.h
+    pub fn mkdir(dirName: *const ::c_char, mode: ::mode_t) -> ::c_int;
+
+    // stat.h
+    pub fn chmod(path: *const ::c_char, mode: ::mode_t) -> ::c_int;
+
+    // stat.h
+    pub fn fchmod(attr1: ::c_int, attr2: ::mode_t) -> ::c_int;
+
+    // unistd.h
+    pub fn fsync(fd: ::c_int) -> ::c_int;
+
+    // dirent.h
+    pub fn closedir(ptr: *mut ::DIR) -> ::c_int;
+
+    // sched.h
+    pub fn sched_yield() -> ::c_int;
+
+    // errnoLib.h
+    pub fn errnoSet(err: ::c_int) -> ::c_int;
+
+    // errnoLib.h
+    pub fn errnoGet() -> ::c_int;
+
+    // unistd.h
+    pub fn _exit(status: ::c_int) -> !;
+
+    // unistd.h
+    pub fn setgid(gid: ::gid_t) -> ::c_int;
+
+    // unistd.h
+    pub fn getgid() -> ::gid_t;
+
+    // unistd.h
+    pub fn setuid(uid: ::uid_t) -> ::c_int;
+
+    // unistd.h
+    pub fn getuid() -> ::uid_t;
+
+    // signal.h
+    pub fn sigemptyset(__set: *mut sigset_t) -> ::c_int;
+
+    // pthread.h for kernel
+    // signal.h for user
+    pub fn pthread_sigmask(
+        __how: ::c_int,
+        __set: *const sigset_t,
+        __oset: *mut sigset_t,
+    ) -> ::c_int;
+
+    // signal.h for user
+    pub fn kill(__pid: pid_t, __signo: ::c_int) -> ::c_int;
+
+    // signal.h for user
+    pub fn sigqueue(
+        __pid: pid_t,
+        __signo: ::c_int,
+        __value: ::sigval,
+    ) -> ::c_int;
+
+    // signal.h for user
+    pub fn _sigqueue(
+        rtpId: ::RTP_ID,
+        signo: ::c_int,
+        pValue: *const ::sigval,
+        sigCode: ::c_int,
+    ) -> ::c_int;
+
+    // signal.h
+    pub fn taskKill(taskId: ::TASK_ID, signo: ::c_int) -> ::c_int;
+
+    // signal.h
+    pub fn raise(__signo: ::c_int) -> ::c_int;
+
+    // taskLibCommon.h
+    pub fn taskIdSelf() -> ::TASK_ID;
+    pub fn taskDelay(ticks: ::_Vx_ticks_t) -> ::c_int;
+
+    // rtpLibCommon.h
+    pub fn rtpInfoGet(rtpId: ::RTP_ID, rtpStruct: *mut ::RTP_DESC) -> ::c_int;
+    pub fn rtpSpawn(
+        pubrtpFileName: *const ::c_char,
+        argv: *mut *const ::c_char,
+        envp: *mut *const ::c_char,
+        priority: ::c_int,
+        uStackSize: ::size_t,
+        options: ::c_int,
+        taskOptions: ::c_int,
+    ) -> RTP_ID;
+
+    // ioLib.h
+    pub fn _realpath(
+        fileName: *const ::c_char,
+        resolvedName: *mut ::c_char,
+    ) -> *mut ::c_char;
+
+    // pathLib.h
+    pub fn _pathIsAbsolute(
+        filepath: *const ::c_char,
+        pNameTail: *mut *const ::c_char,
+    ) -> BOOL;
+
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+
+    // randomNumGen.h
+    pub fn randBytes(buf: *mut c_uchar, length: c_int) -> c_int;
+    pub fn randABytes(buf: *mut c_uchar, length: c_int) -> c_int;
+    pub fn randUBytes(buf: *mut c_uchar, length: c_int) -> c_int;
+    pub fn randSecure() -> c_int;
+
+    // mqueue.h
+    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;
+    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;
+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn mq_receive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+    ) -> ::ssize_t;
+    pub fn mq_timedreceive(
+        mqd: ::mqd_t,
+        msg_ptr: *mut ::c_char,
+        msg_len: ::size_t,
+        msg_prio: *mut ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::ssize_t;
+    pub fn mq_send(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+    ) -> ::c_int;
+    pub fn mq_timedsend(
+        mqd: ::mqd_t,
+        msg_ptr: *const ::c_char,
+        msg_len: ::size_t,
+        msg_prio: ::c_uint,
+        abs_timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;
+    pub fn mq_setattr(
+        mqd: ::mqd_t,
+        newattr: *const ::mq_attr,
+        oldattr: *mut ::mq_attr,
+    ) -> ::c_int;
+}
+
+//Dummy functions, these don't really exist in VxWorks.
+
+// wait.h macros
+safe_f! {
+    pub {const} fn WIFEXITED(status: ::c_int) -> bool {
+        (status & 0xFF00) == 0
+    }
+    pub {const} fn WIFSIGNALED(status: ::c_int) -> bool {
+        (status & 0xFF00) != 0
+    }
+    pub {const} fn WIFSTOPPED(status: ::c_int) -> bool {
+        (status & 0xFF0000) != 0
+    }
+    pub {const} fn WEXITSTATUS(status: ::c_int) -> ::c_int {
+        status & 0xFF
+    }
+    pub {const} fn WTERMSIG(status: ::c_int) -> ::c_int {
+        (status >> 8) & 0xFF
+    }
+    pub {const} fn WSTOPSIG(status: ::c_int) -> ::c_int {
+        (status >> 16) & 0xFF
+    }
+}
+
+pub fn pread(
+    _fd: ::c_int,
+    _buf: *mut ::c_void,
+    _count: ::size_t,
+    _offset: off64_t,
+) -> ::ssize_t {
+    -1
+}
+
+pub fn pwrite(
+    _fd: ::c_int,
+    _buf: *const ::c_void,
+    _count: ::size_t,
+    _offset: off64_t,
+) -> ::ssize_t {
+    -1
+}
+pub fn posix_memalign(
+    memptr: *mut *mut ::c_void,
+    align: ::size_t,
+    size: ::size_t,
+) -> ::c_int {
+    // check to see if align is a power of 2 and if align is a multiple
+    //  of sizeof(void *)
+    if (align & align - 1 != 0)
+        || (align as usize % size_of::<::size_t>() != 0)
+    {
+        return ::EINVAL;
+    }
+
+    unsafe {
+        // posix_memalign should not set errno
+        let e = ::errnoGet();
+
+        let temp = memalign(align, size);
+        ::errnoSet(e as ::c_int);
+
+        if temp.is_null() {
+            ::ENOMEM
+        } else {
+            *memptr = temp;
+            0
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(libc_core_cvoid)] {
+        pub use ::ffi::c_void;
+    } else {
+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help
+        // enable more optimization opportunities around it recognizing things
+        // like malloc/free.
+        #[repr(u8)]
+        #[allow(missing_copy_implementations)]
+        #[allow(missing_debug_implementations)]
+        pub enum c_void {
+            // Two dummy variants so the #[repr] attribute can be used.
+            #[doc(hidden)]
+            __variant1,
+            #[doc(hidden)]
+            __variant2,
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(any(target_arch = "arm"))] {
+        mod arm;
+        pub use self::arm::*;
+    }  else if #[cfg(any(target_arch = "x86"))] {
+        mod x86;
+        pub use self::x86::*;
+    } else if #[cfg(any(target_arch = "x86_64"))] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(any(target_arch = "powerpc"))] {
+        mod powerpc;
+        pub use self::powerpc::*;
+    } else if #[cfg(any(target_arch = "powerpc64"))] {
+        mod powerpc64;
+        pub use self::powerpc64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
diff --git a/library/libc/src/vxworks/powerpc.rs b/library/libc/src/vxworks/powerpc.rs
new file mode 100644
index 00000000..55240068
--- /dev/null
+++ b/library/libc/src/vxworks/powerpc.rs
@@ -0,0 +1,4 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+pub type c_long = i32;
+pub type c_ulong = u32;
diff --git a/library/libc/src/vxworks/powerpc64.rs b/library/libc/src/vxworks/powerpc64.rs
new file mode 100644
index 00000000..4032488b
--- /dev/null
+++ b/library/libc/src/vxworks/powerpc64.rs
@@ -0,0 +1,4 @@
+pub type c_char = u8;
+pub type wchar_t = u32;
+pub type c_long = i64;
+pub type c_ulong = u64;
diff --git a/library/libc/src/vxworks/x86.rs b/library/libc/src/vxworks/x86.rs
new file mode 100644
index 00000000..e617bb83
--- /dev/null
+++ b/library/libc/src/vxworks/x86.rs
@@ -0,0 +1,4 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type c_long = i32;
+pub type c_ulong = u32;
diff --git a/library/libc/src/vxworks/x86_64.rs b/library/libc/src/vxworks/x86_64.rs
new file mode 100644
index 00000000..5e95ea25
--- /dev/null
+++ b/library/libc/src/vxworks/x86_64.rs
@@ -0,0 +1,4 @@
+pub type c_char = i8;
+pub type wchar_t = i32;
+pub type c_long = i64;
+pub type c_ulong = u64;
diff --git a/library/libc/src/wasi.rs b/library/libc/src/wasi.rs
new file mode 100644
index 00000000..e06984c9
--- /dev/null
+++ b/library/libc/src/wasi.rs
@@ -0,0 +1,784 @@
+pub use ffi::c_void;
+
+pub type c_char = i8;
+pub type c_uchar = u8;
+pub type c_schar = i8;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+pub type size_t = usize;
+pub type ssize_t = isize;
+pub type ptrdiff_t = isize;
+pub type intptr_t = isize;
+pub type uintptr_t = usize;
+pub type off_t = i64;
+pub type pid_t = i32;
+pub type clock_t = c_longlong;
+pub type time_t = c_longlong;
+pub type c_double = f64;
+pub type c_float = f32;
+pub type ino_t = u64;
+pub type sigset_t = c_uchar;
+pub type suseconds_t = c_longlong;
+pub type mode_t = u32;
+pub type dev_t = u64;
+pub type uid_t = u32;
+pub type gid_t = u32;
+pub type nlink_t = u64;
+pub type blksize_t = c_long;
+pub type blkcnt_t = i64;
+pub type nfds_t = c_ulong;
+
+pub type __wasi_rights_t = u64;
+
+#[allow(missing_copy_implementations)]
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum FILE {}
+#[allow(missing_copy_implementations)]
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum DIR {}
+#[allow(missing_copy_implementations)]
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum __locale_struct {}
+
+pub type locale_t = *mut __locale_struct;
+
+s! {
+    #[repr(align(8))]
+    pub struct fpos_t {
+        data: [u8; 16],
+    }
+
+    pub struct tm {
+        pub tm_sec: c_int,
+        pub tm_min: c_int,
+        pub tm_hour: c_int,
+        pub tm_mday: c_int,
+        pub tm_mon: c_int,
+        pub tm_year: c_int,
+        pub tm_wday: c_int,
+        pub tm_yday: c_int,
+        pub tm_isdst: c_int,
+        pub __tm_gmtoff: c_int,
+        pub __tm_zone: *const c_char,
+        pub __tm_nsec: c_int,
+    }
+
+    pub struct timeval {
+        pub tv_sec: time_t,
+        pub tv_usec: suseconds_t,
+    }
+
+    pub struct timespec {
+        pub tv_sec: time_t,
+        pub tv_nsec: c_long,
+    }
+
+    pub struct tms {
+        pub tms_utime: clock_t,
+        pub tms_stime: clock_t,
+        pub tms_cutime: clock_t,
+        pub tms_cstime: clock_t,
+    }
+
+    pub struct itimerspec {
+        pub it_interval: timespec,
+        pub it_value: timespec,
+    }
+
+    pub struct iovec {
+        pub iov_base: *mut c_void,
+        pub iov_len: size_t,
+    }
+
+    pub struct lconv {
+        pub decimal_point: *mut c_char,
+        pub thousands_sep: *mut c_char,
+        pub grouping: *mut c_char,
+        pub int_curr_symbol: *mut c_char,
+        pub currency_symbol: *mut c_char,
+        pub mon_decimal_point: *mut c_char,
+        pub mon_thousands_sep: *mut c_char,
+        pub mon_grouping: *mut c_char,
+        pub positive_sign: *mut c_char,
+        pub negative_sign: *mut c_char,
+        pub int_frac_digits: c_char,
+        pub frac_digits: c_char,
+        pub p_cs_precedes: c_char,
+        pub p_sep_by_space: c_char,
+        pub n_cs_precedes: c_char,
+        pub n_sep_by_space: c_char,
+        pub p_sign_posn: c_char,
+        pub n_sign_posn: c_char,
+        pub int_p_cs_precedes: c_char,
+        pub int_p_sep_by_space: c_char,
+        pub int_n_cs_precedes: c_char,
+        pub int_n_sep_by_space: c_char,
+        pub int_p_sign_posn: c_char,
+        pub int_n_sign_posn: c_char,
+    }
+
+    pub struct pollfd {
+        pub fd: c_int,
+        pub events: c_short,
+        pub revents: c_short,
+    }
+
+    pub struct rusage {
+        pub ru_utime: timeval,
+        pub ru_stime: timeval,
+    }
+
+    pub struct stat {
+        pub st_dev: dev_t,
+        pub st_ino: ino_t,
+        pub st_nlink: nlink_t,
+        pub st_mode: mode_t,
+        pub st_uid: uid_t,
+        pub st_gid: gid_t,
+        __pad0: c_uint,
+        pub st_rdev: dev_t,
+        pub st_size: off_t,
+        pub st_blksize: blksize_t,
+        pub st_blocks: blkcnt_t,
+        pub st_atim: timespec,
+        pub st_mtim: timespec,
+        pub st_ctim: timespec,
+        __reserved: [c_longlong; 3],
+    }
+}
+
+// Declare dirent outside of s! so that it doesn't implement Copy, Eq, Hash,
+// etc., since it contains a flexible array member with a dynamic size.
+#[repr(C)]
+#[allow(missing_copy_implementations)]
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub struct dirent {
+    pub d_ino: ino_t,
+    pub d_type: c_uchar,
+    /// d_name is declared in WASI libc as a flexible array member, which
+    /// can't be directly expressed in Rust. As an imperfect workaround,
+    /// declare it as a zero-length array instead.
+    pub d_name: [c_char; 0],
+}
+
+pub const EXIT_SUCCESS: c_int = 0;
+pub const EXIT_FAILURE: c_int = 1;
+pub const STDIN_FILENO: c_int = 0;
+pub const STDOUT_FILENO: c_int = 1;
+pub const STDERR_FILENO: c_int = 2;
+pub const SEEK_SET: c_int = 0;
+pub const SEEK_CUR: c_int = 1;
+pub const SEEK_END: c_int = 2;
+pub const _IOFBF: c_int = 0;
+pub const _IONBF: c_int = 2;
+pub const _IOLBF: c_int = 1;
+pub const F_GETFD: c_int = 1;
+pub const F_SETFD: c_int = 2;
+pub const F_GETFL: c_int = 3;
+pub const F_SETFL: c_int = 4;
+pub const FD_CLOEXEC: c_int = 1;
+pub const FD_SETSIZE: size_t = 1024;
+pub const O_APPEND: c_int = 0x0001;
+pub const O_DSYNC: c_int = 0x0002;
+pub const O_NONBLOCK: c_int = 0x0004;
+pub const O_RSYNC: c_int = 0x0008;
+pub const O_SYNC: c_int = 0x0010;
+pub const O_CREAT: c_int = 0x0001 << 12;
+pub const O_DIRECTORY: c_int = 0x0002 << 12;
+pub const O_EXCL: c_int = 0x0004 << 12;
+pub const O_TRUNC: c_int = 0x0008 << 12;
+pub const O_NOFOLLOW: c_int = 0x01000000;
+pub const O_EXEC: c_int = 0x02000000;
+pub const O_RDONLY: c_int = 0x04000000;
+pub const O_SEARCH: c_int = 0x08000000;
+pub const O_WRONLY: c_int = 0x10000000;
+pub const O_RDWR: c_int = O_WRONLY | O_RDONLY;
+pub const O_ACCMODE: c_int = O_EXEC | O_RDWR | O_SEARCH;
+pub const O_NOCTTY: c_int = 0x0;
+pub const POSIX_FADV_DONTNEED: c_int = 4;
+pub const POSIX_FADV_NOREUSE: c_int = 5;
+pub const POSIX_FADV_NORMAL: c_int = 0;
+pub const POSIX_FADV_RANDOM: c_int = 2;
+pub const POSIX_FADV_SEQUENTIAL: c_int = 1;
+pub const POSIX_FADV_WILLNEED: c_int = 3;
+pub const AT_EACCESS: c_int = 0x0;
+pub const AT_SYMLINK_NOFOLLOW: c_int = 0x1;
+pub const AT_SYMLINK_FOLLOW: c_int = 0x2;
+pub const AT_REMOVEDIR: c_int = 0x4;
+pub const UTIME_OMIT: c_long = 0xfffffffe;
+pub const UTIME_NOW: c_long = 0xffffffff;
+pub const S_IFIFO: mode_t = 49152;
+pub const S_IFCHR: mode_t = 8192;
+pub const S_IFBLK: mode_t = 24576;
+pub const S_IFDIR: mode_t = 16384;
+pub const S_IFREG: mode_t = 32768;
+pub const S_IFLNK: mode_t = 40960;
+pub const S_IFSOCK: mode_t = 49152;
+pub const S_IFMT: mode_t = 57344;
+pub const DT_UNKNOWN: u8 = 0;
+pub const DT_BLK: u8 = 1;
+pub const DT_CHR: u8 = 2;
+pub const DT_DIR: u8 = 3;
+pub const DT_REG: u8 = 4;
+pub const DT_LNK: u8 = 7;
+pub const FIONREAD: c_int = 1;
+pub const FIONBIO: c_int = 2;
+pub const F_OK: ::c_int = 0;
+pub const R_OK: ::c_int = 4;
+pub const W_OK: ::c_int = 2;
+pub const X_OK: ::c_int = 1;
+pub const POLLIN: ::c_short = 0x1;
+pub const POLLOUT: ::c_short = 0x2;
+pub const POLLERR: ::c_short = 0x1000;
+pub const POLLHUP: ::c_short = 0x2000;
+pub const POLLNVAL: ::c_short = 0x4000;
+pub const POLLRDNORM: ::c_short = 0x1;
+pub const POLLWRNORM: ::c_short = 0x2;
+
+pub const E2BIG: c_int = 1;
+pub const EACCES: c_int = 2;
+pub const EADDRINUSE: c_int = 3;
+pub const EADDRNOTAVAIL: c_int = 4;
+pub const EAFNOSUPPORT: c_int = 5;
+pub const EAGAIN: c_int = 6;
+pub const EALREADY: c_int = 7;
+pub const EBADF: c_int = 8;
+pub const EBADMSG: c_int = 9;
+pub const EBUSY: c_int = 10;
+pub const ECANCELED: c_int = 11;
+pub const ECHILD: c_int = 12;
+pub const ECONNABORTED: c_int = 13;
+pub const ECONNREFUSED: c_int = 14;
+pub const ECONNRESET: c_int = 15;
+pub const EDEADLK: c_int = 16;
+pub const EDESTADDRREQ: c_int = 17;
+pub const EDOM: c_int = 18;
+pub const EDQUOT: c_int = 19;
+pub const EEXIST: c_int = 20;
+pub const EFAULT: c_int = 21;
+pub const EFBIG: c_int = 22;
+pub const EHOSTUNREACH: c_int = 23;
+pub const EIDRM: c_int = 24;
+pub const EILSEQ: c_int = 25;
+pub const EINPROGRESS: c_int = 26;
+pub const EINTR: c_int = 27;
+pub const EINVAL: c_int = 28;
+pub const EIO: c_int = 29;
+pub const EISCONN: c_int = 30;
+pub const EISDIR: c_int = 31;
+pub const ELOOP: c_int = 32;
+pub const EMFILE: c_int = 33;
+pub const EMLINK: c_int = 34;
+pub const EMSGSIZE: c_int = 35;
+pub const EMULTIHOP: c_int = 36;
+pub const ENAMETOOLONG: c_int = 37;
+pub const ENETDOWN: c_int = 38;
+pub const ENETRESET: c_int = 39;
+pub const ENETUNREACH: c_int = 40;
+pub const ENFILE: c_int = 41;
+pub const ENOBUFS: c_int = 42;
+pub const ENODEV: c_int = 43;
+pub const ENOENT: c_int = 44;
+pub const ENOEXEC: c_int = 45;
+pub const ENOLCK: c_int = 46;
+pub const ENOLINK: c_int = 47;
+pub const ENOMEM: c_int = 48;
+pub const ENOMSG: c_int = 49;
+pub const ENOPROTOOPT: c_int = 50;
+pub const ENOSPC: c_int = 51;
+pub const ENOSYS: c_int = 52;
+pub const ENOTCONN: c_int = 53;
+pub const ENOTDIR: c_int = 54;
+pub const ENOTEMPTY: c_int = 55;
+pub const ENOTRECOVERABLE: c_int = 56;
+pub const ENOTSOCK: c_int = 57;
+pub const ENOTSUP: c_int = 58;
+pub const ENOTTY: c_int = 59;
+pub const ENXIO: c_int = 60;
+pub const EOVERFLOW: c_int = 61;
+pub const EOWNERDEAD: c_int = 62;
+pub const EPERM: c_int = 63;
+pub const EPIPE: c_int = 64;
+pub const EPROTO: c_int = 65;
+pub const EPROTONOSUPPORT: c_int = 66;
+pub const EPROTOTYPE: c_int = 67;
+pub const ERANGE: c_int = 68;
+pub const EROFS: c_int = 69;
+pub const ESPIPE: c_int = 70;
+pub const ESRCH: c_int = 71;
+pub const ESTALE: c_int = 72;
+pub const ETIMEDOUT: c_int = 73;
+pub const ETXTBSY: c_int = 74;
+pub const EXDEV: c_int = 75;
+pub const ENOTCAPABLE: c_int = 76;
+pub const EOPNOTSUPP: c_int = ENOTSUP;
+pub const EWOULDBLOCK: c_int = EAGAIN;
+
+pub const _SC_PAGESIZE: c_int = 30;
+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;
+pub const _SC_IOV_MAX: c_int = 60;
+pub const _SC_SYMLOOP_MAX: c_int = 173;
+
+#[cfg_attr(
+    feature = "rustc-dep-of-std",
+    link(name = "c", kind = "static", cfg(target_feature = "crt-static"))
+)]
+#[cfg_attr(
+    feature = "rustc-dep-of-std",
+    link(name = "c", cfg(not(target_feature = "crt-static")))
+)]
+extern "C" {
+    pub fn _Exit(code: c_int) -> !;
+    pub fn _exit(code: c_int) -> !;
+    pub fn abort() -> !;
+    pub fn aligned_alloc(a: size_t, b: size_t) -> *mut c_void;
+    pub fn calloc(amt: size_t, amt2: size_t) -> *mut c_void;
+    pub fn exit(code: c_int) -> !;
+    pub fn free(ptr: *mut c_void);
+    pub fn getenv(s: *const c_char) -> *mut c_char;
+    pub fn malloc(amt: size_t) -> *mut c_void;
+    pub fn malloc_usable_size(ptr: *mut c_void) -> size_t;
+    pub fn sbrk(increment: ::intptr_t) -> *mut ::c_void;
+    pub fn rand() -> c_int;
+    pub fn read(fd: c_int, ptr: *mut c_void, size: size_t) -> ssize_t;
+    pub fn realloc(ptr: *mut c_void, amt: size_t) -> *mut c_void;
+    pub fn setenv(k: *const c_char, v: *const c_char, a: c_int) -> c_int;
+    pub fn unsetenv(k: *const c_char) -> c_int;
+    pub fn clearenv() -> ::c_int;
+    pub fn write(fd: c_int, ptr: *const c_void, size: size_t) -> ssize_t;
+    pub static mut environ: *mut *mut c_char;
+    pub fn fopen(a: *const c_char, b: *const c_char) -> *mut FILE;
+    pub fn freopen(
+        a: *const c_char,
+        b: *const c_char,
+        f: *mut FILE,
+    ) -> *mut FILE;
+    pub fn fclose(f: *mut FILE) -> c_int;
+    pub fn remove(a: *const c_char) -> c_int;
+    pub fn rename(a: *const c_char, b: *const c_char) -> c_int;
+    pub fn feof(f: *mut FILE) -> c_int;
+    pub fn ferror(f: *mut FILE) -> c_int;
+    pub fn fflush(f: *mut FILE) -> c_int;
+    pub fn clearerr(f: *mut FILE);
+    pub fn fseek(f: *mut FILE, b: c_long, c: c_int) -> c_int;
+    pub fn ftell(f: *mut FILE) -> c_long;
+    pub fn rewind(f: *mut FILE);
+    pub fn fgetpos(f: *mut FILE, pos: *mut fpos_t) -> c_int;
+    pub fn fsetpos(f: *mut FILE, pos: *const fpos_t) -> c_int;
+    pub fn fread(
+        buf: *mut c_void,
+        a: size_t,
+        b: size_t,
+        f: *mut FILE,
+    ) -> size_t;
+    pub fn fwrite(
+        buf: *const c_void,
+        a: size_t,
+        b: size_t,
+        f: *mut FILE,
+    ) -> size_t;
+    pub fn fgetc(f: *mut FILE) -> c_int;
+    pub fn getc(f: *mut FILE) -> c_int;
+    pub fn getchar() -> c_int;
+    pub fn ungetc(a: c_int, f: *mut FILE) -> c_int;
+    pub fn fputc(a: c_int, f: *mut FILE) -> c_int;
+    pub fn putc(a: c_int, f: *mut FILE) -> c_int;
+    pub fn putchar(a: c_int) -> c_int;
+    pub fn fputs(a: *const c_char, f: *mut FILE) -> c_int;
+    pub fn puts(a: *const c_char) -> c_int;
+    pub fn perror(a: *const c_char);
+    pub fn srand(a: c_uint);
+    pub fn atexit(a: extern "C" fn()) -> c_int;
+    pub fn at_quick_exit(a: extern "C" fn()) -> c_int;
+    pub fn quick_exit(a: c_int) -> !;
+    pub fn posix_memalign(a: *mut *mut c_void, b: size_t, c: size_t) -> c_int;
+    pub fn rand_r(a: *mut c_uint) -> c_int;
+    pub fn random() -> c_long;
+    pub fn srandom(a: c_uint);
+    pub fn putenv(a: *mut c_char) -> c_int;
+    pub fn clock() -> clock_t;
+    pub fn time(a: *mut time_t) -> time_t;
+    pub fn difftime(a: time_t, b: time_t) -> c_double;
+    pub fn mktime(a: *mut tm) -> time_t;
+    pub fn strftime(
+        a: *mut c_char,
+        b: size_t,
+        c: *const c_char,
+        d: *const tm,
+    ) -> size_t;
+    pub fn gmtime(a: *const time_t) -> *mut tm;
+    pub fn gmtime_r(a: *const time_t, b: *mut tm) -> *mut tm;
+    pub fn localtime(a: *const time_t) -> *mut tm;
+    pub fn localtime_r(a: *const time_t, b: *mut tm) -> *mut tm;
+    pub fn asctime_r(a: *const tm, b: *mut c_char) -> *mut c_char;
+    pub fn ctime_r(a: *const time_t, b: *mut c_char) -> *mut c_char;
+
+    pub fn nanosleep(a: *const timespec, b: *mut timespec) -> c_int;
+    // pub fn clock_getres(a: clockid_t, b: *mut timespec) -> c_int;
+    // pub fn clock_gettime(a: clockid_t, b: *mut timespec) -> c_int;
+    // pub fn clock_nanosleep(
+    //     a: clockid_t,
+    //     a2: c_int,
+    //     b: *const timespec,
+    //     c: *mut timespec,
+    // ) -> c_int;
+
+    pub fn isalnum(c: c_int) -> c_int;
+    pub fn isalpha(c: c_int) -> c_int;
+    pub fn iscntrl(c: c_int) -> c_int;
+    pub fn isdigit(c: c_int) -> c_int;
+    pub fn isgraph(c: c_int) -> c_int;
+    pub fn islower(c: c_int) -> c_int;
+    pub fn isprint(c: c_int) -> c_int;
+    pub fn ispunct(c: c_int) -> c_int;
+    pub fn isspace(c: c_int) -> c_int;
+    pub fn isupper(c: c_int) -> c_int;
+    pub fn isxdigit(c: c_int) -> c_int;
+    pub fn isblank(c: c_int) -> c_int;
+    pub fn tolower(c: c_int) -> c_int;
+    pub fn toupper(c: c_int) -> c_int;
+    pub fn setvbuf(
+        stream: *mut FILE,
+        buffer: *mut c_char,
+        mode: c_int,
+        size: size_t,
+    ) -> c_int;
+    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);
+    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE)
+        -> *mut c_char;
+    pub fn atoi(s: *const c_char) -> c_int;
+    pub fn atof(s: *const c_char) -> c_double;
+    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;
+    pub fn strtol(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_long;
+    pub fn strtoul(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_ulong;
+
+    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;
+    pub fn strncpy(
+        dst: *mut c_char,
+        src: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strncat(
+        s: *mut c_char,
+        ct: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;
+    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strdup(cs: *const c_char) -> *mut c_char;
+    pub fn strndup(cs: *const c_char, n: size_t) -> *mut c_char;
+    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;
+    pub fn strncasecmp(
+        s1: *const c_char,
+        s2: *const c_char,
+        n: size_t,
+    ) -> c_int;
+    pub fn strlen(cs: *const c_char) -> size_t;
+    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;
+    pub fn strerror(n: c_int) -> *mut c_char;
+    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;
+    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;
+
+    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;
+    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;
+    pub fn memcpy(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memmove(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;
+
+    pub fn fprintf(
+        stream: *mut ::FILE,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn printf(format: *const ::c_char, ...) -> ::c_int;
+    pub fn snprintf(
+        s: *mut ::c_char,
+        n: ::size_t,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn sprintf(s: *mut ::c_char, format: *const ::c_char, ...) -> ::c_int;
+    pub fn fscanf(
+        stream: *mut ::FILE,
+        format: *const ::c_char,
+        ...
+    ) -> ::c_int;
+    pub fn scanf(format: *const ::c_char, ...) -> ::c_int;
+    pub fn sscanf(s: *const ::c_char, format: *const ::c_char, ...)
+        -> ::c_int;
+    pub fn getchar_unlocked() -> ::c_int;
+    pub fn putchar_unlocked(c: ::c_int) -> ::c_int;
+
+    pub fn shutdown(socket: ::c_int, how: ::c_int) -> ::c_int;
+    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;
+    pub fn mkdir(path: *const c_char, mode: mode_t) -> ::c_int;
+    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;
+    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;
+    pub fn fileno(stream: *mut ::FILE) -> ::c_int;
+    pub fn open(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;
+    pub fn creat(path: *const c_char, mode: mode_t) -> ::c_int;
+    pub fn fcntl(fd: ::c_int, cmd: ::c_int, ...) -> ::c_int;
+    pub fn opendir(dirname: *const c_char) -> *mut ::DIR;
+    pub fn fdopendir(fd: ::c_int) -> *mut ::DIR;
+    pub fn readdir(dirp: *mut ::DIR) -> *mut ::dirent;
+    pub fn closedir(dirp: *mut ::DIR) -> ::c_int;
+    pub fn rewinddir(dirp: *mut ::DIR);
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);
+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;
+
+    pub fn openat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        flags: ::c_int,
+        ...
+    ) -> ::c_int;
+    pub fn fstatat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        buf: *mut stat,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn linkat(
+        olddirfd: ::c_int,
+        oldpath: *const ::c_char,
+        newdirfd: ::c_int,
+        newpath: *const ::c_char,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn mkdirat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn readlinkat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        buf: *mut ::c_char,
+        bufsiz: ::size_t,
+    ) -> ::ssize_t;
+    pub fn renameat(
+        olddirfd: ::c_int,
+        oldpath: *const ::c_char,
+        newdirfd: ::c_int,
+        newpath: *const ::c_char,
+    ) -> ::c_int;
+    pub fn symlinkat(
+        target: *const ::c_char,
+        newdirfd: ::c_int,
+        linkpath: *const ::c_char,
+    ) -> ::c_int;
+    pub fn unlinkat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        flags: ::c_int,
+    ) -> ::c_int;
+
+    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;
+    pub fn close(fd: ::c_int) -> ::c_int;
+    pub fn fpathconf(filedes: ::c_int, name: ::c_int) -> c_long;
+    pub fn getopt(
+        argc: ::c_int,
+        argv: *const *mut c_char,
+        optstr: *const c_char,
+    ) -> ::c_int;
+    pub fn isatty(fd: ::c_int) -> ::c_int;
+    pub fn link(src: *const c_char, dst: *const c_char) -> ::c_int;
+    pub fn lseek(fd: ::c_int, offset: off_t, whence: ::c_int) -> off_t;
+    pub fn pathconf(path: *const c_char, name: ::c_int) -> c_long;
+    pub fn rmdir(path: *const c_char) -> ::c_int;
+    pub fn sleep(secs: ::c_uint) -> ::c_uint;
+    pub fn unlink(c: *const c_char) -> ::c_int;
+    pub fn pread(
+        fd: ::c_int,
+        buf: *mut ::c_void,
+        count: ::size_t,
+        offset: off_t,
+    ) -> ::ssize_t;
+    pub fn pwrite(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::size_t,
+        offset: off_t,
+    ) -> ::ssize_t;
+
+    pub fn lstat(path: *const c_char, buf: *mut stat) -> ::c_int;
+
+    pub fn fsync(fd: ::c_int) -> ::c_int;
+    pub fn fdatasync(fd: ::c_int) -> ::c_int;
+
+    pub fn symlink(path1: *const c_char, path2: *const c_char) -> ::c_int;
+
+    pub fn truncate(path: *const c_char, length: off_t) -> ::c_int;
+    pub fn ftruncate(fd: ::c_int, length: off_t) -> ::c_int;
+
+    pub fn getrusage(resource: ::c_int, usage: *mut rusage) -> ::c_int;
+
+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;
+    pub fn times(buf: *mut ::tms) -> ::clock_t;
+
+    pub fn strerror_r(
+        errnum: ::c_int,
+        buf: *mut c_char,
+        buflen: ::size_t,
+    ) -> ::c_int;
+
+    pub fn usleep(secs: ::c_uint) -> ::c_int;
+    pub fn send(
+        socket: ::c_int,
+        buf: *const ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn recv(
+        socket: ::c_int,
+        buf: *mut ::c_void,
+        len: ::size_t,
+        flags: ::c_int,
+    ) -> ::ssize_t;
+    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::c_int) -> ::c_int;
+    pub fn setlocale(
+        category: ::c_int,
+        locale: *const ::c_char,
+    ) -> *mut ::c_char;
+    pub fn localeconv() -> *mut lconv;
+
+    pub fn readlink(
+        path: *const c_char,
+        buf: *mut c_char,
+        bufsz: ::size_t,
+    ) -> ::ssize_t;
+
+    pub fn timegm(tm: *mut ::tm) -> time_t;
+
+    pub fn sysconf(name: ::c_int) -> ::c_long;
+
+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;
+
+    pub fn fseeko(
+        stream: *mut ::FILE,
+        offset: ::off_t,
+        whence: ::c_int,
+    ) -> ::c_int;
+    pub fn ftello(stream: *mut ::FILE) -> ::off_t;
+    pub fn posix_fallocate(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+    ) -> ::c_int;
+
+    pub fn strcasestr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn getline(
+        lineptr: *mut *mut c_char,
+        n: *mut size_t,
+        stream: *mut FILE,
+    ) -> ssize_t;
+
+    pub fn faccessat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::c_int,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn writev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn readv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+    ) -> ::ssize_t;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn posix_fadvise(
+        fd: ::c_int,
+        offset: ::off_t,
+        len: ::off_t,
+        advise: ::c_int,
+    ) -> ::c_int;
+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;
+    pub fn utimensat(
+        dirfd: ::c_int,
+        path: *const ::c_char,
+        times: *const ::timespec,
+        flag: ::c_int,
+    ) -> ::c_int;
+    pub fn getentropy(buf: *mut ::c_void, buflen: ::size_t) -> ::c_int;
+    pub fn memrchr(
+        cx: *const ::c_void,
+        c: ::c_int,
+        n: ::size_t,
+    ) -> *mut ::c_void;
+    pub fn abs(i: c_int) -> c_int;
+    pub fn labs(i: c_long) -> c_long;
+    pub fn duplocale(base: ::locale_t) -> ::locale_t;
+    pub fn freelocale(loc: ::locale_t);
+    pub fn newlocale(
+        mask: ::c_int,
+        locale: *const ::c_char,
+        base: ::locale_t,
+    ) -> ::locale_t;
+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;
+    pub fn sched_yield() -> ::c_int;
+
+    pub fn __wasilibc_register_preopened_fd(
+        fd: c_int,
+        path: *const c_char,
+    ) -> c_int;
+    pub fn __wasilibc_fd_renumber(fd: c_int, newfd: c_int) -> c_int;
+    pub fn __wasilibc_unlinkat(fd: c_int, path: *const c_char) -> c_int;
+    pub fn __wasilibc_rmdirat(fd: c_int, path: *const c_char) -> c_int;
+    pub fn __wasilibc_find_relpath(
+        path: *const c_char,
+        relative_path: *mut *const c_char,
+    ) -> c_int;
+    pub fn __wasilibc_tell(fd: c_int) -> ::off_t;
+
+    pub fn arc4random() -> u32;
+    pub fn arc4random_buf(a: *mut c_void, b: size_t);
+    pub fn arc4random_uniform(a: u32) -> u32;
+}
diff --git a/library/libc/src/windows/gnu/align.rs b/library/libc/src/windows/gnu/align.rs
new file mode 100644
index 00000000..3af99e3c
--- /dev/null
+++ b/library/libc/src/windows/gnu/align.rs
@@ -0,0 +1,19 @@
+cfg_if! {
+    if #[cfg(target_pointer_width = "64")] {
+        s_no_extra_traits! {
+            #[allow(missing_debug_implementations)]
+            #[repr(align(16))]
+            pub struct max_align_t {
+                priv_: [f64; 4]
+            }
+        }
+    } else if #[cfg(target_pointer_width = "32")] {
+        s_no_extra_traits! {
+            #[allow(missing_debug_implementations)]
+            #[repr(align(16))]
+            pub struct max_align_t {
+                priv_: [i64; 6]
+            }
+        }
+    }
+}
diff --git a/library/libc/src/windows/gnu/mod.rs b/library/libc/src/windows/gnu/mod.rs
new file mode 100644
index 00000000..3e906967
--- /dev/null
+++ b/library/libc/src/windows/gnu/mod.rs
@@ -0,0 +1,31 @@
+pub const L_tmpnam: ::c_uint = 14;
+pub const TMP_MAX: ::c_uint = 0x7fff;
+
+// stdio file descriptor numbers
+pub const STDIN_FILENO: ::c_int = 0;
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+
+extern "C" {
+    pub fn strcasecmp(s1: *const ::c_char, s2: *const ::c_char) -> ::c_int;
+    pub fn strncasecmp(
+        s1: *const ::c_char,
+        s2: *const ::c_char,
+        n: ::size_t,
+    ) -> ::c_int;
+
+    // NOTE: For MSVC target, `wmemchr` is only a inline function in `<wchar.h>`
+    //      header file. We cannot find a way to link to that symbol from Rust.
+    pub fn wmemchr(
+        cx: *const ::wchar_t,
+        c: ::wchar_t,
+        n: ::size_t,
+    ) -> *mut ::wchar_t;
+}
+
+cfg_if! {
+    if #[cfg(libc_align)] {
+        mod align;
+        pub use self::align::*;
+    }
+}
diff --git a/library/libc/src/windows/mod.rs b/library/libc/src/windows/mod.rs
new file mode 100644
index 00000000..a2cd8574
--- /dev/null
+++ b/library/libc/src/windows/mod.rs
@@ -0,0 +1,659 @@
+//! Windows CRT definitions
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+pub type c_float = f32;
+pub type c_double = f64;
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+pub type intmax_t = i64;
+pub type uintmax_t = u64;
+
+pub type size_t = usize;
+pub type ptrdiff_t = isize;
+pub type intptr_t = isize;
+pub type uintptr_t = usize;
+pub type ssize_t = isize;
+pub type sighandler_t = usize;
+
+pub type c_char = i8;
+pub type c_long = i32;
+pub type c_ulong = u32;
+pub type wchar_t = u16;
+
+pub type clock_t = i32;
+
+cfg_if! {
+    if #[cfg(all(target_arch = "x86", target_env = "gnu"))] {
+        pub type time_t = i32;
+    } else {
+        pub type time_t = i64;
+    }
+}
+
+pub type off_t = i32;
+pub type dev_t = u32;
+pub type ino_t = u16;
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum timezone {}
+impl ::Copy for timezone {}
+impl ::Clone for timezone {
+    fn clone(&self) -> timezone {
+        *self
+    }
+}
+pub type time64_t = i64;
+
+pub type SOCKET = ::uintptr_t;
+
+s! {
+    // note this is the struct called stat64 in Windows. Not stat, nor stati64.
+    pub struct stat {
+        pub st_dev: dev_t,
+        pub st_ino: ino_t,
+        pub st_mode: u16,
+        pub st_nlink: ::c_short,
+        pub st_uid: ::c_short,
+        pub st_gid: ::c_short,
+        pub st_rdev: dev_t,
+        pub st_size: i64,
+        pub st_atime: time64_t,
+        pub st_mtime: time64_t,
+        pub st_ctime: time64_t,
+    }
+
+    // note that this is called utimbuf64 in Windows
+    pub struct utimbuf {
+        pub actime: time64_t,
+        pub modtime: time64_t,
+    }
+
+    pub struct tm {
+        pub tm_sec: ::c_int,
+        pub tm_min: ::c_int,
+        pub tm_hour: ::c_int,
+        pub tm_mday: ::c_int,
+        pub tm_mon: ::c_int,
+        pub tm_year: ::c_int,
+        pub tm_wday: ::c_int,
+        pub tm_yday: ::c_int,
+        pub tm_isdst: ::c_int,
+    }
+
+    pub struct timeval {
+        pub tv_sec: c_long,
+        pub tv_usec: c_long,
+    }
+
+    pub struct timespec {
+        pub tv_sec: time_t,
+        pub tv_nsec: c_long,
+    }
+
+    pub struct sockaddr {
+        pub sa_family: c_ushort,
+        pub sa_data: [c_char; 14],
+    }
+}
+
+pub const INT_MIN: c_int = -2147483648;
+pub const INT_MAX: c_int = 2147483647;
+
+pub const EXIT_FAILURE: ::c_int = 1;
+pub const EXIT_SUCCESS: ::c_int = 0;
+pub const RAND_MAX: ::c_int = 32767;
+pub const EOF: ::c_int = -1;
+pub const SEEK_SET: ::c_int = 0;
+pub const SEEK_CUR: ::c_int = 1;
+pub const SEEK_END: ::c_int = 2;
+pub const _IOFBF: ::c_int = 0;
+pub const _IONBF: ::c_int = 4;
+pub const _IOLBF: ::c_int = 64;
+pub const BUFSIZ: ::c_uint = 512;
+pub const FOPEN_MAX: ::c_uint = 20;
+pub const FILENAME_MAX: ::c_uint = 260;
+
+pub const O_RDONLY: ::c_int = 0;
+pub const O_WRONLY: ::c_int = 1;
+pub const O_RDWR: ::c_int = 2;
+pub const O_APPEND: ::c_int = 8;
+pub const O_CREAT: ::c_int = 256;
+pub const O_EXCL: ::c_int = 1024;
+pub const O_TEXT: ::c_int = 16384;
+pub const O_BINARY: ::c_int = 32768;
+pub const O_NOINHERIT: ::c_int = 128;
+pub const O_TRUNC: ::c_int = 512;
+pub const S_IFCHR: ::c_int = 8192;
+pub const S_IFDIR: ::c_int = 16384;
+pub const S_IFREG: ::c_int = 32768;
+pub const S_IFMT: ::c_int = 61440;
+pub const S_IEXEC: ::c_int = 64;
+pub const S_IWRITE: ::c_int = 128;
+pub const S_IREAD: ::c_int = 256;
+
+pub const LC_ALL: ::c_int = 0;
+pub const LC_COLLATE: ::c_int = 1;
+pub const LC_CTYPE: ::c_int = 2;
+pub const LC_MONETARY: ::c_int = 3;
+pub const LC_NUMERIC: ::c_int = 4;
+pub const LC_TIME: ::c_int = 5;
+
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EDEADLK: ::c_int = 36;
+pub const EDEADLOCK: ::c_int = 36;
+pub const ENAMETOOLONG: ::c_int = 38;
+pub const ENOLCK: ::c_int = 39;
+pub const ENOSYS: ::c_int = 40;
+pub const ENOTEMPTY: ::c_int = 41;
+pub const EILSEQ: ::c_int = 42;
+pub const STRUNCATE: ::c_int = 80;
+
+// POSIX Supplement (from errno.h)
+pub const EADDRINUSE: ::c_int = 100;
+pub const EADDRNOTAVAIL: ::c_int = 101;
+pub const EAFNOSUPPORT: ::c_int = 102;
+pub const EALREADY: ::c_int = 103;
+pub const EBADMSG: ::c_int = 104;
+pub const ECANCELED: ::c_int = 105;
+pub const ECONNABORTED: ::c_int = 106;
+pub const ECONNREFUSED: ::c_int = 107;
+pub const ECONNRESET: ::c_int = 108;
+pub const EDESTADDRREQ: ::c_int = 109;
+pub const EHOSTUNREACH: ::c_int = 110;
+pub const EIDRM: ::c_int = 111;
+pub const EINPROGRESS: ::c_int = 112;
+pub const EISCONN: ::c_int = 113;
+pub const ELOOP: ::c_int = 114;
+pub const EMSGSIZE: ::c_int = 115;
+pub const ENETDOWN: ::c_int = 116;
+pub const ENETRESET: ::c_int = 117;
+pub const ENETUNREACH: ::c_int = 118;
+pub const ENOBUFS: ::c_int = 119;
+pub const ENODATA: ::c_int = 120;
+pub const ENOLINK: ::c_int = 121;
+pub const ENOMSG: ::c_int = 122;
+pub const ENOPROTOOPT: ::c_int = 123;
+pub const ENOSR: ::c_int = 124;
+pub const ENOSTR: ::c_int = 125;
+pub const ENOTCONN: ::c_int = 126;
+pub const ENOTRECOVERABLE: ::c_int = 127;
+pub const ENOTSOCK: ::c_int = 128;
+pub const ENOTSUP: ::c_int = 129;
+pub const EOPNOTSUPP: ::c_int = 130;
+pub const EOVERFLOW: ::c_int = 132;
+pub const EOWNERDEAD: ::c_int = 133;
+pub const EPROTO: ::c_int = 134;
+pub const EPROTONOSUPPORT: ::c_int = 135;
+pub const EPROTOTYPE: ::c_int = 136;
+pub const ETIME: ::c_int = 137;
+pub const ETIMEDOUT: ::c_int = 138;
+pub const ETXTBSY: ::c_int = 139;
+pub const EWOULDBLOCK: ::c_int = 140;
+
+// signal codes
+pub const SIGINT: ::c_int = 2;
+pub const SIGILL: ::c_int = 4;
+pub const SIGFPE: ::c_int = 8;
+pub const SIGSEGV: ::c_int = 11;
+pub const SIGTERM: ::c_int = 15;
+pub const SIGABRT: ::c_int = 22;
+pub const NSIG: ::c_int = 23;
+pub const SIG_ERR: ::c_int = -1;
+
+// inline comment below appeases style checker
+#[cfg(all(target_env = "msvc", feature = "rustc-dep-of-std"))] // " if "
+#[link(name = "msvcrt", cfg(not(target_feature = "crt-static")))]
+#[link(name = "libcmt", cfg(target_feature = "crt-static"))]
+extern "C" {}
+
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum FILE {}
+impl ::Copy for FILE {}
+impl ::Clone for FILE {
+    fn clone(&self) -> FILE {
+        *self
+    }
+}
+#[cfg_attr(feature = "extra_traits", derive(Debug))]
+pub enum fpos_t {} // FIXME: fill this out with a struct
+impl ::Copy for fpos_t {}
+impl ::Clone for fpos_t {
+    fn clone(&self) -> fpos_t {
+        *self
+    }
+}
+
+extern "C" {
+    pub fn isalnum(c: c_int) -> c_int;
+    pub fn isalpha(c: c_int) -> c_int;
+    pub fn iscntrl(c: c_int) -> c_int;
+    pub fn isdigit(c: c_int) -> c_int;
+    pub fn isgraph(c: c_int) -> c_int;
+    pub fn islower(c: c_int) -> c_int;
+    pub fn isprint(c: c_int) -> c_int;
+    pub fn ispunct(c: c_int) -> c_int;
+    pub fn isspace(c: c_int) -> c_int;
+    pub fn isupper(c: c_int) -> c_int;
+    pub fn isxdigit(c: c_int) -> c_int;
+    pub fn isblank(c: c_int) -> c_int;
+    pub fn tolower(c: c_int) -> c_int;
+    pub fn toupper(c: c_int) -> c_int;
+    pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;
+    pub fn freopen(
+        filename: *const c_char,
+        mode: *const c_char,
+        file: *mut FILE,
+    ) -> *mut FILE;
+    pub fn fflush(file: *mut FILE) -> c_int;
+    pub fn fclose(file: *mut FILE) -> c_int;
+    pub fn remove(filename: *const c_char) -> c_int;
+    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;
+    pub fn tmpfile() -> *mut FILE;
+    pub fn setvbuf(
+        stream: *mut FILE,
+        buffer: *mut c_char,
+        mode: c_int,
+        size: size_t,
+    ) -> c_int;
+    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);
+    pub fn getchar() -> c_int;
+    pub fn putchar(c: c_int) -> c_int;
+    pub fn fgetc(stream: *mut FILE) -> c_int;
+    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE)
+        -> *mut c_char;
+    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;
+    pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;
+    pub fn puts(s: *const c_char) -> c_int;
+    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;
+    pub fn fread(
+        ptr: *mut c_void,
+        size: size_t,
+        nobj: size_t,
+        stream: *mut FILE,
+    ) -> size_t;
+    pub fn fwrite(
+        ptr: *const c_void,
+        size: size_t,
+        nobj: size_t,
+        stream: *mut FILE,
+    ) -> size_t;
+    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;
+    pub fn ftell(stream: *mut FILE) -> c_long;
+    pub fn rewind(stream: *mut FILE);
+    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;
+    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;
+    pub fn feof(stream: *mut FILE) -> c_int;
+    pub fn ferror(stream: *mut FILE) -> c_int;
+    pub fn perror(s: *const c_char);
+    pub fn atoi(s: *const c_char) -> c_int;
+    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;
+    pub fn strtol(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_long;
+    pub fn strtoul(
+        s: *const c_char,
+        endp: *mut *mut c_char,
+        base: c_int,
+    ) -> c_ulong;
+    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;
+    pub fn malloc(size: size_t) -> *mut c_void;
+    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;
+    pub fn free(p: *mut c_void);
+    pub fn abort() -> !;
+    pub fn exit(status: c_int) -> !;
+    pub fn _exit(status: c_int) -> !;
+    pub fn atexit(cb: extern "C" fn()) -> c_int;
+    pub fn system(s: *const c_char) -> c_int;
+    pub fn getenv(s: *const c_char) -> *mut c_char;
+
+    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;
+    pub fn strncpy(
+        dst: *mut c_char,
+        src: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strncat(
+        s: *mut c_char,
+        ct: *const c_char,
+        n: size_t,
+    ) -> *mut c_char;
+    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;
+    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;
+    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;
+    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;
+    pub fn strdup(cs: *const c_char) -> *mut c_char;
+    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;
+    pub fn strlen(cs: *const c_char) -> size_t;
+    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;
+    pub fn strerror(n: c_int) -> *mut c_char;
+    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;
+    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;
+    pub fn wcslen(buf: *const wchar_t) -> size_t;
+    pub fn wcstombs(
+        dest: *mut c_char,
+        src: *const wchar_t,
+        n: size_t,
+    ) -> ::size_t;
+
+    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;
+    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;
+    pub fn memcpy(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memmove(
+        dest: *mut c_void,
+        src: *const c_void,
+        n: size_t,
+    ) -> *mut c_void;
+    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;
+
+    pub fn abs(i: c_int) -> c_int;
+    pub fn atof(s: *const c_char) -> c_double;
+    pub fn labs(i: c_long) -> c_long;
+    pub fn rand() -> c_int;
+    pub fn srand(seed: c_uint);
+
+    pub fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t;
+    pub fn raise(signum: c_int) -> c_int;
+
+    #[link_name = "_gmtime64_s"]
+    pub fn gmtime_s(destTime: *mut tm, srcTime: *const time_t) -> ::c_int;
+    #[link_name = "_time64"]
+    pub fn time(destTime: *mut time_t) -> time_t;
+    #[link_name = "_chmod"]
+    pub fn chmod(path: *const c_char, mode: ::c_int) -> ::c_int;
+    #[link_name = "_wchmod"]
+    pub fn wchmod(path: *const wchar_t, mode: ::c_int) -> ::c_int;
+    #[link_name = "_mkdir"]
+    pub fn mkdir(path: *const c_char) -> ::c_int;
+    #[link_name = "_wrmdir"]
+    pub fn wrmdir(path: *const wchar_t) -> ::c_int;
+    #[link_name = "_fstat64"]
+    pub fn fstat(fildes: ::c_int, buf: *mut stat) -> ::c_int;
+    #[link_name = "_stat64"]
+    pub fn stat(path: *const c_char, buf: *mut stat) -> ::c_int;
+    #[link_name = "_wstat64"]
+    pub fn wstat(path: *const wchar_t, buf: *mut stat) -> ::c_int;
+    #[link_name = "_wutime64"]
+    pub fn wutime(file: *const wchar_t, buf: *mut utimbuf) -> ::c_int;
+    #[link_name = "_popen"]
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;
+    #[link_name = "_pclose"]
+    pub fn pclose(stream: *mut ::FILE) -> ::c_int;
+    #[link_name = "_fdopen"]
+    pub fn fdopen(fd: ::c_int, mode: *const c_char) -> *mut ::FILE;
+    #[link_name = "_fileno"]
+    pub fn fileno(stream: *mut ::FILE) -> ::c_int;
+    #[link_name = "_open"]
+    pub fn open(path: *const c_char, oflag: ::c_int, ...) -> ::c_int;
+    #[link_name = "_wopen"]
+    pub fn wopen(path: *const wchar_t, oflag: ::c_int, ...) -> ::c_int;
+    #[link_name = "_creat"]
+    pub fn creat(path: *const c_char, mode: ::c_int) -> ::c_int;
+    #[link_name = "_access"]
+    pub fn access(path: *const c_char, amode: ::c_int) -> ::c_int;
+    #[link_name = "_chdir"]
+    pub fn chdir(dir: *const c_char) -> ::c_int;
+    #[link_name = "_close"]
+    pub fn close(fd: ::c_int) -> ::c_int;
+    #[link_name = "_dup"]
+    pub fn dup(fd: ::c_int) -> ::c_int;
+    #[link_name = "_dup2"]
+    pub fn dup2(src: ::c_int, dst: ::c_int) -> ::c_int;
+    #[link_name = "_execl"]
+    pub fn execl(path: *const c_char, arg0: *const c_char, ...) -> intptr_t;
+    #[link_name = "_wexecl"]
+    pub fn wexecl(path: *const wchar_t, arg0: *const wchar_t, ...)
+        -> intptr_t;
+    #[link_name = "_execle"]
+    pub fn execle(path: *const c_char, arg0: *const c_char, ...) -> intptr_t;
+    #[link_name = "_wexecle"]
+    pub fn wexecle(
+        path: *const wchar_t,
+        arg0: *const wchar_t,
+        ...
+    ) -> intptr_t;
+    #[link_name = "_execlp"]
+    pub fn execlp(path: *const c_char, arg0: *const c_char, ...) -> intptr_t;
+    #[link_name = "_wexeclp"]
+    pub fn wexeclp(
+        path: *const wchar_t,
+        arg0: *const wchar_t,
+        ...
+    ) -> intptr_t;
+    #[link_name = "_execlpe"]
+    pub fn execlpe(path: *const c_char, arg0: *const c_char, ...) -> intptr_t;
+    #[link_name = "_wexeclpe"]
+    pub fn wexeclpe(
+        path: *const wchar_t,
+        arg0: *const wchar_t,
+        ...
+    ) -> intptr_t;
+    #[link_name = "_execv"]
+    pub fn execv(
+        prog: *const c_char,
+        argv: *const *const c_char,
+    ) -> ::intptr_t;
+    #[link_name = "_execve"]
+    pub fn execve(
+        prog: *const c_char,
+        argv: *const *const c_char,
+        envp: *const *const c_char,
+    ) -> ::c_int;
+    #[link_name = "_execvp"]
+    pub fn execvp(c: *const c_char, argv: *const *const c_char) -> ::c_int;
+    #[link_name = "_execvpe"]
+    pub fn execvpe(
+        c: *const c_char,
+        argv: *const *const c_char,
+        envp: *const *const c_char,
+    ) -> ::c_int;
+    #[link_name = "_wexecv"]
+    pub fn wexecv(
+        prog: *const wchar_t,
+        argv: *const *const wchar_t,
+    ) -> ::intptr_t;
+    #[link_name = "_wexecve"]
+    pub fn wexecve(
+        prog: *const wchar_t,
+        argv: *const *const wchar_t,
+        envp: *const *const wchar_t,
+    ) -> ::intptr_t;
+    #[link_name = "_wexecvp"]
+    pub fn wexecvp(
+        c: *const wchar_t,
+        argv: *const *const wchar_t,
+    ) -> ::intptr_t;
+    #[link_name = "_wexecvpe"]
+    pub fn wexecvpe(
+        c: *const wchar_t,
+        argv: *const *const wchar_t,
+        envp: *const *const wchar_t,
+    ) -> ::intptr_t;
+    #[link_name = "_getcwd"]
+    pub fn getcwd(buf: *mut c_char, size: ::c_int) -> *mut c_char;
+    #[link_name = "_getpid"]
+    pub fn getpid() -> ::c_int;
+    #[link_name = "_isatty"]
+    pub fn isatty(fd: ::c_int) -> ::c_int;
+    #[link_name = "_lseek"]
+    pub fn lseek(fd: ::c_int, offset: c_long, origin: ::c_int) -> c_long;
+    #[link_name = "_lseeki64"]
+    pub fn lseek64(
+        fd: ::c_int,
+        offset: c_longlong,
+        origin: ::c_int,
+    ) -> c_longlong;
+    #[link_name = "_pipe"]
+    pub fn pipe(
+        fds: *mut ::c_int,
+        psize: ::c_uint,
+        textmode: ::c_int,
+    ) -> ::c_int;
+    #[link_name = "_read"]
+    pub fn read(fd: ::c_int, buf: *mut ::c_void, count: ::c_uint) -> ::c_int;
+    #[link_name = "_rmdir"]
+    pub fn rmdir(path: *const c_char) -> ::c_int;
+    #[link_name = "_unlink"]
+    pub fn unlink(c: *const c_char) -> ::c_int;
+    #[link_name = "_write"]
+    pub fn write(
+        fd: ::c_int,
+        buf: *const ::c_void,
+        count: ::c_uint,
+    ) -> ::c_int;
+    #[link_name = "_commit"]
+    pub fn commit(fd: ::c_int) -> ::c_int;
+    #[link_name = "_get_osfhandle"]
+    pub fn get_osfhandle(fd: ::c_int) -> ::intptr_t;
+    #[link_name = "_open_osfhandle"]
+    pub fn open_osfhandle(osfhandle: ::intptr_t, flags: ::c_int) -> ::c_int;
+    pub fn setlocale(category: ::c_int, locale: *const c_char) -> *mut c_char;
+    #[link_name = "_wsetlocale"]
+    pub fn wsetlocale(
+        category: ::c_int,
+        locale: *const wchar_t,
+    ) -> *mut wchar_t;
+    #[link_name = "_aligned_malloc"]
+    pub fn aligned_malloc(size: size_t, alignment: size_t) -> *mut c_void;
+}
+
+extern "system" {
+    pub fn listen(s: SOCKET, backlog: ::c_int) -> ::c_int;
+    pub fn accept(
+        s: SOCKET,
+        addr: *mut ::sockaddr,
+        addrlen: *mut ::c_int,
+    ) -> SOCKET;
+    pub fn bind(
+        s: SOCKET,
+        name: *const ::sockaddr,
+        namelen: ::c_int,
+    ) -> ::c_int;
+    pub fn connect(
+        s: SOCKET,
+        name: *const ::sockaddr,
+        namelen: ::c_int,
+    ) -> ::c_int;
+    pub fn getpeername(
+        s: SOCKET,
+        name: *mut ::sockaddr,
+        nameln: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn getsockname(
+        s: SOCKET,
+        name: *mut ::sockaddr,
+        nameln: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn getsockopt(
+        s: SOCKET,
+        level: ::c_int,
+        optname: ::c_int,
+        optval: *mut ::c_char,
+        optlen: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn recvfrom(
+        s: SOCKET,
+        buf: *mut ::c_char,
+        len: ::c_int,
+        flags: ::c_int,
+        from: *mut ::sockaddr,
+        fromlen: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn sendto(
+        s: SOCKET,
+        buf: *const ::c_char,
+        len: ::c_int,
+        flags: ::c_int,
+        to: *const ::sockaddr,
+        tolen: ::c_int,
+    ) -> ::c_int;
+    pub fn setsockopt(
+        s: SOCKET,
+        level: ::c_int,
+        optname: ::c_int,
+        optval: *const ::c_char,
+        optlen: ::c_int,
+    ) -> ::c_int;
+    pub fn socket(
+        af: ::c_int,
+        socket_type: ::c_int,
+        protocol: ::c_int,
+    ) -> SOCKET;
+}
+
+cfg_if! {
+    if #[cfg(libc_core_cvoid)] {
+        pub use ::ffi::c_void;
+    } else {
+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help
+        // enable more optimization opportunities around it recognizing things
+        // like malloc/free.
+        #[repr(u8)]
+        #[allow(missing_copy_implementations)]
+        #[allow(missing_debug_implementations)]
+        pub enum c_void {
+            // Two dummy variants so the #[repr] attribute can be used.
+            #[doc(hidden)]
+            __variant1,
+            #[doc(hidden)]
+            __variant2,
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(all(target_env = "gnu"))] {
+        mod gnu;
+        pub use self::gnu::*;
+    } else if #[cfg(all(target_env = "msvc"))] {
+        mod msvc;
+        pub use self::msvc::*;
+    } else {
+        // Unknown target_env
+    }
+}
diff --git a/library/libc/src/windows/msvc.rs b/library/libc/src/windows/msvc.rs
new file mode 100644
index 00000000..8f20deb5
--- /dev/null
+++ b/library/libc/src/windows/msvc.rs
@@ -0,0 +1,17 @@
+pub const L_tmpnam: ::c_uint = 260;
+pub const TMP_MAX: ::c_uint = 0x7fff_ffff;
+
+// POSIX Supplement (from errno.h)
+// This particular error code is only currently available in msvc toolchain
+pub const EOTHER: ::c_int = 131;
+
+extern "C" {
+    #[link_name = "_stricmp"]
+    pub fn stricmp(s1: *const ::c_char, s2: *const ::c_char) -> ::c_int;
+    #[link_name = "_strnicmp"]
+    pub fn strnicmp(
+        s1: *const ::c_char,
+        s2: *const ::c_char,
+        n: ::size_t,
+    ) -> ::c_int;
+}
diff --git a/library/libc/tests/const_fn.rs b/library/libc/tests/const_fn.rs
new file mode 100644
index 00000000..0e7e1864
--- /dev/null
+++ b/library/libc/tests/const_fn.rs
@@ -0,0 +1,5 @@
+#![cfg(libc_const_extern_fn)] // If this does not hold, the file is empty
+
+#[cfg(target_os = "linux")]
+const _FOO: libc::c_uint = unsafe { libc::CMSG_SPACE(1) };
+//^ if CMSG_SPACE is not const, this will fail to compile
diff --git a/library/libc/triagebot.toml b/library/libc/triagebot.toml
new file mode 100644
index 00000000..702ee90f
--- /dev/null
+++ b/library/libc/triagebot.toml
@@ -0,0 +1,6 @@
+[relabel]
+allow-unauthenticated = [
+    "C-*", "O-*", "S-*"
+]
+
+[assign]
diff --git a/library/panic_unwind/src/gcc.rs b/library/panic_unwind/src/gcc.rs
index 14f49bbf..b3daafa2 100644
--- a/library/panic_unwind/src/gcc.rs
+++ b/library/panic_unwind/src/gcc.rs
@@ -99,7 +99,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {
 #[cfg(target_arch = "x86")]
 const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX
 
-#[cfg(target_arch = "x86_64")]
+#[cfg(any(target_arch = "x86_64", target_arch = "llir_x86_64"))]
 const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX
 
 #[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
diff --git a/library/std/src/os/linux/raw.rs b/library/std/src/os/linux/raw.rs
index 617c4098..dc62b393 100644
--- a/library/std/src/os/linux/raw.rs
+++ b/library/std/src/os/linux/raw.rs
@@ -304,7 +304,7 @@ pub struct stat {
     }
 }
 
-#[cfg(any(target_arch = "x86_64", target_arch = "powerpc64"))]
+#[cfg(any(target_arch = "x86_64", target_arch = "llir_x86_64", target_arch = "powerpc64"))]
 mod arch {
     use crate::os::raw::{c_int, c_long};
 
diff --git a/library/std/src/sys_common/alloc.rs b/library/std/src/sys_common/alloc.rs
index 6c1bc0d8..3173a595 100644
--- a/library/std/src/sys_common/alloc.rs
+++ b/library/std/src/sys_common/alloc.rs
@@ -21,6 +21,7 @@
 pub const MIN_ALIGN: usize = 8;
 #[cfg(all(any(
     target_arch = "x86_64",
+    target_arch = "llir_x86_64",
     target_arch = "aarch64",
     target_arch = "mips64",
     target_arch = "s390x",
diff --git a/library/unwind/build.rs b/library/unwind/build.rs
index 24bcd40c..5c486d2a 100644
--- a/library/unwind/build.rs
+++ b/library/unwind/build.rs
@@ -4,6 +4,10 @@ fn main() {
     println!("cargo:rerun-if-changed=build.rs");
     let target = env::var("TARGET").expect("TARGET was not set");
 
+    if cfg!(feature = "system-llvm-libunwind") {
+        return;
+    }
+
     if cfg!(feature = "llvm-libunwind")
         && ((target.contains("linux") && !target.contains("musl")) || target.contains("fuchsia"))
     {
diff --git a/library/unwind/src/lib.rs b/library/unwind/src/lib.rs
index dbdefa47..cc7a6500 100644
--- a/library/unwind/src/lib.rs
+++ b/library/unwind/src/lib.rs
@@ -37,7 +37,7 @@
     }
 }
 
-#[cfg(target_env = "musl")]
+#[cfg(all(target_env = "musl", not(target_arch = "llir_x86_64")))]
 #[link(name = "unwind", kind = "static", cfg(target_feature = "crt-static"))]
 #[link(name = "gcc_s", cfg(not(target_feature = "crt-static")))]
 extern "C" {}
@@ -63,6 +63,15 @@
 #[link(name = "unwind", cfg(not(target_feature = "crt-static")))]
 extern "C" {}
 
+#[cfg(all(
+    target_os = "linux",
+    target_env = "musl",
+    not(feature = "llvm-libunwind"),
+    feature = "system-llvm-libunwind"
+))]
+#[link(name = "unwind", cfg(not(target_feature = "crt-static")))]
+extern "C" {}
+
 #[cfg(target_os = "redox")]
 #[link(name = "gcc_eh", kind = "static-nobundle", cfg(target_feature = "crt-static"))]
 #[link(name = "gcc_s", cfg(not(target_feature = "crt-static")))]
diff --git a/library/unwind/src/libunwind.rs b/library/unwind/src/libunwind.rs
index ff1d82fc..3b8c06be 100644
--- a/library/unwind/src/libunwind.rs
+++ b/library/unwind/src/libunwind.rs
@@ -27,7 +27,7 @@ pub enum _Unwind_Reason_Code {
 #[cfg(target_arch = "x86")]
 pub const unwinder_private_data_size: usize = 5;
 
-#[cfg(target_arch = "x86_64")]
+#[cfg(any(target_arch = "x86_64", target_arch = "llir_x86_64"))]
 pub const unwinder_private_data_size: usize = 6;
 
 #[cfg(all(target_arch = "arm", not(target_os = "ios")))]
diff --git a/llir-build.sh b/llir-build.sh
new file mode 100755
index 00000000..665ce6cd
--- /dev/null
+++ b/llir-build.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+PREFIX="$1"
+HOST=$(uname -m)
+
+OPENSSL_LIB_DIR=/usr/lib/$HOST-linux-gnu OPENSSL_INCLUDE_DIR=/usr/include ./x.py build
+
diff --git a/llir-configure.sh b/llir-configure.sh
new file mode 100755
index 00000000..8598e566
--- /dev/null
+++ b/llir-configure.sh
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+PREFIX="$1"
+HOST=$(uname -m)
+PWD=$(pwd)
+
+if [ "$HOST" == "$ARCH" ]; then
+  exit 1
+else
+
+cat >config.toml <<EOL
+[llvm]
+targets = "AArch64;PowerPC;RISCV;X86;LLIR"
+
+[build]
+build = "$HOST-unknown-linux-gnu"
+host = ["$HOST-unknown-linux-gnu"]
+target = ["$ARCH-unknown-linux-musl"]
+extended = true
+tools = ["cargo"]
+docs = false
+
+[target.$HOST-unknown-linux-gnu]
+llvm-config = "$PREFIX/bin/llvm-config"
+cc = "$PWD/wrapper-gcc"
+cxx = "$PWD/wrapper-g++"
+linker = "$PWD/wrapper-gcc"
+ranlib = "ranlib"
+ar = "ar"
+
+[target.$ARCH-unknown-linux-musl]
+llvm-config = "$PREFIX/bin/llvm-config"
+cc = "$ARCH-unknown-linux-musl-gcc"
+cxx = "$ARCH-unknown-linux-g++"
+linker = "$ARCH-unknown-linux-musl-gcc"
+ranlib = "$ARCH-unknown-linux-ranlib"
+ar = "$ARCH-unknown-linux-ar"
+
+[rust]
+musl-root = "$PREFIX"
+llvm-libunwind = "system"
+
+[install]
+prefix = "$PREFIX"
+sysconfdir = "etc"
+EOL
+
+cat >wrapper-gcc <<EOL
+#!/bin/sh
+gcc -L$PREFIX/llvm/lib \$@
+EOL
+chmod a+x wrapper-gcc
+
+cat >wrapper-g++ <<EOL
+#!/bin/sh
+g++ -L$PREFIX/llvm/lib \$@
+EOL
+chmod a+x wrapper-g++
+
+fi
diff --git a/llir-install.sh b/llir-install.sh
new file mode 100755
index 00000000..13812150
--- /dev/null
+++ b/llir-install.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+PREFIX="$1"
+HOST=$(uname -m)
+
+OPENSSL_LIB_DIR=/usr/lib/$HOST-linux-gnu OPENSSL_INCLUDE_DIR=/usr/include ./x.py install
+
+mkdir -p $PREFIX/.cargo
+
+cat >$PREFIX/.cargo/config.toml <<EOL
+[build]
+target = "$ARCH-unknown-linux-musl"
+
+[target.$ARCH-unknown-linux-musl]
+linker = "$ARCH-unknown-linux-musl-gcc"
+
+EOL
diff --git a/src/bootstrap/native.rs b/src/bootstrap/native.rs
index 6dc83c7d..06f922b3 100644
--- a/src/bootstrap/native.rs
+++ b/src/bootstrap/native.rs
@@ -154,7 +154,7 @@ fn run(self, builder: &Builder<'_>) -> PathBuf {
             Some(s) => s,
             None => {
                 "AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\
-                     Sparc;SystemZ;WebAssembly;X86"
+                     Sparc;SystemZ;WebAssembly;X86;LLIR"
             }
         };
 
